<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[临风|刀背藏身]]></title>
  <subtitle><![CDATA[代码是一棱刀背，幸好，有此藏身。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-04T03:32:44.413Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[临风]]></name>
    <email><![CDATA[xuelinf@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HTML的纷争 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/04/HTML%E7%9A%84%E7%BA%B7%E4%BA%89-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/04/HTML的纷争-《The-Tangled-Web》/</id>
    <published>2016-05-04T03:31:30.000Z</published>
    <updated>2016-05-04T03:32:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 id="HTML_文档的基本概念">HTML 文档的基本概念</h2>
<p><strong>语法</strong></p>
<p>HTML 是标签组成的层级结构，文本穿插其中，而主要是使用无个字符进行约束和限制，<strong>左右尖括号，单引号，双引号，&amp;</strong>，所以说，HTML 里会有一些针对这些字符的规则：</p>
<ul>
<li>HTML 文档的绝大部分区域不应该出现单个「&amp;」符号。</li>
<li>HTML 标签内部不应该出现左右尖括号。</li>
<li>文本节点的左尖括号是危险的。</li>
<li>标签中出现引号字符串可能导致意想不到的效果。</li>
</ul>
<p>以上几条规劝，实际上就是在告诫这样书写的代码，随时会被攻击者抓住，利用代码的缺陷，构造XSS 或者是SQL注入。</p>
<p><strong>文档解析模式</strong></p>
<p>对于传统的HTML，解析器会修复大部分语法上的不合规，同时不区分大小写，参数值不一定要用括号括起来，某些标签可以隐式闭合，而对于XML 来说，标签必须严格匹配，区分大小写，可以整合其他兼容格式内容。</p>
<p>值得一提的是，对于HTML ，碰到某些标签后，会落入特殊模式，直到出现特定的终止字符才会退出状态。如style, script, textarea, xmp 直到出现反斜杠匹配，才会退出。</p>
<p>而对于XML，禁止出现单个「&lt;」和「&amp;」，还有一个特殊的语法，只要一”&lt;![CDATA[“字符串开头，以”]])”结束的，中间短路可以封装含有人以标签的任意原始文本数据。</p>
<p><strong>语义之争</strong>：Tim Berners-Lee 的语义网梦想，这里还是比较遥远，不做进一步探讨。</p>
<h2 id="HTML_解析器的行为"><strong>HTML 解析器的行为</strong></h2>
<p>对于XML 来说，不需要担心，因为解析器的错误几乎零容忍。但是，对于HTML 来说，简直就是灾难，为了最大程度的解析，HTML 会以各种让人摸不着头脑的大胆的方式猜测网页作者的用途。以下边这个标签为例：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-04-14623256480455.jpg" alt=""></p>
<p>先不考虑它没有闭合仍然正常被解析这件事，看各家解析器做出的各种支持：</p>
<ul>
<li>IE 浏览器允许吧空字节NUL（0x00） 插入到1位置</li>
<li>2，4的空白位置可以使用垂直制表符(0x0b)或者进纸换页符(0x0c)替换，令人惊奇的是FireFox 允许在2 用单个普通的正斜杠代替。</li>
<li>3，曾经WebKit 甚至允许此处有正斜杠使用。</li>
<li>位置5，在IE还能接受反引号。</li>
<li>被引号括起来的参数，后边实际上隐式的跟着一个空格符，所以位置6空格可以去掉。</li>
</ul>
<p>一个常见的攻击手段就是xss，此处借助title,我们将 hello world 替换成 hello world” onerror=”alert(1) 于是，对于原标签就变成了：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=image.jpg tile=<span class="string">"hello world"</span>onerror=<span class="string">"alert(1)"</span> <span class="keyword">class</span>=example&gt;</div></pre></td></tr></table></figure>

<p>很自然的一个脚本被我们植入进去了，一个xss 就被触发了。</p>
<p><strong>多重标签的交互</strong></p>
<p>在不正常的HTML 里，还会出现多个HTML 标签堆叠在一起，看起来就让人头疼，而浏览器在解析的时候，也会有区别，比如:</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i &lt;b&gt;</div></pre></td></tr></table></figure>

<p>大多数浏览器会先解析成<strong>‘&lt; i &gt;’</strong> ，而把&lt; b 视为无效的标签参数。</p>
<p>另外，整个文档结束时候标签未闭合的情况也让人摸不清头脑。比如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i foo=<span class="string">"&lt;b&gt;"</span> [EOF]</div></pre></td></tr></table></figure>

<p>大多数浏览器解析为i 的标签，或者是整个忽略掉，但对于IE 和 Opera 却从后往前处理，把这一串理解成 b 的标签。</p>
<p>所以假如攻击者，可以阶段加载的页面，就可以通过构造手段，让浏览器解析成完全不同的内容。</p>
<h2 id="HTML_实体编码">HTML 实体编码</h2>
<p>（由于MarkDown语言里，自动把这些编码识别出来了，包括尖括号，只好中间加空格或这种方式来书写。）</p>
<p>hTML 的实体编码格式是以&amp;开头，以分号结尾，在HTML 规范里，散步着无数这样的命名实体，比如&amp; lt; 插入左尖括号，&amp; gt;用于插入右尖括号，&amp; amp; 替换 &amp;符号自身。&amp; rarr; 代表一个Unicode箭头等等。</p>
<p>除了命名实体，还可以插入任意十进制ASCII 或者 Unicode 字符编码，样式是 &amp;#数字；<br>例如 &amp;# 60; 被识别成左尖括号，&amp;# 62; 别识别为右尖括号。而十六进制的标记符在这在编码前边加一个x,所以 &amp;# x3c; 仍然是一个左尖括号。</p>
<p>对于HTML 来说，解析器能识别在文本节点和参数值里边的实体编码，在创建文档树的时候，透明的对这些编码进行解码。</p>
<p>但是有一点疑惑的是，在识别和解析HTML 实体任务重，有一些奇怪的解析，比如传统解析中，只要实体名称后边跟着的字符不是字母数字，即使是少了分号，实体名还是被接受了。对于数字型的实体，后边可以跟任意多个0，导致一个超长的数字串，会造成出错。</p>
<h2 id="HTTP/HTML_交互语义">HTTP/HTML 交互语义</h2>
<p>一般来说，我们会在HTTP 的头域指定内容的一些信息，比如Content-Type, Content-Disposition, Transfer-Encoding等等，然而考虑如果我们不适用HTTP 传输HTML，甚至是直接从本地加载HTML，就不能依靠HTTP 的头域来确定编码等信息了。如果缺了像 MIME type 或者字符集这样关键参数，就会破事浏览器随意处置文档的编码解析问题。</p>
<p>解决办法就是文档开头声明&lt; meta http-equiv=…&gt; 指令进行编码设定，一个典型的指定是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></div></pre></td></tr></table></figure>



<p>如果多个http-equiv冲突，或者从服务器端返回HTTP 头域有冲突的话，浏览器表现就会很不一致，一般优先支持hTTP 响应头，然后支持第一个出现的charset。</p>
<h2 id="超链接与内容包含">超链接与内容包含</h2>
<p>这一块是XSS 的重灾区。</p>
<p>一个单纯的HTML 链接写法是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.example.com/"</span>&gt;</span>click me!<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>对于这个超链接，它支持指向浏览器支持的所有协议，包括伪URL，如data: javascript:。</p>
<p>同时，该语法可选的target参数有四种，<strong>_blank</strong>总是打开新窗口；<strong>_parent</strong> 转到包含发出当前链接文档的上一级视图；<strong>_top</strong> 转到浏览器最顶级窗口。<strong>_self</strong> 和没有设置这个值一样。</p>
<p><strong>表单和表单触发的请求</strong></p>
<p>XSS 重灾区。</p>
<p>一个典型的表单写法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">GET</span> <span class="attribute">action</span>=<span class="value">"/process_form.cgi"</span>&gt;</span></div><div class="line">名字：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">given</span>&gt;</span></div><div class="line">姓氏：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">family</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">submit</span> <span class="attribute">value</span>=<span class="value">"完成后提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></div></pre></td></tr></table></figure>

<p>值得注意的是，form 彼此不能嵌套，如果嵌套了，只有最外层的有效。</p>
<p>如果method 为GET，那么包含的字段名称和他们的值，会以百分号编码机制转义，但其中空格(0x20) 会被以加号代替而非%20,而所有的加号被编码成%2b 。经过编码的「名称=值」数据对用&amp; 连接付分割，组成完整的字符串。</p>
<p>如果method 是POST，分几种情况：</p>
<ul>
<li>默认情况下，application/x-www-form-urlencoded 编码方式，信息组成方式与GET 方式相同，不同的是数据会放在请求头的数据体部分提交，目标URL 查询字符串和其他部分保持不变。<strong>潜在的问题，如果查询字符串和POST 数据体参数相同，冲突，可能会造成HTTP 参数污染</strong></li>
<li>额外的把form 标签中的编码设置为enctype = “text/plain”。而采用这种做法，字段的名称和值不会以百分号编码方式进行编码，某些浏览器可能会把空格替换成加号，而原来用于分割的&amp; 以换行符替换。因此，这样格式的数据，无法明确的对赎金进行解析，因为无法完全区分换行符和等号是表单带进来的，还是浏览器加入的。</li>
<li>entype = “multipart/form-data”，通过表单提交用户选择的文件时候，要用这种模式，会产生一系列较短的MIME 消息，对应于提交的每个字段。然后每个字段会有一个由哭护短选择的特定符号分割。</li>
</ul>
<p><strong>Frame 框架</strong></p>
<p>其作用是使HTML 文档内嵌和显示另一个页面中，有独立的文档视图，甚至独立的JS 环境。对于src 值的限定，与其他链接的规则基本相同， 所以 iframe 也是一个安全隐含。</p>
<p><strong>其他特定的内容</strong></p>
<p>包括图片，层级样式表，客户端脚本，插件内容等等，这些不再赘述，他们都有XSS 的风险。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>良好的规范，良好的规范，良好的规范，毫无疑问要确保输出统一的、有效的、浏览器支持的Content-type 响应头和 charset 字符集信息，以免文档不能按照原有意思解析。</li>
<li>文档包括可被控制的信息时，应当充分考虑到漏洞的可能。<ul>
<li>针对文本部分里用户提供内容：应当以实体编码方式处理左右尖括号和&amp; ， 以及其他的各种ASCII等编码问题。同时，某些Unicode 元字符 U+202E 可能会改变之后文本的显示方向和顺序，<strong>是不是想起了微信</strong>。</li>
<li>针对style 和 on* 标签参数，要做多重编码转义处理，但这种处理往往又有可能出错，所以处处小心。</li>
<li>其他的HTML 参数值，对攻击者能够控制的输入，总是用引号来括起来，对左右尖括号和&amp; 以及任何<strong>单独出现的引号</strong>都要进行实体编码。同时，不要对URL 或其他参数有问题的值做黑名单验证，反而会造成脚本执行漏洞。</li>
<li>特殊的解析模式下，如script, style 区块里的内容，仍然是仔细处理引号字符串，左右尖括号，所有非打印字符都应做好合适的转义处理。</li>
</ul>
</li>
</ul>
<hr>
<p>HTML 部分写完，但是要想完全搞清楚HTML 编码部分的问题，简直是一件不可能完成的任务，曾经有本书叫《Web Application Obfuscation》，它企图创建出能拦截所有已知的危险模式的过滤器，同时又不会影响到其他段落的正常功能，而实际上，这是不可能完成的任务。</p>
<p>一个良好的方法是用一个解析器，把输入的文档翻译成放在内存里的层级文档树，然后去除掉那些无法识别的参数和标签，和所有不需要的标签、参数、参数值。然后在对文档树进行良好的排序和转义，这样看起来要方便和清晰许多。</p>
<p>另外，HTML 中存在问题，造成最大的影响就是XSS 和CSRF 这两个攻击手段，攻击者会绞尽脑汁的绕过开发者设置的层层障碍，他们的最终目的无论如何，都是试图通过各种混淆的代码，让解析器理解成其他意思，达成攻击效果。而XSS 的三种攻击模式，反射型，储存型，DOM 型，都是在这些修修补补的篱笆上找一个足以穿越过去的漏洞。</p>
<p>在配合上HTTP 的问题，可以创造一切可能，对于XSS 的世界，脑洞有多大，可能有多大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 i]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 2)把XSS放进脚本 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-2-%E6%8A%8AXSS%E6%94%BE%E8%BF%9B%E8%84%9A%E6%9C%AC-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-2-把XSS放进脚本-XSS升级之路/</id>
    <published>2016-05-03T13:29:18.000Z</published>
    <updated>2016-05-03T13:29:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 1)无过滤规则的XSS -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-1-%E6%97%A0%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E7%9A%84XSS-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-1-无过滤规则的XSS-XSS升级之路/</id>
    <published>2016-05-03T13:26:29.000Z</published>
    <updated>2016-05-03T13:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这一块知识聚拢一下，写成一篇文章。想了想，从简单到难，那就是一条打怪升级之路，所以就从最简单的反射型漏洞开始，一点一点提高，直到把大部分XSS 的形式找出来。</p>
<h1 id="level_1_无过滤规则的XSS">level 1 无过滤规则的XSS</h1>
<p>最简单的跨站，也就是我们说的反射型跨站，也叫作非持久型，参数型跨站脚本。这种类型的脚本出现的面非常的广，互联网上这样的漏洞非常多，一般出没在各路小站点，大站点很少出现。乌云的漏洞列表里，海量的XSS 漏洞都来自互联网上访问量不高的小站，被辛苦挖洞的XSSer 们发掘出来的。</p>
<p>站在新手村我们的，需要一个最简单的野怪刷一下，这个野怪上下无任何装备，没有一点防御。也就是说，这个XSS 漏洞对于用户的输入，不做任何过滤行为。</p>
<p>一般来说，XSS 存在的地方，一定是需要有输入和输出概念的，一般的过滤规则，也是出现在输入阶段或者是输出阶段，如果两个都没有过滤，那么很轻松的就造成了漏洞。通常来说，这种洞非常好刷，比较自动化的方式是，建立一个爬虫系统，预设一些URL，爬虫爬取网页，在网页源码中寻找用户可以输入的地方，然后在可以输入的地方，将构造好的XSS 代码以输入形式，构造成请求，然后观察响应，是否对我们的输入做了过滤策略。如果是原本的返回，那么我们就说可能存在有xss漏洞。</p>
<p>同时，有另一种更为简单的漏洞，是直接在URL 中，如果有直接赋值参数的行为，也相当于一个可输入的位置，我们直接在URL 中将XSS 代码构造在URL 中，观察返回是否做了过滤处理，如果没有，那么就是一个最简单的野怪诞生。</p>
<p>在乌云中，有不少这样的漏洞，小站很多，大站很少，因为大站一般都有完备的过滤规则，很难在这些小问题上有任何闪失，再加上如今浏览器基本上都有安全策略对此类型进行防御，所以这种威力相对较小。</p>
<p>之前在HTTP 的文章里，有详细讲过 URL的格式，其基本格式如此：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622667602815.jpg" alt=""></p>
<p>每个结构对应的含义如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<p>通常的注入发生在query 这一块，而一般一个安全的行为，就是对query 中的字符进行过滤，以防止xss。以百度的URL 为例，一个通常的URL 查询之后的造型是下面这样的：</p>
<p><a href="http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969" target="_blank" rel="external">http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969</a></p>
<p>问号之后有一大堆参数，&amp;用来分割参数，他们对应的是什么意思不是本文关注的重点，可以参见这一篇文章<a href="http://www.biaodianfu.com/baidu-url-secret.html" target="_blank" rel="external">百度搜索URL 参数解析</a>。</p>
<p>其中wd 就是我们所说的搜索关键词，也就是我们的输入，如果我们将此字符改成</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>在输出时我们看到，URL 变成了如下，可疑的部分被转义了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.baidu.com/s?wd=%22%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&rsv_spt=1&rsv_iqid=0xb3f5d3380002c15f&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&oq=%26lt%3Bscript%26gt%3Balert(%26%2339%3Bxss%26%2339%3B)%26lt%3B%2Fscript%26gt%3B&rsv_t=455e8xS9GVGwfM%2BTxjkNH6uUohEOPZHQFWlqocmOh9s1caJr5IHzVrPJJKJ1OwdTglc3&inputT=5478&rsv_sug3=27&rsv_sug1=21&rsv_sug7=100&rsv_pq=cce2beda0002a800&rsv_sug2=0&rsv_sug4=6278</span></div></pre></td></tr></table></figure>

<p>在这里举一个大站腾讯的简单的xss，是乌云上某马甲提交的，作为一个最简单的XSS 挖给大家学习。网站的网址是这样的：<br><strong><a href="http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886" target="_blank" rel="external">http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886</a></strong></p>
<p>如果我们在这个URL 里尝试修改参数，将score 参数改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>

<p>而输出的源码并没有发生变化：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673299696.jpg" alt=""></p>
<p>在网易中看到的结果就变成了这样：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673544485.jpg" alt=""></p>
<p>这很显然，就是一个xss漏洞了，将经典的xss 代码插入进去即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score=<span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">1</span> <span class="attribute">onerror</span>=<span class="value">alert(1);</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622674130351.jpg" alt=""></p>
<p>这就是一个最无防御的XSS 存在，很明显的，它简单，暴力，当然也是极容易防御的，所以在一个较高级的攻防对抗，或者是大站漏洞中，基本上不会出现这样的漏洞（然而腾讯还是有这样的问题~~）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP许多事-《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/03/HTTP%E8%AE%B8%E5%A4%9A%E4%BA%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/03/HTTP许多事-《The-Tangled-Web》/</id>
    <published>2016-05-03T01:26:05.000Z</published>
    <updated>2016-05-03T01:26:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提供任何额外的元数据交换空间</strong>，其过程非常的简单，只有一行，客户端的请求只有一行，比如以GET 开头，后跟URL 路径和查询字符串，CRLF结束，服务器端接到后立刻返回HTML 数据。</p>
<p>所以，这个版本上，有很明显的缺陷，比如无法根据浏览器用户的首选语言或者文档类型进行交互处理，找不到请求文件或返回内容不是HTML的话，无法通知客户端，比如不能做到在一个服务器用一个IP 支持多个不同主机名的网站。</p>
<p><strong>HTTP/1.0 &amp; HTTP/1.1</strong></p>
<p>下面这两个版本，修正了这些问题和缺陷，其格式在之前的HTTP 详解里，已经介绍过了，请求头里包括了具体版本信息，和许多以键值对形式存在的数据，同时一个单独的空行代表结束。响应头则包含了包含协议版本，响应码，状态信息，和一些其他的键值对形式存在的响应信息，同时以一个空行结束，随后才是要返回的具体资源。</p>
<p>很显然，这一版本就成熟了许多，但是协议里有一个要求，HTTP/1.0 的客户端必须能够理解HTTP/0.9 ，这看起来是一种向下兼容的表现，但实际上会带来许多恶果，如果攻击者想要攻击某个HTTP 客户端，攻击者会试图令客户端HTTP 降级，采用0.9的模式，而这种模式下，十分危险，返回给客户端的文件，然而在0.9中，返回的内容只有请求的文件本身，无法从这些回应的内容里，表明响应方确实可以理解HTTP 协议，以及返回内容是否是真的HTML 文件。</p>
<p>这让我想起了SSL 里的安全问题，也是由于SSL 3.0 需要向下支持SSL 2.0 ,而SSL 2.0 中存在有严重的漏洞，所以攻击者会故意引起降级到SSL 2.0，寻找漏洞。到后来，进步到TLS后，SSL 3.0也不被信任了。</p>
<p><strong>换行处理</strong></p>
<p>这是一个小细节，HTTP/1.1 要求客户端不仅要接受CRLF 和LF 换行模式，还要接受CR，然而不同的浏览器和服务器却又有不一样的支持情况，比如Apache 就不接受RFC 这条建议，而FireFox以外的客户端都能接受。</p>
<p>所以，开发人员在处理HTTP 头域的时候，不仅要考虑LF，CRLF，还要考虑CR 字符。不然就有可能产生漏洞利用，也就是在头域中注入CR ，响应拆分。</p>
<p>另外一个不安全的小细节是，HTTP/1.1 要求支持多行请求头，也就是以一个空格开头的行，认为是接上一行的内容。但是这一规定，有些浏览器和服务器支持，有些却并不支持，比如IE ，Opera 等等都不支持。这种混乱，就会造成漏洞，不过这种攻击可能性比较低一些，我也没想到它能造成什么严重的影响。</p>
<p><strong>经过代理的HTTP 请求</strong></p>
<p>这一块在HTTP 详解那里，只对代理这一部分做了基础的了解。使用代理的原因有很多，比如为了提高性能（缓存），强制某些网络的访问策略（禁止）或需要以代理方式接入某些独立的网络环境等等。</p>
<p>相比于普通语法格式，有一些不同：<strong>第一行URL 是一个完整的URL</strong>，而在Host 中也要标识出主机名，这看起来是重复的，但实际上两者是两套机制独立发展起来的，<strong>当Host 与 URL 不匹配时，代理服务器以URL为准，或用特定的URL-Host 数据对和缓存内容关联</strong></p>
<p>同时，代理服务器还允许浏览器获取非HTTP 类型的资源，比如FTP 文件或者目录。这种情况下，数据返回给用户之前，代理服务器会把HTTP 响应里返回的内容先封装整理，转换成HTML格式。而如果服务器不便于查看数据，就另做处理了。也就是Connect 方式，这样代理服务器就会进行盲转发。当时，盲转发中间存在一个疏忽，不过已经解决，处理代理服务器返回的非加密错误响应信息时，浏览器会认为是目的服务器返回的。</p>
<p>另外有一些代理服务器并不适用HTTP 方式和浏览器打交道，这些代理为了缓存内容或者强制执行某些规则，会需要检查HTTP 过程中的信息交换。比如一个透明代理，它拦截TCP/IP 层流量，但是它能看到连接的目标端IP，和主机头Host信息，但是它并不能确认，要连接的目标端IP 是否真的和Host 设定的服务器名称匹配，除非去做一次查询，确定两者是否相关，否则客户端和服务器串通好久回对代理服务器造成影响。比如，如果不检查，攻击者可以向代理服务器要求连接自己的服务器，但发送的是一个故意误导的代理的Host头，www.google.com ，这样，那些想要访问www.google.com 获得的可能是错误缓存的响应内容。</p>
<p><strong>重复或者有冲突的头域的解析</strong></p>
<p>一句话，不同的浏览器和服务端都有不同的处理，而且在协议中，对此的描述也有很多小的疏漏，比如同时有用HTTP/1.0 和1.1 相同功能但是不同名称的头域，应当如何处理，比如EXPires 和 Cache-Control。</p>
<p>另外，比如第一行的URL 和 Host 冲突时候，应当怎么处理，文档要求是不要理会Host, 但是Host 必须存在。</p>
<p><strong>以分号作分隔符的头域值</strong></p>
<p>有一些HTTP 头域，比如Cache-Control 或者Content-Disposition ，可以使用分号来分隔在同一行里的几对独立的’名称=值’数据组，允许使用这种嵌套语法，可以更加有效率和直观。</p>
<p>同时RFC 里规定了某些使用场景，这种数据组里等号右边的参数可以使用Quoted-String(双引号括起来的任意可打印字符组成的字符串，支持分号和空格)。</p>
<p>但遗憾的是有些浏览器对该语法的支持并不好，比如IE，他不能支持分号，如果””中存在分号，有分号的地方就会被截断，造成安全漏洞。</p>
<p>还有一个问题并有做统一规定，就是多次出现的名称=值，名称如果相同，应该如何处理，不同的浏览器和服务器做了不同的处理。一般以第一次出现的值为准。</p>
<p><strong>头域里的字符集和编码策略</strong></p>
<p>这又是一个令人头疼的地方，因为规则混乱，处理方式混乱，甚至可以说，没有任何一套编码方式能同时为所有的浏览器所支持。书里只是简单的举例说明了这个编码有多混乱，记录如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14620909259094.jpg" alt=""></p>
<p><strong>Referer头域的表现</strong></p>
<p>Referer 头域里包含的是，哪个URL 地址触发了对当前网页的访问，Referer头域都纠错处理有一定的帮助，但是这个头域也会泄露一定的信息，还会暴露引用页面的查询字符串参数等。</p>
<p>一般情况下，在HTTP 头域都会出现，但除了一下集中情况：</p>
<ul>
<li>地址栏直接输出新的URL</li>
<li>浏览器动作是由data: 或者javascript: 伪协议触发的</li>
<li>当前请求来自Refresh 响应头</li>
<li>从加密站点到非加密站点，<strong>注意虽然有此措施，但是还会有信息泄露（未明）</strong></li>
<li>用户可以通过调整浏览器设置或者安装隐私保护插件，选择不发送或者干脆伪造一个来源。</li>
</ul>
<h2 id="HTTP_请求类型">HTTP 请求类型</h2>
<p>这一块比较清楚，但是其中包含的各种问题有一些之前没有想到过。在此简单列举：</p>
<ul>
<li>GET 本来RFC 只要求GET 只用于索取信息，但现在浏览器和服务器基本上都依靠GET 来更多的操作。同时，Range 请求头域代表非连续请求字段，也叫断点续传。</li>
<li><strong>POST</strong>，将客户端提交的信息传递给服务端，由于POST 的动作，可能带来持久性的副作用，所以浏览器在重载包含POST 方式的数据时，浏览器都会健身的向用户确认。但POST方法，有很多服务器是默认拒绝的。</li>
<li><strong>HEAD</strong> 和GET 方向类似，但只返回头域，一般是用来自动化测试等。</li>
<li><strong>PUT</strong> 向服务器特定URL 上传文件，但是大部分浏览器都不支持该方法，一般使用POST 完成。同时，某些服务器在配置上的错误，可能导致支持PUT 请求，这也会产生安全问题。</li>
<li><strong>OPTIONS</strong> 元数据请求，返回其所支持的所有方法列表。在提议阶段的跨域请求授权协议的基础。</li>
<li><strong>DELETE</strong> 与PUT 类似。</li>
<li><strong>TRACE</strong> 主要用于在安全测试中，揭示远程网络的内部架构的。所以，这一般用户用不到，一般被禁止了。</li>
<li>CONNECT 通过HTTP 代理服务器建立非HTTP 类型连接时使用。该指令不能直接发送给目标服务器<br>，如果特定服务器上不小心设置了支持CONNECT，可能会造成安全问题，攻击者可以通过他进一步攻击。</li>
</ul>
<h2 id="HTTP_响应码">HTTP 响应码</h2>
<p>同上，此处也做过详细解释，RFC 文档里列出了几十种状态码，但是常用的大约15种，而其他的一般是为未来准备的。这些有用的，列举如下：</p>
<ul>
<li>200 OK。没什么说的</li>
<li>204 No Content。无内容，说明请求已经执行成功，但是不做任何响应。</li>
<li>206 Partial Content。部分内容，根据Range 设置返回部分请求内容。</li>
<li>301 Moved Permanently。永久移动。</li>
<li>302 Found。 找到</li>
<li>303 See Other。 参见其他。以上三个响应码都意味着，重定向同时给出新地址，一般会在Location 响应头指出。如果是POST 请求，一般会替换成GET 方法，去除POST 数据体部分，并重新发送一次。</li>
<li>304 Not Modified.无变化，告诉请求者现在请求的文档和之前请求的没有变化，该响应信息会根据If-Modified-Since 头域的设定，对最后修改时间进行条件判断。</li>
<li>307 Temporary Redirect 。 临时重定向，与302类型，但是307 方法下，浏览器不会吧POST 重置为GET 方法。</li>
<li>400 Bad Request.不合规范的请求，服务器不愿或者不能做出回应，更详细的有 411 Length Required。405 Method Not Allowed.414 Request-URL Too LOng.</li>
<li>401 Unauthorized 未授权。</li>
<li>403 FOrbidden.禁止访问。文件存在但是不允许访问。</li>
<li>404 Not Found. 文件找不到</li>
<li>500 Internal Server Error 内部服务器错误，503 Service Unavailable 服务不可用。 </li>
</ul>
<h2 id="持续会话和分段数据传输">持续会话和分段数据传输</h2>
<p>持续会话应当注意，使用KeepAlive 会话时，响应端要包含一个Content-Length 头域，用于判断还有多少数据，有可能遇上拆分漏洞，也是前边所提到的[CR][CRLF]等等的处理品混乱。</p>
<p>对于分段数据传输，RFC 提供了 Transfer-Encoding:chunked 功能，协议里讲，只要可能，产生的数据立刻作为部分内容先发送出去，单独传输的每部分长度，都以16进制整数标识放在一个单独的行里，但是整个文件的长度是不确定的，知道出现下一个0字节标志整段结束。</p>
<h2 id="缓存机制">缓存机制</h2>
<p>RFC 里说，如果没有其他服务器端指令，客户端可以默认装若干的GET请求的HTTP响应码进行缓存，只要请求方法和URL 一致。</p>
<p>当响应被缓存后，客户端都会在重用之前判断是否需要验证和重载内容。通过Data/If-Modified-Since 和 ETag/If-None-Match 判断是否重用。这些是隐式的缓存机制，存在一些问题，比如我们通过以上两组的搭配，在结合Cache-Control: private ，能方便的获得浏览器在一段时间内的访问规律和习惯。甚至，如果讲一个字符串标记嵌入和缓存的JavaScript 文件中，然后在访问该文件时候，如果请求头里包含了缓存条件，一律答复 304 Not Modified 。</p>
<p>为此，服务器更倾向于使用显示的HTTP 缓存指令。但是HTTP/1.0 和 1.1之间的处理方式有不同。</p>
<p>1.0中提供的是Expires响应头，判断Expires He  Date 之间的联系，文档没有详细的说明，不同的浏览器处理不同，FireFox，Opera 根据两者的差值，其他浏览器则是Expires和缓存服务器的系统时间进行相比。</p>
<p>同时，1.0中还提供一个Pragma: no-cache ，代理服务器如果收到该请求头，就会重新抓取。</p>
<p>1.1 中，则是在Cache-Control 中承载缓存指令，有四种区域：<strong>public</strong> 可以被公开缓存的文档。<strong>private</strong> 代理服务器不得缓存文档。<strong>no-cache</strong> 可以被缓存，不能被重用（仅能用于后退前进）。<strong>no-store</strong>, 不缓存。</p>
<p>1.0 和 1.1 处理方式的不同，造成了服务器和客户端在处理上，必须两者都兼容。</p>
<p><strong>HTTP 缓存带来的安全问题</strong></p>
<p>攻击者可以通过拦截对某些URL 的请求，想受害者返回被篡改，并且长期缓存的请求内容，这样收到污染的浏览器缓存如何在受信任的网络上被重用，被注入的内容可能就出人意料的重新浮现。甚至，攻击者可以精心选择一些敏感域，然后在其他上下文环境中再引用这些域的内容。</p>
<h2 id="HTTP_cookie">HTTP cookie</h2>
<p>cookie 是四种全局授权方式之一，其他三种是HTTP 认证，IP检查， 客户端认证。</p>
<p>cookie 是通过Set-Cookie 响应头进行设置的,其基本参数之前列举过，现在简单陈列：</p>
<ul>
<li>Expires Cookie过期时间</li>
<li>Max-age  另一种建议的过期时间</li>
<li>Domain  Cookie 的有效范围，与安全会有关联。</li>
<li>Path ，允许Cookie 在特定的请求路径内有效</li>
<li>Secure 禁止以非加密形式传输Cookie.</li>
<li>HttpOnly 禁止JavaScript的doccument.cookie API 的方式读取Cookie.</li>
</ul>
<h2 id="HTTP_认证_和_SSL">HTTP 认证 和 SSL</h2>
<p>HTTP 认证现在很少有人用了，而且会有401钓鱼的风险。</p>
<p>SSL 部分参见另一篇博文。</p>
<p>值得注意的是，出于方便和降低成本的考虑，某些机构现在只需要一张信用卡，在目标服务器放一个用于完成验证的文件就能够获得证书。这种做法导致了证书中除了cn 和 subjectAltName 两个字段，信息都不再可信了。</p>
<h2 id="安全工程">安全工程</h2>
<p>处理Content-Disposition 头域中用户提供的文件名，如果不需要非拉丁语系的文件名，通常只保留字母数字和<strong>. \ - _</strong>  ，其他字符一概移除。为了保证用户免遭有害或者欺骗文件，至少保证文件名的首字符是字母或者数字，并把所有最后一个句号外的其他句号一律用其他字符代替。</p>
<p>如果而需要用到非拉丁语系的文件名，按照RFC 文档昨说，根据浏览器的情况使用百分号编码的URL 形式作为文件名，确保过滤控制字符(0xxx~0x1f) 和对任何分号，反斜杠和引号进行转义。</p>
<p>在处理<strong>HTTP cookie 里的用户出入信息</strong>，应当对字母和数字以外的所有字符进行百分号编码，或者干脆使用base64, 因为那些引号，控制字符(0x00~0x1f)，高位字符（0x80~0xff），逗号，分号，反斜杠都可能导致Cookie注入，或是当前Cookie 含义发生变化。</p>
<p>在发送<strong>用户提供的Location 头域</strong>，应对提供的URL 进行解析和规范化处理，确保URL 对应协议的允许的白名单上，以及重定向到的指定主机是安全的。同时确保任何控制字符和高位字符得到了恰当的转义。</p>
<p>在发送<strong>用户提供的Redirect 头域</strong>，遵从与Location 主机头一样的建议，注意在这里，分号也是不安全的，而且没办法的进行可靠的转义，而分号在某些特定的URL 里又有特殊的含义，应当干脆杜绝这样的URL 或者对分号进行百分号编码。</p>
<p>构建其他类别的用户输入请求或者是响应时，一定要<strong>进行语法检查，排除头域可能导致的副作用</strong>，重点注意控制字符，高位字符，逗号，引号，反斜杠，分号。<strong>创建新HTTP客户端，服务器或代理时</strong>，一定要注意上述那些问题。</p>
<hr>
<p>HTTP 这一部分，算是吧基础的知识又一次串了一遍，很明显的，所谓Web 安全问题，都是围绕 HTTP展开的，因为任何web的交互，基本上都需要使用HTTP 协议。本篇提到的，我觉得迷惑点最多的还是混乱的编码模式，由于很难搞清楚各种编码的真谛，何处支持何种编码，拒绝何种编码，才能真正的解决那些通过各种构造形式的攻击，所以，关于编码，后边我还会再做讨论，当然，我感觉这是一个漫长的工作量，因为在任何一个犄角旮旯里，都会藏着对Web 致命威胁的点。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从URL 开始 --《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/04/29/%E4%BB%8EURL-%E5%BC%80%E5%A7%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/04/29/从URL-开始-《The-Tangled-Web》/</id>
    <published>2016-04-29T03:19:19.000Z</published>
    <updated>2016-04-29T03:20:59.000Z</updated>
    <content type="html"><![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br><a id="more"></a><br>这也是一本疯狂的吐槽书，在作者的眼里，整个Web 应用界，混乱不堪，看似繁荣却处处都是破绽，而且确实如此，因为作者随随便便便发现了数百个安全漏洞。</p>
<p>所以我以逐章节的形式，写自己的读书笔记，希望在阅读和反刍的过程中，收获到更多的信息，构建起更完善的知识体系。</p>
<h1 id="这里放一个前言">这里放一个前言</h1>
<p>Web安全为什么存在，是因为它沉寂的太久，而又崛起的太快，崛起的过程中，各方势力互相角力，争议不断，浏览器的厂家拥有强势的决定权，W3C 理事会又缺乏足够的控制能力，组织内部又常常意见不统一，造成了Web 一路发展过来，有许多千奇百怪的新东西出现又消失。再加上天然的Web 的强交互本质，其在安全上存在的风险是巨大的。</p>
<p>首先，用户是Web 应用的使用者，而大部分缺乏安全素养的个人用户，在使用Web应用的时候，怎么可能会去关注那些林林总总的安全风险问题，所以，首先web应用不应当寄希望于将安全的决策权交给用户，然而这一点上浏览器上做的并不好，虽然在逐渐改进，但是有很多忽然跳出来的选项，跳出来的专业词汇，对于小白用户来说就是一个灾难，大多数情况，小白一般就会忽略这些安全风险提示，直接操作到最后。</p>
<p>其次，Web 运行环境难以隔离，各类相关数据杂糅在一起难解难分，在其他领域，数据对象，用户层应用，操作系统内核之间界限清晰，每个应用程序的进程各自独立，相互通信，输入输出都要靠系统内核进行调配。然而在浏览器中，却不存在这样的隔离，<strong>文档和代码交融在一起，无关的应用之间无法完全隔离，因为他们常常使用了相同的全局JavaScript运行环境</strong> ，这也就造成了诸如跨站，CSRF等等的攻击。</p>
<p>同时还有一些不言而明的缺陷，比如缺乏一个统一的安全体系，在浏览器领域，<strong>同源策略</strong>算是他的一个核心安全范式了，但是这种同源策略仍然是问题多多的，比如复杂的使用场景（JavaScript DOM访问， XML HttpRequest API，HTTP Cookie, 本地存储API， FLash,java插件等等等）。比如跨浏览器交互的问题，比如客户端和服务端的区别逐渐模糊，会在如今安全仍然非常脆弱的情况下，增加复杂度，也使得设计层面更加混乱，进一步增加了风险。</p>
<h1 id="URL_开始">URL 开始</h1>
<p>我们都知道一条URL 对应的是Web 服务器上某个独一无二的资源，在简短的一行长度里，我们希望浏览器和服务器能够获取足够的信息量，RFC 文档为URL 制定了一系列规则，好让一个URL 里可以携带更多信息，所以五花八门的功能和内容也会爬上URL， 而此时由于繁多的URL 花样加上各种浏览器的不同解读方式，也让其漏洞百出，有无数安全的隐患。</p>
<p>为了让URL 拥有更多功能，于是有了伪URL ，它不是资源，而是包括了一些功能，诸如脚本引擎，集中特别的文档渲染模式等功能。但是由于URL 本身机制上的疏漏和浏览器对协议的解析机制的不同，带来了诸多安全问题。具体RFC 文档可参见，<strong>RFC3986</strong>，以及RFC 1738，2616等次要文档。</p>
<h2 id="URL_结构">URL 结构</h2>
<p>在之前的笔记里，已经整理HTTP 里的大部分内容，其中就包括URL 部分，所以一个典型的结构是：<br><strong><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></strong></p>
<h3 id="协议名称">协议名称</h3>
<p>这是第一个会出问题的地方，IANA 维护了官方认可的有效URL 地址，如http,https, ftp, 等几十项，而实际上浏览器会支持一些额外的协议，如data: , javascript:  这些都会带来安全问题。</p>
<p><strong>（此处应插入更详细解释）</strong></p>
<p>在RFC 1738 定义中，要求绝对URL 在冒号之前只能出现字母，数字，「+」 ，「-」 , 「.」。但是在实际上各个浏览器都有一些奇怪的支持和不支持方式，在书中列举的例子，我偷懒复制一下别人写的思维导图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618519826666.jpg" alt=""></p>
<p>实际测试下，我手动构造一个HTTP 请求，在协议头这个部分，他也会忽略掉空格0x00这样的字段，比如ht%20tps://www.baidu.com/index.html 仍然是能够正常解析的，我想这应该是服务器方面解析的原因了，目前不知道这上边编码的混乱如何利用制造安全问题。</p>
<h3 id="层级URL_标记符号">层级URL 标记符号</h3>
<p>仍然是我们的RFC 1738 要求我们的绝对URL 应当包含’//‘，如果没有这个东西，后边的URL 就无法正常解析了，只能把他们看成一个含糊的与某个协议有关的内容了。</p>
<p>然而文档里包含了很多含混不清的东西，比如如果一个费层级结构的URL 带有了// ，如何处理，同时如果一个协议没有带//该如何解析，这些在1738 文档里都没有讲清楚。最常见的就是http:www.google.com这样的结构，或者是javascript://www.google.com/%0Aalert(1)。不同的浏览器都有各种各样的解释方式。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618533600523.jpg" alt=""></p>
<h3 id="访问资源的身份验证">访问资源的身份验证</h3>
<p>这一块貌似是没什么重点内容了，直接挂别人的思维导图，略过：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618534589822.jpg" alt=""></p>
<h3 id="服务器地址">服务器地址</h3>
<p>这里就是放域名或者IP地址的地方，IP还有IPv4 的，或者是放在方括号里的IPv6。RFC 要求规范的IP地址写法，然而大多数应用都支持八进制，十进制，十六进制的写法，甚至还可以把其中几个或者全部8位元数据拼在一起转成单个整数的写法。所以实际上一下几个地址是一样的：</p>
<ul>
<li><a href="http://127.0.0.1/" target="_blank" rel="external">http://127.0.0.1/</a></li>
<li><a href="http://0x7f.1/" target="_blank" rel="external">http://0x7f.1/</a>  先以16进制表示标准写法的第一个八位元，剩下三个按照16进制然后拼在一起，然后再整体转换成一个十进制的数字，好绕。</li>
<li><a href="http://017700000001/" target="_blank" rel="external">http://017700000001/</a>  以0为前缀，后面是把全部4个8位元数据的十六进制拼在一起，同意转换成单个八进制整数。</li>
</ul>
<p>大部分浏览器都会忽略出现在URL 内且数值范围在 0x0a~0x0d 和 0xa0~0xad之间的控制字符。因为这些是换行符等等特殊字符。</p>
<h3 id="服务器端口">服务器端口</h3>
<p>这里可以指定端口号，作者说这里会造成一个安全问题，就是我们可以用浏览器向人以网络服务发送攻击者提供的数据，尽管浏览器并不支持这些服务的协议。作者举得例子虽然知道是什么，但实在是不知道这怎样引发安全问题，作者说后边会详细说，然而宝宝粗略的翻阅后边，没发现哪里有讲，等我找到了，我再回来补上。</p>
<h3 id="层级的文件路径">层级的文件路径</h3>
<p>这一块不用做过多解释，他是直接从UNIX 目录语义拿过来的，所以也会出现/../这种路径，作者没有提其中的安全问题，但这一块大约是安全问题比较多的，通过/../可以向上搜索文件，如果服务器没有适当的设置权限，或者是对此类的请求进行过滤的话，就有可能引起文件泄露。</p>
<h3 id="查询字符串">查询字符串</h3>
<p>用于把一串非层级格式的任意参数传递给由前边路径对应的资源。关于这一块的格式，RFC 文档里都没有任何强制性的规定，所以作为浏览器，或者是服务器，它可以以任意喜欢的方式去处理和解析。这也是在URL 上存在注入的原因之一，通过在URL 里嵌入脚本，企图注入路径上的文件，达到攻入的效果。</p>
<h2 id="保留字符，百分号编码">保留字符，百分号编码</h2>
<p>为了不破坏URL 语法，一些符号需要保留：<strong>: / ? # [] @</strong><br>同时RFC 也规定了若干底层分隔符，这些符号留给上层协议或者具体的应用去实现：<strong>! $ &amp; ‘ () * + , ; =</strong></p>
<p>以上这些都是原则性的，但是仍然允许应用有合适的使用方法，那就是对这些字符进行编码，也就是我们常说的百分号编码或URL编码，以一个百分号加上字符的ASCII编码对应的2位16进制数字替换这些字符。比如/ 编码成%2F，百分号本身也会被编码成%25,查阅wiki， 列表如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618914319078.jpg" alt=""></p>
<p>值得注意的是，中间程序在处理URL 的时候，不应当对这些URL 保留字符进行编码，以免传递下去的时候改变了URL 的含义。</p>
<p>另外，虽然禁止，但如果接收到这样的字符，浏览器方为了保证高容错率，一般都会有一套处理方式，但是RFC文档中没有明确说明，所以各家浏览器处理起来完全自由发挥。</p>
<p>同时，RFC 还规定了一批非保留字符（这个听起来有点莫名其妙了），包括字母，数字，- . _ ~ ，意思大概是说，只有这里边的字符，以及出现在正确位置的保留字符，才能够使规范的URL。但是规定里并没有说不可以对非保留字符编码，出现在URL。所以对这些保留字符进行编码，其表示的效果仍然是一样的，例子如下：</p>
<ul>
<li><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></li>
<li><a href="http://%65ample.%63om/" target="_blank" rel="external">http://%65ample.%63om/</a></li>
<li><a href="http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/" target="_blank" rel="external">http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/</a></li>
</ul>
<p>对此可以在浏览器中进行尝试，完全一样的效果。当然这种编码也是因为攻击的一种方式。而一般的，浏览器会在地址栏直接进行强制解码，让这些非必要的编码字符以规范化形式展现。</p>
<p>同时，还有一些，既不在保留字符，又不在非保留字符，RFC 文档的描述有一定的缺失，此时的处理就要看浏览器了，这里直接上图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618924205141.jpg" alt=""></p>
<p>另外，在非正常的US-ASCII 编码问题上，浏览器的解决之道各种混乱，在家这各种编码规范鱼龙混杂，这里我还没有完全搞清楚，此处留坑。</p>
<h2 id="常见_URL_协议及其功能">常见 URL 协议及其功能</h2>
<p>这里讲讲协议的两三事：</p>
<h3 id="浏览器本身支持的，与获取文档有关的协议">浏览器本身支持的，与获取文档有关的协议</h3>
<p>这就是最基本的浏览器内部直接处理，通过特定的传输协议，获取指定文档内容，通过常规的内核解析引擎的逻辑处理。最常规的协议，http,https,ftp等。</p>
<h3 id="第三方应用和插件支持的协议">第三方应用和插件支持的协议</h3>
<p>当浏览器匹配到这个协议的时候，会将处理转交给相应的第三方应用或者插件上，比如arobat:,callto: ,等一票调用第三方应用的协议，大多数情况来说，这些协议对于发起他们的Web 应用本身没有安全性的影响，但是那些第三方协议的处理程序往往是漏洞百出，并有可能导致操作系统被入侵。</p>
<h3 id="未封装的伪协议">未封装的伪协议</h3>
<p>这些伪协议，是为了访问浏览器脚本解析引擎和某些内部功能的，不需要从远程获取数据，同时一般也无法通过互联网访问到。如最常见的 javascript：，data:(不需要额外的网络请求，创建一个短小的内置式文档),这两个都是高危险的协议。</p>
<h3 id="封装过的伪协议">封装过的伪协议</h3>
<p>这类特别的伪协议，可以放在任何的URL 前面，只是将取回的内容强制进行特殊的解码或者渲染显示。比如最常见的查看源码，view-source： 同时其他浏览器还有一些各自支持的伪协议：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618948022474.jpg" alt=""></p>
<p>在这种伪协议的方式下，会隐藏最后实际有浏览器处理的真是URL ，比如 view-source:javacript: 后边跟恶意代码，就会达到攻击的目的。或者说，微软的mhtml 协议，会护绿服务器返回的HTTP 内容设置指令。</p>
<p>最后要说的是，这些协议里暗藏各种杀机，而简单的设置黑名单又很难完全杜绝，因为攻击者可以对其进行各种各样的变形，如加上制表符，将JavaScript 编程 VBScript等等，都同样会触发安全问题。</p>
<h2 id="相对URL_解析">相对URL 解析</h2>
<p>RFC里定义了，URL 字符串不是以有效协议名开始，后边没有跟冒号，或没有// ，都是相对URL。按道理讲，这讲的很明确了吧，如果有上下文环境，那就放在上下文环境里构造成安全的相对链接，如果没有正确的上下文环境，那就拒绝访问。</p>
<p>然而，事实上并没有看起来那么轻巧，各种浏览器的具体实现千差万别，有效协议名称的字符集又各不相同，以及各种替代// 的做法出现，这时候，在处理上就应当小心翼翼，因为随时可能会有黑客构造出一个URL 的变形，对你的文件资源进行攻击。</p>
<p>下面有一些情况：</p>
<p><strong>有协议名称，没有授权信息</strong></p>
<p>如： http:foo.txt 这是RFC 文档早期的疏漏，规范认为这种URL是一个无效的绝对地址，但是，提供的解析算法又会对这种地址有一些含混的解释。在现在的地址解析算法中,这种形式的URL ，协议，路径，查询字符串或者片段ID以URL 为准，授权信息以引用页面为准。这个可以在HTTP 构造包时候进行尝试。</p>
<p><strong>没有协议名，但有授权信息</strong></p>
<p>如： //example.com 这也是个奇怪的写法。此时的处理方式一般是，保留当前页面的协议，字符串作为新的授权信息字段。这个好理解。</p>
<p><strong>没有协议名，没有授权信息，有路径</strong></p>
<p>如： ../notes.txt 这里要用到一些常见的处理方式了，如果开头没有/ ，要添加到引用URL 最右边的的/ 后边，而如果初始路径形如 <a href="http://example.com/files/index.html" target="_blank" rel="external">http://example.com/files/index.html</a> ，则需要将其部分砍掉，拼接路径。</p>
<p><strong>只有片段ID</strong></p>
<p>如 ：#bunnies 这种情况，除ID 外，全部信息原封不动引用，然后替换片段ID 部分。通常这样的 构造，不会让页面重新加载。</p>
<h2 id="安全工程指导">安全工程指导</h2>
<p>如果要构建用户用户输入的全新的URL 时候，一定要慎重：</p>
<p>如果允许用户构造URL 的路径、查询或者片段ID 部分，应当注意，如果其中一部分不能正确的的转移，就有可能会产生意外的结果。所以，最好的做法是，如果要插入攻击者能控制的字段值，应当对除了字母和数字，都进行百分号编码的转义。当然，这种方法也只是部分的解决了问题，还有一些二次转义等绕过的问题。</p>
<p>如果允许用户提供协议名称或者是授权信息部分数据：这里会造成严重的代码注入问题，这时候就应当设置合理的URL 过滤器了。</p>
<p>一些常见的URL 过滤方式：</p>
<ul>
<li>相对URL ，直接禁用相对URL ，避免不必要的麻烦。 </li>
<li>协议名称，建议直接使用白名单模式，因为使用黑名单不知道会漏掉那些漏网之鱼。</li>
<li>授权信息部分，主机名部分应当只包含数字，字母，-和. 在他的后边只能跟<strong>/ ? #</strong> 或者字符串结束符号。允许其他的任何数据都会带来风险。<strong>如果需要检查主机名，确保合理的使用从右往左的截取匹配模式</strong></li>
</ul>
<p>而如果需要从接受的URL 那里进行参数解码，注意，任何从URL 里获取到的值，准备放入数据库查询前，或者是拼接成新的URL前，一定要做好过滤，这些值不一定是安全的，随时可能造成安全问题。</p>
<hr>
<p>至此，URL 部分写完了，但是中间还是留存有许多坑，后边还需要在这些坑上做修补，对细节更加理解。URL 存在的安全问题，应该是较为显眼的攻击了，几年前也许这些攻击有如家常便饭，现在在安全编码的规范下，很多人都会更加关注URL 上的问题，所以在URL 上做文章的几率也在逐渐变低。</p>
<p>所以，联系到我之前做数据挖掘方向上的网络安全分析，如果单纯的拿到服务器的日志，（对于服务器的日志格式，《HTTP权威指南》中有一定介绍，各家服务器也支持自定义）拿到默认的数据格式的数据的话，可以构造的特征值，除了时间分析，频率分析，大概也只有URL 了。虽然URL 藏有非常多的玄机，但在处理上千变万化以及莫名其妙，直接处理都有难度的情况下，还试图通过挖掘的形式直接找到玄机，可能还是不够的。所以，为了能够抓取到最够有用的信息，我们还需要在服务器上获取更多的信息，如对系统调用的日志，如每次发包的的协议头部分内容，甚至还有可能要分析实体部分。当然，目前有一个清晰地轮廓，但是内里确是模糊的，在继续看下去的过程中，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次简单的缓冲区溢出实验]]></title>
    <link href="http://yoursite.com/2016/04/27/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2016/04/27/一次简单的缓冲区溢出实验/</id>
    <published>2016-04-27T02:11:14.000Z</published>
    <updated>2016-04-27T02:11:14.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP再详解]]></title>
    <link href="http://yoursite.com/2016/04/27/HTTP%E5%86%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/27/HTTP再详解/</id>
    <published>2016-04-27T02:05:51.000Z</published>
    <updated>2016-04-27T02:07:29.000Z</updated>
    <content type="html"><![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br><a id="more"></a></p>
<h1 id="概述">概述</h1>
<p>本部分内容较为笼统，直接快速跳过，只简述极少内容。</p>
<h2 id="版本协议">版本协议</h2>
<ul>
<li>HTTP/1.0: 使得包含图片的web页面和交互表格可以实现。</li>
<li>HTTP/1.0+: 包括持久keep-alive，虚拟机支持，代理连接被加入。</li>
<li>HTTP/1.1 校正HTTP设计中的结构缺陷，明确语义，性能优化。</li>
<li>HTTP/2.0: 关注性能的提升，更强大的服务逻辑远程执行框架。</li>
</ul>
<h2 id="Web_结构组件">Web 结构组件</h2>
<p>Web 上比较重要的应用：</p>
<ul>
<li>代理，中间实体</li>
<li>缓存，HTTP仓库，常用页面的副本保存在离客户端较近的地方，CDN。</li>
<li>网关，帮助连接到特殊的Web服务器,HTTP/FTP 网关。</li>
<li>隧道，HTTP报文进行盲转发的特殊处理，SSL。</li>
<li>Agent代理，发起自动HTTP请求的半智能Web 客户端，爬虫。</li>
</ul>
<h1 id="URL">URL</h1>
<p>这是在研究WEB 安全中的重要的内容，在我们抓取到的包内容中，包含非常多的信息。</p>
<h2 id="URL_结构">URL 结构</h2>
<ul>
<li>第一部分是URL 方案，scheme，方案可以告知Web 客户端怎样访问资源。常见例子中，URL 说明要使用HTTP 协议。</li>
<li>URL 第二部分,host 主机 ，www.google.com ，指服务器的位置，也就是资源位于何处，此处通过DNS 解析可以解析到其IP 地址。</li>
<li>URL 第三部分，比如/seasonal/index.html ，是资源路径，说明了请求服务器上哪个资源。</li>
</ul>
<p>其重点在于第三部分，第三部分可以承载URL 的语法，很多的入侵行为也出现在第三部分。</p>
<h3 id="URL_语法">URL 语法</h3>
<p><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
<p>以上是一个URL 的通用格式，包含9部分内容。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<h2 id="编码机制">编码机制</h2>
<p>为了避开安全字符集（US-ASCII）表示法带来的限制，为URL 设计了一种新的编码机制，通过一种『转义』表示法来表示不安全字符，包含一个百分号和两个表示字符ASCII 码的十六进制。</p>
<p>同时，保留了一些有特殊含义的字符，这些字符与某些协议或网关会产生混淆，所以应当注意，在将其用于保留用途之外的场合时，应当对其进行编码。其中有：<strong>% / . .. # ? ; : $,+ @,&amp;,= {}|\^~[]’ &lt;&gt;”</strong></p>
<p><strong>URL 包含的内容丰富多样，但是这些字段更多的信息，在后边才会介绍到，在这里，了解了URL 的基本格式和编码机制已经基本足够，而其中包含的字段和意义，再后边会有更详细的介绍。</strong></p>
<h1 id="HTTP_报文流">HTTP 报文流</h1>
<h2 id="报文流">报文流</h2>
<p>报文的流动方向和基本的格式在此不再过多介绍，因为这一部分属于基础内容，在所有的内容中都会接触，无需记录也不会忘记，这里简要记录一下：</p>
<ol>
<li>method 方法： 如GET，HEAD，POST 等。</li>
<li>request-URL : 命名请求的资源。</li>
<li>version: HTTP 版本。</li>
<li>status-code: 状态码，描述请求过程中发生的情况，后边会有详述。</li>
<li>reason-phrase: 原因短语，仅用于人阅读，机器忽视，属于状态码的可读版本。</li>
<li>header： 有多个键值对，以一个空行结束CRLF。</li>
<li>entity-body： 实体部分，以一个空行结束。</li>
</ol>
<h2 id="起始行">起始行</h2>
<p>起始行可以分为请求行和响应行，其起始行的内容不同。对于起始行，其起始行包含有method, request-URL,version。一些常见的方法有：</p>
<ol>
<li>GET， 获取一份文档</li>
<li>HEAD，获取首部</li>
<li>POST，向服务器发送需要处理的数据</li>
<li>TRACE，对可能经过的代理服务器传送到服务器上的报文进行追踪</li>
<li>OPTIONS，决定可以在服务器上执行哪些方法</li>
<li>DELETE，从服务器上删除一份文档</li>
</ol>
<p>GET，HEAD 方法被认为是安全的，是因为这些方法不会再服务器上产生什么结果，而像POST 方法，会提交信息在服务器上，就会执行一系列动作。而安全方法并非说不会执行服务器动作，而是当出现可能不安全行为的时候，会发出警告，这些由用户决议。</p>
<p><strong>HEAD</strong>：响应中只返回头部，不返回实体，使用HEAD，可以在不获取资源的情况下了解资源的情况，判断类型等；通过查看响应状态码，确定某对象是否存在；通过查看首部，测试资源是否被修改。</p>
<p><strong>PUT</strong>： 该方法是向服务器写入文档，其语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的文档，如果已存在，就替换之。执行PUT 请求，需要先登录。</p>
<p><strong>POST</strong>： 用来向服务器输入数据，一般用来支撑HTML 表单数据，发送给服务器。</p>
<p><strong>TRACE</strong>: 该请求可能会要求穿过防火墙、代理、网关等，都会修改HTTP 内容。而其目的一般用于诊断，一般用于验证请求是否如愿穿过了请求，或者响应链。但是，目前仍然有一些缺点，比如TRACE ，不会区分不同的方法机制。TRACE 请求中不带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<p><strong>OPTION</strong>: 请求web 服务器告知其支持的各种功能，包括通常支持的方法，或者对某些特殊资源支持哪些方法。</p>
<p><strong>DELETE</strong>: 请求服务器删除URL 所指定的资源。</p>
<p><strong>扩展方法</strong>： 其他还有一些扩展的方法，LOCK 锁定资源, MKCOL 允许用户创建资源, COPY 复制资源, MOVE 服务器上移动资源。</p>
<p>对于响应行，则一般会返回状态码，和reason-phrase，状态码是人们规定的一系列表示状态的code.</p>
<ul>
<li>1开头，表示信息提示，目前定义了100，101</li>
<li>2开头的，表示成功，200~206 最常见的还是200</li>
<li>3开头，表示重定向，300~305</li>
<li>4开头，客户端错误，400~415</li>
<li>5开头，服务器错误，500~505</li>
</ul>
<p><strong>100 Continue</strong>:<br>100状态码是HTTP/1.1 之后引入的信息性状态码， 其复杂性和感知价值存在一些争论。他实际上是客户端要向服务器发送一个实体，同时愿意在发送实体前等待100 Continue 响应，所以会发送一个值为100 Continue 的Except 请求首部。但中间会有很多问题，比如服务器如果没有回复响应，客户端一定要一直等着么，所以一般客户端会设置一个超时时间，超过后客户端会直接发送实体。而服务器需要处理几种情况，一种是还没有响应就收到了实体，一种是由于错误等服务器决定结束响应。对于代理，同样应当有处理逻辑，比如兼容问题，比如错误响应等。</p>
<p><strong>200 成功状态码</strong>：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609658165005.jpg" alt=""></p>
<p>成功状态码存在的问题是，hack 可能会伪装成服务器，向客户端发送虚假的成功码，就会劫持客户，所以此处的响应码就可能包含更多的信息。</p>
<p><strong>重定向状态码</strong>：<br>对于重定向状态码来说，也是极有可能对客户端发生劫持的内容，有可能将用户导向错误的地址，以下是更为详细的内容：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609660727847.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609661357874.jpg" alt=""><br>从图中可以看出，不同的状态码其实非常相近，其实内部各有区别，对于不同版本的HTTP 都有其处理上的差别，在此不再详述，有需要时再详细识别。</p>
<p><strong>客户端错误码</strong></p>
<p>4开头的状态码大概是用户最讨厌碰见的状态码，这一部分也包含了非常多的内容，同样的，在此不详述，具体见下表。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664853726.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664914763.jpg" alt=""></p>
<p><strong>服务器错误状态码</strong></p>
<p>当服务器自身出现错误的时候，就会返回这样的状态码，同样的，不同的状态码也代表了服务器不同的状态。</p>
<ul>
<li>500 Internal server error： 服务器遇到一个妨碍它为请求提供服务的错误。</li>
<li>501 not implemented ： 客户端发起的请求超过服务器能力范围。</li>
<li>502 bad gateway: 作为代理或者网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应。</li>
<li>503 service unavailable： 目前无法提供服务，如果知道什么时候可以提供服务，会在首部包含一个retry-after，告知。</li>
<li>504 gateway timeout: 等待另一个服务器对其请求进行响应超时了。</li>
<li>505 http version not supported： 使用了它不支持的协议版本。</li>
</ul>
<h2 id="首部">首部</h2>
<p>首部其所包含的内容和属性更多，一般来说，可以分为以下几类：</p>
<ol>
<li>通用首部：可以出现在请求报文和响应报文</li>
<li>请求首部：有关请求的信息</li>
<li>响应首部：如题</li>
<li>实体首部：描述主体长度，内容，或资源自身。</li>
<li>扩展首部：规范未定义的新首部。</li>
</ol>
<p>另外，如果想让某行分出多行提高可读性，记得要在多出来的行前加入空格或者tab。</p>
<p><strong>通用首部：</strong></p>
<ul>
<li>Connection 允许客户端和服务器指定与请求/响应连接有关的选项</li>
<li>Date 提供日期和时间的标志</li>
<li>MIME-Version MIME 版本号。</li>
<li>Trailer 如果报文采用了分块传输编码，使用这个首部列出报文拖挂（trailer）部分的首部集合。</li>
<li>Transfer-Encoding 采用的编码方式。</li>
<li>Update 更新的协议和版本。</li>
<li>Via 显示经过的中间节点。</li>
</ul>
<p>强调一点，<strong>Connection</strong>首部是一个逐跳首部，只适用于单挑传输链路，他不会沿着传输链路向下传输，也就是只在两个最近连接中产生作用。<br>同时，还有两个通用的缓存首部，就是允许http应用程序缓存对象本地副本的首部。</p>
<ul>
<li>Cache-Control 用于随报文传送缓存指示</li>
<li>Pragma 另一种随报文传送指示的方式，并不专用于缓存</li>
</ul>
<p><strong>请求首部</strong></p>
<ul>
<li>Client-IP 客户端机器的IP 地址。</li>
<li>From 客户端用户的E-mail 地址。</li>
<li>Host 接受请求的服务器的主机名和端口号。</li>
<li>Referer UA-Color UA-CPU UA-Disp UA-OS UA-Pixels User-Agent</li>
</ul>
<p>后边这些，基本上很少会出现，也很难去寄希望挖掘到有用的信息。</p>
<ul>
<li>Accept 首部为客户端提供了一种将其倾向告知服务器的方式。包括了媒体类型，字符集，编码方式，语言等内容。</li>
<li>条件请求首部，则是为请求加入一些限制。</li>
<li>安全请求首部，对请求进行质询/响应认证，其中Authorization ,cookie, cookie2 首部就是这一类。</li>
<li>代理请求首部。</li>
</ul>
<p><strong>响应首部</strong></p>
<ul>
<li>Age  响应持续时间，从最初创建开始</li>
<li>Public 服务器为其资源支持的请求方法列表</li>
<li>Retry-After 资源不可用时，可响应的重试时间</li>
<li>Server 服务器应用程序软件的名称和版本</li>
<li>Title html文档标题</li>
<li>Warning 警告报文</li>
<li>协商首部，具有一定协商能力，内容包括对某资源可接受的范围和向阳发生变化的时候可选择。</li>
<li>安全响应首部，对应于前边的authenticate,cookie</li>
</ul>
<p><strong>实体首部</strong><br>此处可能会发生安全问题，比如劫持服务器，像客户发送错误的 location ，让客户链接向错误的地址。</p>
<ul>
<li>Allow 可以对实体执行的请求方法</li>
<li>Location 告知客户端实体实际上位于何处，用于接收端定向到资源的位置上去。</li>
<li>内容首部，包括Content-Base（解析主体相对URL 时使用的基础URL），对主体执行的编码方式，自然语言，主体长度，资源位置，MD5，字节范围，对象类型等。</li>
<li>实体缓存首部，对被缓存的实体添加的一些信息，如验证已缓存的副本是否仍然有效等等。其中包括了标记，不再有效的日期，最后一次被修改的时间等。</li>
</ul>
<h1 id="连接管理">连接管理</h1>
<p>本部分，介绍的是HTTP 以及其之下的TCP 的原理和内容，实际上，这也是报文流的过程结构，其中会有许多安全上的危险发生。</p>
<h2 id="TCP">TCP</h2>
<p>先列一下TCP 套接字的常用接口函数，很常用，这是在分析代码时候必要的寻找流程的几个关键节点。</p>
<ul>
<li>s = socket() 创建套接字。</li>
<li>bind(s, <ip:port>) 绑定地址和端口</ip:port></li>
<li>connect(s, <remote ip:port="">) 创建本地套接字和远程主机和端口的链接</remote></li>
<li>listen(s, …) 坚挺</li>
<li>s2 = accept(s) 等待某人建立一条道本地端口的连接。</li>
<li>n = read(s, buffer, n) 从套接字到缓冲区读取n 个字节。</li>
<li>n = write(s, buffer, n) 从缓冲区向套接字写入n 个字节。</li>
<li>close(s) 关闭</li>
<li>shutdown(s,<side>) 关闭TCP 连接的输入或输出端</side></li>
<li>getsockopt(s, ..) 读取某内部套接字配置选项的值</li>
<li>setsockopt(s, ..) 修改某内部套接字配置选项的值</li>
</ul>
<p>以下就是一个正常的HTTP 服务器和客户端交互的过程。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14610508715798.jpg" alt=""></p>
<h2 id="HTTP_TCP_性能考量">HTTP TCP 性能考量</h2>
<p><strong>HTTP 事务的时延</strong></p>
<p>在日常上网过程中，我们时常被龟一样的网速折磨，其中有很多原因，有一部分是HTTP 的事务上的，一部分是TCP 之上的。HTTP上的事务延迟可能的原因有：</p>
<ol>
<li>通过DNS 解析将主机名换成一个IP 可能会花费不小的时间。</li>
<li>TCP 连接的建立时间延迟。</li>
<li>对TCP 报文的解析和处理依靠服务器性能，有一定的时间延迟。</li>
<li>Web 响应时间延迟。</li>
</ol>
<p><strong>TCP相关的时间延迟</strong></p>
<p>此处就进入较为深入的部分了，本来在研究上不需要达到这一地步，但是出于兴趣，做以简要挖掘。</p>
<ul>
<li>TCP 建立握手。</li>
<li>TCP 慢启动拥塞控制。</li>
<li>数据聚集的Nagle 算法。</li>
<li>用于捎带确认的TCP 延迟确认算法</li>
<li>TIME_WAIT 时间延迟和端口耗尽。</li>
</ul>
<p>对于第一点，HTTP 通过保持重用现存连接来解决每次握手花费时间的问题。</p>
<p>低于第二点，不需过多解释，HTTP 为了解决在初始调谐时速度慢的问题，采用长连接，也就是持久连接的方式解决。</p>
<p>对于第三点，Nagle 算法解决的问题，是说TCP 的数据流接口，允许任意尺寸的数据放入栈中，一次一个字节也可以，但是当大量的一字节内容发送，而实际上TCP 为这一字节的内容要装在40字节的标记和首部，造成了性能的严重下降。Nagle 算法就是试图将大量TCP 数据绑在一起，提高网络效率。Nagle 算法的主旨是鼓励网络发送全尺寸段（1500字节），只有在目前所有挂起的分组都被确认了，才可以立即发送非全尺寸段。而其他时间，则是将他们缓存起来，积累到一个全尺寸分组才发出去。</p>
<p>Nagle 算法在优化网络的同时，可能会对HTTP 性能造成一定影响，因为一个小的报文，必须要等到之前所有段都确认了，才可以发送，而这段时间，会有延迟，一般来说，HTTP 会设置参数TCP_NODELAY ,来禁用。当然这里还有很多文章可以做。</p>
<p>对于第四点，在我们TCP 连接的时候，每一个发出去的报文，都期望收到一个很小的确认包，但是因为报文非常小，不值得每次都单独发送，所以有时候延迟确认算法会在一个特定的窗口内将确认包放在缓冲区，等待一个时间窗口内，看能够有输出数据分组发出，将这个确认报文捎带上，如果这段时间里没有，就单独发包。这一点上，本来是为了解决TCP 连接中频繁发小包引起的性能问题而采用的算法，但是HTTP 确实具有明显的双峰特征，就是一端会频繁输出，而另一端只是频繁接收，如果还是使用这种延迟算法，则可能会带来性能上的下降，此时就应当调整和禁止延迟确认算法，来提高性能。</p>
<p>对于第五点，TIME_WAIT 的出现时机应当都很清楚，这个状态一般需要保持一小段时间，通常使用的是<strong>最大分段使用期的两倍，2MSL，通常两分钟</strong>，来确保这个时间段不会创建具有相同地址和端口号的连接。而如果一个服务器是短连接属性的，如果一段时间有较高的访问，就会出现大量的TIME_WAIT 状态，导致端口耗尽，性能急剧下降。一般的解决办法是剪短TIME_WAIT 时间，或者是用虚拟地址，增加更多的连接组合。</p>
<p><strong>提高HTTP 性能的技术</strong></p>
<ul>
<li>并行连接，多条TCP 连接发起并发的HTTP请求。</li>
<li>持久连接，重用TCP 连接，消除连接和关闭的时间延迟。</li>
<li>管道化连接，通过共享的TCP 连接发起并发的HTTP 请求。</li>
<li>复用的连接，交替传送请求和响应报文。</li>
</ul>
<p>对于并行连接，无需过多解释，目前考虑到性能等方面，浏览器一般支持的并行连接数量是4个。</p>
<p>对于持久连接，也就是保持TCP 连接状态，HTTP/1.0+ 上采用的是keep-alive 连接，HTTP/1.1 上采用的是 persistent 连接。关于keep-alive 中有很多信息，但是没有过于复杂的知识点，都是可以理解的内容，不再赘述。</p>
<p>对于管道化连接，他是keep-alive的进一步优化。在响应到达之前，可以将多条请求放入队列，如此连续的以管道化的形式进行传输，可以降低网络上的环回时间，提高性能。<br>注意，为了实现这种高性能，实际上是有一些限制：</p>
<ul>
<li>客户端应确认连接是持久的</li>
<li>HTTP 响应不能失序，否则无法与请求匹配。</li>
<li>客户端要做好随时可能会关闭的准备，以及要重发所有未完成请求的准备。</li>
<li>不应发送产生副作用的请求，如POST。（非幂等请求）<strong>HTTP 的幂等性待搞明白，简单来说就是一次和多次请求带来的副作用应当是一样的</strong><a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html" target="_blank" rel="external">参考文章</a></li>
</ul>
<p>另外，关闭连接也包含了大量的内容，这里我不想深究了，因为在保持连接部分里边的坑就目测很深，关闭连接里边也很深，因为要涉及到冲连接，安全性，数据完整，幂等性这些东西，都会有很多需要处理的内容，待到以后需要用到，再深究吧。简单的说，关闭连接，包括内容有『任意』接触连接，content-length 和截尾操作，连接关闭容限，重试等。</p>
<h1 id="HTTP_结构">HTTP 结构</h1>
<p>这一部分，略过了一些内容，只选择有价值的一部分，另外一些可能会有更深层的信息待挖。</p>
<h2 id="响应实体">响应实体</h2>
<p>响应实体的报文通常包括：</p>
<ul>
<li>描述响应主体MIME类型的Content-Type 首部。</li>
<li>描述响应主体长度的 Content-Length 首部。</li>
<li>报文主体。</li>
</ul>
<p>其中MIME类型负责指示资源的类型，一般服务器会提供魔法分类，或者是自定义分类。</p>
<p><strong>重定向：</strong></p>
<p>一个3xx 的重定向响应一般有如下情况</p>
<ul>
<li>永久删除资源：301</li>
<li>临时删除资源：303 307</li>
<li>URL 增强，一般是重写URL用于嵌入上下文，客户端会根据这个重定向信息重新发起请求。303 307</li>
<li>负载均衡 303 307</li>
<li>服务器关联，Web 服务器可能会有某些用户的本地信息，服务器可以将客户端重定向到包含那个客户信息的服务器上去。 303 307</li>
<li>规范目录名称：也就是规范URL 名。</li>
</ul>
<h2 id="代理">代理</h2>
<p>这是一个和其他部分没有太大联系的门类，其中包含的信息非常的大，在这里，我先留个坑，不花费时间去处理这个内容，留待单开补充。</p>
<h2 id="缓存">缓存</h2>
<p>缓存是解决带宽瓶颈的一个重要的方法，以CDN 为代表的技术仍然是主流。主要解决了网络时延，带宽瓶颈，瞬间拥塞，冗余数据的问题。</p>
<p>缓存包含的技术术语有：命中与未命中（这个很常见），再验证（新鲜度检测）。</p>
<p><strong>命中与未命中</strong><br><strong>再验证</strong>，缓存对缓存的副本再验证时，会向原始服务器发送一个小的再验证请求，如果内容没有变化，服务器会响应304，这个被称作再验证命中。这种方式要与原始服务器进行核对，所以比单纯的缓存命中要慢。</p>
<p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，最常用的是 If-Modified-Since 首部。首部添加到GET 请求中，告诉服务器，只有在缓存了对象的副本，又对其进行了修改的情况下，才发送此对象。对于再验证命中，则返回304，表示仍然新鲜。如果未命中，则像正常响应200.如果已删除，返回404，缓存的副本也将删除。</p>
<p><strong>命中率</strong>，这是一个重要的考量目标，缓存提供服务所占的比率，他与缓存大小，缓存用户兴趣点的相似性，缓存数据的变化或者个性化频率，以及缓存的配置，都影响到命中率。</p>
<p><strong>字节命中率</strong>，由于有些大型对象被访问的次数可能较少，但是由于尺寸的原因，对整个数据流量的贡献却很大。所以，有时候使用字节命中率更加准确。字节命中率表示缓存提供的字节在传输的所有字节中所占的比率。</p>
<p>客户端判断命中和未命中的方法是使用Date 首部，将响应的Date首部值与当前时间比较，如果响应日期比较早，可能认为这是一条缓存的响应，也可以使用Age 首部进行判断。</p>
<p><strong>代理缓存的层次结构</strong></p>
<p>实际上，缓存还存在有层次化的结构，一级缓存二级缓存等，这是为了逐步采用更大，功能更强的缓存来装在更多的用户共享文档。</p>
<p>而更加复杂的，还有网状缓存，内容路由以及对等缓存。可以考虑现在的P2P技术与之类似。</p>
<h3 id="缓存处理的基本步骤">缓存处理的基本步骤</h3>
<ul>
<li>接收，缓存读取请求报文。</li>
<li>解析，提取URL 和首部。</li>
<li>查询，查看是否有本地副本可用，没有就获取一份副本，将其保存本地。</li>
<li>新鲜度检测，如果已有，就验证是否新鲜，如果不新鲜，则请求服务器是否有更新。</li>
<li>创建响应，缓存构建响应报文。</li>
<li>发送</li>
<li>日志</li>
</ul>
<p>下图是一个新鲜的缓存命中<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200094685.jpg" alt=""></p>
<p>以一个更为一般化的流程图做以描述：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200650513.jpg" alt=""></p>
<p>服务器可以通过HTT 定义集中方式来控制缓存：Cache-Control ，Expires 首部等等，里边的内容包括max-age，详细的不再纠结。</p>
<p>后边关于缓存还有更多的知识点，甚至还有一些算法，比如使用期的算法，新鲜生存期算法，新鲜度算法等等。</p>
<h1 id="集成点：_网关，隧道，中继">集成点： 网关，隧道，中继</h1>
<h2 id="网关">网关</h2>
<p>网关的概念可以作为某种翻译器理解，抽象出了一种能够到达资源的方法。更形象的讲，网关就是一个门，用用程序可以通过接口请求网关来处理请求，网关提供响应。同时网关可以向数据库发送查询语句，生成动态内容等。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613152822853.jpg" alt=""></p>
<p>Web 网关在一侧使用HTTP 协议，在另一侧则使用另一种协议。例如当网关收到了一个对FTP 资源的请求，客户端实际上发送的是HTTP 请求，而网关则会打开一条到原始服务器的FTP 端口，通过FTP 协议去获取对象。完成之后，将对象放在HTTP 响应中返回给客户端。</p>
<p>再比如，客户端以普通的HTTP 形式浏览Web 内容，而网关可以自动加密用户对话，这是常见的HTTP/HTTPS 安全网关。而另外一种客户端安全加速网关则是反过来的HTTPS/HTTP 网关，这是为了确保在客户端和网关连接中途发生安全问题。</p>
<p>而最常见的网关，则是为了在客户端通过HTTP 通信的时候，能够与服务器端的应用程序相连，这时候就是需要调用服务器上应用程序的API ，来实现应用程序的调用。<strong>最早期的应用程序网关API 是CGI</strong>，而纯CGI 来写的人已经很少了，因为注入ASP，PHP 已经将CGI 包装好，实现了其特性，本质上CGI 就像一个非常简单的协议，人们更习惯使用更加简单易读的PHP 等语言。</p>
<p>在CGI 初始，由于CGI 是分离的，服务器要为每条CGI 请求引发一个新进程，这会极大的限制服务器的性能，为解决这个问题，人们开发的新语言FastCGI ，这个接口模拟CGI，作为持久守护进程运行的，消除了每个请求简历和拆除进程带来的性能损耗。当然实际上，现在还是PHP 这些语言的天下。</p>
<p>时至今天，应用程序和Web服务的接口越来越多，甚至我们也看到了Chrome Book 甚至可以仅仅将一个浏览器就可以作为一个操作系统的入口。这时候，HTTP 其实可以作为一种连接应用程序的基础软件来看待，而此时，将HTTP 协议与其他应用程序的协议之间的协商和接口，都成为了重要的内容。</p>
<h2 id="隧道">隧道</h2>
<p>接上一个话题，刚才说的是通过HTTP 协议，与应用程序之间建立接口，而HTTP 还有另一个用法，就是为应用程序之间建立通信，这就是隧道（Web tunnel）。通过隧道，非HTTP 协议可以在HTTP 协议包装下，穿过只允许Web 流量的防火墙了。</p>
<p>常见的隧道建立方式是通过<strong>Connect</strong> 建立的，CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的TCP 连接，并对客户端和服务器之间后继数据进行盲转发。下图就是以建立SSL 隧道为例，注意看其中的请求，则是以CONNECT 为首，主机号和端口号取代了URI，响应短语经常为Connection Established。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613168465645.jpg" alt=""></p>
<p>为什么我们要实现SSL 的隧道呢，因为对于传统的代理服务器，SSL 的信息是加密的，防火墙无法识别，就会被HTTP 防火墙拦截。而实现了隧道化的SSL ，加密数据放入正常的HTTP 报文中，就能通过防火墙了。在隧道的起点用HTTP 封装SSL ，然后以普通HTTP 报文的形式通过防火墙，然后在对报文解封，继续进行普通的SSL 连接。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613176934946.jpg" alt=""></p>
<p>SSL 隧道与我们刚才所讲的网关实现HTTP/HTTPS 有一定的差别。相比于隧道，网关实现方式有几个缺点：</p>
<ol>
<li>客户端到网关之间的连接是普通的HTTP，因为只有普通的http 才可以通过防火墙。</li>
<li>尽管代理是已认证的主体，但客户端无法对远端的服务器执行SSL 客户端认证 X509证书。</li>
<li>网关要支持完整的SSL 实现。</li>
</ol>
<p>同时，隧道为了安全考虑，也需要将代理的认证支持与隧道配合使用，对客户端使用隧道权利进行认证，过程如图。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613179676011.jpg" alt=""></p>
<p>出于对隧道安全的考虑，因为我们在传输过程中，不知道其内容是什么，所以有些人就可能通过诸如SSL 隧道，越过防火墙传递其他流量，包含一些恶意信息等，所以一般情况下，网关只对特定的端口和特定的内容开发端口，如443.</p>
<h2 id="中继">中继</h2>
<p>中继的内容不多，理解为一个没有完全遵循HTTP 规范的HTTP 代理。中继在两个连接之间，只进行盲转发。当然，我们也可以在中继上部署一些简单的过滤，诊断和内容转换的功能。</p>
<p>但是，中继上存在一个严重的问题，它无法正确处理Connection 首部，所以有潜在挂起 keep-alive 连接的可能。因为Connection 它是逐跳首部，只适用于单条传输链路，中继仅仅是盲转发，无法理解，也无法让他沿着链路一直传送下去，但是对于服务器和客户端，双方都以为建立了keep-alive 长连接，但实际上并非如此。所以，就陷入了麻烦。当然，现代的方法，采用了更加智能的判断方式，来消除这一个风险。</p>
<h1 id="Web_robot">Web robot</h1>
<h2 id="爬虫">爬虫</h2>
<p>爬虫是一个有趣的门类，他看起来很简单，似乎也有很多现成的解决方案，但是在实际的场景中，却又会有很多新的问题要解决，爬虫和反爬虫之间的斗争也一直在延续。本质上，在网络上活跃的自动化脚本，都可以叫做爬虫，他们日夜不停的执行着任务，为自己的老板收集大量的有用的内容。</p>
<p>下面是围绕到爬虫的一些必要的内容，当然，这是与HTTP 相关的内容：</p>
<h3 id="连接提取和相对链接标准化"><strong>连接提取和相对链接标准化</strong></h3>
<p>很简单，我们爬去的URL ，有些可能是相对链接，所以我们要根据其父亲结点，将相对链接标准化，处理成能够规范整理的信息。</p>
<h3 id="环路避免"><strong>环路避免</strong></h3>
<p>为了避免出现循环和重复，对那些访问过的URL ，我们要用特殊的结构保存起来，以确保在爬取的是新的URL，一般采用下面这些技术：</p>
<ul>
<li><strong>树和散列表</strong>，使用树形结构和散列表的结构，去寻找已访问的URL，提高了一定的速度，但在空间上仍然是巨大的。</li>
<li><strong>有损的存在位图</strong>，这里用的就是位图的概念，建立一个存在位数组，对每个URL 都转换为一个定长的数字，这个数字对应在数组的位置就是存在位，爬行过之后，该位置就置位。由于URL 潜在数量是近乎无限的，但是给予的空间总是有限的，所以很可能有两个不同的URL 对应于一个存在位，所以就可能会有部分URL 被忽略，所以是有损的。</li>
<li><strong>本地化列表</strong>，URL 列表应保存一份在本地硬盘，防止机器人崩溃，前功尽弃。</li>
<li><strong>分类</strong>，实际上就是采用了爬虫集群，分工的形式对某URL 片进行爬取，个体之间可能还需要相互通信，实现更复杂的功能。</li>
</ul>
<p>注意，不仅在URL 上可能会有环路问题，在文件系统连接上也会存在环路，在目录层次上可能会进入深度无限的假象。比如一个subdir 的链接链接到上层文件夹，就会让层级无限深入下去。</p>
<p>而在爬虫和反爬虫的斗争中，网管甚至还会创造一些虚假信息，他们会发布一个看起来是普通的文件，实际上却是网关应用程序，这是很容易的，当爬虫去请求了这个URL，服务器就会捏造一个新的HTML页面和一个新的虚构的URL ，以此让爬虫在这个看似都不同的URL 陷阱里越陷越深。如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613267668464.jpg" alt=""></p>
<p>在斗智斗勇的路上，爬虫也会进化：</p>
<ul>
<li>规范化URL，以此来避免别名带来的URL 重复</li>
<li><strong>广度优先</strong>，采用此策略，可以降低环路带来的影响，因为不像深度优先一样爬进一个坑里出不来。</li>
<li><strong>节流</strong>， 为防止在一个URL 站点里越陷越深，适当的限制重复的页面总数和对服务器访问总数来截至该操作。</li>
<li>限制URL 大小，某些情况，可能会让URL 无限增长，最简单的办法就是限制一个URL 的长度。一般1kb</li>
<li>URL 黑名单，建立一个列表，维护那些曾经让机器人陷入回路和陷阱的站点列表，所爬取的时候，就绕过他们。</li>
<li><strong>模式检测</strong>，造成环路陷阱的一般都会有一定的模式，比如固定模式循环出现，某组件重复出现超过三次等等。</li>
<li><strong>内容指纹</strong>，这是更加复杂的方法，爬虫爬取某页面，会通过提取部分字节建立指纹，指纹压缩存储起来，爬取新页面的时候，提取其校验和，与指纹库比较，如果以前见过，就不再爬取，这样就避免了仅依靠URL 做判断的方法。</li>
<li><strong>人工审计</strong>，这是最无奈的方法。</li>
</ul>
<h3 id="别名的判断"><strong>别名的判断</strong></h3>
<p>有些时候，同一地址的URL 可能会不同，叫做别名，比如URL 上添加不添加端口号，比如URL 编码，比如使用标签，服务器文件大小写，默认页面写不写，ip地址和域名地址等。</p>
<p>所以在别名的判断时候，有时就会对URL 进行规范，比如加上指定端口，把所有的转义字符用等价字符表示，删除#标签。</p>
<h2 id="爬虫与HTTP">爬虫与HTTP</h2>
<p>一个良好的爬虫，是受网站欢迎的，比如搜索引擎的爬虫爬取网站的基本信息，提供给人们搜索，可以提高网站访问，所以遵循道德准则的爬虫往往是放行的。而一个爬虫在爬取网页时，它也需要像正常请求一个，使用HTTP 请求，请求页面内容，只是在爬取的阶段中，可以在http 的首部告知自己的身份，也可以在Accept 里写明自己想要爬取什么样的内容，图片，文本等。</p>
<p>在使用HTTP 发出请求的时候，应当注意一些细节：</p>
<ul>
<li>一定要携带Host,如果遇到一个服务器提供两个站点，而发送请求没有携带Host， 服务器可能只会返回默认的那个站点。</li>
<li>爬虫辛苦爬到的站点，可能随时会改变内容，爬虫应当对时间戳或者是实体标签进行比较，来确认获取的版本是否升级，这方法类似于缓存查看机制。</li>
<li>对响应做处理，比如状态码，常见状态码，和一些特别的状态码。</li>
<li>实体部分，有些响应的实体中，可能会包含一些重定向等信息，包含在元标签如 http-equiv 等，<meta></li>
</ul>
<p>不良爬虫的特点：</p>
<ul>
<li>失控，访问速度太快，造成站点服务器过载，会被当做ddos攻击的爬虫。</li>
<li>失效URL ，没有更新URL，总是使用失效的URL 向服务器进行访问，也会对服务器的开销造成影响。</li>
<li>很长又错误的URL，同样造成web服务器性能下降。而且这两个都会让审计日志变得杂乱。</li>
<li>不小心访问了私有的URL地址。</li>
<li>保留了一些已经被删除的信息。</li>
</ul>
<p>由于有不良爬虫的存在，但是良好的爬虫仍然是有益的，所以人们约定在服务器文档根目录上提供一个可选的文件，robots.txt ，里边包含了对机器人的一些约束，也提供给良好的爬虫，让其更加方便的爬取信息。所以，一个良好的爬虫，首先要做的就是试图去获取站点的robots.txt 资源，并根据响应码做出下一步的反应，比如200，则拿到robots.txt， 就必须进行解析，依照规则爬取；如果404，说明不受限；如果401或403，表示该站完全不欢迎爬虫；如果503，则应稍后重试；如果3xx，则重定向方向去爬取。</p>
<p>至于robots.txt 的格式，很简单，不再赘述，因为我还没有想做一个站长，而且现在很多成熟的爬虫，会有自动化工具给予采用。而且，现在的站点，为了优化自己让搜索引擎更快的更新站点信息，会提供一个sitemap.txt 的文件，让爬虫直接顺着内容爬取即可，这样双方受益，效率可观。</p>
<h2 id="搜索引擎">搜索引擎</h2>
<p>爬虫有很多终极目的，而搜索引擎可以说是最重要的应用之一。搜索引擎相比于爬虫，还要多提供全文索引，本地内容存储的功能。因为为了给用户提供关键词的搜索，搜索引擎必须对它所搜索到的页面建立一个『全文索引』的复杂本地数据库，用户发送查询请求的时候，他应当在自己的数据库中找到所有的包含该关键词的文档。</p>
<p>更复杂的，搜索引擎还应当对匹配的结果进行排名，这一部分就包含了更多的东西，在这里不是重点了，有机会更深一步的时候，再进行理解。</p>
<h1 id="HTTP，识别、认证、安全">HTTP，识别、认证、安全</h1>
<h2 id="cookie_机制">cookie 机制</h2>
<p>在cookie机制之前，我们还会介绍另外一些识别机制，各有优劣，先列如下：</p>
<ul>
<li>HTTP 首部承载用户信息</li>
<li>客户端 IP地址跟踪，通过IP 进行识别。</li>
<li>用户登录，根据用户认证识别用户。</li>
<li>胖URL， 一种在URL 中嵌入识别信息的技术。</li>
<li>cookie</li>
</ul>
<p><strong>HTTP 首部承载信息</strong></p>
<p>在HTTP 首部中有七个常见可承载信息的首部：</p>
<ul>
<li>From 用户Email.</li>
<li>User-Agent 用户浏览器软件</li>
<li>Referer 用户是从这个页面上依链接条转过来的。</li>
<li>Authorization 用户名和密码</li>
<li>Client-IP 客户端IP。</li>
<li>X-Forwarded-For 客户端IP地址。</li>
<li>Cookie 服务器产生的ID 标签。</li>
</ul>
<p>实际上其中可用的信息实际上是后三个：</p>
<p><strong>客户端IP</strong></p>
<p>首先应说，Client-IP 首部并不一定是存在的，但是我们仍然可以调用诸如 UNIX 下 getpeername 的函数来返回客户端IP ,但是实际上，客户端IP 很难作为识别用户的方式。</p>
<ul>
<li>客户端IP描述的是机器，不是用户。</li>
<li>很多服务商是动态分配IP，每次登陆会得到不同的地址，所以现在利用IP 识别的，也一般仅仅是识别一个IP段，去做某种操作。</li>
<li>有些防火墙会通过NAT 网络地址转换方式，转换成一个防火墙共享IP 来访问。</li>
<li>有些会从HTTP 代理或网关出重新发出TCP 连接。</li>
</ul>
<p><strong>用户登录</strong><br>如果服务器希望在用户提供对站点访问之前，先行登陆，就会响应一个401 状态码，Login Required，然后显示一个登陆对话框，在随后的请求中会添加Authorization 首部。</p>
<p>其实这种方法已经不怎么用了，因为安全性太低了，现在也会出现有401钓鱼的行为，用户的登录信息虽然会加密，但是加密信息实在是太好破了，而且如果劫持了用户的信息，还可以放在自己的首部伪装成用户登录。</p>
<p><strong>胖URL</strong></p>
<p>有些站点利用对URL 添加特定的URL 版本，来追踪用户身份，比如一些商务网站，通过针对每个用户在URL 后边生成特定的标示符，可以实现对用户浏览的追踪。通过胖URL 可以将Web服务器上的若干个HTTP 事务绑定在一个会话和访问上，用户首次访问某站点，生成一个ID ，服务器通过识别ID 的方式，添加到URL 中去，然后将客户端导向到那个胖URL 上去。不论什么时候，只要服务器收到了胖URL 请求，都可以查找那个用户ID 相关的操作，增量状态等，然后重写输出超链接，让其成为胖URL，维护用户ID。</p>
<p>但是，这样的操作，我们也很明显看出了其中的问题：</p>
<ul>
<li>URL 丑陋，不说了</li>
<li>URL 无法共享，因为它包含了特定用户的一些信息。仅在部分情况下可以，就比如邀请人链接，刚好是需要这样的识别。</li>
<li>破坏缓存，每个用户的URL 都生成特定的版本，那么意味着没有公共可访问的URL 需要缓存了。</li>
<li>服务器负荷，重写HTML 和 生成胖URL。</li>
<li>逃逸，如果用户逃离了严格修改的URL 链接，就会失去了他所有的进展。</li>
<li>会话期间非持久，除非用户收藏了特定的URL， 否则用户删除之后，再也找不回来了。</li>
</ul>
<p>当然，胖URL 技术还是有很多应用的，这就要应对许多新的场景，展开更丰富的联想，也可以通过加入其它手段来克服其中的缺点，总之，不要放弃任何一种方法，有时候都是会起死回生。</p>
<p><strong>cookie</strong></p>
<p>cookie 可以分为两类： <strong>会话cookie 和 持久cookie</strong></p>
<p>对于会话cookie， 它是一种临时的cookie， 记录了用户访问站点时候的设置和偏好，用户退出浏览器，会话cookie 就会删除掉。而持久cookie 显然是生存周期更久的一种。常见的，如果cookie 设置了Discard 参数，没有设置Expires 或者 Max-Age 参数来说明扩展过期时间，那么一般就是一个会话cookie.</p>
<p>cookie 包含了一个由名字和值 组成的信息构成，通过Set-Cookie,Set-Cookie2 HTTP响应首部来给用户。下边这只是一个例子，cookie 的格式又服务器决定：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613325046800.jpg" alt=""></p>
<p>cookie 罐的概念，就是浏览器在本地管理cookie 信息的形式，浏览器要负责储存这些信息，一般统称为<strong>客户端侧状态</strong>，这种规范叫HTTP状态管理机制。不同的浏览器，会有不同的cookie 的储存机制。储存起来的cookie 包含了一些名称变量过期安全等考量，具体可查看每种浏览器的cookie格式。</p>
<p>虽然我们说，cookie 只会发给那些之前对应的服务器，但是某些无量的广告商，他们会发送持久cookie ，一些站点会委托同一个广告公司提供服务（比如百度），那么浏览器会将持久的cookie 发过来，广告公司通过将此技术和referer 结合，暗地里构建了一个用户档案和浏览习惯的详尽数据集。</p>
<p>cookie 将包含一些必要的信息，有些信息是可选的，其中具体的内容，这里不再赘述，具体可参见RFC 2965：</p>
<ul>
<li>cookie 域属性，Domain 属性将控制哪些站点可以得到那个cookie.</li>
<li>cookie 路径属性，cookie 规范允许用户将cookie 与部分 Web站点关联起来。Path 属性来实现功能，在这个属性下列出的URL 前缀下所有的cookie 都是有效的。</li>
<li>安全属性，可选</li>
<li>日期属性，可选</li>
</ul>
<p>而在cookie 的扩展版本中，引入了Set-Cookie2首部 和Cookie2 首部，做出了一些新的改进，它能够与cookie 互操作。</p>
<p>而 Set-Cookie2 属性包括有：</p>
<ul>
<li>NAME=VALUE 强制</li>
<li>Version 强制，规范版本。</li>
<li>Comment 可选，说明服务器如何使用cookie.</li>
<li>CommentURL  可选，策略文档。</li>
<li>Discard 可选，客户端程序终止时，指示客户端放弃cookie.</li>
<li>Domain 可选，域。</li>
<li>Max-Age 可选，生存期，秒为单位。</li>
<li>Path 可选，路径。</li>
<li>Port 可选，可以应用cookie 的端口列表。</li>
<li>Secure 可选，使用SSL才可以发送的指示。</li>
</ul>
<h3 id="cookie_与会话跟踪">cookie 与会话跟踪</h3>
<p>一张图，讲所有：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613368816595.jpg" alt=""></p>
<p>Web 通过一系列的重定向，URL 重写，和cookie 设置来附加标识信息。</p>
<h3 id="cookie_与缓存">cookie 与缓存</h3>
<p>目前还不需要用到相关业务，暂且不表。</p>
<h2 id="认证">认证</h2>
<p>HTTP 通过一组可定制的控制首部，为不同的认证协议提供一个可扩展的框架。主要分<strong>基本认证和摘要认证</strong></p>
<ul>
<li>质询 WWW-Authentiacate，服务器以401状态码拒绝请求，说明需要提供用户名和密码。</li>
<li>授权 Authorization 客户端重新发送请求，但这一次会负责为一个Authorization 首部，用来说明认证算法，用户名和密码。 属于GET</li>
<li>成功 Authentication-Info 如果授权书正确，服务器会将文档返回，授权算法在该首部返回一些与授权会话相关的信息。 200 OK。</li>
</ul>
<p>下面是相关的流程示意图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614015756784.jpg" alt=""></p>
<p><strong>安全域</strong></p>
<p>在上边的质询里有一个realm 他就是安全域，也就是你试图访问的安全域，需要哪个授权。</p>
<h3 id="基本认证">基本认证</h3>
<p>基本认证就是我们刚刚讲的质询响应，用户请求的资源位于某个安全域中，服务器会返回一个401，质询，并提供安全域。用户只有将用户名密码（base64 处理）后返回，才可以获得正确响应。</p>
<h3 id="代理认证">代理认证</h3>
<p>中间的代理服务器也可以实现认证功能，这样我们就可以在代理服务器上对访问策略进行集中管理。代理认证的首部有所不同，对应的返回码也是不同的。</p>
<ul>
<li>代理服务器返回 407</li>
<li>Proxy-Authenticate 对应 WWW-Authenticate</li>
<li>Proxy-Authorization 对应 Authorization</li>
<li>Proxy-Authentication-Info 对应 Authentication-Info</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<p>基本认证的缺陷很明显，所以现代的服务器基本不是这样处理了，缺陷有这么几点：</p>
<ol>
<li>基本认证通过网络发送用户名和密码，bash-64 没有安全可言。</li>
<li>即使密码是更难解码的方式加密，第三方用户仍然可以捕获修改过的用户名和密码，重放攻击。</li>
<li>即使将基本认证用于一些不重要的应用程序，如内部网络访问控制和个性化的访问，但捕获这些密码，可以构建撞库的可能。</li>
<li>基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，如果他们不修改认证首部，但是修改了报文的其他部分，仍然是严重的。</li>
<li>假冒服务器容易骗过基本认证，这也就是401钓鱼。</li>
</ol>
<h2 id="摘要认证">摘要认证</h2>
<p>摘要认证是另一种HTTP 认证协议，修复了一些严重的缺陷，一般有如下改进：</p>
<ul>
<li>永远不会以明文方式在网络上发送密码</li>
<li>可以防止恶意用户捕获并重放认证的握手过程</li>
<li>可以有选择的防止对报文内容的篡改</li>
<li>防范集中常见的攻击方式，如重放攻击等。</li>
</ul>
<p>单向摘要，实际上就是我们常用的MD5 ，SHA-1 了。<br>而为了防止重放攻击，服务器和客户端使用随机数这样的特殊令牌，客户端在计算摘要前将随机数附加上去，这样每次发送的信息，都会有一个随时间变化的随机数。</p>
<p>摘要算法的核心是对公共信息，保密信息，和有时限的随机值的摘要。核心是三个组件：</p>
<ul>
<li>单向散列函数H(d) 摘要KD(s, d)组成的一对函数。s表示密码，d表示数据。</li>
<li>包含安全信息的の数据块A1，包括密码。</li>
<li>包含请求报文中非保密属性的数据块，A2。</li>
</ul>
<p>其中A1 的数据块是密码，和受保护信息的产物，包含有用户名，密码，保护域，随机数的内容。一般是MD5.<br>A2 表示的是与报文自身有关的信息，比如URL，请求方法和报文实体部分。A2主要是防止方法，资源，报文被篡改。当qop = 「auth」 只包含HTTP 请求方法和URL。qop=’auth-int’ ，添加了报文的实体主题部分，提供一定程度的报文完整性检测。<br>摘要认证的过程及其内容看起来像是一个弱化版的SSL，所以在这里不再赘述，一个图大约够了。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614149936666.jpg" alt=""></p>
<p>稍微补充几个概念：</p>
<ul>
<li>预授权，正常来说，如果按照上边的说法，每次的请求，都要做一次质询，但如果我们采用授权模式，如果一次请求授权成功之后，每次服务器会返回一个随机数，客户利用随机数再发出下一次的请求，和授权，这样就节省了很多交互。</li>
<li>随机数的产生，是一个只有服务器知道的数据。</li>
<li>不仅可以有单向的认证，还可以采用对称形式的认证。</li>
</ul>
<p>下面则是讨论一下这个认证一些重要的实际问题和安全性问题：</p>
<ol>
<li>多重质询，因为服务器不知道客户端可以做到哪种能力的认证，所以可以又提供基本认证质询，又提供摘要认证质询。</li>
<li>差错处理，如果某个指定其值不正确或缺少必要指令，应当返回400 bad request。而且某些时候，连续的差错可能代表了某种攻击行为。</li>
<li>保护空间，也就是提供授权访问的区域。对于基本认证，考虑URL 之下的所有子路径都是同一保护空间。对于摘要认证，服务器会提供一个URI 的列表。</li>
<li>缓存，Cache-Control 指令为must-revalidate 和 public 会有不一样的处理。</li>
</ol>
<p>安全性的考量：</p>
<ol>
<li>首部篡改，这里的认证机制，实际上只是一个首部防篡改系统，对数据并起不到多少的保护作用。</li>
<li>重放攻击，也是前边一直力图解决的问题，防止中间人利用截获的认证证书用于其他事务。最重要的实际上应当是防止POST 请求和PUT 请求，可能会篡改服务器的内容。上边内容的缺陷在于面对代理集群传输的时候，会遇上麻烦，而且攻击者伪造IP 也是有可能的。而一种完全可以避免重放共及的方式就是为每个事务提供唯一的随机数，发布的随机只对指定的事务有效，而且只在超时区间内有效，这样中间人即使是篡改了报文，但随机数只对某事务有效，它仍然无法成功，当然这会造成服务器的负担。</li>
<li>多重认证机制，因为服务器支持多重认证，攻击者可能会采用某些方法，让服务器采用最弱的基本认证机制，而基本认证机制会有一些安全上的脆弱，所以，解决办法也只能是不允许降级。其实主动降级攻击这在攻击表里很常见，例如对SSL 的攻击了，就是试图去让SSL 退化到早先的版本，然后利用其中的漏洞进行攻击。</li>
<li>词典攻击，大部分是针对弱密码，采用复杂密码或者是密码过期策略之外，没有更好的办法。</li>
<li>中间人，恶意代理。客户端和服务器之间的代理，在处理客户端的报文时，故意降级，采用较弱的认证方式，实现前边所说的攻击。</li>
<li>选择明文攻击，这里是一个恶意的服务器，伪装成服务器，预先使用一个随机数和一个常见密码变化形式形成一组响应，创建一个词典。一旦有了规模可观的词典，攻击服务器或代理就可以完成对流量的封锁，向客户发送预先确定的随机数。攻击者从客户端得到一个响应时，会搜索生成的字典，寻找匹配项。找到对应的匹配项，就能获取密码了。另外，暴力枚举现在能力也很强大，他不使用预设的字典去匹配了，直接在指定空间内枚举全部可能，直接暴力破解。</li>
<li>服务器保存了密码文件，用来与用户响应的内容比较，如果密码文件被侵入，那该域中文件就不再安全了。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式探索之路（下）]]></title>
    <link href="http://yoursite.com/2016/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/12/设计模式探索之路（下）/</id>
    <published>2016-03-12T13:50:01.000Z</published>
    <updated>2016-03-12T13:51:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="组合模式(Composite_Pattern)">组合模式(Composite Pattern)</h2>
<p>我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>组合模式</strong>： 允许你将对象组合成树形结构来表现『整体/部分』的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br><a id="more"></a><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901208629.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901303514.jpg" alt=""></p>
<p> <strong>抽象构件（Component）</strong>: 这是一个抽象角色，它给参加组合的对象定义出公共的接口以及默认行为，可以用来管理所有的子对象。在安全式的组合模式里，构件角色并不是定义出管理子对象的方法，这一定义由树枝构件对象给出。<br> <strong>树叶构件（Leaf）</strong> : 树叶对象是没有下级子对象的方法，定义出参加组合的原始对象的行为。<br> <strong>树枝构建（Compositic）</strong>: 代表参加组合的有下级子对象的对象。树枝对象给出所有的管理子对象的方法，比如add(),remove(),getChild()等。</p>
<p>组合模式的实现根据所实现接口的区别分为两种形式，分别称为安全模式和透明模式。组合模式可以不提供父对象的管理方法，但组合模式必须在合适的地方提供子对象的管理方法（诸如：add、remove、getChild等）。</p>
<p><strong>透明模式</strong>： 在Component里面声明所有的用来管理子类对象的方法，包括add（）、remove（），以及getChild（）方法。这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端可以同等同的对待所有的对象。这就是透明形式的组合模式。</p>
<p>这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此add（）、remove（）以及getChild（）方法没有意义，是在编译时期不会出错，而只会在运行时期才会出错或者说识别出来。针对这个，我们常常用throw 抛出异常。</p>
<p><strong>安全方式</strong>： 是在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，因为树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。<br>这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。</p>
<p>上边的图安全方式的组合模式的类图结构和样例实现，透明方式就是在叶子节点的add()/remove()/GetChild()均有实现，不过是无意义的实现。大部分应用都是基于透明模式的，因为这样代码可以重用。</p>
<p>下面看一个实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Menu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> Menu    </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> ~Menu();  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Add(Menu*);  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Remove(Menu*);  </div><div class="line">    <span class="keyword">virtual</span> Menu* GetChild(<span class="keyword">int</span>);  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Display() = <span class="number">0</span>;  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    Menu();  </div><div class="line">    Menu(std::<span class="built_in">string</span>);  </div><div class="line">    std::<span class="built_in">string</span> m_strName;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//Menu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line">  </div><div class="line">Menu::Menu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu::Menu(std::<span class="built_in">string</span> strName) : m_strName(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu::~Menu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Menu::Add(Menu* pMenu)  </div><div class="line">{}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Menu::Remove(Menu* pMenu)  </div><div class="line">{}  </div><div class="line">  </div><div class="line">Menu* Menu::GetChild(<span class="keyword">int</span> index)  </div><div class="line">{  </div><div class="line">    <span class="keyword">return</span> NULL;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="comment">//SubMenu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> SubMenu : <span class="keyword">public</span> Menu    </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SubMenu();  </div><div class="line">    SubMenu(std::<span class="built_in">string</span>);  </div><div class="line">    <span class="keyword">virtual</span> ~SubMenu();  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> Display();  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//SubMenu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "SubMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line">SubMenu::SubMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">SubMenu::SubMenu(<span class="built_in">string</span> strName) : Menu(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">SubMenu::~SubMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> SubMenu::Display()  </div><div class="line">{  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; m_strName &lt;&lt; endl;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="comment">//CompositMenu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> CompositMenu : <span class="keyword">public</span> Menu  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    CompositMenu();  </div><div class="line">    CompositMenu(std::<span class="built_in">string</span>);  </div><div class="line">    <span class="keyword">virtual</span> ~CompositMenu();  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> Add(Menu*);  </div><div class="line">    <span class="keyword">void</span> Remove(Menu*);  </div><div class="line">    Menu* GetChild(<span class="keyword">int</span>);  </div><div class="line">    <span class="keyword">void</span> Display();  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;Menu*&gt;</span> m_vMenu;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//CompositMenu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompositMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line">CompositMenu::CompositMenu()  </div><div class="line">{  </div><div class="line">      </div><div class="line">}  </div><div class="line">  </div><div class="line">CompositMenu::CompositMenu(<span class="built_in">string</span> strName) : Menu(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">CompositMenu::~CompositMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Add(Menu* pMenu)  </div><div class="line">{  </div><div class="line">    m_vMenu.push_back(pMenu);  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Remove(Menu* pMenu)  </div><div class="line">{  </div><div class="line">    m_vMenu.erase(&pMenu);  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu* CompositMenu::GetChild(<span class="keyword">int</span> index)  </div><div class="line">{  </div><div class="line">    <span class="keyword">return</span> m_vMenu[index];  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Display()  </div><div class="line">{  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> &lt;&lt; m_strName &lt;&lt; endl;  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Menu*&gt;</span>::iterator it = m_vMenu.begin();  </div><div class="line">    <span class="keyword">for</span> (; it != m_vMenu.end(); ++it)  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"|-"</span>;  </div><div class="line">        (*it)-&gt;Display();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "SubMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompositMenu.h"  </span></div><div class="line">  </div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])  </div><div class="line">{  </div><div class="line">    Menu* pMenu = <span class="keyword">new</span> CompositMenu(<span class="string">"国内新闻"</span>);  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"时事新闻"</span>));  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"社会新闻"</span>));  </div><div class="line">    pMenu-&gt;Display();  </div><div class="line">    pMenu = <span class="keyword">new</span> CompositMenu(<span class="string">"国际新闻"</span>);  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"国际要闻"</span>));  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"环球视野"</span>));  </div><div class="line">    pMenu-&gt;Display();  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>几个要点：</strong></p>
<ul>
<li>组合模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。</li>
<li>组合模式在具体实现中，可以让父对象中的子对象反向追溯，这样做的话，当需要删除子节点的时候，通过父节点就更容易操作一些。</li>
<li>如果父对象有频繁的遍历需求，那么就可以使用缓存的技巧来改善效率。</li>
<li>将“客户代码与复杂的对象容器结构”解耦是组合模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复内部实现结构——发生依赖关系，从而更能“应对变化”。</li>
<li>客户端尽量不要直接调用树叶类的方法，而是借助其父类（Component）的多态性，完成调用，这样可以增加代码的复用性。</li>
</ul>
<h2 id="状态模式（State_Pattern）">状态模式（State Pattern）</h2>
<p><strong>状态模式</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901470388.jpg" alt=""></p>
<p>就像我们平时用的开关，开关有两个状态，开启和关闭，当它处于不同的状态的时候它的行为是不一样的，当我们遇到了更多的状态的时候，就需要动用到了这个状态模式。</p>
<p><strong>Context 上下文环境</strong>： 它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的具体状态对象来处理。<br><strong>Stata 抽象状态</strong>: 定义了一个接口以封装使用上下文环境的一个特定状态相关的行为。<br><strong>Concrete State 具体状态</strong>： 实例抽象状态定义的接口。</p>
<p>下面例子以游戏中坦克为例，坦克架起的时候，攻击力加强，不能移动。收起的时候，可攻击可移动。c++ 实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="keyword">class</span> SiegeTank;  </div><div class="line"><span class="keyword">class</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack() = <span class="number">0</span>;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> SiegeState : <span class="keyword">public</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SiegeState(SiegeTank* pTank): m_pTank(pTank){}  </div><div class="line">      </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't move in siege mode."</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attacking for 40"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    SiegeTank* m_pTank;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> TankState : <span class="keyword">public</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    TankState(SiegeTank* pTank): m_pTank(pTank){}  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attacking for 20"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    SiegeTank* m_pTank;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> SiegeTank  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SiegeTank()  </div><div class="line">    {  </div><div class="line">        m_pTankState = <span class="keyword">new</span> TankState(<span class="keyword">this</span>);  </div><div class="line">        m_pSiegeState = <span class="keyword">new</span> SiegeState(<span class="keyword">this</span>);  </div><div class="line">        m_pSiegeTankState = m_pTankState;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> enterTankMode()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = m_pTankState;  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Switch to tank mode"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> enterSiegeMode()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = m_pSiegeState;  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Switch to siege mode"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState-&gt;attack();  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState-&gt;move(x, y);  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">void</span> setState(ISiegeTankState* pSiegeTankMode)  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = pSiegeTankMode;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    TankState* m_pTankState;  </div><div class="line">    SiegeState* m_pSiegeState;  </div><div class="line">    ISiegeTankState* m_pSiegeTankState;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    SiegeTank tank;  </div><div class="line">    tank.enterTankMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">1</span>, <span class="number">1</span>);  </div><div class="line">  </div><div class="line">    tank.enterSiegeMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">2</span>, <span class="number">2</span>);  </div><div class="line">  </div><div class="line">    tank.enterTankMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">3</span>, <span class="number">3</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>状态模式与策略模式</strong>：<br>状态模式中，我们将一群行为封装在状态对象中，context 的行为随时可委托到那些状态对象中的一个。当前状态在状态对象的集合中游走改变，反映出context 内部的状态，context的行为也因此跟着改变。<br>策略模式中，客户通常主动指定Context 所要组合的策略对象是哪一个。</p>
<p>一般来说，策略模式是一个弹性替代继承的一种方案。状态模式则是弹性替代了过多的条件判断。</p>
<p>状态模式主要解决的是党当控制一个状态转换的条件表达式过于复杂的时候，把状态的判断逻辑转移到表示不同状态的一个系列类中，可以吧复杂的判断逻辑简单化。当一个对象行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。</p>
<h2 id="代理模式（Proxy_Pattern）">代理模式（Proxy Pattern）</h2>
<p><strong>代理模式</strong>： 为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901592239.jpg" alt=""></p>
<ul>
<li><strong>抽象主题角色（Subject）</strong>：生命了真是主体和代理主题的共同接口，这样一来在任何使用真实主题的地方，都可以使用代理主题。</li>
<li><strong>代理主题角色（Proxy）</strong>: 代理主题角色内部含有对真实主题的引用，从而可以在任何时候操作真实主题对象；代理主题角色提供一个真实主题相同的接口，以便在任何时候都可以代替真实主题；控制真实主题的应用，负责在需要的时候创建真实主题；代理角色通常在讲客户端调用传递给真实主题之前或之后，都要执行某个操作，而不是单纯地将调用传递给真实主题对象。</li>
<li><strong>真实主题角色（RealSubject）：</strong> 定义了代理角色所代表的真实对象。</li>
</ul>
<p><strong>代理模式的分类</strong>：</p>
<ul>
<li><strong>远程代理</strong>： 为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可以是在另一个机器中。远程代理又叫大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的对象是局域的而不是远程的，而代理对象承担了大部分的网络通讯工作。</li>
<li><strong>虚拟代理</strong>：根据需要创建一个资源消耗较大的对象，使得此对象只在需要的时候才会被真正的创建，使用虚拟代理模式的好处就是代理对象可以在必要的时候才被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块在加载十分耗费资源的情况下，虚拟代理的好处就非常明显了。</li>
<li><strong>Copy-on-Write（写入时复制代理）</strong>： 虚拟代理的一种，把复制（克隆）拖延到只有客户端需要时，才真正采取行动。</li>
<li><strong>保护代理（Protector Access）</strong>： 控制一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。保护代理的好处是它可以在运行时对用户的有关权限进行检查，然后在核实后决定将调用传递给被代理的对象。</li>
<li><strong>Cache 代理</strong>： 为某一个目标操作的结果提供临时的储存空间，以便多个客户端可以共享这些结果。</li>
<li><strong>防火墙（Firewall）代理</strong>： 保护目标，不让恶意用户接近。</li>
<li><strong>同步化代理（Synchronization）</strong>： 使几个用户能够使用一个对象而没有冲突。</li>
<li><strong>智能引用代理（SmartReference）</strong>： 当一个对象被引用的时候，提供一些额外的操作，比如将此对象调用的次数记录下来等等。</li>
<li><strong>缓存代理</strong>： 为开销大的运算结果提供暂时存储；它允许多个客户共享结果，以减少计算或网络延迟。<br><strong>复杂隐蔽代理（Complexity Hiding Proxy）</strong> : 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理（Facade Proxy），复杂隐藏代理和外观代理是不一样的，因为代理控制访问，而外观模式只是提供另外一组接口。<br>其中，远程代理，虚拟代理，智能引用代理，保护代理最为常见。</li>
</ul>
<p>在C++ 中，智能指针采用引入计数器的方法可以帮助管理内存，而其使用的设计模式就是代理模式，代码重现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;  </span></div><div class="line">  </div><div class="line"><span class="preprocessor">#define KSAFE_DELETE(p) \  </span></div><div class="line">    <span class="keyword">if</span> (p)           \  </div><div class="line">        {                \  </div><div class="line">        delete p;    \  </div><div class="line">        p = <span class="type">NULL</span>;    \  </div><div class="line">        }  </div><div class="line"><span class="class">  </span></div><div class="line"><span class="keyword">class</span> <span class="type">KRefCount</span>  </div><div class="line">{  </div><div class="line">public:  </div><div class="line">    <span class="type">KRefCount</span><span class="container">()</span>:m_nCount<span class="container">(0)</span>{}  </div><div class="line">  </div><div class="line">public:  </div><div class="line">    void <span class="type">AddRef</span><span class="container">()</span>{m_nCount++;}  </div><div class="line">    int <span class="type">Release</span><span class="container">()</span>{return <span class="comment">--m_nCount;}  </span></div><div class="line">    void <span class="type">Reset</span><span class="container">()</span>{m_nCount=0;}  </div><div class="line">  </div><div class="line">private:  </div><div class="line">    int m_nCount;  </div><div class="line">};  </div><div class="line">  </div><div class="line">template &lt;typename <span class="type">T</span>&gt;  </div><div class="line"><span class="keyword">class</span> <span class="type">KSmartPtr</span>  </div><div class="line">{  </div><div class="line">public:  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="title">void</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="type">NULL</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span><span class="container">()</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="type">T</span>* <span class="title">pValue</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="title">pValue</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span><span class="container">()</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="title">const</span> <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& <span class="title">sp</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="title">sp</span>.<span class="title">m_pData</span>)</span>  </div><div class="line">        , m_pReference<span class="container">(<span class="title">sp</span>.<span class="title">m_pReference</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    ~<span class="type">KSmartPtr</span><span class="container">(<span class="title">void</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    inline <span class="type">T</span>& operator*<span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        return *m_pData;  </div><div class="line">    }  </div><div class="line">    inline <span class="type">T</span>* operator-&gt;<span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        return m_pData;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& operator=<span class="container">(<span class="title">const</span> <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& <span class="title">sp</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">this</span> != &<span class="title">sp</span>)</span>  </div><div class="line">        {  </div><div class="line">            if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">            {  </div><div class="line">                <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">                <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">            }  </div><div class="line">  </div><div class="line">            m_pData = sp.m_pData;  </div><div class="line">            m_pReference = sp.m_pReference;  </div><div class="line">            m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">        }  </div><div class="line">  </div><div class="line">        return *this;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& operator=<span class="container">(<span class="type">T</span>* <span class="title">pValue</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">        m_pData = pValue;  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">  </div><div class="line">        return *this;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="type">T</span>* <span class="type">Get</span><span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        <span class="type">T</span>* ptr = <span class="type">NULL</span>;          </div><div class="line">        ptr = m_pData;  </div><div class="line">  </div><div class="line">        return ptr;  </div><div class="line">    }  </div><div class="line">    void <span class="type">Attach</span><span class="container">(<span class="type">T</span>* <span class="title">pObject</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">  </div><div class="line">        m_pData = pObject;  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="type">T</span>* <span class="type">Detach</span><span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        <span class="type">T</span>* ptr = <span class="type">NULL</span>;  </div><div class="line">  </div><div class="line">        if <span class="container">(<span class="title">m_pData</span>)</span>  </div><div class="line">        {             </div><div class="line">            ptr = m_pData;  </div><div class="line">            m_pData = <span class="type">NULL</span>;  </div><div class="line">            m_pReference-&gt;<span class="type">Reset</span><span class="container">()</span>;  </div><div class="line">        }  </div><div class="line">        return ptr;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">private:  </div><div class="line">    <span class="type">KRefCount</span>* m_pReference;  </div><div class="line">    <span class="type">T</span>* m_pData;  </div><div class="line">};</div></pre></td></tr></table></figure>

<p>适配器为适配对象提供了不同的接口，而代理模式则是提供了相同的接口。<br>装饰者为对象添加多个功能，而代理模式则是控制对对象的访问。<br><strong>在软件系统中</strong>，加一个中间层使我们常用的解决方法，常常就是使用的代理模式。</p>
<h2 id="设计模式之王—MVC（Model_-_View_-_Controller）">设计模式之王—MVC（Model - View - Controller）</h2>
<p>MVC 模式是复合模式的经典例子，也是现在开发中最常用到的设计模式，下面对它进行一一划分，因为C++ 中的没有现成的例子（或者说我的C++ 水平还很菜，没有意识到~MFC 比较接近），HeadFirst 设计模式中是以java为例写的，iOS开发中也常常用到。</p>
<p><strong>Model</strong>： 模型存储数据。对应了 Swift 中的 Album 这个类。<br><strong>View</strong>： 负责模型的可视化展示，并且负责和用户交互，在 Swift 开发中，对应了UIView 这个类。<br><strong>Controller</strong>: 控制器是整个系统的掌控者，它连接了模型层和数据层，并且吧数据在视图中展示出来，监听各种事件，负责数据的各种操作。对应Swift中的 ViewController 类。</p>
<p>下面这个是斯坦福大学公开课中给的MVC 的类图，非常的形象，被各种使用：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901805125.jpg" alt=""></p>
<p>view中射出的箭头，指向target，代表在ios中对界面上的操作，反馈给了controller中去。<br>model 中的小发射塔，设定观察者，当model发生改变，会给观察者们以反馈。典型的例子就是iOS中的键盘呼出。<br><strong>Model</strong>: 它是应用数据和应用的状态，可能是一个数据库，也可能是你发动时创建的内存，或是你从网络得到的东西，它本质上是应用程序的数据，它基本上什么事情都不做。</p>
<p><strong>View</strong>：在界面上看到的东西，是互动的对象，它代表着你所使用的界面相称的用户模型，但它不清楚数据本身，视图允许你操纵数据，如果我有一个能改变磁盘上数据的滑动条，这个滑动条就是视图，他不存储任何数据，他们完全是动态的，他们被创建后，使用完就会清楚，他们很容易配置，如表格视图，他不了解数据，只代表数据。</p>
<p><strong>Model</strong>：Model是你的应用中数据的存储或数据的表现，相同的模型应该可以在不同的界面中重复使用和未作改变，如果你有代表一些数据集合的应用，假设这是个代表人口和选举信息的数据，这个数据本身，这个模型并不清楚信息是如何展示给用户，因此这个模型能够运用于不同的平台，他能用在不同的应用上，这个的前提是它独立的如何展现</p>
<p><strong>Controller</strong>：可以管理并把数据展示给视图，同样的，当视图想要操作数据，控制器会是视图能这样做的管道。在这个基础上，视图和模型永远不应该相互知道或相互交谈，控制器是管理，演示和控制的媒介。控制器基本是告诉视图关于数据的改变以及在视图需要时改变数据，大部分你的应用逻辑都会在控制器中。</p>
<p>那么MVC模式都复合了上边了解过的那些模式呢？</p>
<ul>
<li><strong>策略模式</strong>：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略。视图只关心系统中的可视部分，对于任何界面行为，都委托给控制器处理。使用策略模式也可以让视图和模型之间的关系解耦，因为控制器负责和模型交换来传递用户的请求。对于工作是怎么完成的，视图毫不知情。</li>
<li><strong>观察者模式</strong>： 为模型设立观察者，当模型发生变化的时候，会将变化反馈给所有的观察者，也就是控制器，做出相应的改变。</li>
<li><strong>组合模式</strong>： 视图是GUI组件的组合。顶层的组件包含其他组件，一直到叶子节点。</li>
</ul>
<p><strong>由于我们使用的是上帝视角，所以其实以上部分，谁与谁之间不能对话，不能调用显得没有那么强硬，我们在编码的过程中，实际上可以实现任何操作，但是，应当遵循的原则，是按照图片中所说的，让model 和 View 尽量解耦，所有的操作应当在Controller中完成。</strong></p>
<p>因为目前没有学习 Java ，Swift 也只是简单的上了下手，对MVC 模型的实战留在日后，而MVC 与web的操作在适配MVC 这一模式，使它更符合浏览器 / 服务器的模型，人们叫它 Model 2，以后有时间继续深挖。</p>
<h2 id="只是个开始">只是个开始</h2>
<p>至此，Headfrist 设计模式中提到的14种设计模式被我用了大约一周多的时间过了一遍，书讲的很通俗很入门，但缺点就是比较浅，没法对每一种模式有更深入的认识。另外，作为凌驾于所有语言之上的设计模式，认真学习它是必须和刻不容缓的。在此基础上，从这本书开始，我应当继续探索设计模式的内容，以贴近实践的方式体会和理解设计模式给开发带来的优势，下边是对这些设计模式的一个分类和一句话总结。</p>
<p><strong>创建型</strong>（4，5未提及）用来处理对象的创建过程：</p>
<ol>
<li><strong>单例模式(Singleton Pattern)</strong>： 确保有且只有一个对象被创建，提供一个访问它的全局访问点。</li>
<li><strong>工厂方法模式(Factory Method Pattern)</strong>： 定义一个创建产品对象的工厂接口，而由子类决定要创建的具体类是哪一个，也就是将实际创建工作推迟到子类中去。</li>
<li><strong>抽象工厂模式(Abstract Factory Pattern)</strong>： 提供一个创建一些列相关或者相互依赖的接口，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder pattern）</strong>:  讲一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype Pattern）</strong>： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
</ol>
<p><strong>结构型</strong>用来处理类或对象的组合：</p>
<ol>
<li><strong>适配器模式（Adapter Pattern）</strong>： 讲一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容不能一起工作的那些类可以一起工作。</li>
<li><strong>组合模式（Composite Pattern）</strong>： 将对象组合成树形结构以表示『部分-整体』的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li>
<li><strong>外观模式（Facade Pattern）</strong>： 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li><strong>装饰者模式（Decorator Pattern ）</strong>： 动态的给一个对象添加一些额外的职责，就增加功能来说，这一模式比生成子类更为灵活。（包装一个对象，提供新的行为）。</li>
<li><strong>代理模式（Proxy Pattern）</strong>： 为其他对象提供一种代理以控制对这个对象的访问。</li>
<li><strong>桥接模式（Bridge Pattern）</strong>： 将抽象部分与实际部分分离，使他们可以独立的变化。</li>
<li><strong>享元模式（Flyweight Pattern）</strong>： 以共享的方式高效的支持大量的细粒度的对象。</li>
</ol>
<p><strong>行为型</strong>用来对类和对象怎样交互和分配职责进行描述：</p>
<ol>
<li><strong>命令模式（Command Pattern）</strong>： 将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</li>
<li><strong>迭代器模式（Iterator Pattern）</strong>： 提供一个方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象内部的表示。</li>
<li><strong>观察者模式（Observer Pattern）</strong>： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</li>
<li><strong>状态模式（State Pattern）</strong>: 允许一个对象在其内部改变时改变它的行为，使对象看起来似乎修改了它的类。封装基本状态的行为，并使用委托在行为之间切换。</li>
<li><strong>策略模式</strong>： 准备一组算法，并将每个算法封装起来，使用委托来决定使用哪一个。</li>
<li><strong>模板方法模式（Template Method Pattern）</strong>： 子类在不改变一个算法的结构情况下，可以重定义该算法的某些特定步骤。</li>
<li><strong>责任链模式（Chain of Responsibility Pattern）</strong>： 在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上某一个对象决定处理此请求，使得系统可以在不影响客户端的情况下动态的重新组织链和分配责任。</li>
<li><strong>解释器模式（Interpreter Pattern）</strong>： 描述了如何为简单的语言顶一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。</li>
<li><strong>中介者模式（Mediator Pattern） </strong>： 定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示的相互调用，从而使其耦合性松散，而且可以独立的改变他们之间的交互。</li>
<li><strong>备忘录模式（Memento Pattern）</strong>： 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
<li><strong>访问者模式（Visitor Pattern）</strong>： 表示一个作用于某对象结构中的各个元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ol>
<p>最后，是几个奉劝：</p>
<ul>
<li>学会用模式去思考</li>
<li>保持一切越简单越好</li>
<li>设计模式不是银弹，不是万灵丹</li>
<li>你应当知道何时需要模式</li>
<li>重构的时间，其实就是运用模式的时间</li>
<li>拿掉你不需要的设计模式</li>
</ul>
<p>设计模式的魅力是无穷的，而设计模式的学习和体悟，需要通过不断的实践去反思和体会的，旅途刚刚开始，Keep Moving…</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="组合模式(Composite_Pattern)">组合模式(Composite Pattern)</h2>
<p>我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>组合模式</strong>： 允许你将对象组合成树形结构来表现『整体/部分』的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br>]]>
    
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式探索之路（上）]]></title>
    <link href="http://yoursite.com/2016/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/12/设计模式探索之路（上）/</id>
    <published>2016-03-12T13:44:48.000Z</published>
    <updated>2016-03-12T13:51:39.000Z</updated>
    <content type="html"><![CDATA[<p>这篇学习加总结的文章写了很久了，但是因为之前是使用马克飞象来写的，其中的图片保存在本地，再上传到博客上非常麻烦，于是就一直趴在电脑里。后来使用了MWeb之后，Mweb推出了图床的功能，懒癌的我找到了最爱，终于可以开心的将一些文章扔博客里去了。鉴于这篇文章太长，大约有两万五千多字，拆分成两篇，作为设计模式的学习理解。设计模式这个东西，说他厉害他确实在工程里占有很高的地位，但是不应当过分的信仰这种东西，他其实只是解决工程问题的有效途径，但并不一定是最佳的途径。</p>
<p>当然试图去寻找到最佳的途径，显示是要先对这些人们已经充分认同的设计模式有所理解。<br><a id="more"></a></p>
<h2 id="策略模式（引子）">策略模式（引子）</h2>
<p>重新设计类结构，创造更多接口，而不是简单地增加进程。比如我们建立一个鸭子的超类，超类中拥有呱呱叫和飞的两个函数。因为我们认为鸭子普遍是可以飞和叫的。当我们在分别建立绿头鸭红头鸭子类的时候，可以直接继承了两种方法。但是此时如果要建立橡皮鸭呢?建立木头鸭呢？这个时候，我们就面临着这个超类的可复用的弹性问题了。所以，我们采用的方法是，把呱呱叫和飞行封装，形成借口，封装的行为里，定义一组行为，有可以飞不可以飞，呱呱叫吱吱叫或者是完全不叫，这一组行为，可以叫一个『算法族』。这样就大大提高了系统的弹性。</p>
<p>简单来讲，定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。<br><strong>设计的原则：</strong></p>
<ol>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。（使用组合建立系统具有更大弹性）</li>
</ol>
<h2 id="观察者模式">观察者模式</h2>
<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。当两个对象<strong>松耦合</strong>，他们依然可以交互，但是不清楚彼此的细节。</p>
<p>有多个观察者的时候，不可以依赖特定的通知次序。</p>
<p>Java API 内置了观察者模式，java.util 包内包含了最基本的 Observer 接口和 Observalbe 类。不过 java.util.Observable 是一个类而不是接口，所以在实现上，他还有一些问题，限制了它的使用和福永，所以在使用中应当注意。（OBservable 是一个类，必须设计一个类继承它，如果某个类想要同时具有Observable 类和另外一个超类的行为，就会陷入两难，因为 Java 不支持多重继承。）</p>
<p>JDK 中 Swing 大量使用了观察者模式，很多GUI 框架也是如此。</p>
<p>我们常听说的MVC 其实就是观察者模式中的代表人物。 </p>
<p><strong>设计的原则（增）：</strong></p>
<ol>
<li>（找出变化，独立出来）在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这叫前提规则。</li>
<li>（针对接口编程，而非针对实现）主题与观察者都是用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点。</li>
<li>（多用组合，少用继承）观察者利用『组合』将许多观察者组合进主题中，对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。</li>
<li>为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</li>
</ol>
<h2 id="装饰者模式">装饰者模式</h2>
<p>首先了解一个开放-关闭原则，是装饰者模式的一个重要设计原则，我们的目标是允许类更容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。如能实现这样的目标，这样的设计就具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>
<p><strong>装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</strong></p>
<p><strong>以咖啡馆为例</strong>：咖啡馆提供各种饮料，现在要设计一个订单系统，来优化他们的饮料供应要求。如果我们用最基本的类设计，让一个超类具有提供通用的方法，子类继承并实现cost() 等方法，这样我们就看到一个爆炸式的类继承图。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577898209517.jpg" alt=""></p>
<p>所以，这个时候我们考虑装饰者模式，如果一个顾客需要摩卡和奶泡深焙咖啡，那么我们就先拿一个深焙咖啡对象，然后用摩卡对象装饰它（包起来），以奶泡对象装饰它，最后调用 cost（）方法，一来委托将调料的价钱加上去。如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899539183.jpg" alt=""></p>
<ul>
<li>装饰着和被装饰者对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象的场合，可以用装饰过的对象来代替他。</li>
<li><strong>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态的不限量的把你喜欢的装饰者来装饰对象。<br>这是修改成装饰者模式的框架：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899646754.jpg" alt=""></li>
</ul>
<p>在 Java 中， java.io 包就是一个使用装饰者模式最好的例子。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>因为在设计中加入了大量的小类，所以导致不容易理解这种设计方式。</li>
<li>类型问题。人们在客户代码中依赖某种特殊类型，然后忽然导入装饰者，就会出现各种状况。</li>
<li>采用装饰者在实例化组件时，将增加代码的复杂度。</li>
</ol>
<p><strong>设计原则：</strong></p>
<ol>
<li>类应该对扩展开放，对修改关闭。</li>
</ol>
<h2 id="工厂模式">工厂模式</h2>
<p>人们普遍认为工厂模式分三类，简单工厂模式，工厂方法模式，和抽象工厂模式，不过要澄清一下，其实简单工厂模式只是在概念上符合了工厂模式，而其实还存在有缺陷。简单工厂就是最简单的创造了一个工厂，在实例化对象的时候，由工厂来决定实例化哪一种对象。</p>
<p>以下面代码为例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> CTYPE {COREA, COREB};     </div><div class="line">class SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//单核A    </span></div><div class="line">class SingleCoreA: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore A"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//单核B    </span></div><div class="line">class SingleCoreB: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore B"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></div><div class="line">class Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:     </div><div class="line">    SingleCore* <span class="title">CreateSingleCore</span>(<span class="keyword">enum</span> CTYPE ctype)    </div><div class="line">    {    </div><div class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA(); <span class="comment">//生产核A    </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); <span class="comment">//生产核B    </span></div><div class="line">        <span class="keyword">else</span>    </div><div class="line">            <span class="keyword">return</span> NULL;    </div><div class="line">    }    </div><div class="line">};</div></pre></td></tr></table></figure>

<p>这个设计的缺点在于，如果我们要增加新的类型，就需要进入工厂类中去修改，这就违反了我们上次提到的原则：<strong>类应当向扩展开放，向修改封闭</strong>。</p>
<p>所以，此时我们的工厂方法模式就出现了，工厂方法模式的定义是：<strong>工厂模式的特点就是我们定义一个创建对象的接口，但是由子类来决定实例化的类是哪一个。工厂方法就是让类把实例化推迟到了子类。</strong> 工厂方法用来处理对象的创建，然后将这个行为封装到子类中去，本身并不进行实例化，这样的话，客户程序中关于超类的代码，就和子类对象创建的代码解耦了。</p>
<p>结合实例讲解就是，这家生产处理器核为自己设立了一个总厂，总厂并不做生产的活动，而是再开设一个工厂专门用来生产B型号的单核，和另一个工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面这个是代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//单核A    </span></div><div class="line">class SingleCoreA: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore A"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//单核B    </span></div><div class="line">class SingleCoreB: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore B"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line">class Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//生产A核的工厂    </span></div><div class="line">class FactoryA: <span class="keyword">public</span> Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    SingleCoreA* <span class="title">CreateSingleCore</span>() { <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; }    </div><div class="line">};    </div><div class="line"><span class="comment">//生产B核的工厂    </span></div><div class="line">class FactoryB: <span class="keyword">public</span> Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    SingleCoreB* <span class="title">CreateSingleCore</span>() { <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; }    </div><div class="line">};</div></pre></td></tr></table></figure>

<p>在《HeadFirst设计模式》书中，利用另外一个例子讲述了这个问题，有一家披萨店，在纽约和芝加哥开了披萨的分店，而每个分店为了满足当地人的口味，有着当地口味的各种披萨。于是我们就看到了这个UML图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899825102.jpg" alt=""></p>
<p>这里边工厂方法是创造一个框架，让子类去决定如何实现。在工厂方法中，<code>orderPizza()</code> 方法提供了一般框架，以便创建披萨，<code>orderPizza()</code>方法依赖工厂方法创建具体类，然后制造出具体的披萨出来。而简单工厂的做法是可以将对象的创建封装起来，但是不具备工厂方法的弹性。这种方法，相比于简单工厂的模式，拥有了更多的弹性。</p>
<p>下面我们再引入一个原则：<br><strong>设计原则：</strong></p>
<ol>
<li>要依赖抽象，不要依赖具体类。（依赖倒置原则 Dependency Inversion Principle）无论是高层组件，和低层组件，都应当依赖于抽象，而非具体的类。</li>
</ol>
<p>下面几个指导方针，可以避免在设计中违反依赖倒置原则：</p>
<ul>
<li>变量不可以持有具体类的引用。（如果使用一个new，就会持有具体类的引用，可以改用工厂方法来避开这种做法）</li>
<li>不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类）</li>
<li>不要覆盖基类中已经实现的方法。（如果覆盖了基类中已经实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已经实现的方法，应该由所有的子类共享）</li>
</ul>
<p>那么，下面我们就能引入抽象工厂模式，<strong> 抽象工厂模式，提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</strong>。下面这张图将有助于理解其中的关系。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900057893.jpg" alt=""></p>
<p>我们看到，抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包括了一组方法用来生产产品。下面回到那个披萨店的问题，下面这张图就更加复杂，而其中抽象出来的披萨原料工厂接口，正是整个抽象工厂概念的精髓。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900183155.jpg" alt=""><br><img src="./1444916335159.png" alt="Alt text"></p>
<p>具体的披萨工厂负责生产披萨原料，每个工厂都知道如何产生符合自己区域的正确对象，而披萨店有两个具体事例，纽约披萨店和芝加哥披萨店，他们就是抽象工厂的客户。</p>
<p><strong>工厂方法模式和抽象工厂模式的区别</strong>：<br><strong>工厂方法在创建对象的方法是利用继承，而抽象工厂是通过对象的组合。</strong>这意味着，利用工厂方法创建对象，需要扩展一个类，并覆盖它的工厂方法，这个工厂方法用来创建对象，而整个工厂方法模式，不过就是通过子类来创建对象，用户在使用时候，只需要知道他们所使用的抽象类型就可以了。而抽象工厂提供了一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被生产的方法。要想使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中去。</p>
<p>所以，当你需要创建一个产品将组，想让制造的相关产品集合起来的时候，可以使用抽象工厂模式。而当你目前还不知道到底需要实例化哪些具体类，可以使用工厂方法模式，因为扩展和修改很快。</p>
<h2 id="单件模式（Singleton_Pattern）">单件模式（Singleton Pattern）</h2>
<p>看完了一个相当复杂的工厂模式，下面转入一个比较简单的模式，单件模式。定义如下：</p>
<p><strong>单件模式确保一个类只有一个实例，并提供一个全局访问点。</strong></p>
<p>有一些对象其实我们只需要一个，比方说：<strong>线程池（threadpool）、缓存（cache）、对话框、处理偏好设置、注册表（registry）的对象、日志对象、打印机显卡等设备的对象。</strong>  由于普通的全局变量，必须在程序已开始就创建好对象，那么如果这个对象非常的消耗资源，而在程序的运行过程中一直没有用到它，不就形成了浪费了么。所以使用单件模式，就可以在需要的时候去创建这个对象。</p>
<p><strong>适用性</strong>：</p>
<ol>
<li>对于一个类，如果他比较大，而且这些资源可以被全局共享，就可以设计成单件模式。</li>
<li>对于一个类，需要对实例进行计数。可以在 Instance 中进行，并可以对实例的个数进行限制。</li>
<li>对于一个类，需要对其实例的具体行为进行控制。例如，期望返回的实例实际上是自己子类的实例。这样可以通过单件模式，对客户端代码保持透明。</li>
</ol>
<p>单件模式，没有公开的构造器，是私有的。当为了取得实例，必须请求得到一个实例，而不是自行实例化得到一个一个实例。类中有一个静态方法 ，叫做GetInstance() ，调用这个方法，就可以让这个唯一的实例现身，这个实例也许是第一次创建，也许是已经创建了。下面是一个单件模式的通用写法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">作用：保证一个class只有一个实体（instance），并为它提供一个全局唯一的访问点 </div><div class="line">*/  </div><div class="line">class singleton  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ~<span class="title">singleton</span>()  </div><div class="line">    {<span class="comment">//析构时使用  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">static</span> singleton* getInstance()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(_instance == NULL)  </div><div class="line">        {  </div><div class="line">            _instance = <span class="keyword">new</span> singleton();  </div><div class="line">        }  </div><div class="line">        <span class="keyword">return</span> _instance;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">static</span> singleton *_instance;  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">//最好将所有此类的实例化的进口全部堵死  </div><div class="line">    <span class="title">singleton</span>()  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">    singleton(<span class="keyword">const</span> singleton&)  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">    singleton& operator=(<span class="keyword">const</span> singleton &)  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">singleton *singleton::_instance = NULL;</div></pre></td></tr></table></figure>

<p>看起来很美好，不过这个代码仍然存在问题。</p>
<ol>
<li>释放的问题，上述例子中的<code>_instance</code>，不会自动释放，而需要手动去释放，尤其是做借口时候，需要告知使用方调用 <code>delete singleton::getInstance()</code>语句。</li>
<li>多线程使用的环境下，极有可能会出现同时创造了前后不一致的对象，失去了单件模式的本意，这个问题就严重了。</li>
</ol>
<p><strong>解决方法：</strong><br>针对释放问题的解决方法：</p>
<ol>
<li>调用 <code>delete singleton::getInstance()</code>语句。</li>
<li>注册一个<code>atexit()</code>函数，将释放内存的方法放进去，此方法可以将多个单件放在一起调用。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void <span class="function">releasefun</span>()  </div><div class="line">{  </div><div class="line">    delete singleton<span class="value">::<span class="function">getInstance</span>();</span>  </div><div class="line">}  </div><div class="line"><span class="comment">//在使用完成后调用  </span></div><div class="line"><span class="function">atexit</span>(releasefun);</div></pre></td></tr></table></figure>

<ol>
<li>使用智能指针，C++ STL中的<code>auto_ptr</code>就是一个。<code>static auto_ptr&lt;singleton&gt; _instance;</code> </li>
<li>利用c++ 内嵌类和一个静态成员自动释放机制，将这个类嵌入到单件模式的类中去。然后在<code>getInstance（）</code> 中声明一个静态的实例对象。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class clearer  </div><div class="line">    {  </div><div class="line">    public<span class="value">:  </span></div><div class="line">        <span class="function">clearer</span>(){}  </div><div class="line">        ~<span class="function">clearer</span>()  </div><div class="line">        {  </div><div class="line">            <span class="function">if</span>(singleton::<span class="function">getInstance</span>())  </div><div class="line">            {  </div><div class="line">                delete singleton::<span class="function">getInstance</span>();  </div><div class="line">            } }  };</div></pre></td></tr></table></figure>

<p><strong>针对多线程的问题：</strong><br>在这里引入一个著名的双检测锁机制，看到代码，一定会觉得非常的有想法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> singleton* getInstance()  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(_instance == <span class="keyword">NULL</span>)  </div><div class="line">    {  </div><div class="line">        <span class="comment">//加入临界区  </span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">NULL</span> == _instance)  </div><div class="line">        {  </div><div class="line">            _instance = <span class="keyword">new</span> singleton();  </div><div class="line">        }  </div><div class="line">        <span class="comment">//释放临界区  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> _instance;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里边这个临界区的思路，正好解决了多线程的问题。</p>
<p>同时，如果有多个类加载器存在的时候，很有可能创建各自不同的单件实例，这个时候，就要小心，应该自行指定类加载器，并指定同一个类加载器。</p>
<h2 id="命令模式（Command_Pattern）">命令模式（Command Pattern）</h2>
<p><strong>命令模式将『请求』封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</strong></p>
<p>一个简单的生活中的例子就是，我们去餐厅吃饭，通过服务员来点餐，具体谁来做这些菜还什么时候完成这些菜我们并不知道。而服务员则只是将我们下的订单，传递给厨师，具体的做菜过程是由厨师完成的。所以，『菜单请求者』和『菜单实现者—厨师』之间是解耦的。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900365661.jpg" alt=""></p>
<p>图中的几个角色有：</p>
<ul>
<li><strong>客户（Client）角色：</strong>创建了一个具体命令(ConcreteCommand)对象并确定其接收者。</li>
<li><strong>请求者（Invoker）角色：</strong>负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
<li><strong>命令（Command）角色：</strong>声明了一个给所有具体命令类的抽象接口。这是一个抽象角色。</li>
<li><strong>具体命令（ConcreteCommand）角色：</strong>定义一个接受者和行为之间的弱耦合；实现Execute()方法，负责调用接收考的相应操作。Execute()方法通常叫做执行方法。调用者只需要调用<code>excute()</code>就可以发出请求。</li>
<li><strong>接收者（Receiver）角色：</strong>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ul>
<p>在刚才那个餐厅的例子，我们建立一一的对应关系，这样理解起来就更加容易了。</p>
<ul>
<li>女招待 &lt;—&gt; <code>invoker</code></li>
<li>快餐厨师 &lt;—&gt; <code>Receiver</code></li>
<li><code>orderUp()</code> &lt;—&gt; <code>execute()</code></li>
<li>订单 &lt;—&gt; <code>command</code></li>
<li>顾客 &lt;—&gt; <code>Client</code></li>
<li><code>takeOrder()</code> &lt;—&gt; <code>setCommand()</code></li>
</ul>
<p>下面我们看一个实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">// 烤肉师傅  </span></div><div class="line"><span class="keyword">class</span> RoastCook  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> MakeMutton() { <span class="built_in">cout</span> &lt;&lt; <span class="string">"烤羊肉"</span> &lt;&lt; endl; }  </div><div class="line">    <span class="keyword">void</span> MakeChickenWing() { <span class="built_in">cout</span> &lt;&lt; <span class="string">"烤鸡翅膀"</span> &lt;&lt; endl; }  </div><div class="line">};  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">// 抽象命令类  </span></div><div class="line"><span class="keyword">class</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    Command(RoastCook* temp) { receiver = temp; }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() = <span class="number">0</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    RoastCook* receiver;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 烤羊肉命令  </span></div><div class="line"><span class="keyword">class</span> MakeMuttonCmd : <span class="keyword">public</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    MakeMuttonCmd(RoastCook* temp) : Command(temp) {}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() { receiver-&gt;MakeMutton(); }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 烤鸡翅膀命令  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> MakeChickenWingCmd : <span class="keyword">public</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    MakeChickenWingCmd(RoastCook* temp) : Command(temp) {}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() { receiver-&gt;MakeChickenWing(); }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 服务员类  </span></div><div class="line"><span class="keyword">class</span> Waiter  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> SetCmd(Command* temp);  </div><div class="line">  </div><div class="line">    <span class="comment">// 通知执行  </span></div><div class="line">    <span class="keyword">void</span> Notify();  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Command*&gt;</span> m_commandList;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Waiter::SetCmd(Command* temp)  </div><div class="line">{  </div><div class="line">    m_commandList.push_back(temp);  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"增加订单"</span> &lt;&lt; endl;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Waiter::Notify()  </div><div class="line">{  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Command*&gt;</span>::iterator it;  </div><div class="line">    <span class="keyword">for</span> (it=m_commandList.begin(); it!=m_commandList.end(); ++it)  </div><div class="line">    {  </div><div class="line">        (*it)-&gt;ExecuteCmd();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    <span class="comment">// 店里添加烤肉师傅、菜单、服务员等顾客  </span></div><div class="line">    RoastCook* cook = <span class="keyword">new</span> RoastCook();  </div><div class="line">    Command* cmd1 = <span class="keyword">new</span> MakeMuttonCmd(cook);  </div><div class="line">    Command* cmd2 = <span class="keyword">new</span> MakeChickenWingCmd(cook);  </div><div class="line">    Waiter* girl = <span class="keyword">new</span> Waiter();  </div><div class="line">  </div><div class="line">    <span class="comment">// 点菜  </span></div><div class="line">    girl-&gt;SetCmd(cmd1);  </div><div class="line">    girl-&gt;SetCmd(cmd2);  </div><div class="line">    <span class="comment">// 服务员通知  </span></div><div class="line">    girl-&gt;Notify();  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>命令模式有几个常见的可适用功能：</p>
<ul>
<li>当系统需要支持撤销的命令（undo）。类中加入一个新的实例变量，命令对象使用它追踪那个最后被调用的命令，不管何时撤销按钮被按下，我们都可以调出这个命令然后实现undo。</li>
<li><strong>宏命令</strong>，我们可以制造一个新的命令，用来执行其他一堆命令，形成一个命令的集合。</li>
<li><strong>队列请求</strong>，一个命令对象和原先的请求发送者可以有不同的生命期。换言之，原先的请求发送者可能已经不存在了，而命令对象本身仍然在活动中。这时，命令的接受者可以是在本地，也可以是网络的另外一个地址。命令对象可以在串行化之后传送到另一台机器上。</li>
<li><strong>日志请求</strong>，如果一个系统想要将系统中的所有数据更新到日志中，以便在系统崩溃的时候，可以根据日志回读所有的数据来更新命令，从新调用<strong>*excute()</strong>方法一条一条的执行这些命令，从而恢复系统在崩溃之前所有的数据更新。</li>
</ul>
<h2 id="适配器模式和外观模式（the_Adapter_and_Facade_Patterns）">适配器模式和外观模式（the Adapter and Facade Patterns）</h2>
<p>比如我们中国的电压是220v，而美国的电压是110v，为了一个中国的电脑，能在美国使用，就必须需要一个变压器转换电压之后才可以使用，这就是真实世界里的适配器。而我们OO世界里的适配器和它是一个道理，就是<strong>将一个接口转换成另一个接口，以符合客户的期望。适配器让原本接口不兼容的类可以合作。</strong></p>
<p>客户使用适配器的过程：</p>
<ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口。</li>
<li>客户接受到调用的结果，并未察觉到这一切是适配器在起转换作用。</li>
</ol>
<p>下面是它的类图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900527574.jpg" alt=""></p>
<p>Adaptee类没有Request方法，而客户期待这个方法。为了使客户能够使用Adaptee类，提供一个中间环节，即类Adapter类，Adapter类实现了Target接口，并继承自Adaptee，Adapter类的Request方法重新封装了Adaptee的SpecificRequest方法，实现了适配的目的。</p>
<p>以下是一个简单的c++ 实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">// "ITarget"  </span></div><div class="line"><span class="keyword">class</span> Target  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Methods  </span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Request(){};  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// "Adaptee"  </span></div><div class="line"><span class="keyword">class</span> Adaptee  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Methods  </span></div><div class="line">    <span class="keyword">void</span> SpecificRequest()  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Called SpecificRequest()"</span>&lt;&lt;endl;  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// "Adapter"  </span></div><div class="line"><span class="keyword">class</span> Adapter : <span class="keyword">public</span> Adaptee, <span class="keyword">public</span> Target  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Implements ITarget interface  </span></div><div class="line">    <span class="keyword">void</span> Request()  </div><div class="line">    {  </div><div class="line">        <span class="comment">// Possibly do some data manipulation  </span></div><div class="line">        <span class="comment">// and then call SpecificRequest    </span></div><div class="line">        <span class="keyword">this</span>-&gt;SpecificRequest();  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">    </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    <span class="comment">// Create adapter and place a request  </span></div><div class="line">    Target *t = <span class="keyword">new</span> Adapter();  </div><div class="line">    t-&gt;Request();  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>适配器分为对象的适配器，和类的适配器。上边给出的类图，是对象适配器的图。而类适配器与其的差别是适配器继承了Target和Adaptee。而对象适配器利用组合的方式将请求传送给被适配者。下边是类适配器。由于类适配器使用了多重继承，所以在java上不能实施。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900649733.jpg" alt=""></p>
<p>我们看到适配者模式的几个要点：</p>
<ol>
<li>适配者模式主要用于『希望复用一些现存的类，但是接口又与复用环境要求不一致的情况』，在遗留代码复用，类库迁移等方面非常有用。</li>
<li>适配者模式有对象适配器和类适配器两种形式的实现结构，但是类适配器采用的是『多继承』的实现方式，带有不良的高耦合，所以一般不推荐采用。对象适配器采用『对象组合』的方式，更符合松耦合的精神。</li>
<li>适配者模式的实现可以非常的灵活，不必拘泥于两种结构，例如完全可以将适配者模式中的『现存对象』作为新的接口方法参数，来达到适配的目的。</li>
<li>适配者模式本身要求我们尽可能的使用『面向接口的编程』风格，这样才能在后期很方便的进行适配。</li>
</ol>
<p>而与适配者模式很相近的一个模式，叫外观模式。而实际上他的作用其实是为了简化接口。比如我们建立了一套家庭影院，这套家庭影院里拥有各种各样的方法类，但是当我们想要看电影的时候，去逐个完成准备的动作，将变得非常的繁琐。而有效的方式，则是将一系列的任务和在一起，外观类将家庭影院的诸多组件视为一个子系统，通过调用这个子系统，来实现一个方法，这个方法包含了子系统的各种方法。</p>
<p>所以，我们知道，外观类并未将原来的子系统阻隔起来，只是提供了更简洁的接口，这种方法，也可以将客户从组件的子系统中解耦。</p>
<p><strong>新的设计原则</strong>：</p>
<ol>
<li>最少知识原则，只和你的密友谈话。（意思是，当你设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。）不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他的部分。  </li>
</ol>
<p>最后我们再看一下 ，适配者模式，装饰模式，外观模式的区别：<br><strong>适配者模式</strong>将一个对象包装起来以改变其接口；<strong>装饰者</strong>将一个对象包装起来以增加新的行为和责任。<strong>外观</strong>将一群对象包装起来以简化其接口。</p>
<h2 id="模板方法模式（Template_Method_Pattern）">模板方法模式（Template Method Pattern）</h2>
<p>《设计模式》对模板方法模式的定义是：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以再不改变算法结构的情况下，重新定义算法中的某些步骤。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900837995.jpg" alt=""></p>
<p><strong>抽象模板角色（AbstractClass）：</strong><br>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，他们是一个顶级逻辑的组成步骤。定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体的方法。这个就是我们定义了我们固定的操作顺序。</p>
<p><strong>具体模板角色(ConcreteClass):</strong><br>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。<br>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<p>来自Head First 设计模式中的一个例子的c++实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> CaffeineBeverage  <span class="comment">//咖啡因饮料  </span></div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> PrepareRecipe() <span class="comment">//咖啡因饮料冲泡法  </span></div><div class="line">    {  </div><div class="line">        BoilWater();  <span class="comment">//把水煮沸  </span></div><div class="line">        Brew();    <span class="comment">//冲泡  </span></div><div class="line">        PourInCup();  <span class="comment">//把咖啡因饮料倒进杯子  </span></div><div class="line">        AddCondiments(); <span class="comment">//加调料  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">void</span> BoilWater()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"把水煮沸"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {<span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;Brew();}  </div><div class="line">    <span class="keyword">void</span> PourInCup()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"把咖啡倒进杯子"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {<span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;AddCondiments();}  </div><div class="line">};  </div><div class="line"><span class="keyword">class</span> Coffee : <span class="keyword">public</span> CaffeineBeverage&lt;Coffee&gt;  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"用沸水冲泡咖啡"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"加糖和牛奶"</span> &lt;&lt; std::endl;}  </div><div class="line">};  </div><div class="line"><span class="keyword">class</span> Tea : <span class="keyword">public</span> CaffeineBeverage&lt;Tea&gt;  </div><div class="line">  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"用沸水浸泡茶叶"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"加柠檬"</span> &lt;&lt; std::endl;}  </div><div class="line">};  </div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)  </div><div class="line">{  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"冲杯咖啡:"</span> &lt;&lt; std::endl;  </div><div class="line">    Coffee c;  </div><div class="line">    c.PrepareRecipe();  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; std::endl;  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"冲杯茶:"</span> &lt;&lt; std::endl;  </div><div class="line">    Tea t;  </div><div class="line">    t.PrepareRecipe();  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>其实在模板父类里，我们可以定义一个『默认不做事』的方法，我们称这种方法为『Hook』钩子，子类可以视情况决定要不要覆盖它们。这就让子类在实现的时候有了更多的灵活性。<br><strong>钩子</strong>： </p>
<ul>
<li>钩子可以让子类实现算法中的可选部分，或者钩子对于子类的实现并不重要的时候， 子类可以对钩子置之不理。</li>
<li>让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤做出反应。比如说justReOrderedList（） 的钩子方法允许子类在内部列表重新组织后执行某些动作。</li>
<li>可以让子类有能力为其抽象类做一些决定。</li>
</ul>
<p>适用性：</p>
<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 </li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 </li>
<li>控制子类扩展。模板方法只在特定点调用“Hook”操作，这样就只允许在这些点进行扩展。</li>
</ol>
<p><strong>新的设计原则</strong>：<br>戏称为<strong>好莱坞原则</strong>，别调用我们，我们会调用你。我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。模板方法模式就是典型的好莱坞原则。其他还有工厂方法，观察者等等。</p>
<h2 id="迭代器（Iterator_Pattern）">迭代器（Iterator Pattern）</h2>
<p>现在有两种储存数据的模式，一种用的是ArrayList , 而另一种则用的是数组，两种结构所拥有的方法各不相同。假如我们想要将两种数据存储方式整合在一起，然后用相同的方法使用遍历它们的时候，这个时候就要用到了鼎鼎大名的迭代器了。</p>
<p>当我们说『集合』（collection）的时候，我们指的是一群对象。其储存方式可以使各种各样的数据结构，如，列表，数组，散列表。无论用什么方式，一律可以视为集合，有时候也称为『聚合』（aggregate）。</p>
<p>迭代器模式的精髓：提供一个方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900977664.jpg" alt=""></p>
<p>重要角色：<br><strong>迭代器角色</strong>：迭代器负责定义访问和遍历元素的接口。<br><strong>具体迭代器角色（Concrete Iterator）</strong> ： 具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。<br><strong>集合角色（Aggregate）</strong>: 集合角色负责提供创建具体迭代器角色的接口。<br><strong>具体集合角色（Concrete Aggregate）</strong>: 具体集合角色实现创建具体迭代器角色的接口——这个具体迭代器角色与该集合的结构有关。</p>
<p>回到实例中去看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> Iterator  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> next()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> Item* currentItem()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> isDone()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> ~Iterator(){}  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteAggregate;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteIterator : <span class="keyword">public</span> Iterator &lt;Item&gt;  </div><div class="line">{  </div><div class="line">    ConcreteAggregate&lt;Item&gt; * aggr;  </div><div class="line">    <span class="keyword">int</span> cur;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ConcreteIterator(ConcreteAggregate&lt;Item&gt;*a):aggr(a),cur(<span class="number">0</span>){}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first()  </div><div class="line">    {  </div><div class="line">        cur=<span class="number">0</span>;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> next()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(cur&lt;aggr-&gt;getLen())  </div><div class="line">            cur++;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> Item* currentItem()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(cur&lt;aggr-&gt;getLen())  </div><div class="line">            <span class="keyword">return</span> &(*aggr)[cur];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> NULL;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> isDone()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> (cur&gt;=aggr-&gt;getLen());  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> Aggregate  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> Iterator&lt;Item&gt;* createIterator()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> ~Aggregate(){}  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteAggregate:<span class="keyword">public</span> Aggregate&lt;Item&gt;  </div><div class="line">{  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Item &gt;</span>data;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ConcreteAggregate()  </div><div class="line">    {  </div><div class="line">        data.push_back(<span class="number">1</span>);  </div><div class="line">        data.push_back(<span class="number">2</span>);  </div><div class="line">        data.push_back(<span class="number">3</span>);  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> Iterator&lt;Item&gt;* createIterator()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;Item&gt;(<span class="keyword">this</span>);  </div><div class="line">    }  </div><div class="line">    Item& <span class="keyword">operator</span>[](<span class="keyword">int</span> index)  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> data[index];  </div><div class="line">    }  </div><div class="line">    <span class="keyword">int</span> getLen()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> data.size();  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    Aggregate&lt;<span class="keyword">int</span>&gt; * aggr =<span class="keyword">new</span> ConcreteAggregate&lt;<span class="keyword">int</span>&gt;();  </div><div class="line">    Iterator&lt;<span class="keyword">int</span>&gt; *it=aggr-&gt;createIterator();  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(it-&gt;first();!it-&gt;isDone();it-&gt;next())  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;*(it-&gt;currentItem())&lt;&lt;endl;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">delete</span> it;  </div><div class="line">    <span class="keyword">delete</span> aggr;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>迭代器</strong>的特点：</p>
<ul>
<li>迭代抽象： 访问一个聚合对象而无需暴露它的内部表示。</li>
<li>迭代多态： 为遍历不同的集合结构，提供了一个统一的借口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑： 遍历的同时要更改迭代器所在的集合结构，会导致问题。<br>C++ 下有 STL Iterator 实现，Java 下有 java.util.Iterator 和 java.util.Enumeration。 </li>
</ul>
<p><strong>新的设计原则</strong>：<br><strong>单一责任</strong>： 一个类应该只有一个引起变化的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇学习加总结的文章写了很久了，但是因为之前是使用马克飞象来写的，其中的图片保存在本地，再上传到博客上非常麻烦，于是就一直趴在电脑里。后来使用了MWeb之后，Mweb推出了图床的功能，懒癌的我找到了最爱，终于可以开心的将一些文章扔博客里去了。鉴于这篇文章太长，大约有两万五千多字，拆分成两篇，作为设计模式的学习理解。设计模式这个东西，说他厉害他确实在工程里占有很高的地位，但是不应当过分的信仰这种东西，他其实只是解决工程问题的有效途径，但并不一定是最佳的途径。</p>
<p>当然试图去寻找到最佳的途径，显示是要先对这些人们已经充分认同的设计模式有所理解。<br>]]>
    
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinyhttpd analysis]]></title>
    <link href="http://yoursite.com/2016/03/12/Tinyhttpd-analysis/"/>
    <id>http://yoursite.com/2016/03/12/Tinyhttpd-analysis/</id>
    <published>2016-03-12T13:28:57.000Z</published>
    <updated>2016-03-12T13:31:26.000Z</updated>
    <content type="html"><![CDATA[<p>这是个不错的源码，用C 语言写的一个超轻量的HttpServer, 开发应该是用不上了，但是对于学习Unix 网络编程，套接字，进程等等来说相当够用。源代码大约500行，属于一个比较容易理解的代码量。</p>
<p>阅读C 源码的好处在于你不必去考虑类和对象，不用花时间去看类里有哪些成员变量和成员函数，不用费力去构建类图。只需要按照过程阅读就好了。</p>
<p>在源码上我进行了注释，在这里我对其中涉及到的Unix知识进行一点解释，也算是给啃UNP做一个预热。</p>
<p>打开httpd.c，这一长串函数，最重要的就是 <strong>startup</strong>, <strong>accept_request</strong>, 和 <strong>execute_cgi</strong>，以及<strong>get_line</strong>。 下面是每个函数的功能。<br><strong>accept_request</strong>:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。<br><a id="more"></a></p>
<ul>
<li><strong>bad_request</strong>: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.</li>
<li><strong>cat</strong>: 读取服务器上某个文件写到 socket 套接字。</li>
<li><strong>cannot_execute</strong>: 主要处理发生在执行 cgi 程序时出现的错误。</li>
<li><strong>error_die</strong>: 把错误信息写到 perror 并退出。</li>
<li><strong>execute_cgi</strong>: 运行 cgi 程序的处理，也是个主要函数。</li>
<li><strong>get_line</strong>: 读取套接字的一行，把回车换行等情况都统一为换行符结束。</li>
<li><strong>headers</strong>: 把 HTTP 响应的头部写到套接字。</li>
<li><strong>not_found</strong>: 主要处理找不到请求的文件时的情况。</li>
<li><strong>sever_file</strong>: 调用 cat 把服务器文件返回给浏览器。</li>
<li><strong>startup</strong>: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。</li>
<li><strong>unimplemented</strong>: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</li>
</ul>
<p>下面找到main函数，开始往下读。因为没有学习过Unix网络编程，所以中间一大把时间都花在了wiki的扩展。</p>
<p>首先将流程讲一下。</p>
<ol>
<li><strong>startup</strong>（）启动服务器，在指定的端口绑定httpd服务。</li>
<li>因为打开了listen, 当accept 到HTTP 请求时，那么久派生出一个进程去运行<strong>accept_request()</strong></li>
<li>在<strong>accept_request</strong>（） 中，取出HTTP 请求，获取它的method(可能是GET 或 POST)和url 。对于GET来说，若这个GET 请求带有参数，那么久会存在于url 中的「？」之后，将它保存在<strong>query_string</strong>中。</li>
<li>然后格式化url，将它保存到path数组中，也就是浏览器请求的服务器文件路径，如果url以<strong>/</strong>结尾，那就在路径结尾默认加上index.html，用来表示访问主页。</li>
<li>检验这个路径，如果不合法则返回错误。如果合法，再如果是一个没有参数的GET 请求，那我们直接输出服务器中的文件到浏览器就可以了，也就是用HTTP 格式写到套接字上，然后就可以直接结束了。对于其他情况（有参数的GET， POST， url是可执行文件），那么久继续调用 excute_cgi 来执行cgi.</li>
<li>进入excute_cgi(),读取HTTP请求，然后丢弃，如果他是一个POST 请求，那么有一个Content-Length, 找出来，然后把HTTP 200 状态码写到套接字。</li>
<li>用pipe建立两个管道,<strong>cgi_input</strong>,<strong>cgi_output</strong>，等下fork一个进程。管道是用来父进程和子进程通信的。</li>
<li>子进程中，STDOUT 也就是 1， 重定向到<strong>cgi_output</strong>的写入端，也就是<strong>cgi_output</strong>[1], STDIN 也就是 0， 重定向到<strong>cgi_input</strong>的读取端，也就是<strong>cgi_input</strong>[0]。子进程中关闭<strong>cgi_input</strong>的写入端，<strong>cgi_output</strong>的读取端。</li>
<li>仍然是在子进程中，设置<strong>request_method</strong>的环境变量，如果是GET 的话设置<strong>query_string</strong> 的环境变量，POST的话设置<strong>content_length</strong> 的环境变量，这个变量的作用是让cgi调用，在管道里进行通信，然后execl运行cgi，进行通信。</li>
<li>在父进程中，关闭<strong>cgi_input</strong>的读取端，<strong>cgi_output</strong>的写入端，如果请求是POST 的话，就把POST 写入<strong>cgi_input</strong>,在子进程中，他被重定向到了STDIN，读取<strong>cgi_output</strong>的管道输出到客户端，这个管道的输入被重定向到了STDOUT。然后关闭所有管道，等待子进程结束。</li>
<li>最后结束，关闭连接，完成了一次HTTP请求与回应。</li>
</ol>
<p>关于CGI 技术，现在并不需要详细的学习CGI，只需要了解一下四点：</p>
<ol>
<li>web-server将POST数据重定向到CGI的标准输入，读用户POST的数据可以直接读stdin</li>
<li>web-server将Http头设置成CGI的环境变量，所有读Http头信息可以通过getenv函数</li>
<li>web-server将GET数据设置成CGI的环境变量，可以通过getenv(“QUERY_STRING”)得到</li>
<li>web-server将CGI的标准输出重定向到浏览器，所以CGI输入内容直接向stdout输出就可以了。</li>
</ol>
<p>未完待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是个不错的源码，用C 语言写的一个超轻量的HttpServer, 开发应该是用不上了，但是对于学习Unix 网络编程，套接字，进程等等来说相当够用。源代码大约500行，属于一个比较容易理解的代码量。</p>
<p>阅读C 源码的好处在于你不必去考虑类和对象，不用花时间去看类里有哪些成员变量和成员函数，不用费力去构建类图。只需要按照过程阅读就好了。</p>
<p>在源码上我进行了注释，在这里我对其中涉及到的Unix知识进行一点解释，也算是给啃UNP做一个预热。</p>
<p>打开httpd.c，这一长串函数，最重要的就是 <strong>startup</strong>, <strong>accept_request</strong>, 和 <strong>execute_cgi</strong>，以及<strong>get_line</strong>。 下面是每个函数的功能。<br><strong>accept_request</strong>:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。<br>]]>
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/tags/Unix/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The different means of Stack]]></title>
    <link href="http://yoursite.com/2016/03/10/The-different-means-of-Stack/"/>
    <id>http://yoursite.com/2016/03/10/The-different-means-of-Stack/</id>
    <published>2016-03-10T05:40:05.000Z</published>
    <updated>2016-03-10T05:45:02.000Z</updated>
    <content type="html"><![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。<a id="more"></a>

</li>
</ul>
<h3 id="代码存放的区域">代码存放的区域</h3>
<p>stack 的另一种含义是存放数据的一种内存区域，参考<a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" target="_blank" rel="external">维基百科</a> ，我们知道，程序包含几个区域，静态区，堆区，栈区。</p>
<ul>
<li><strong>栈区（stack）</strong>— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li>
<li><strong>堆区（heap）</strong> — 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)。 - 程序结束后由系统释放</li>
<li><strong>文字常量区</strong> — 常量字符串就是放在这里的。 程序结束后由系统释放</li>
<li><strong>程序代码区</strong>— 存放函数体的二进制代码。</li>
</ul>
<p>下面这是个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">main.cpp </div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>; 全局初始化区 </div><div class="line"><span class="keyword">char</span> *p1; 全局未初始化区 </div><div class="line">main() </div><div class="line">{ </div><div class="line"><span class="keyword">int</span> b; 栈 </div><div class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>; 栈 </div><div class="line"><span class="keyword">char</span> *p2; 栈 </div><div class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="number">123456</span>在常量区，p3在栈上。 </div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； 全局（静态）初始化区 </div><div class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </div><div class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </div><div class="line">分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。 </div><div class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="number">123456</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">"123456"</span>优化成一个地方。 </div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于stack 来说，stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；但是heap 是没有结构的，数据可以任意的存放，因此，stack 的寻址速度要快于heap。</p>
<p>而且，一般来说，对每个线程会分配一个stack ,每个进程分配一个heap 。那么stack 就是线程独占的，而heap 则是线程共用的。stack 在创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap 的大小是不确定的，需要的话，可以不断的增加。</p>
<p>所以，只要是局部的，占用空间确定的数据，都会存放在stack 里边，其他的不确定的，动态生成的，就存放在heap 里去。</p>
<p>比如我们的创建新的对象，就会存放在heap中，因为stack 在使用完后会又编译器自动释放，但是heap 如果不去有效的清理，等待系统的垃圾清理机制去将这块内存清理，就很容易发生内存溢出。</p>
<p>更多详细的解释，可以参考<a href="http://blog.csdn.net/chenke1988/article/details/7273375" target="_blank" rel="external">这篇文章</a></p>
<h3 id="代码运行的方式-_调用栈">代码运行的方式- 调用栈</h3>
<p>第三种含义可以是调用栈，call stack 。它用的就是栈的思路，表示函数或者子例程像堆积木一样存放，以实现层层调用。</p>
<p>对于调用栈的方式，我们举个例子，该例子来自<a href="http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/" target="_blank" rel="external">java 8 stack and heap</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Student{</div><div class="line">    <span class="keyword">int</span> age;              </div><div class="line">    String name;      </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Student</span>(<span class="keyword">int</span> Age, String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.age = Age;</div><div class="line">        setName(Name);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.name = Name;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">            Student s;           </div><div class="line">            s = <span class="keyword">new</span> Student(<span class="number">23</span>,<span class="string">"Jonh"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其调用main 方法时候，需要生成一个student实例，于是调用student 构造函数，在构造函数中又调用了setName方法。如图（来自阮一峰）：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575871473636.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSL 图解]]></title>
    <link href="http://yoursite.com/2016/03/10/SSL-%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/10/SSL-图解/</id>
    <published>2016-03-10T03:22:20.000Z</published>
    <updated>2016-03-10T03:23:36.000Z</updated>
    <content type="html"><![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br><a id="more"></a><br>SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。SSL 包括的工作原理有，<strong>握手协议，记录协议，报警协议。</strong></li>
</ul>
<h3 id="握手协议">握手协议</h3>
<p>握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。</p>
<p>每个握手协议包含以下3个字段</p>
<ul>
<li>Type：表示10种消息类型之一</li>
<li>Length：表示消息长度字节数</li>
<li>Content：与消息相关的参数<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575301594684.jpg" alt=""></li>
</ul>
<p>比如我们在发送已加密的 HTTP 报文之前,客户端和服务器要进行一次 SSL 握手,在这个握手过程中,它们要完成以下工作:</p>
<ul>
<li>交换协议版本号;</li>
<li>选择一个两端都了解的密码;</li>
<li>对两端的身份进行认证;</li>
<li>生成临时的会话密钥,以便加密信道。</li>
</ul>
<p>我这里引述阮一峰在博客中举得alice and Bob 的例子。</p>
<ol>
<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>
<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ol>
<p>下面再进一步详解每一部分：</p>
<p><strong>第一和第二步，建立安全能力</strong></p>
<p>SSL握手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。<br>Client hello消息包括Version，Random，Session id，Cipher suite，Compression method等信息。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575307943892.jpg" alt=""></p>
<p>ClientHello 客户发送CilentHello信息，包含如下内容：</p>
<ul>
<li>客户端可以支持的SSL最高版本号</li>
<li>一个用于生成主秘密的32字节的随机数。</li>
<li>一个确定会话的会话ID。</li>
<li>一个客户端可以支持的密码套件列表。</li>
<li>一个客户端可以支持的压缩算法列表。</li>
</ul>
<p>密码套件格式：每个套件都以“SSL”开头，紧跟着的是密钥交换算法。用“With”这个词把密钥交换算法、加密算法、散列算法分开，例如：SSL_DHE_RSA_WITH_DES_CBC_SHA, 表示把DHE_RSA(带有RSA数字签名的暂时Diffie-HellMan)定义为密钥交换算法；把DES_CBC定义为加密算法；把SHA定义为散列算法。</p>
<p>而ServerHello服务器用ServerHello信息应答客户，包括下列内容</p>
<ul>
<li>一个SSL版本号。取客户端支持的最高版本号和服务端支持的最高版本号中的较低者。</li>
<li>一个用于生成主秘密的32字节的随机数。（客户端一个、服务端一个）</li>
<li>会话ID</li>
<li>从客户端的密码套件列表中选择的一个密码套件</li>
<li>从客户端的压缩方法的列表中选择的压缩方法</li>
</ul>
<p>这个阶段之后，客户端服务端知道了下列内容：</p>
<ul>
<li>SSL版本</li>
<li>密钥交换、信息验证和加密算法</li>
<li>压缩方法</li>
<li>有关密钥生成的两个随机数。</li>
</ul>
<p><strong>第二阶段，服务器鉴别与密钥的交换</strong></p>
<p>服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：</p>
<ul>
<li>证书：服务器将数字证书和到根CA(Certification Authority)整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。</li>
<li>服务器密钥交换（可选）：这里视密钥交换算法而定</li>
<li>证书请求：服务端可能会要求客户自身进行验证。</li>
<li>服务器握手完成：第二阶段的结束，第三阶段开始的信号</li>
</ul>
<p>这一步在刚才的例子中被合并在第二步里。其重点在于服务端的验证和密钥的交换。在SSL 中密钥交换算法有6种：无效（没有密钥交换）、RSA、匿名Diffie-Hellman、暂时Diffie-Hellman、固定Diffie-Hellman、Fortezza。</p>
<p>在阶段一那里，双方已经协商确定使用哪种算法。而且CA 证书里包含了公钥。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575744280354.jpg" alt=""></p>
<p>比如我们协商使用了RSA 交换密钥，那么过程是这样的：<br>这个方法中，服务器在它的第一个信息中，发送了RSA加密/解密公钥证书。不过，因为预备主秘密是由客户端在下一个阶段生成并发送的，所以第二个信息是空的。注意，公钥证书会进行从服务器到客户端的验证。当服务器收到预备主秘密时，它使用私钥进行解密。服务端拥有私钥是一个证据，可以证明服务器是一个它在第一个信息发送的公钥证书中要求的实体。</p>
<p><strong>第三阶段，客户机鉴别与密钥交换</strong></p>
<p>在这一阶段，主要是我们的客户机启动，发送消息，服务器是唯一的接收方。分为三个阶段：</p>
<ul>
<li>证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。</li>
<li>客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。</li>
<li>证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。</li>
</ul>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575746918586.jpg" alt=""></p>
<p>这里的重点就是，我们的客户端把自己的公钥发给服务端，方便服务端用公钥加密，然后通过服务端之间发过来的证书里的公钥，加密自己的随机数和预备秘密，又保证了秘密的私密性，又证明了它拥有证书的公钥。</p>
<p><strong>第四阶段</strong></p>
<p>刚才服务端收到了用公钥加密的第三个随机数，这时服务端和客户端就可以使用三个随机数生成本次的会话密钥，双方通过计算得到本次使用的会话密钥。然后互相发送：</p>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>握手结束通知，表示握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供互相校验。</li>
</ul>
<p>而这三个随机数要获得总共六个加密秘密：四个密钥（客户公钥私钥 和服务器公钥私钥），两个IV（initialization vector 初始向量，与区块加密模式有关）。加密过程如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575782242346.jpg" alt=""></p>
<p>首先利用之前发送的预备主秘密，双方发送的随机数等组合散列并获得MD5值，得到一个主秘密。再对主秘密进行处理，得到一串散列值，这个散列值可以拆分成四个密钥和两个IV。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791281572.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791478878.jpg" alt=""></p>
<h3 id="记录协议">记录协议</h3>
<p>刚才讲的只是在完成了握手协议，下面在握手成功后，双方如何互传信息呢。就需要使用记录协议。记录协议提供了两个服务：</p>
<ul>
<li>保密性，使用握手协议定义的秘密密钥实现</li>
<li>完整性，握手协议定义了MAC， 用于保证信息完整性</li>
</ul>
<p>整个记录协议的过程如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575792771159.jpg" alt=""></p>
<h3 id="警报协议">警报协议</h3>
<p>当客户和服务器发现出现错误的时候，就需要处理这个错误。于是，就向对方发送一个警报信息。如果是致命错误，那么就会立即关闭SSL 连接，而且双方还会删除相关的会话号，秘密和密钥。这就是警报协议，每个警报的信息共有两个字节，第一个字节表示错误类型，如果是警报，置1，如果是致命错误，置2.第二个字节指定实际的错误类型。</p>
<p>相关扩展：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">DH加密方法</a></p>
<p><a href="http://www.openssl.org/" target="_blank" rel="external">OpenSSL</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP/IP 完全解读之传输层协议]]></title>
    <link href="http://yoursite.com/2016/03/09/TCP-IP-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB1/"/>
    <id>http://yoursite.com/2016/03/09/TCP-IP-完全解读1/</id>
    <published>2016-03-09T09:29:23.000Z</published>
    <updated>2016-03-09T09:36:38.000Z</updated>
    <content type="html"><![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br><a id="more"></a></p>
<h3 id="1-1_多路复用/分解">1.1 多路复用/分解</h3>
<p>在阐述这个问题之前，我们先来简单谈一下不同主机应用程序<strong>进程间通信</strong>的问题。我们知道不同应用程序之间的交互实际上是进程间的交互，在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。在这个过程中，通信间进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送和接收报文，套接字是同一台主机内应用层与传输层之间的接口（因此套接字也称为应用程序和网络之间的API）。在网络中，主机地址由IP地址标识，一个发送进程要将报文送往另一台主机的接收进程，除了要知道主机IP地址外，还要知道接收进程的接收套接字，这个接收套接字对应一个目的地<strong>端口号（port number）</strong>。</p>
<p>对于传输层传输的每个报文，其中都有一些字段，传输层检查这个字段，进而把报文定向到正确的接收套接字。将运输层报文段中的数据交付到正确的套接字的工作就称为<code>多路分解</code>。与之对应，源主机从不同套接字收集数据块，并为每个数据块封装上首部信息（用于以后分解）从而生成报文段，并将报文段传递到网络层的工作称为<code>多路复用</code>。</p>
<p>实际中，这些特殊的字段是<strong>源端口号</strong>字段和<strong>目的端口号</strong>字段，端口号是一个16bit的数，大小在0—65535之间，其中0—1023范围称为<strong>周知端口号（well-known port number）</strong>，保留给诸如HTTP（80端口）、FTP（控制：21端口，数据：20端口）、telnet（23端口），SMTP（25端口），POP3（110端口），NNTP（119端口）等周知的应用层协议使用。查看周知端口号可前往：<a href="www.iana.org">www.iana.org</a></p>
<p>下这张图给出了一个多路复用和分解的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-1.png" alt="1"></p>
<h4 id="1-1-1_无连接的多路复用/分解">1.1.1 无连接的多路复用/分解</h4>
<p>UDP采用无连接的多路复用与分解，一个UDP套接字是由一个二元组（源端口号，目的端口号）来标识的，该二元组包含一个目的IP地址和目的端口号，两个UDP报文只要有相同的IP地址和目的端口号，那么这两个报文就将通过相同的目的套接字被定向到相同的目的进程。在下面的例子中，主机A中的一个进程具有UDP端口号19157，它要发送一个应用程序数据块给位于主机B的另一进程，该进程具有UDP端口号46428。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-2.png" alt="2"></p>
<h4 id="1-1-2_有连接的多路复用/分解">1.1.2 有连接的多路复用/分解</h4>
<p>TCP采用有连接的多路复用与分解，一个TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，与UDP不同，即使两个TCP报文有相同的目的IP地址和目的端口号，如果它们源IP地址或源端口号不同，就会被定向到两个不同的套接字。例子如下：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-3.png" alt="3"></p>
<h2 id="2_UDP">2 UDP</h2>
<p>UDP（User Datagram Protocol）指用户数据报协议，简单来讲，UDP无非就是对网络层协议增加了多路复用/分解功能而已（还有少量差错检测）。</p>
<p>使用UDP时，在发送报文之前，发送方和接收方的运输层实体间没有握手，因此UDP被称为<strong>无连接的</strong>。UDP无法提供可靠的数据传输，它有以下特点：</p>
<blockquote>
<ul>
<li>只要应用程序将数据传递给UDP，UDP就会将此数据打包进UDP报文并立即将其传递给网络层（相比之下TCP有拥塞控制机制）。由于实时应用通常要求最小发送速率，不希望过分延迟报文段的传送，且能容忍一些数据丢失，因此这些应用可以采用UDP实现。</li>
<li>无需建立连接，TCP在开始数据传输之前要经过三次握手，而UDP不需要任何准备即可传输数据，因此UDP不会引入建立连接的时延（正是由于这个原因，DNS使用UDP而不是TCP）。</li>
<li>无需维护连接状态，TCP要在端系统间维护连接状态（接收/发送缓存，拥塞控制参数，序号，确认号），而UDP不维护连接状态，因此也不需要这些参数。对于一些应用而言，相比TCP，UDP能支持更多的活跃用户。</li>
<li>分组首部开销小，每个TCP报文有20字节的首部开销，而UDP仅有8字节，更节约流量带宽。</li>
<li>由于UDP缺乏拥塞控制机制，因此发生拥塞时可能导致发送方和接收方的高丢包率，并会挤垮TCP会话。</li>
</ul>
</blockquote>
<h3 id="2-1_UDP报文段结构">2.1 UDP报文段结构</h3>
<p>UDP定义在RFC 768中，如下图所示，UDP首部只有四个字段（源端口号，目的端口号，长度，检验和），每个字段由两个字节组成。长度字段指示了UDP报文段中的字节数（首部+数据），检验和提供了差错检验功能。</p>
<p><em>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。</em><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-4.png" alt="4"><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-32.png" alt="32"></p>
<blockquote>
<ol>
<li>源端口：16bits，该数据报的发出端口。发送进程将在此端口发送数据包。</li>
<li>目标端口：16bits，该数据报的接收端口。接收进程将在此端口处进行接收。</li>
<li>总长度：整个UDP报文的长度，即UDP头部和数据的长度。</li>
<li>校验和：一个16位补码，是由伪IP头，UDP头（由于校验和字段本身就在UDP头部中，因此使用UDP头计算时先假设校验和为0），UDP数据形成的。其中，伪IP头的协议号为17。如果要求接收方忽略校验和，发送方不计算校验和，直接把校验和设置为0。对伪IP头的说明见下一小节。</li>
</ol>
</blockquote>
<h3 id="2-2_UDP检验和">2.2 UDP检验和</h3>
<p>根据RFC 768，<strong>检验和的计算方法如下：</strong><br>图中给出了伪IP头的格式，注意，<code>TCP与UDP计算检验和的方式是一样的。</code><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-0.png" alt="0"></p>
<blockquote>
<p>发送方<code>对伪IP头，UDP头（校验和为0），UDP数据的所有16bits字的和进行反码运算，求和时遇到的所有溢出都被回卷</code>（即忽略最高位的进位溢出），得到的结果放在检验和字段。在接收方，将全部字段之和与检验和字段相加，如果没有引入差错，则这个结果应当是全1的，如果有任何&gt;一位为0，则说明传输出现了差错。（参见下图）<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-5.png" alt="5"></p>
</blockquote>
<p>这里还有一个问题要说明，<strong>虽然UDP提供差错检测，但它对差错的恢复无能为力</strong>，对于出错的报文段，UDP的接收方有两种选择：</p>
<blockquote>
<ol>
<li>丢弃受损的报文段。</li>
<li>将受损的报文段交给应用程序并给出警告。</li>
</ol>
</blockquote>
<h2 id="3_可靠数据传输原理">3 可靠数据传输原理</h2>
<h3 id="3-1_可靠数据传输">3.1 可靠数据传输</h3>
<p>借助于可靠信道，传输数据比特不会受到损坏或丢失，而且所有数据都是按其顺序进行交付，我们将实现这种服务的抽象称为可靠数据传输协议（reliable data transfer protocol）（注意：可靠数据传输协议的下层协议也许是不可靠的），下面两图给出了一个可靠数据传输协议所提供的服务及其概要实现，其中rdt表示可靠数据传输协议，理解这两张图是理解TCP的基础。</p>
<p><strong>可靠数据传输协议提供的服务和实现：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片1.png" alt="图片1"></p>
<p><strong>详细说明：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片2.png" alt="图片2"></p>
<p>接下来我们逐步讨论实现可靠数据传输协议的几个要点，在讨论过程中，我们会用到<strong>FSM</strong>（有限状态机，finite-state machine），其中初始状态用虚线指出，箭头代表从一个状态变化到另一个状态，每个箭头旁会附有引起变迁的事件（横线上方）及事件发生时所采取的行动（横线下方），符号\^表示空集（横线上方表示条件为空/横线下方表示所采取的行动为空）。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-11.png" alt="11"></p>
<p>为了能更深入的理解TCP，我们先在研究TCP之前改概略的研究以下协议：<strong>rdt1.0-&gt;rdt2.0-&gt;rdt3.0</strong>，它们从最理想的网络情况切入，一步步拓展到真实网络环境，其中rdt1.0假设传输信道完全可靠，rdt2.0假设传输信道会有比特差错但不会丢包，rdt3.0假设传输信道不仅会有比特差错，还会丢包（和真实网络情况一致）。</p>
<blockquote>
<p><strong>rdt1.0:假设发送双方经完全可靠信道传输</strong>，这种情况下我们不必担心任何差错，因为我们假定信道是完全可靠的，且假定接收方接收速率和发送方发送速率一样快。</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-12.png" alt="12"></p>
<blockquote>
<p><strong>rdt2.0:假设经有比特差错但不会丢包的信道传输</strong>，一个分组在传输、传播、缓存的过程中都可能出现差错，这种情况下，我们需要在rdt1.0的基础上引入以下三种功能来解决。</p>
<ol>
<li>差错检验：利用<code>检验和</code>使接收方能够检测到数据分组是否出错。</li>
<li>接收方反馈：如果没有出错，则返回肯定确认（ACK）给发送方，如果检测到出错，则返回否定确认（NAK），即引入<code>肯定和否定</code>分组。</li>
<li>重传：如果发送方收到NAK，则重传该分组。</li>
</ol>
</blockquote>
<p><strong>由此我们得到rdt2.0如下：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-13.png" alt="13"></p>
<p>在上图中，只有发送方收到来自接收方的ACK，才会发送下一个分组，如果收到NAK，则重发当前分组。这之中用到了停等协议（stop-and-wait）的思想。但rdt2.0存在以下问题：<strong>没有考虑到ACK或NAK在发送过程中受损的问题</strong>。如果ACK或NAK受损，rdt2.0的发送方就无法判断该进入哪个状态。解决这一问题的思路是：作为发送方如果不确定收到的是ACK还是NAK，只需重传当前分组（注意：这种方法在信道中引入了<strong>冗余分组</strong>），但是新的问题来了，如果采取这种方法，作为接收方如何判断自己收到的分组是新的还是一次重传？为了解决这一问题，我们引入<code>序号</code>字段。即在数据分组中增加一个序号字段，让发送方对其发送的数据进行编号，对于停等协议，这个序号1比特就足够了（使用0、1两个状态轮流标记发送分组），由此我们得到了改进版的rdt2.5，可以看到，此时接收方可以根据序号识别这个一个新的分组还是一次重传。!</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-14.png" alt="14"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-15.png" alt="15"></p>
<blockquote>
<p><strong>rdt3.0:假设经有比特差错且会丢包的信道传输</strong>，这是真实网络的情况，为了能处理丢包，我们必须解决以下两个问题：如何检测丢包及发生丢包后该做些什么。第二个问题的答案是显然的，因为其实在引入<code>检验和</code>、<code>序号</code>、<code>肯定和否定分组</code>及<code>重传</code>机制后，只要能检测到丢包，我们就可以通过通过重传解决这个问题。<br>解决第一个问题的办法是引入一个定时器，即选定一个合适的时间值，以判定可能发生了丢包（虽然不能确保是丢包），如果在这个时间内没有收到ACK，则重传该分组。（注意：如果一个分组经历了一个特别大的时延，即使该数据分组及其ACK都没有丢失，发送方也会重传该分组，这在信道中引入了<strong>冗余数据分组</strong>，但正如rdt2.0中讨论的那样，我们已有的机制可以处理这种冗余，即：可以判断收到的分组是新的还是一次重传。）</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-16.png" alt="16"></p>
<h3 id="3-2_ARQ">3.2 ARQ</h3>
<p>如果在协议中，发送方在准备下一个数据项目之前先等待一个肯定的确认，则这样的协议称为ARQ（Automatic Repeat Request，自动重传请求协议）。自动重传请求（Automatic Repeat Request），通过接收方请求发送方重传出错的数据报文来恢复出错的报文，是通信中用于处理信道所带来差错的方法之一，传统自动重传请求分成为三种，即<strong>停等协议</strong>(stop-and-wait），<strong>回退n帧</strong>（go-back-n），以及<strong>选择性重传</strong>（selective repeat）。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为流水线ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。接下来停等协议我们已经在之前粗略的提到过，接下来我们分别对这三个协议进行讨论。</p>
<h4 id="3-2-1_停等协议（stop-and-wait）">3.2.1 停等协议（stop-and-wait）</h4>
<p>我们在上述讨论中提到的rdt3.0也被称为比特交替协议（alternating-bit protocol），尽管它是一个功能正确的协议，但其性能并不令人满意，其性能问题的核心在于它是一个停等协议，下面两张图分别给出了停等协议在<strong>无丢包</strong>、<strong>分组丢失</strong>、<strong>ACK丢失</strong>和<strong>过早超时</strong>4种情况的过程：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-17.png" alt="17"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-18.png" alt="18"></p>
<p>停等协议的性能不佳主要集中表现在它对信道的利用率很低，假设两个距离很远的端系统间的RTT大约为30ms，分组长度为1000字节（8000bits）的数据通过发送速率为1Gbps的信道传输，根据下图的说明和给出的公式计算可知信道利用率只有万分之2.7，停等协议极大的限制了底层网络硬件所能提供的能力，事实上，如果再考虑上发送方与接收方之间路由器的处理时间和排队时延，性能将更加糟糕。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-19.png" alt="19"></p>
<p>停等协议的性能问题的根源在于每次只能发送一个分组，为了解决其存在的性能问题，我们可以采用流水线技术，即允许发送方一次发送多个分组而无需等待确认，但这也引入一些新的问题：</p>
<blockquote>
<ol>
<li>由于每个传输中的分组必须有一个唯一的序号，因此必须<code>增加序号的范围</code>。</li>
<li>发送方和接收方两端必须能<code>缓存多个分组</code>，具体而言，发送方最低限度应当能缓存那些已经发送但还没有确认的分组，接收方，而接收方可能需要缓存那些已正确接收的分组（具体取决于采用GBN还是SR）。</li>
<li>解决流水线下的差错恢复。</li>
</ol>
</blockquote>
<p><strong>解决流水线差错恢复的两种基本方法分别是：GBN和SR</strong>。</p>
<h4 id="3-2-2_GBN（go-back-n）">3.2.2 GBN（go-back-n）</h4>
<p>在GBN中，允许发送方发送多个分组而不需要等待确认，但这里有一个限制，即在流水线中未确认的分组数不能超过某个最大允许数N（N即为窗口长度），下图中，我们定义base为最早的未确认分组号，定义nextseqnum为最小的未使用序号（也即下一个待发分组的序号），则[0，base-1]对应已经发送并被确认的分组，[base,nextseqnum-1]对应已经发送但未被确认的分组，[nextseqnum,base+N-1]内的序号能用于那些要被立即发送的分组，而大于等于base+N的序号是不能使用的。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-21.png" alt="21"></p>
<p>在未被确认的分组被确认后，窗口向前滑动，因此GBN也被称为滑动窗口协议，分组序号承载在分组首部一个固定长度的字段中（如果分组序号的比特数是k,则序号范围是$[0，2^k-1]$），关于GBN需要理解以下几点：</p>
<blockquote>
<ol>
<li>当上层要发送数据时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组，如果窗口未满，则产生一个分组并将其发送，并相应的更新变量，如果窗口已满，发送方缓存这些数据或使用同步机制让上层在仅当窗口不满时才能调用rdt_send()请求发送。</li>
<li>在GBN中，对序号为n的分组采取累积确认的方式，接收方丢弃所有收到的失序分组，知道收到期待接收的分组n，然后为分组n返回一个ACK，作为发送方，一旦收到分组n的ACK，就表明n及n之前的所有分组都已被正确接收。</li>
<li>发送方仅使用一个定时器，这个定时器是最早的已发送但未被确认的分组适用的定时器。出现超时时，发送方重传所有已发送但还未被确认的分组，即回退n步，并重启计时器。</li>
</ol>
</blockquote>
<p>一个GBN的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-24.png" alt="24"></p>
<p>GBN的优点是接收缓存简单，缺点是单个分组的差错就可能引起大量本没有必要重传的分组重传。</p>
<p><strong>实现了GBN的rdt4.0：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-22.png" alt="22"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-23.png" alt="23"></p>
<h4 id="3-2-3_SR（selective_repeat）">3.2.3 SR（selective repeat）</h4>
<p> 在GBN中，随着信道差错率的增加，信道可能会被不必要重传的分组所充斥，而SR则可以避免这一问题，选择重传协议通过让发送方重传那些它怀疑在接收方出错的分组而避免不必要的重传，关于SR需要理解以下几点：</p>
<blockquote>
<ol>
<li>接收方确认一个正确接收的分组而不管其是否按序，失序的分组将被缓存直到所有序号更小的分组都被收到为止。</li>
<li>具体而言有三种情况：如果一个分组的序号落在接收方的窗口内时，如果该分组以前没有收到过，则缓存该分组，回发ACK；如果该分组序号等于接收窗口的基序号（rcv_base），则该分组及其之后缓存的序号连续的分组被交付给上层，而后接收方窗口向后滑动；如果该分组已经被缓存，则也必须回发一个ACK（否则如果上一次回发的该分组的ACK丢失，则发送方将永远无法向后移动窗口）。</li>
</ol>
</blockquote>
<p> 一个SR的例子：<br> <img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-25.png" alt="25"></p>
<p>SR协议看起来比BNG优秀很多，但它也引入了新的问题，即：由于发送方和接收方窗口间缺乏同步，如果SR接受窗口太大，会带来下图中的问题：接收方在最后收到具有序号0的分组时，无法区分它是第1个分组的重传还是第5个分组的首次传输。<br><strong>这里要首先补充一点：</strong>由于序号空间是一个长度为$2^k$的环（即序号$2^k-1$之后的序号为0）。</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-26.png" alt="26"></p>
<p>为了避免上述问题，通常我们规定窗口长度必须小于序号空间大小的一半。</p>
<h2 id="4_TCP">4 TCP</h2>
<h3 id="4-1_TCP概述">4.1 TCP概述</h3>
<p>与UDP不同，TCP是面向连接的，两个端系统的进程在通信前首先要经过三次握手建立连接。TCP提供全双工服务，是点对点的（如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向A的同时，也从A流向B）。在发送方，当应用层有数据要发送时，客户进程通过套接字传递数据流，TCP将这些数据流引导到发送缓存中（发送缓存在三次握手初期设置），之后TCP会从发送缓存中取出一块数据，加上40字节的首部形成TCP报文段（TCP segment）下传给网络层。当TCP在另一端收到一个报文后，将其存入接收缓存，而后接收方应用程序从此缓存中读取数据流。</p>
<p>这里我们谈到“TCP会从发送缓存中取出一块数据”，所谓一块究竟是多大呢？TCP可从缓存中取出并放入报文段中的数据量受限于<strong>最大报文段长度（maximum segment size，MSS）</strong>，而MSS通常根据最大链路层帧长度，即最大传输单元（maximum transmission unit，MTU）来设置。以太网和PPP链路层协议都具有1500字节的MTU，除去TCP40字节的首部，因此MSS的典型值为1460字节。</p>
<h3 id="4-2_TCP报文段结构">4.2 TCP报文段结构</h3>
<p>TCP定义在RFC 793中，下图显示了TCP报文段的结构：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-31.png" alt="31"></p>
<p><strong>下面我们逐个分析这些字段：</strong></p>
<blockquote>
<ol>
<li>源端口号/目的端口号：各长16bits，分别标识了源端口号和目的端口号。</li>
<li>序号：32bits，是该报文段首字节的字节流编号。</li>
<li>确认号：32bits，主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</li>
<li>首部长度：4bits，该字段指示了以32bits的字为单位的TCP首部的长度，由于选项字段的原因，TCP首部长度是可变的，通常选项字段为空，因此TCP首部典型长度为20字节。</li>
<li>保留未用：6bits，必须全0。</li>
<li>标志（flag）：6bits，其中ACK用于确认号字段中的值是有效的，即该报文包括一个对已被成功接收报文段的确认；RST，SYN，FIN比特用于连接的建立和拆除（这一点我们在之后对三次握手的讨论中会详细阐述）；PSH比特被置位时，指示接收方应立即将数据交给上层；URG比特用来指示报文段中有被发送端上层实体置位紧急的数据（紧急数据的最后一个字节由16比特的紧急数据指针字段指出，当紧急数据存在且给出紧急数据尾的指针时，TCP必须通知上层实体）。注意，在实际中PSH，URG和紧急数据指针并没有被使用。</li>
<li>窗口大小：通告接收缓冲区空闲块大小（确认字节之后还可以发送多少字节）。</li>
<li>检验和：一个16位补码，是由伪IP头，TCP头，TCP数据形成的。伪IP头与UDP类似，其中的协议号为6。</li>
<li>紧急数据指针：与标志URG一起用来取出紧急数据或指出记录边界。</li>
<li>选项：最大数据段长度(Maximum Segment Size，MSS)：为TCP有效载荷的最大长度；窗口比例(Scale): 乘以通知窗口大小；允许选择性确认(SACK-Permitted；选择性确认(SeletiveACK,SACK): 已收到数据段的序号集合；时间戳等等。Unix系统的默认值：MSS为536，SACK-Permitted为False。Windows 的默认值MSS为1460，SACK-Permitted为True。</li>
</ol>
</blockquote>
<p><strong>详细说明：</strong></p>
<blockquote>
<ul>
<li>URG: Urgent Pointer field significant（紧急(Urgent)指针标志，表示本数据段包含紧急数据，位于数据段前部，直到紧急指针指向的位置（从0开始）。可以用来在字节流中指明记录的边界。）</li>
<li>ACK: Acknowledgment field significant（确认号有效标志。）</li>
<li>PSH: Push Function（告知接收方发送方执行了推送(Push)操作，接收方需要尽快将这些数据交给接收进程，不要将其放在缓冲区。另外，PSH还实现了段的立即传输，不用等待构建一个大的数据段再发送。当缓冲区中出现回车后，系统会自动设置PSH。因此，PSH在发送端和接收端均起作用。）</li>
<li>RST: Reset the connection（重置(Reset)连接。因为出现了错误，通知对方立即中止连接并释放与连接有关的资源。）</li>
<li>SYN: Synchronize sequence numbers（同步(Synchronous)序号标志，用来发起一个TCP连接。）</li>
<li>FIN: No more data from sender（结束(Finish)标志，表示发送方完成了所有发送任务，要求释放连接。）<br><code>（* 所有标志为1有效。）</code></li>
</ul>
</blockquote>
<h3 id="4-3_往返时间（RTT）的估计与超时">4.3 往返时间（RTT）的估计与超时</h3>
<h4 id="4-3-1_RTT的估计">4.3.1 RTT的估计</h4>
<p>TCP通过如下方式估计发送方与接收方的往返时间：<br>我们定义SampleRTT为某报文段被发出到对报文段的确认被收到之间所用的时间，同时TCP维持一个SampleRTT的均值EstimatedRTT。TCP每隔一段时间测量一次SampleRTT，并根据以下公式更新EstimatedRTT。<br>$$EstimatedRTT = (1- α)<em>EstimatedRTT + α</em>SampleRTT$$<br><strong>RFC 6298给出α的参考值为0.125</strong></p>
<p>EstimatedRTT是一个加权平均值，这个加权平均值对最近的样本赋予的权值要大于对老样本赋予的权值，因为越近的样本越能反应当前网络的拥塞情况。除了估算RTT外，测量RTT的变化也是有价值的，RFC 6298定义RTT偏差：DevRTT，用于估算SampleRTT偏离EstimatedRTT的程度：<br>$$DevRTT = (1-β)<em>DevRTT + β</em>|SampleRTT-EstimatedRTT|$$<br><strong>RFC 6298给出α的参考值为0.25</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-41.png" alt="41"></p>
<h4 id="4-3-2_超时">4.3.2 超时</h4>
<p>给出SampleRTT和EstimatedRTT的定义后，我们不妨考虑，TCP超时间隔应该选取什么值呢？我们定义这个值为TimeoutInterval为超时时间间隔。（显然，TimeoutInterval应当大于EstimatedRTT，否则会造成不必要的重传，但也不能比EstimatedRTT大太多，否则报文丢失时将无法很快的重传丢失报文）根据下面公式计算TimeoutInterval：<br>$$TimeoutInterval = EstimatedRTT + 4*DevRTT$$<br>RFC 6298推荐的TimeoutInterval初始值为1秒，并在超时后将TimeoutInterval加倍，直到报文收到确认后就使用上面的公式计算TimeoutInterval。</p>
<h3 id="4-4_可靠数据传输">4.4 可靠数据传输</h3>
<p>TCP在IP不可靠的尽力而为的服务之上提供了可靠的数据传输服务，确保了一个进程从其接收缓存读取的数据是<strong>无损坏，无间隔，非冗余和按序</strong>的数据流。接下来我们将具体讨论TCP是如何做到这一点的，我们将会看到，它与我们之前讨论的rdt3.0再很多细节上有所不同。</p>
<p>在之前rdt3.0的讨论中，为了解决丢包的问题，我们实际上为每个分组都引入了一个计时器，一旦计时器超时，就重传该分组，但这样做我们要为计时器的管理付出巨大开销，因此，TCP实际上只采用单一的重传计时器（即使有多个已发送但还未被确认的报文段），这个计时器具体的工作方式我们会在下面逐步给出。</p>
<h4 id="4-4-1_超时间隔加倍">4.4.1 超时间隔加倍</h4>
<p>在大多数TCP的实现中，对TimeoutInterval的取值并不总是按照4.3.2中的公式进行计算，而是这样一个过程：<br>每当超时时间发生时，TCP重传具有最小序号的还未被确认的报文段，并将TimeoutInterval的值设为之前的两倍，而不是使用4.3.2中的公式计算，因此，TimeoutInterval会成指数增长，但是，如果遇到<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>事件时，定时器会重新启动，此时启动的定时器将按照4.3.2中的公式计算TimeoutInterval。</p>
<p>之所以这么做是出于以下考虑：如果发生超时，则很可能是由于网络拥塞造成的，而频繁的重传分组会使得拥塞更加严重，因此在没有<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>时，TCP使用加倍TimeoutInterval的方式，让重传经过越来越长的时间间隔进行。</p>
<h4 id="4-4-2_快速重传">4.4.2 快速重传</h4>
<p>如果我们仅依赖是否超时来判断是否丢包，则对于这个真正丢失的分组，发送方必须在超时之后才会重传它，如果超时周期较长，重传会被延迟。为了优化这个问题，TCP引入了<strong>快速重传</strong>机制。</p>
<p>假设接收方期待接收序号为n的报文段但却收到了序号大于n的报文段，我们就说此时它检测到了数据流的一个间隔，造成间隔的原因可能是报文段丢失或报文段被重新排序，由于TCP不使用否定确认，它会对已经收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK），作为发送方如果收到对同一个数据的<strong>3个冗余ACK</strong>（即第4次收到这个数据的ACK），即使当前计时器还没有超时，TCP也立即重传这个分组，这就是快速重传机制。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-43.png" alt="43"></p>
<h4 id="4-4-3_累积确认">4.4.3 累积确认</h4>
<p>TCP返回的ACK实际上是它期待（从发送方）接收的下一个分组号，TCP的确认是累积式的，正确接收但失序的报文会被缓存但不会被逐个确认（确认号都是其期待接收的下一个分组号，即前面提到的冗余ACK）。发送方只需要维护已发送但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum），对于发送方的一组报文1,2，…，N，假设报文段n丢失（n&lt;N），但它之前的全部报文和它之后的全部报文在超时前到达了接收方，则超时后TCP只会重传至多一个报文段（而GBN则会重发n及n之后的分组）。如果对报文段n+1的确认在n超时前到达，即使对n的确认还没有到达，发送方也可以知道接收方已经正确接收报文n了，这是因为TCP采取累积确认，收到对n+1的确认就意味着n+1之前的分组接收方都收到了。</p>
<p>附：RFC 5681对产生TCP ACK的建议：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-44.png" alt="44"></p>
<h3 id="4-5_流量控制">4.5 流量控制</h3>
<h4 id="4-5-1_流量控制的实现">4.5.1 流量控制的实现</h4>
<p>一条TCP连接每一侧主机都为该连接设置了接收缓存，如果应用程序读取数据相对缓慢，而发送方发送的太多太快，发送的数据就会时接收缓存溢出。TCP为应用程序提供<strong>流量控制服务（flow-control service）</strong>以消除发送方使接收方缓存溢出的可能性，因此流量控制是一个速度匹配服务。</p>
<p>TCP通过让发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量来提供流量控制（接收窗口告诉发送方该接收方还有多少缓存空间）。因为TCP是全双工通信，因此在连接两端的发送方都各自维护一个接收窗口。<br>定义：LastByteRead为主机B上应用程序从缓存读出的数据流的最后一字节的编号，LastByteRcvd为从网络中到达主机B并且已经放入主机B接收缓存中的数据流的最后一个字节的编号。则为了不使缓存溢出，下面式子必须成立：<br>$$LastByteRcvd - LastByteRead≤RcvBuffer$$<br>用rwnd表示接收窗口大小，则：<br>$$rwnd=RcvBuffer-（LastByteRcvd - LastByteRead）$$<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-45.png" alt="45"></p>
<p>为了不使主机B接收缓存溢出，主机A只需轮流跟踪2个变量：LastByteSent和LastByteAcked，注意到LastByteSent - LastByteAcked就是主机A发送到连接中但未被确认的数据量，通过将未被确认的数据量控制在rwnd以内，就可以保证主机B的缓存不会溢出。</p>
<h4 id="4-5-2_死锁处理">4.5.2 死锁处理</h4>
<p>在上面的讨论中，如果主机B接收缓存已满，即rwnd=0，在将这一信息告诉主机A后，如果B没有任何数据要发送给A，就会发生死锁，因为此时即使B将缓存中的数据取走，A也无法得知这一事实。为了解决这一问题，我们采用“聪明的发送方/笨拙的接收方”，即发送方定期(Persist Timer)发送一个字节数据，以使接收方响应以获得通知窗口的大小。接收方响应采用下一个期待接收的字节。</p>
<h3 id="4-6_连接管理">4.6 连接管理</h3>
<h4 id="4-6-1_三次握手">4.6.1 三次握手</h4>
<p>建立连接的过程需要三步，称为<strong>三次握手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个SYN报文段，不含应用层数据，SYN=1，客户端会随机选择一个初始序号x。</li>
<li>服务器收到客户端的SYN报文段后，为TCP连接分配缓存和变量，返回一个SYNACK报文段，SYN=1，ACK=1，ACKNum=x+1，同时服务器选择自己的初始序号y。</li>
<li>在收到SYNACK报文段后，客户端也分配缓存和变量，并回发一个报文段进行确认，SYN=0，ACK=1，ACKNum=y+1，可以在负载中携带数据。</li>
</ol>
</blockquote>
<p><strong>超时重发：</strong>每一步均采用超时重发，多次重发后将放弃。重发次数与间隔时间依系统而不同。<br><strong>数据字节序号：</strong>客户和服务器发送的第一个数据字节的序号分别为x+1和y+1。<br><strong>选项：</strong>头两个数据段给出选项：SACK-Permited，Scale，MSS。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-46.png" alt="46"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-47.png" alt="47"></p>
<h4 id="4-6-2_四次挥手">4.6.2 四次挥手</h4>
<p>中断连接的过程需要四步，称为<strong>四次挥手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个FIN报文段，FIN=1，seq=x，客户端进入FIN_WAIT_1状态。</li>
<li>服务器收到客户端的FIN报文段后，返回一个ACK报文段，ACK=1，ACKNum=x+1，客户端收到后进入FIN_WAIT_2状态。</li>
<li>服务器TCP向客户端TCP发送一个FIN报文段，FIN=1，seq=y。</li>
<li>客户端收到服务器的FIN报文段后向服务器发送一个确认，ACK=1，ACKNum=y+1，并进入TIME_WAIT状态，假设ACK丢失，TIME_WAIT状态会使客户端重传最后的报文。</li>
</ol>
</blockquote>
<p><strong>释放连接：</strong>先发FIN一方在ACK发送完毕后需要等待2MSL(Maximum Segment Lifetime)的时间才完全关闭。TCP标准中MSL采用60秒，Unix采用30秒。<br><strong>超时重发：</strong>超时未收到确认，则超时自动重发，在若干次重发后依然没有收到确认，则发送RST后强行释放连接。不同的系统重发方法不同。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-48.png" alt="48"></p>
<h4 id="4-6-3_SYN洪泛攻击">4.6.3 SYN洪泛攻击</h4>
<p>在三次握手的过程中，如果客户端不发送ACK完成第三步，则服务器将在一段时间内出于半开连接的状态，并在这一时间之后才断开连接并收回资源，如果攻击方发送大量TCP SYN连接但又不完成第三步，就会导致服务器的连接资源最终被耗尽。这种攻击方式被称为SYN Flood Attack，是一种经典的DOS攻击方式，我们可以采用SYN cookie（RFC 4987）来避免它。</p>
<h3 id="4-7_拥塞控制">4.7 拥塞控制</h3>
<p>TCP发送方法可能因为IP网络的拥塞而被遏制，这种对发送方的控制称为拥塞控制。由于IP层不向端系统提供显式的网络拥塞反馈，因此TCP必须使用端到端的拥塞控制。TCP拥塞控制的方法大致可描述为根据发送方所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果TCP发送方感知到路径上没有拥塞，则增加发送速率，反之则降低发送速率。<br>运行在发送方的拥塞控制机制需要跟踪一个额外的变量，即拥塞窗口（congestion window），不妨定义它为cwnd，发送方中未被确认的数据量不能超过cwnd和rwnd中的较小值，即：<br>$$LastByteRcvd - LastByteRead≤min{cwnd , rwnd}$$<br><strong>TCP拥塞控制算法主要包括三个部分：慢启动，拥塞避免，快速恢复。</strong>其中慢启动和拥塞避免是TCP的强制部分，快速恢复是可选部分。</p>
<h4 id="4-7-1_慢启动">4.7.1 慢启动</h4>
<p>当一条TCP连接开始时，在慢启动（slow-start）状态，cwnd的值以1个MSS开始，并且每当传输的报文段被首次确认就增加一个MSS，这样每经过一个RTT发送速率就会翻倍，因此，采用慢启动算法，TCP发送速率起始慢，但在慢启动阶段以指数增长。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-51.png" alt="51"></p>
<p>我们记ssthresh为“慢启动阈值”，在以下三种情况发生时，结束慢启动过程：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，TCP发送方将ssthresh设置为cwnd/2（即当检测到拥塞时将ssthresh值置位拥塞窗口的一半），将cwdn设置为1，并重启慢启动算法。</li>
<li>当cwnd等于ssthresh时，结束慢启动算法，转移到<strong>拥塞避免</strong>模式。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，此时TCP执行快速重传并转入<strong>快速恢复</strong>状态。</li>
</ol>
</blockquote>
<h4 id="4-7-2_拥塞避免">4.7.2 拥塞避免</h4>
<p>进入拥塞避免状态时，cnwd的值大约是上次遇到拥塞时值的一半，此时TCP采取一种较为保守的方法，每到达一个新的确认，就将cwnd增加一个<strong>MSS*(MSS/cwnd)</strong>字节，即每个RTT只将cwnd的值增加一个MSS（线性增长）。<br>在以下两种情况发生时，结束拥塞避免的线性增长：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，TCP发送方将cwnd的值减半，将ssthresh设置为cwnd/2，进入<strong>快速恢复</strong>状态。<h4 id="4-7-3_快速恢复">4.7.3 快速恢复</h4>
<strong>注意：</strong>快速恢复只是TCP推荐但非必须的构件。<br>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK（最少为3个，但可能不止3个），cwnd的值都增加一个MSS（最少增加3个MSS），不妨设因为冗余ACK而增加的MSS数为k。<br>在以下两种情况发生时，结束快速恢复：</li>
<li>当丢失报文段的一个ACK到达时，TCP将cnwd减去k后进入拥塞避免状态。</li>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
</ol>
</blockquote>
<p>一个可能的TCP拥塞窗口变化图如下（图中画出了Reno版TCP与Tahoe版TCP拥塞窗口的变化情况，其中Reno使用了快速恢复而Tahoe没有使用快速恢复）：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-52.png" alt="52"></p>
<p>TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，每出现3个冗余ACK时cwnd减半，因此TCP拥塞控制也被称为加性增，乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）拥塞控制方式。如下图所示：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-53.png" alt="53"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[薛定谔的2016]]></title>
    <link href="http://yoursite.com/2016/01/11/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%842016/"/>
    <id>http://yoursite.com/2016/01/11/薛定谔的2016/</id>
    <published>2016-01-11T12:37:27.000Z</published>
    <updated>2016-01-11T12:40:08.000Z</updated>
    <content type="html"><![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的转变，因为我认识到自己性格里的不成熟和缺陷，认识到大约二十年的无知以及自以为是。这算是一份特别的工作带给我的最大收获。</p>
<hr>
<p>回头将自己2015年的日记回看了一遍，就像又走了一遍2015年，看着自己一点一点的变化。看自己从迷茫到坚定，到焦虑，到淡定，到迟疑，到沉默…</p>
<p>年初的时候，我给自己定下了许多规划，试图去重建自己的生活习惯，比如坚持写日记，硬规定阅读量，坚持为记录时间，完善GTD。我试着去打破过去二十年懒惰的自己，重构出一个不一样的自己，这个过程，艰难，但显得自然而然。</p>
<p>而到了八月份，回到这个久违的荒岛（当然，现在已经商业开发的不再是荒岛了），度过最初的适应之后，那种期盼中的生活慢慢的展开，时间就真变成了离弦的箭，因为所有想要做的事情都展开了，在这个过程中，过去半年所规划的生活也被我重新调整。当然，在这个过程里，各种好的坏的习惯被改变，有很多过去无法完成的事情成了自然而然的一件小事。</p>
<p>在这接下来的半年里，从纠结的选择到淡定，从焦虑到从容。每天沉浸在实验室，感觉时间的每个节点，都被放大成了一个波澜不惊的平面，在这些平面上，我可以做许多事情。而且，我更珍惜每一个时间的断面，想要做更多的事情。</p>
<p>回到15年年初给自己定下的规划：</p>
<ul>
<li>关于阅读：一百本书的量基本完成，后半段大量的技术文档和文章可以填补本来的规划。</li>
<li>关于日记：止步于开学后不久，因为将精力投入到做事中，无暇记录。</li>
<li>关于知识结构：基本满意。</li>
<li>关于自控力：提高明显。</li>
<li>关于时间管理：不满意，使用了数种GTD 方法，均弃。</li>
<li>关于性格：有进步，但缺点明显，仍未改变。</li>
<li>关于健身：基本满意，身体素质提高，需坚持。</li>
<li>关于未来：有了更多的期许。</li>
</ul>
<p>所以，实际上，我的2015年看似是我变动最大的一年，也是环境变化最剧烈的一年，但似乎又是理所当然和波澜不惊的，我预想了一整年的状态，也预料到了这些波澜不惊。</p>
<p>实际上，2015年带给我的最大最大的收获，是我认识到，未来，哪怕是短短的一年两年，都应当是不可预测的。而如果未来是可测的，那人生一定是可悲的，因为那是一条毫无意义的路，你看不到不一样的风景，看不到未知，看不到未知里所藏匿着的壮美。去年，我一篇日志里写，追赶时间最佳的方式只有阅读，因为每本书实际上都是一段时间线的扩展，它可以将二维的时间提升到三维，四维…在更高的维度下，理解世界的方式在变化，认识人生轨迹的方式也在变化。</p>
<p>对于2016年，我所要面对的生活，将会有更大的变化，我甚至无法预测在未来的某个时间节点，我会在哪里出现，我在做什么。所以，我把我的二零一六称为薛定谔的二零一六，因为所有的可能都存在，在我没有打开盒子的时候，我不会知道我将为自己创造一个怎样的2016。所以，关于规划，我只写期望。</p>
<ul>
<li>关于阅读： 因为阅读量代表的是时间的量，我希望时间越长越好，所以仍然会给自己留下一百本的要求，按照2015年经验，平均每月8+本阅读，每本10w+字数，一个月的阅读量100w+ 难度不高。但鉴于书籍的选择我会尽量筛去口水化严重的书，那就需要花费更多的时间反思和内化，所以最后的实际期望在80~100本之间。2015的后半程没有坚持把每一本书都记录和总结出来，在2016年，一定要坚持将每一本书记录下来。</li>
<li>关于日记：我希望整合进时间管理中去，2015年有一大部分日记是用来思考和反省的，花费了较多时间。而2016年我希望，日记能作为一种行为习惯，与时间规划一起，用来整理人生。所以，选择一个优秀的APP或者自己开发一个应用，回顾事件和时间。日记的另一部分，用极简的话，记录收获。</li>
<li>关于自控力：自控力就像肌肉，只有锻炼，才能保持，否则只会越来越差。只要记住这句就好了。</li>
<li>关于时间管理：是2015年的最大遗憾，也是因为糟糕的时间管理能力，让一整年很多事情做起来毫无头绪，并行多线程互抢资源的情况经常发生。所以，新的一年，结合日记和一个合适的GTD方法，管理自己的时间，将是重点关注的事情。</li>
<li>关于健身：两天一次。</li>
<li>关于性格：藏拙，克己，平心，助人。</li>
<li>关于知识结构：结合时间管理，有计划的补充知识点。就技术而言，两向发展，技术内核学习一个方向，实践coding另一个方向。就知识面而言，依兴趣点规划，比如心理学方面把荣格的作品看完。</li>
<li>关于写作：2015年，其实总结了不少文章，但是因为懒惰，也因为感觉没有时间去整理，就没有挂在博客上。2016年，我还是应当学会用清晰的文字表达自己的学习内容，研究问题，学会表达。</li>
</ul>
<p>整个2015年，我认识到的另一件重要事，也是非常浅显的道理：所有的预想和规划，都无法代替真正的经历和体会，只有实践才能给出答案。所有对2016年的规划，都不过是一种期许，在新的一年，也许自己会面对新的挑战，不期而遇的变化，所有的计划都追赶不上变化，而我唯一要做的，就是努力将时光铺陈在所有美好的事物上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的]]>
    </summary>
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Python写一个虚拟解释器]]></title>
    <link href="http://yoursite.com/2015/11/09/%E7%94%A8Python%E5%86%99%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://yoursite.com/2015/11/09/用Python写一个虚拟解释器/</id>
    <published>2015-11-09T13:18:08.000Z</published>
    <updated>2015-11-09T13:20:14.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br><a id="more"></a></p>
<h2 id="0-_解释器到底是什么">0. 解释器到底是什么</h2>
<p>前边解释了一些，但解释的并不清楚，在<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a>中，做一个比较不错的解释。</p>
<blockquote>
<p>首先我们来谈一下解释器是什么。说白了解释器跟计算器差不多。它们都接受一个“表达式”，输出一个 “结果”。比如，得到 ‘(+ 1 2) 之后就输出 3。不过解释器的表达式要比计算器的表达式复杂一些。解释器接受的表达式叫做“程序”，而不只是简单的算术表达式。从本质上讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p>
<p>需要注意的是，我们的解释器接受的参数是一个表达式的“数据结构”，而不是一个字符串。这里我们用一种叫“S-expression”的数据结构来表示表达式。比如表达式 ‘(+ 1 2) 里面的内容是三个符号：’+, ‘1 和 ‘2，而不是字符串“(+ 1 2)”。从结构化的数据里面提取信息很方便，而从字符串里提取信息很麻烦，而且容易出错。</p>
<p>从广义上讲，解释器是一个通用的概念。计算器实际上是解释器的一种形式，只不过它处理的语言比程序的解释器简单很多。也许你会发现，CPU 和人脑，从本质上来讲也是解释器，因为解释器的本质实际上是“任何用于处理语言的机器”。</p>
</blockquote>
<h2 id="1-_学习写一个解释器的另一个原因">1. 学习写一个解释器的另一个原因</h2>
<p>在《编程珠玑》的第十章，提到代码空间技术，如何节省足够的空间，讲到了解释程序。他说，远古时代，有时候空间的瓶颈不在于数据，而在于程序本身的规模。比如一开始一个图形程序，有如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">17</span>, <span class="number">43</span>]</span> set(<span class="built_in">i</span>, <span class="number">68</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">18</span>, <span class="number">42</span>]</span> set(<span class="built_in">i</span>, <span class="number">69</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">81</span>, <span class="number">91</span>]</span> set(<span class="number">30</span>, <span class="built_in">j</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">82</span>, <span class="number">92</span>]</span> set(<span class="number">31</span>, <span class="built_in">j</span>)</div></pre></td></tr></table></figure>

<p>其中，set(i,j)表示点亮屏幕（i, j）处的像素，也就是说这实际上是一个绘制直线的程序。而当我们使用了适当的函数，比如用于绘制水平线的hor函数和垂直线的ver函数，就可以替代上述代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">hor</span><span class="params">(<span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span>)</span></span></div><div class="line"><span class="title">hor</span><span class="params">(<span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span>)</span></div></pre></td></tr></table></figure>

<p>而上述代码又可以利用一个解释器来替换，这个解释程序可以从下面的数组中读取命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">h</span> <span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span></div><div class="line">h <span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span></div><div class="line">v <span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span></div><div class="line">v <span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span></div></pre></td></tr></table></figure>

<p>至此，我们已经将空间减小了很多了，但如果你还想减少，那么就可以为命令h 或 v分配两个位，为后边的三个数字，每个数字，分配10个位置，这样一个32位的数字，表示一行命令了。这就是代码空间技术的运用。</p>
<p>当然，今天我们谈起节省空间，好像已经成了笑话，但是，当我们面对巨量数据，也就是我们今天所说的大数据的时候，空间，时间，效率的话题又一次被提起来。当我们面对着像混乱电流一样的数据时，尝试将自己的头脑想象成计算机，学会用更加底层的方式去思考，对对理解数据处理将有更深刻的认识。</p>
<p>为什么我们时常提起像机器一样思考呢？那是因为机器远比我们人类严谨，也是所有检验逻辑最严格的关卡，他不容许一点点错误，一个毫不起眼的bug，都会让程序完全崩溃。而程序是写给计算机的语言，所以，程序的严谨性就应当像计算机一样严谨。所以我们时常劝告自己要像计算机一样思考。</p>
<p>正如『正义的花生』在<a href="http://www.jianshu.com/p/f0863846b7e8" target="_blank" rel="external">数学与编程</a>中提到的一样：</p>
<blockquote>
<p>普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。</p>
</blockquote>
<p>诚然，大牛作者在思想上有很多偏执的地方，但是往往他的观点我都有着不小的认同感。前边那篇『怎样写一个解释器』也是他的文章。</p>
<p>所以，学习写一个解释器，可以带给我更多的思考，从效率，空间，机器等等方面进一步认识程序运行的本质，将这种认识正反馈到实际编程中，将潜移默化的带来影响。当然，这篇文章试着依葫芦画瓢的写完一个解释器，显然仅仅算是摸了摸门道，想要继续探索，还有更多的事情可以做。做更多的事情，可以参考上边提到的开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。</p>
<h2 id="1-_构建堆栈机">1. 构建堆栈机</h2>
<p>堆栈机的执行原理很简单，将需要处理的值放进堆栈中，然后执行。Python， Java这些高级语言将它作为自己的虚拟机。</p>
<p>所以我们利用了堆栈的方式存放指令。首先，我们需要一个指令指针栈，它能够储存返回地址。这个返回地址就是当我们执行一个子程序（如函数）的时候，需要用它跳回到开始调用该函数的地方。</p>
<p>我们将这个复杂的问题简洁化。比如有一个数学表达式：<code>（2+3）*4</code> ，这个表达式的意思就是依次推入<code>2 3 + 4 *</code>, 将2 和3 依次推入栈中，接下来要推入的指令是 <code>+</code>， 将两个数字弹出，令他们执行加法运算，然后将结果入栈。然后继续进行下去，直到计算出结果。</p>
<p>依靠这个原理，我们开始建立一个栈，我们使用python 中的一个类 collections.deque。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(deque)</span>:</span> <span class="comment"># 定义一个栈</span></div><div class="line">    push = deque.append  <span class="comment"># 添加元素</span></div><div class="line">    <span class="comment"># 返回最后一个元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self[-<span class="number">1</span>]</div></pre></td></tr></table></figure>

<p>deque 中自带pop 方法，所以我们就不用再定义 pop .</p>
<p>接下来我们继续构建一个虚拟机的类 Machine。 我们需要两个栈和一段储存代码的内存空间。一个栈储存数据，一个栈储存地址。得益于Python 动态类型，因此我们可以往列表里面存储任何东西，但是我们不能区分列表里面的内置函数和字符串，正确的做法是将Python 内置函数单独存放在一个列表。这里我们使用字典方法，键值分别对应字符串和函数。另外，我们需要一个指令指针，用来指向代码中下一个需要被执行的模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Machine</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, code)</span>:</span> <span class="comment"># 预先定义一个初始化函数</span></div><div class="line">       self.data_stack = Stack()</div><div class="line">       self.return_addr_stack = Stack()</div><div class="line">       self.code = code</div><div class="line">       self.instruction_pointer = <span class="number">0</span> </div><div class="line">    <span class="comment"># 再创建一些栈结构中必备的函数</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.pop()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.data_stack.push(value)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.top()</div></pre></td></tr></table></figure>

<p>为了执行操作码，而这个操作码并非实际意义上的操作码，它只是一种动态类型，所以我们建立一个dispatch 函数，在这之前，我们创建一个解释器的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>   <span class="comment"># 代码运行的条件</span></div><div class="line">    <span class="keyword">while</span> self.instruction_pointer &lt; len(self.code):</div><div class="line">         opcode = self.code[self.instruction_pointer]</div><div class="line">         self.instruction_pointer += <span class="number">1</span></div><div class="line">         self.dispatch(opcode)</div></pre></td></tr></table></figure>

<p>它的原理很简单： 获取下一个指令，指令指针自增1 然后基于操作码执行dispatch 函数，下面就是dispatch函数的定义。而对解释器的扩展增强基本在这个函数中实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, op)</span>:</span></div><div class="line">    dispatch_map = {</div><div class="line">        <span class="string">"%"</span>:        self.mod,</div><div class="line">        <span class="string">"*"</span>:        self.mul,</div><div class="line">        <span class="string">"+"</span>:        self.plus,</div><div class="line">        <span class="string">"-"</span>:        self.minus,</div><div class="line">        <span class="string">"/"</span>:        self.div,</div><div class="line">        <span class="string">"=="</span>:       self.eq,</div><div class="line">        <span class="string">"cast_int"</span>: self.cast_int,</div><div class="line">        <span class="string">"cast_str"</span>: self.cast_str,</div><div class="line">        <span class="string">"drop"</span>:     self.drop,</div><div class="line">        <span class="string">"dup"</span>:      self.dup,</div><div class="line">        <span class="string">"if"</span>:       self.if_stmt,</div><div class="line">        <span class="string">"jmp"</span>:      self.jmp,</div><div class="line">        <span class="string">"over"</span>:     self.over,</div><div class="line">        <span class="string">"print"</span>:    self.print_,</div><div class="line">        <span class="string">"println"</span>:  self.println,</div><div class="line">        <span class="string">"read"</span>:     self.read,</div><div class="line">        <span class="string">"stack"</span>:    self.dump_stack,</div><div class="line">        <span class="string">"swap"</span>:     self.swap,</div><div class="line">        }</div><div class="line">    <span class="keyword">if</span> op <span class="keyword">in</span> dispatch_map:</div><div class="line">        dispatch_map[op]()</div><div class="line">    <span class="keyword">elif</span> isinstance(op, int):  <span class="comment"># 如果指令是整形数据，就将数据存放到数据栈中</span></div><div class="line">        self.push(op)</div><div class="line">    <span class="keyword">elif</span> isinstance(op, str) <span class="keyword">and</span> op[<span class="number">0</span>]==op[-<span class="number">1</span>]==<span class="string">'"'</span>:</div><div class="line">        <span class="comment"># 如果是字符串类型，就将字符串内容存放到数据栈中</span></div><div class="line">        self.push(op[<span class="number">1</span>:-<span class="number">1</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError( <span class="string">"Unknown opcode: '%s'"</span> % op)</div></pre></td></tr></table></figure>

<p>上边的指令的意思是，当输入一段指令后，该函数就会根据这段指令在字典中找到对应的方法。比如符号<code>*</code>对应的是self.mul 。而这个self.mul 也是我们定义的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self)</span>:</span></div><div class="line">    self.push(self.pop() * self.pop())</div></pre></td></tr></table></figure>

<p>其他的函数定义也如此。</p>
<p>搭建好环境之后，下面继续进行。一个语言解释器包括两个部分：</p>
<ol>
<li>解析：解析部分接受一个由字符序列表示的输入指令，然后将输入字符分解成一系列的词法单元</li>
<li>执行： 程序内部的解释器根据语义规则进一步处理词法单元，进而执行原指令的实际运算。</li>
</ol>
<p>这是流程图：</p>
<figure class="highlight flow"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 指令</div><div class="line">op1=&gt;operation: 解析器</div><div class="line">op2=&gt;operation: 词法单元</div><div class="line">op3=&gt;operation: 执行运算</div><div class="line">e=&gt;end: 结果</div><div class="line"></div><div class="line">st<span class="variable">-&gt;op1</span><span class="variable">-&gt;op2</span><span class="variable">-&gt;op3</span><span class="variable">-&gt;e</span></div></pre></td></tr></table></figure>

<h2 id="2-_下面我们创建一个简单的解析器">2. 下面我们创建一个简单的解析器</h2>
<p>使用<a href="https://docs.python.org/3/library/tokenize.html" target="_blank" rel="external">tokenize</a>模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tokenize</div><div class="line"><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="comment"># 将text以StringIO的形式读入内存</span></div><div class="line">    <span class="comment"># 以字符串形式返回刀generate_tokens()函数中。</span></div><div class="line">    tokens = tokenize.generate_tokens(StringIO(text).readline)</div><div class="line">    <span class="comment"># generate_tokens 生成器生成一个5元组：标记类型、标记字符串、标记开始位置二元组、标记结束位置二元组以及标记所在的行号</span></div><div class="line">    <span class="comment"># 下面大写的单词都属于token模块的常量</span></div><div class="line">    <span class="keyword">for</span> toknum, tokval, _, _, _ <span class="keyword">in</span> tokens:</div><div class="line">        <span class="keyword">if</span> toknum == tokenize.NUMBER:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> toknum <span class="keyword">in</span> [tokenize.OP, tokenize.STRING, tokenize.NAME]:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> tokun == tokenize.ENDMARKER:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"Unknown token %s: '%s'"</span> % (tokenize.tok_name[toknum], tokval))</div></pre></td></tr></table></figure>

<p>关于token常量，查看<a href="https://docs.python.org/3/library/token.html#module-token" target="_blank" rel="external">官方文档</a>。</p>
<p>其中还有一个关键字 <code>yield</code>，它是用来定义生成器(Generator)，具体功能是可以当return 使用，从函数理返回一个值，不同之处是用yield 返回之后，可以让函数从上回yield 返回的地点继续执行。也就是说，yield 返回函数，交给调用者一个返回值，然后再移动回去，让函数继续运行下去，知道下一个yield语句再返回一个新的值。举个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def test_yield():</div><div class="line">...     yield 1</div><div class="line">...     yield 2</div><div class="line">...     yield (1,2)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; a = test_yield()</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">1</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">2</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">(1, 2)</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">StopIteration</div></pre></td></tr></table></figure>

<p>我们用生成器产生一个Fibonacci数列的函数就会更加直观：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></div><div class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></div><div class="line">    <span class="keyword">while</span> a &lt; max:</div><div class="line">        <span class="keyword">yield</span> a</div><div class="line">        a, b = b, a+b</div><div class="line"> </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> fab(<span class="number">20</span>):</div><div class="line"><span class="prompt">... </span>    <span class="keyword">print</span> i,<span class="string">","</span>,</div><div class="line">...</div><div class="line"><span class="number">0</span> , <span class="number">1</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">5</span> , <span class="number">8</span> , <span class="number">13</span> ,</div></pre></td></tr></table></figure>

<h2 id="3-_简单优化：_常量折叠">3. 简单优化： 常量折叠</h2>
<blockquote>
<p>常量折叠是其中一种被很多现代编译器使用的编译器最优化技术。常量折叠是在编译时间简单化常量表达的一个过程。简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表。可以算作一种编译优化。</p>
</blockquote>
<p>也就是我们最早举例子的时候说的，将2，3放入栈中，+ 进来的时候，2 3取出来进行运算，然后将运算结果放入栈中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_fold</span><span class="params">(code)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="comment"># 指令中找到两个连续的数字以及一个运算符</span></div><div class="line">        <span class="keyword">for</span> i, (a, b, op) <span class="keyword">in</span> enumerate(zip(code, code[<span class="number">1</span>:], code[<span class="number">2</span>:])):</div><div class="line">            <span class="keyword">if</span> isinstance(a, int) <span class="keyword">and</span> isinstance(b, int) <span class="keyword">and</span> op <span class="keyword">in</span> {<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>}:</div><div class="line">                m = Machine((a, b, op))</div><div class="line">                m.run()</div><div class="line">                code[i:i+<span class="number">3</span>] = [m.top()]</div><div class="line">                print(<span class="string">"Constant-folded %s%s%s to %s"</span> % (a, op, b, m.top()))</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> code</div></pre></td></tr></table></figure>

<h2 id="读取-求值-输出循环">读取-求值-输出循环</h2>
<blockquote>
<p>“读取-求值-输出”循环（英语：Read-Eval-Print Loop，简称REPL）是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境，但也能指代命令行的模式和例如APL、BASIC、Clojure、F#、Haskell、J、Julia、Perl、PHP、Prolog、Python、R、Ruby、Scala、Smalltalk、Standard ML、Tcl、Javascript这样的编程语言所拥有的类似的编程环境。这也被称做交互式顶层构件（interactive toplevel）。</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" target="_blank" rel="external">read-eval-print loop</a><br>这个名字来自于以下几个Lisp用来实现这种机制的内置函数：</p>
<ul>
<li>读入函数接收一个来自于用户的表达式，将其解析成数据结构并存入内存。例如，用户可能会输入一个s-表达式　(+ 1 2 3)，这句话会被解析成一个包含四个元素的链表。</li>
<li>求值函数　负责处理内部的数据结构并对其求值。在Lisp中，求一个以函数名开头的ｓ－表达式意味着对接下来的参数调用那个函数。所以函数”+”被在参数1 2 3上调用，产生结果6。</li>
<li>输出函数接受求值结果，并呈现将其给用户。尽管当前的结果“6”并不具有复杂的格式，但如果是一个较为复杂的表达式，那么它将会被精心处理，以便于更方便地被理解。</li>
</ul>
<p>代码应当这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Hit CTRL+D or type "exit" to quit.'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            source = raw_input(<span class="string">"&gt; "</span>)</div><div class="line">            code = list(parse(source))</div><div class="line">            code = constant_fold(code)</div><div class="line">            Machine(code).run()</div><div class="line">        <span class="keyword">except</span> (RuntimeError, IndexError) <span class="keyword">as</span> e:</div><div class="line">            print(<span class="string">"IndexError: %s"</span> % e)</div><div class="line">        <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">            print(<span class="string">"\nKeyboardInterrupt"</span>)</div></pre></td></tr></table></figure>

<h2 id="再思考">再思考</h2>
<p>这样，基本上的我们就完成了一个简单的解释器，实际上它的能力很弱小，但是作为一个锻炼思考的方式，是一个不错的实践。接下来，可以给这个解释器添加更多的功能。</p>
<p>另外，推荐几个其他的文章：<br><a href="http://python.jobbole.com/82206/" target="_blank" rel="external">用 Python 从零开始写一个简单的解释器</a><br><a href="http://blog.jobbole.com/88152/" target="_blank" rel="external">一起来写个简单的解释器</a><br><a href="http://blog.jobbole.com/47659/" target="_blank" rel="external">如何使用Python编写一个Lisp解释器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python高效编程小技巧]]></title>
    <link href="http://yoursite.com/2015/10/28/Python%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/10/28/Python高效编程小技巧/</id>
    <published>2015-10-28T13:34:59.000Z</published>
    <updated>2015-10-28T13:37:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Python_高效编程小技巧">Python 高效编程小技巧</h1>
<p>Python 一直被我拿来写算法题，小程序，因为他使用起来太方便了，各种niubi闪闪的技能点也在写算法的过程中逐渐被挖掘到，感谢万能的谷哥度娘SOF以及各大博客网站，在这里整理一二。<br><a id="more"></a><br><strong>几句废话：</strong></p>
<blockquote>
<p>因为我是懒癌晚期，最不喜欢在文章里发图片，因为Mweb写作或者是马克飞象写作，可以直接拖图进来，但是上传博客的话，就需要考虑是使用服务器上的媒体库，还是放七牛，放七牛上还得用它的命令行工具，或者是Web端操作，想想都好麻烦。所以，本地一直存放着几篇写完的文章楞是没有上传（一篇探索红黑树，一篇是设计模式C++版半完全指南，一篇是Linux的小文章），就是因为往里边塞了太多图片的原因。所以以后写文，尽量控制图片 &lt;= 3。</p>
</blockquote>
<p>下面进入密集式正题，过于炫技的部分被我去掉了，因为我看过之后只是碎了膝盖，然而并不常用。因为自己很少做整理，现在知道整理的强大之处了，所以以后也会注意相关知识的整理。以下方法的适用场景我也就不用多说了，因为都是最最常见的场景：</p>
<h2 id="1-_拆箱（这个方法比较常见，非常高效）">1. 拆箱（这个方法比较常见，非常高效）</h2>
<p>变量声明利用拆箱这种方式，非常高效，这也算是Python 里最常用的技巧了，也是我最开始使用 Python 时感觉非常惊奇的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = (<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, (b, c), d = [<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c, d</div><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></div></pre></td></tr></table></figure>

<p>拆箱也可用于变量交换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>, <span class="number">2</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b = b, a</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b</div><div class="line">(<span class="number">2</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>

<h2 id="2-_指定步长的切割">2. 指定步长的切割</h2>
<p>刚开始接触Python 的时候，被Python 深拷贝的方式逗乐了，写Python 你可以利用想象力写代码。深拷贝利用的就是这个指定步长的切割。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line"><span class="comment"># 下边这个实现深拷贝</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> a[::<span class="number">1</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line"><span class="comment"># 逆序拷贝</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> a[::-<span class="number">1</span>]</div><div class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</div><div class="line"><span class="comment"># 你还可以给切割的部分赋值，也可以借此插入数组</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">0</span>, <span class="number">0</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="comment"># 还有命名列表切割方式</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>last_three = slice(-<span class="number">3</span>, <span class="keyword">None</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>last_three</div><div class="line">slice(-<span class="number">3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[last_three]</div><div class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>

<h2 id="3-_压缩器zip">3. 压缩器zip</h2>
<p>zip 这个也是靠想象力实现各种各样的功能。</p>
<ol>
<li>列表 or 迭代器的压缩与解压缩</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>z = zip(a, b)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>z</div><div class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(*z)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)]</div></pre></td></tr></table></figure>

<ol>
<li>列表相邻元素压缩器</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(*([iter(a)] * <span class="number">2</span>))</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*([iter(a)] * k))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</div><div class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(a[::<span class="number">2</span>], a[<span class="number">1</span>::<span class="number">2</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(a[::<span class="number">3</span>], a[<span class="number">1</span>::<span class="number">3</span>], a[<span class="number">2</span>::<span class="number">3</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*(a[i::k] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</div><div class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</div></pre></td></tr></table></figure>


<ol>
<li>用压缩器翻转字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m.items()</div><div class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(m.values(), m.keys())</div><div class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'d'</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>mi = dict(zip(m.values(), m.keys()))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>mi</div><div class="line">{<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>}</div></pre></td></tr></table></figure>

<h2 id="4-_列表展开">4. 列表展开</h2>
<p>列表展开的方式五花八门，动用大脑可以创造各种各样的方法，最便于理解的是以下两种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(a, [])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>

<h2 id="5-_生成器表达式">5. 生成器表达式</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>g = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</div><div class="line"><span class="number">2025</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">1</span>)</div><div class="line"><span class="number">408</span></div></pre></td></tr></table></figure>

<h2 id="6-_字典推导和集合推导">6. 字典推导和集合推导</h2>
<p>一上来我打成了推倒是什么心理，相信在平时推导过列表，他还有更多的应用方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这个是最常见的推导</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list2 = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> list1]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list2</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="comment"># 我们可以用语法来创建集合和字典表，开开脑洞</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = { x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> }</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</div><div class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</div><div class="line"><span class="comment"># 其实，我们有更简单的方式创建一个集合：</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>setlist = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>setlist</div><div class="line">set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"><span class="comment"># 创建字典表</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>d = { x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) }</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>d</div><div class="line">{<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>}</div><div class="line"><span class="comment"># 利用这个脑洞，你还可以用字典推导翻转字典</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m</div><div class="line">{<span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>{v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items()}</div><div class="line">{<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>}</div></pre></td></tr></table></figure>

<p>另外，刚刚提到了，直接省略set 方式的创建集合，它还有一些在这基础之上更犀利的应用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B</div><div class="line">set([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A | B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A & B</div><div class="line">set([<span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A - B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B - A</div><div class="line">set([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A ^ B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>(A ^ B) == ((A - B) | (B - A))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>

<h2 id="7-_Counter_计数器">7. Counter 计数器</h2>
<p>对于我们来说，数一个东西，是非常常用的，然而这件事又不是程序员喜欢做的事情，我们用 counter 来完成这个操作。他在我们python 内置的库里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c = Counter(<span class="string">'hello world'</span>)</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c</div><div class="line">Counter({<span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>})</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c.most_common(<span class="number">2</span>)</div><div class="line">[(<span class="string">'l'</span>, <span class="number">3</span>), (<span class="string">'o'</span>, <span class="number">2</span>)]</div></pre></td></tr></table></figure>

<h2 id="8-_双端队列">8. 双端队列</h2>
<p>我们都知道，队列和栈实际上就是对在双端队列的基础上实现的，python可以直接操作双端队列。当然也在内置的库 collections 里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q = collections.deque()</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.append(<span class="number">1</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.appendleft(<span class="number">2</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.extend([<span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.extendleft([<span class="number">5</span>, <span class="number">6</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.pop()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.popleft()</div><div class="line"><span class="number">6</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.rotate(<span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.rotate(-<span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure>

<p>同时，我们还可以在括号里添加 maxlen 来限制双端队列的最大长度。<code>last_three = collections.deque(maxlen=3)</code></p>
<h2 id="9-_默认词典">9. 默认词典</h2>
<p>一般情况下，空词典它就是空的，但是我们利用 collections 里的函数，可以实现默认的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = dict()</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">KeyError: <span class="string">'a'</span></div><div class="line"><span class="comment"># 你可以在括号里添加各种条件</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(int)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(str)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="string">''</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>] += <span class="string">'a'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="keyword">lambda</span>: <span class="string">'[default value]'</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="string">'[default value]'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="string">'[default value]'</span></div></pre></td></tr></table></figure>

<h2 id="10-_利用json库打印出漂亮的JSON串">10. 利用json库打印出漂亮的JSON串</h2>
<p>这个方法就是为了让让人面对眼花缭乱的JSON串，能够打印出一个漂亮的可读的格式，对于在控制台交互编程，或者是做日志是，还是非常有用的。另外，也可以注意一下pprint 这个模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">data = {<span class="string">"status"</span>: <span class="string">"OK"</span>, <span class="string">"count"</span>: <span class="number">2</span>, <span class="string">"results"</span>: [{<span class="string">"age"</span>: <span class="number">27</span>, <span class="string">"name"</span>: <span class="string">"Oz"</span>, <span class="string">"lactose_intolerant"</span>: true}, {<span class="string">"age"</span>: <span class="number">29</span>, <span class="string">"name"</span>: <span class="string">"Joe"</span>, <span class="string">"lactose_intolerant"</span>: false}]}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>print(json.dumps(data))  <span class="comment"># No indention</span></div><div class="line">{<span class="string">"status"</span>: <span class="string">"OK"</span>, <span class="string">"count"</span>: <span class="number">2</span>, <span class="string">"results"</span>: [{<span class="string">"age"</span>: <span class="number">27</span>, <span class="string">"name"</span>: <span class="string">"Oz"</span>, <span class="string">"lactose_intolerant"</span>: true}, {<span class="string">"age"</span>: <span class="number">29</span>, <span class="string">"name"</span>: <span class="string">"Joe"</span>, <span class="string">"lactose_intolerant"</span>: false}]}</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">2</span>)) {</div><div class="line">  <span class="string">"status"</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="string">"count"</span>: <span class="number">2</span>,</div><div class="line">  <span class="string">"results"</span>: [</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="string">"age"</span>: <span class="number">27</span>,</div><div class="line">      <span class="string">"name"</span>: <span class="string">"Oz"</span>,</div><div class="line"></div><div class="line">      <span class="string">"lactose_intolerant"</span>: true</div><div class="line">    },</div><div class="line">    {</div><div class="line">      <span class="string">"age"</span>: <span class="number">29</span>,</div><div class="line"></div><div class="line">      <span class="string">"name"</span>: <span class="string">"Joe"</span>,</div><div class="line">      <span class="string">"lactose_intolerant"</span>: false</div><div class="line">    }</div><div class="line">  ]</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="11-_最大和最小的几个列表元素">11. 最大和最小的几个列表元素</h2>
<p>这个经常用到啊，少年们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random, heapq</div><div class="line">a = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">100</span>)]</div><div class="line">b = heapq.nsmallest(<span class="number">5</span>, a)</div><div class="line">c = heapq.nlargest(<span class="number">5</span>, a)</div><div class="line"><span class="keyword">print</span> b,c</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>]</div></pre></td></tr></table></figure>

<h2 id="12-_一些更贴近大脑的写法，和一些掉了下巴的代码段">12. 一些更贴近大脑的写法，和一些掉了下巴的代码段</h2>
<p>有一些语句，写出来你就能读懂，就像读一篇文章一样。有时候，其他语言用了超长的代码写出来的程序，python只需要几行，甚至是，1行。</p>
<ol>
<li>数值比较</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">2</span></div><div class="line"><span class="keyword">if</span> <span class="number">3</span> &gt; x &gt; <span class="number">1</span>:</div><div class="line">   <span class="keyword">print</span> x</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span></div><div class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; x &gt; <span class="number">0</span>:</div><div class="line">   <span class="keyword">print</span> x</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span></div></pre></td></tr></table></figure>

<ol>
<li>有这么一个算法题，打印数字1到100，3的倍数打印“Fizz”来替换这个数，5的倍数打印“Buzz”，对于既是3的倍数又是5的倍数的数字打印“FizzBuzz”。对此，我们只使用一行代码，搞定它.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):<span class="keyword">print</span><span class="string">"fizz"</span>[x % <span class="number">3</span>*<span class="number">4</span>::]+<span class="string">"buzz"</span>[x % <span class="number">5</span>*<span class="number">4</span>::]<span class="keyword">or</span> x</div></pre></td></tr></table></figure>

<h2 id="13-_一个超小型的Web服务">13. 一个超小型的Web服务</h2>
<p>我们在两台机器或者服务器之间做一些简单的基础的RPC之类的交互，我们就可以用到python 这个神奇的模块。<br>服务器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_reader</span><span class="params">(file_name)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">return</span> f.read()</div><div class="line"></div><div class="line">server = SimpleXMLRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>))</div><div class="line">server.register_introspection_functions()</div><div class="line"></div><div class="line">server.register_function(file_reader)</div><div class="line"></div><div class="line">server.serve_forever()</div></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xmlrpclib</div><div class="line">proxy = xmlrpclib.ServerProxy(<span class="string">'http://localhost:8000/'</span>)</div><div class="line"></div><div class="line">proxy.file_reader(<span class="string">'/tmp/secret.txt'</span>)</div></pre></td></tr></table></figure>

<p>这样就得到了一个远程文件读取工具，超小型，没有外部依赖，当然没有任何安全可言，仅作家里使用，当然我现在还没用过这个。</p>
<hr>
<p>人生苦短，我用Python。</p>
<p>ps. 似乎不说一句这个名言，就不像是在写Python一样。当然了，我还是要滚回去好好地学C++。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Python_高效编程小技巧">Python 高效编程小技巧</h1>
<p>Python 一直被我拿来写算法题，小程序，因为他使用起来太方便了，各种niubi闪闪的技能点也在写算法的过程中逐渐被挖掘到，感谢万能的谷哥度娘SOF以及各大博客网站，在这里整理一二。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里云上CentOS的图形访问]]></title>
    <link href="http://yoursite.com/2015/10/11/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8ACentOS%E7%9A%84%E5%9B%BE%E5%BD%A2%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2015/10/11/阿里云上CentOS的图形访问/</id>
    <published>2015-10-11T08:14:49.000Z</published>
    <updated>2015-10-11T08:33:47.000Z</updated>
    <content type="html"><![CDATA[<p>因为阿里云给学生白菜价格购买ECS，那我就买来玩玩，顺便用来学习Linux/UNIX。买回来之后，发现闲着也是闲着，就现在上边搭了个博客，用 WordPress。因为WordPress这个建站很厉害，但是以前在自己的电脑上，不想为了玩一下wordpress 配置一堆东西，把电脑搞乱了，所以一直用的 Hexo这个用node.js写的轻量博客系统，挂在Github上。<br><a id="more"></a><br>这个新的博客先放在二级域名上 new.xuelinf.cc ，不过阿里云上建站要备案，目前还在备案中（备案是一个坑坑的过程），想要访问还是用IP访问吧 ：）。目前想法是吧这个网站做成一个小小的圈子，放一些干货，文章之类的东西上去。<a href="http://115.28.190.231" target="_blank" rel="external">地址在这里</a></p>
<p>WordPress 现在这个系统真的是太大了，传说全球百分之二十多的网站都是使用WordPress搭建的，也就是每进入四个网站，就有一个是用WP做的，当然了，不同水平有不同的效果，有闲功夫我也会做几个WP的小插件或者主题玩玩。</p>
<p>回到正题，搭完WordPress之后，无聊之余，我就想建立图形访问，像远程登陆一样登陆CentOS，这样有时候学习Linux的话，更直观一些了。在阿里云文档的帮助下，解决了问题。下面是步骤：</p>
<hr>
<p>首先查看一下自己的centos的版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> /etc/redhat-release</div></pre></td></tr></table></figure>

<p>检查版本之后，导入CentOS 6 的证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">#rpm</span> <span class="subst">--</span><span class="keyword">import</span> http:<span class="comment">//mirrors.163.com/centos/RPM-GPG-KEY-CentOS-6</span></div></pre></td></tr></table></figure>

<p>为了让下载速度快一些，所以选用网易的源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#cd /etc/yum.repos.d/</span></div><div class="line"><span class="preprocessor">#wget http://mirrors.163.com/.help/CentOS-Base-163.repo</span></div></pre></td></tr></table></figure>

<p>所有mirrorlist前面加上#，把所有$releasever替换成6，保存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="array">#sed </span>-i <span class="string">'/mirrorlist/d'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'/\[addons\]/,/^$/d'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'s/\$releasever/6/'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'s/RPM-GPG-KEY-CentOS-5/RPM-GPG-KEY-CentOS-6/'</span> CentOS-Base-<span class="number">163.</span>repo</div></pre></td></tr></table></figure>

<p>完成后，清理并重新生成yum缓存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#yum clean metadata</span></div><div class="line"><span class="preprocessor">#yum makecache</span></div></pre></td></tr></table></figure>

<p>因为想要远程图形访问，那么就首先要让CentOS有一个图形界面，下面就是安装 gnome 的图形界面了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"X Window System"</span></div><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"Desktop"</span></div><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"Chinese Support"</span></div></pre></td></tr></table></figure>

<p>系统有了图形界面之后，就是安装和配置VNCserver了<br>首先看一下你有没有已经安装了vncserver</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -<span class="keyword">qa</span> |<span class="keyword">grep</span> vnc</div></pre></td></tr></table></figure>

<p>如果显示了<code>tigervnc-server-1.0.90-0.17.20110314svn4359.el6.x86_64</code>类似的一条，那么久已经安装过了，就不需要再安装了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#yum <span class="operator"><span class="keyword">install</span> -y tigervnc-<span class="keyword">server</span></span></div></pre></td></tr></table></figure>

<p>如果想设置为开机启动，那么可以<code>#chkconfig --level 345 vncserver on</code></p>
<p>配置vnc密码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#vncserver</span></div><div class="line">You will <span class="built_in">require</span> <span class="operator">a</span> password <span class="built_in">to</span> access your desktop.</div><div class="line">Password:</div><div class="line">Verify:</div></pre></td></tr></table></figure>

<p>将桌面配置为使用gnome桌面，修改 /root/.vnc/xstartup文件，把最后的 twm &amp; 删掉 加上 gnome-session &amp;。<br>配置VNCserver 启动监听端口和环境参数<br>修改/etc/sysconfig/vncservers 文件添加以下内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">VNCSERVERS</span>=<span class="string">"1:root"</span></div><div class="line"># 桌面号:用户    监听 <span class="number">590</span>* 端口</div><div class="line"><span class="constant">VNCSERVERARGS[1]</span>=<span class="string">"-geometry 1200x800"</span></div></pre></td></tr></table></figure>

<p>配置完成后，就是需要允许我们的root用户访问图形界面了，同时生成一个新的machine-id</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#sed -i 's/.*!= root.*/#&/' /etc/pam.d/gdm </span></div><div class="line"><span class="preprocessor">#dbus-uuidgen &gt;/var/lib/dbus/machine-id</span></div></pre></td></tr></table></figure>

<p>同时，一不做二不休，我把防火墙都关掉了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># service iptables stop </span></div><div class="line"><span class="preprocessor"># chkconfig iptables off</span></div></pre></td></tr></table></figure>

<p>然后在你的主机上下载<a href="http://www.realvnc.com/download/viewer/" target="_blank" rel="external">VNC Viewer</a>，这个软件支持我所能想到的所有设备了，连手机端也有。下载之后运行，host填入<code>address:1</code>，输入密码就可以远程访问了。</p>
<p><img src="http://i2.wp.com/upload-images.jianshu.io/upload_images/30117-4a0ebd4f135228eb.png?w=690" alt="pc_vncview"></p>
<p><img src="http://i0.wp.com/upload-images.jianshu.io/upload_images/30117-e3429711db2fc233.jpg?w=690" alt="ios_vncview"><br>当然，平时我也不能老开着这个VNCserver , 虽说阿里云上不开白不开。输入<code>vncserver -kill :2</code> 就行了。</p>
<p>感谢<a href="http://help.aliyun.com/knowledge_detail.htm?knowledgeId=5974462" target="_blank" rel="external">阿里云的帮助</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为阿里云给学生白菜价格购买ECS，那我就买来玩玩，顺便用来学习Linux/UNIX。买回来之后，发现闲着也是闲着，就现在上边搭了个博客，用 WordPress。因为WordPress这个建站很厉害，但是以前在自己的电脑上，不想为了玩一下wordpress 配置一堆东西，把电脑搞乱了，所以一直用的 Hexo这个用node.js写的轻量博客系统，挂在Github上。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《C陷阱与缺陷》笔记]]></title>
    <link href="http://yoursite.com/2015/10/08/%E3%80%8AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/10/08/《C陷阱与缺陷》笔记/</id>
    <published>2015-10-08T14:27:37.000Z</published>
    <updated>2015-10-08T14:45:50.000Z</updated>
    <content type="html"><![CDATA[<p>这本书超薄，但含金量很高，里边一些常见的陷阱也是面试的时留的坑，适合没事翻一翻，指不定什么时候还有意外惊喜。<br><a id="more"></a></p>
<h2 id="词法陷阱">词法陷阱</h2>
<p><strong>词法分析中的『贪心法』</strong>：<br>编译器将程序分解成符号的方法是,从左到右一个字符一个字符地读入,如果该字符可能组成一个符号,那么再读入下一个字符,判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分;如果可能,继续读入下一个字符,重复上述判断,直到读入的字符组成的字符串已不再可能组成一个有意义的符号。<br>比如：<code>y = x/*p</code>与<code>y = x / *p</code>一个将<code>/*</code> 理解为注释的开始，一个理解为指针。</p>
<p><strong>双引号与单引号</strong>：<br>也就是字符与字符串的区别，在C语言里，单引号引起的一个字符实际上代表的是一个张数，与ASCII严格对应。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针，该数组被双引号之间的字符以及一个额外的二进制值为0的字符<code>\0</code> 初始化。</p>
<h2 id="语法陷阱">语法陷阱</h2>
<p><strong><code>（*(void(*)())0）()</code>所代表的含义</strong><br>实际上一层一层看即可，<code>void(*)()</code>是一个函数指针,该函数返回<code>void</code>型数据<br><em>`(void(</em>)())0<code>*就是将常数0转换为指向返回值为</code>void<code>的函数的指针
而</code>(<em>(void(</em>)())0)();<code>就是一个表达式,调用</code>0`地址的函数</p>
<p>而它的等价表达式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef void (<span class="keyword">*</span>funcptr)();</div><div class="line">(<span class="keyword">*</span>(funcptr)0)();</div></pre></td></tr></table></figure>

<p><strong>运算符优先级问题</strong>：<br>这类问题例子很多，比如 <code>if (A &amp; B != 0)</code> 其中的<code>&amp;</code>优先级更低，所以先执行 非等判断，再进行与操作。所以解决这类问题的方式，就是在不知道优先级的情况下，加上括号就好了。记住几点：</p>
<ul>
<li>任何一个逻辑运算符的优先级低于任何一个关系运算符</li>
<li>移位运算符的优先级比算术运算符要低，但是比关系运算符要高</li>
<li>所有的赋值运算符的优先级是一样的，他们的结合方式是从右到左，所以<code>home = visitor = 0</code> 是从右往左赋值的。</li>
</ul>
<p><strong>几个小陷阱注意</strong></p>
<ul>
<li>分号，有时候不会引起编译错误，但是结果千差万别。</li>
<li><code>switch</code> 语句中每一个case 不要忘记<code>break</code>， 否则顺序执行。</li>
<li><code>else</code> 始终与同一对括号内最近的未匹配的if结合。</li>
</ul>
<h2 id="语义陷阱">语义陷阱</h2>
<p><strong>非数组的指针</strong>：<br>下面这个方法想要合并s， t两个字符串，变成一个单字符串r，但是这种方法是行不通的，因为不能确定r指向了何处。不仅要让<code>r</code> 指向一个地址，还应该有内存空间可供容纳字符串。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="value">char</span> *r;</div><div class="line"><span class="function">strcpy</span>(r, s);</div><div class="line"><span class="function">strcat</span>(r, t);</div></pre></td></tr></table></figure>

<p>在这里引入一个库函数<code>malloc</code> 实现这个操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *r, *<span class="built_in">malloc</span>();</div><div class="line">r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t));</div><div class="line"><span class="built_in">strcpy</span>(r, s);</div><div class="line"><span class="built_in">strcat</span>(r, t);</div></pre></td></tr></table></figure>

<p>但是这样仍然是不对的，原因有三个。</p>
<ul>
<li>malloc 函数可能无法提供请求的内存，这种情况下malloc 函数会返回一个空指针作为内存分配失败的信号。</li>
<li>r 分配的内存在使用结束后，应当立即释放。</li>
<li>长度是不够的，因为字符串最后一位空字符没有算在内，需要 +1。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *r, *<span class="built_in">malloc</span>();</div><div class="line">r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t) + <span class="number">1</span>)；</div><div class="line"><span class="keyword">if</span>(!r){</div><div class="line">	complain();</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">}</div><div class="line"><span class="built_in">strcpy</span>(r, s);</div><div class="line"><span class="built_in">strcat</span>(r, t);</div><div class="line"><span class="comment">//一段时间以后</span></div><div class="line"><span class="built_in">free</span>(r);</div></pre></td></tr></table></figure>

<p>（所以说，c简直就是个坑，入大Python教）</p>
<p><strong>空指针</strong><br>编译器保证由<code>0</code> 转化而来的指针不等于任何有效的指针，通常被<code>null</code> 这个值代替，所以任何企图使用该指针所指向的内存中存储的内容的行为都是非法的。</p>
<p><strong>求值顺序</strong>：<br>C语言中只有四个运算符<code>(&amp;&amp; ,  || ,  ?: , ,)</code>存在规定的求值顺序.运算符<code>&amp;&amp;</code>和运算符<code>||</code>首先对左侧操作数求值,只在需要时才对右侧操作数求值.运算符<code>?:</code>有3个操作数:在<code>a?b:c</code>中,操作数a首先被求值,根据<code>a</code>的值再求操作数<code>b</code>或<code>c</code>的值.而逗号运算符<code>,</code>首先对左侧操作数求值,然后该值被”丢弃”,再对右侧操作数求值.其他所有运算符对其操作数求值的顺序都是未定义的.特别的,赋值运算符并不保证任何求值顺序.</p>
<h2 id="连接">连接</h2>
<p>这部分是C语言的特性，所以就直接粗略的看了一下跳过去。<br><strong>static 修饰符与命名冲突</strong>：他是一个能有效减少命名冲突的方式，<code>static int a;</code> 之后，a 的作用域限制在了一个源文件里，其他文件是不可见的。<code>static</code> 同样适用于函数。</p>
<h2 id="库函数">库函数</h2>
<p>作者刁刁的，写这本书的时候，ANSI C 标准还没有最后定案。所以书中考虑了很多现在不需要考虑的问题，比如兼容各种风格，兼容K&amp;R 风格的函数定义形式。<br><strong><code>getchar（）</code>函数</strong>：<br>getchar()函数读取的字符，如何直接赋值给一个<code>char</code>型的 <code>c</code> ，就会出现问题。因为c无法容下所有可能的字符，特别是，可能无法容下读文件结束时候的<code>EOF</code>，这样就会出现问题，如果getchar()读入的字符无法存入<code>char c</code>中去，那么就会『截断』，结果可能正确，但是这样做是不对的。</p>
<p><strong>更新文件顺序</strong>：<br>一个输入操作不能随后直接紧跟一个输出操作，输入fread和输出fwrite同时操作，需在其中插入fseek函数的调用，之后文件就可以正常的读取或写入了。</p>
<p><strong>缓冲输出</strong>：<code>setbuf(stdout, buf)</code>  将写入刀stdout 的输出都使用buf 作为输出缓冲区，知道buf 缓冲区已满，或者是直接调用 <code>fflush</code> buf 缓冲区的内容才会实际写入stdout中去。</p>
<p><strong>errno 检测错误</strong>： 在库函数调用没有失败的情况下，并没有强制要求库函数一定要设置<code>errno</code> 为0，也可能是上一个执行失败的库函数设置的值。甚至在函数看似正确执行的情况下，也会将<code>errno</code> 设置一个值，所以用 <code>if(errno)</code> 来处理这个错误的方式是不可以的，我们可以用 <code>if (返回错误的值) 检查 errno</code> 这种方式，也就是我们检测作为错误指示的返回值，确定程序执行已经失败，再检查errno，来搞清楚错误原因。</p>
<p><strong> signal </strong>：信号这个函数非常的复杂，因为在其他的库函数中，可能已经有信号在执行过程中，我们再使用signal处理函数，极有可能导致数据完全崩溃。所以，信号非常的复杂和棘手，具有一些从本质上不可移植的特性，所以要让<code>signal</code>处理函数尽可能的简单。</p>
<h2 id="预处理器">预处理器</h2>
<p>C语言里的宏，和C++中的泛型模板，在精神上有相仿之处，也有人用C 的宏实现通用容器。众多C++书籍都告诉我们，宏是万恶之首，所以没达到得心应手的时候，所以这一块，当做了解来看。</p>
<p><strong>不要忽视宏定义中的空格</strong>：注意这里说的是<strong>宏定义</strong>。一个宏如果不带参数，则只需要调用宏名即可，括号无关紧要，所以宏定义后边的空格可能就会引起下面的麻烦。<br><code>#define f (x) ((x)-1)</code><br>f代表(x) ((x)-1),而不是f(x)代表((x)-1),后者应写为<br><code>#define f(x) ((x)-1)</code><br>这一规则不适用于宏调用,只对宏定义适用.因此上面完成宏定义后,f(3)与f (3)求值后都等于2.</p>
<p><strong>宏不是函数</strong>：最好在宏定义中把每个参数都用括号括起来，整个结果表达式也用括号括起来，防止当宏用于一个更大一些的表达式中可能出现的问题。<br><strong>宏不是语句</strong>：assert(e)的正确定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define <span class="keyword">assert</span>(e) /</div><div class="line">             ((<span class="keyword">void</span>)((e) || _assert_error(<span class="keyword">__FILE__</span>,<span class="keyword">__LINE__</span>)))</div></pre></td></tr></table></figure>

<p>这个定义实际上利用了||运算符对两侧的操作数依次顺序求值的性质.<br><strong>宏不是类型定义</strong>：<br>宏的一个常见用途是，让多个不同变量的类型可以在一个地方说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define FOOTYPE struct foo</span></div><div class="line"><span class="title">FOOTYPE</span> a;</div><div class="line"><span class="title">FOOTYPE</span> b,c;</div></pre></td></tr></table></figure>

<p>这样，我们只需要在程序中改动一行代码，就可以改变a, b, c 的类型了，而与a, b, c 在程序中的什么地方声明无关。这与<code>typedef</code> 的方式相同，但是后者更通用一些。而宏的方式某些时候，可能存在一些问题。</p>
<h2 id="可移植性缺陷">可移植性缺陷</h2>
<p>作者大牛在这里超前讨论了C语言在移植的时候小心的一些坑和缺陷。</p>
<ul>
<li><strong>标示符名称的限制</strong></li>
<li><strong>整数的大小</strong>：因为无法保证short型，int型，long型在不同语言中的长度，所以考虑到可移植性，也许最好的方式是使用long型，也可以自己定义一个新的类型。</li>
<li><strong>字符是有符号整数还是无符号整数</strong>：在char 类型转化刀较大的整数int类型时，做有符号处理还是无符号处理，影响是巨大的。而如果使用<code>（unsigned）c</code> 同样会带来问题，因为将字符转换为无符号的整数时，首先会被转换为int型整数，同样达不到预期效果，较好的解决方法是使用语句<code>（unsigned char）c</code> ，一个<code>unsigned char</code>类型的字符在转换为无符号整数类型的时候，无需首先转换为int型。</li>
<li><strong>移位运算符</strong>：<ul>
<li>向右移位时,空出的位是由0填充,还是由符号位的副本填充?<br>  如果被移位的对象是无符号数,那么空出的位将被0填充.如果被移位的是有符号数,那么C语言实现既可以用0填充空出的位,也可以用符号位的副本填充空出的位.</li>
<li>移位计数(即移位操作的位数)允许的取值范围是什么?<br>  如果被移位的对象长度是n位,那么移位计数必须大于或等于0,而严格小于n.</li>
<li>另外，不要用除法代替有符号的整数的移位运算，例如<code>（-1）&gt;&gt;1</code></li>
</ul>
</li>
<li>null 指针不知现任和对象，除非用于赋值和比较运算，其他用法都是非法的。</li>
<li><strong>除法运算</strong>：大多数编译器要求余数与被除数的正负号相同.</li>
<li><strong>随机数的大小</strong></li>
<li><strong>大小写的转换</strong>： C语言有两种处理大小写转换的方式，一种是直接利用ASCII码转换，但是当输入的字母大小写不对的时候，就会返回一些奇异的值，另一种则进行了一个判断操作，但是这样增加了开销，所以根据效率自行选择，在移植的时候，应当注意这个问题。</li>
<li><code>malloc</code>, <code>realloc</code> , <code>free</code> </li>
</ul>
<h2 id="建议">建议</h2>
<p>最后作者提出了几个建议，说的挺有意思。比如作者推荐我们在编程的时候，一定要尽可能的清晰表达意图，该用括号的时候，都尽量用括号，以防不该有的错误出现。同时要考察一些最简单的特例，测试程序的工作情况。一定要注意一些边界问题，比如数组的下标。以及一些潜伏在暗处的Bug。</p>
<p>最后作者提出了防御性编程，其实就是在说，啊，C语言有很多很多的坑，我们不知道什么时候就会踩到了坑，所以再变成的时候，一定要采用最稳妥的方式编程，意思就是一定要走那些被证明是康庄大道的平坦的道路呀，少年，不然你就要被坑惨了~~</p>
<p>以上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书超薄，但含金量很高，里边一些常见的陷阱也是面试的时留的坑，适合没事翻一翻，指不定什么时候还有意外惊喜。<br>]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web开发规范]]></title>
    <link href="http://yoursite.com/2015/10/06/Web%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2015/10/06/Web开发规范/</id>
    <published>2015-10-06T12:12:43.000Z</published>
    <updated>2015-10-06T12:17:30.000Z</updated>
    <content type="html"><![CDATA[<p>from: <a href="">Github</a></p>
<h2 id="通用规范">通用规范</h2>
<ul>
<li>使用空格代替TAB，windows和Linux的Tab占位不同。</li>
<li>CSS样式属性和 JavaScript代码后边添加分号<code>;</code> ，方便断句，利于压缩。</li>
<li>文件内容编码均统一为UTF-8。</li>
<li>CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。</li>
</ul>
<h2 id="文件规范">文件规范</h2>
<ul>
<li>文件名用英文单词，多个单词用驼峰命名法。</li>
<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。<code>ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao</code><br><a id="more"></a><h2 id="HTML书写规范">HTML书写规范</h2>
</li>
<li>为每个HTML页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>文档类型声明统一为HTML5声明类型，编码统一为UTF-8。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li><code>&lt;HEAD&gt;</code>中添加信息。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"author"</span> <span class="variable">content=</span><span class="string">"smile@kang.cool"</span>&gt;//作者</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"description"</span> <span class="variable">content=</span><span class="string">"hello"</span>&gt;//网页描述</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"keywords"</span> <span class="variable">content=</span><span class="string">"a,b,c"</span>&gt;//关键字,“，”分隔</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"expires"</span> <span class="variable">content=</span><span class="string">"Wed, 26 Feb 1997 08：21：57 GMT"</span>&gt;//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Pragma"</span> <span class="variable">content=</span><span class="string">"no-cache"</span>&gt;//禁止浏览器从本地机的缓存中调阅页面内容</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Window-target"</span> <span class="variable">content=</span><span class="string">"_top"</span>&gt;//用来防止别人在框架里调用你的页面</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Refresh"</span> <span class="variable">content=</span><span class="string">"5;URL=http://kahn1990.com/"</span>&gt;//跳转页面，<span class="number">5</span>指时间停留<span class="number">5</span>秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"robots"</span> <span class="variable">content=</span><span class="string">"none"</span>&gt;//content的参数有all,none,index,noindex,follow,nofollow，默认是all</div><div class="line">&lt;link <span class="variable">rel=</span><span class="string">"Shortcut Icon"</span> <span class="variable">href=</span><span class="string">"favicon.ico"</span>&gt;//收藏图标</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Cache-Control"</span> <span class="variable">content=</span><span class="string">"no-cache, must-revalidate"</span>&gt;//网页不会被缓存</div></pre></td></tr></table></figure>

<ul>
<li>IE支持通过特定<meta>标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为edge mode ，从而通知IE采用其所支持的最新的模式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta <span class="variable">http-equiv=</span><span class="string">"X-UA-Compatible"</span> <span class="variable">content=</span><span class="string">"IE=Edge"</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li><p>非特殊情况下CSS样式文件外链至HEAD之间，JAVASCRIPT文件外链至页面底部。引入JAVASCRIPT库文件，文件名须包含库名称及版本号及是否为压缩版。引入JAVASCRIPT插件, 文件名格式为库名称+.+插件名称。<code>jQuery.cookie.js</code></p>
</li>
<li><p>HTML属性应当按照以下给出的顺序依次排列，来确保代码的易读性。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span></div><div class="line">id 、 name</div><div class="line">data-*</div><div class="line">src、<span class="keyword">for</span>、 <span class="class"><span class="keyword">type</span>、 <span class="title">href</span></span></div><div class="line">title、alt</div><div class="line">aria-*、 role</div></pre></td></tr></table></figure>

<ul>
<li>编码均遵循XHTML标准，标签、属性、属性命名由小写英文、数字和_组成，且所有标签必须闭合，属性值必须用双引号””，避免使用中文拼音尽量简易并要求语义化。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CLASS <span class="comment">--&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）</span></div><div class="line">ID <span class="comment">--&gt; n_head_title --&gt; ID遵循名称+_</span></div><div class="line">NAME <span class="comment">--&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_</span></div><div class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"nHeadTitle"</span> <span class="property">id</span>=<span class="string">"n_head_title"</span> <span class="property">name</span>=<span class="string">"N_Head_Title"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li>当JAVASCRIPT获取单个元素时，通常使用<code>document.getElementById</code>来获取dom元素，<code>document.getElementById</code>兼容所有浏览器，<strong>但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"test"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"alert(document.getElementById('test').tagName)"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- ie6下为INPUT --&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>特殊符号应使用转意符。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;    <span class="literal">-</span><span class="literal">-</span>&gt;    <span class="comment">&lt;</span></div><div class="line">&gt;    <span class="literal">-</span><span class="literal">-</span>&gt;    <span class="comment">&gt;</span></div><div class="line"><span class="comment">空格</span>  <span class="literal">-</span><span class="literal">-</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li>含有描述性表单元素（INPUT，TEXTAREA）添加LABEL。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"test"</span>&gt;</span>测试<span class="tag">&lt;/<span class="title">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"test"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>多用无兼容性问题的HTML内置标签，比如SPAN、EM、STRONG、OPTGROUP、LABEL等,需要自定义HTML标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有，可使用须以“data-”为前缀来添加自定义属性，避免使用其他命名方式。</li>
<li>语义化HTML。</li>
<li>尽可能减少<code>&lt;DIV&gt;</code>嵌套。</li>
<li>书写链接地址时避免重定向。<br><code>href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/”</code></li>
</ul>
<h1 id="Web开发规范（二）">Web开发规范（二）</h1>
<p>@(总结)</p>
<h2 id="CSS书写规范">CSS书写规范</h2>
<p>-为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合<code>W3C</code>的代码写到一个文件中,而一些IE中必须而又不能通过<code>W3C</code>验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 放置所有浏览器样式--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">href</span>=<span class="value">""</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if IE]</span></div><div class="line">    &lt;link rel="stylesheet" href=""&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>

<ul>
<li><p>CSS样式新建或修改尽量遵循以下原则。</p>
<ul>
<li>根据新建样式的适用范围分为三级：全站级、产品级、页面级。</li>
<li>尽量通过继承和层叠重用已有样式。</li>
<li>不要轻易改动全站级CSS。改动后，要经过全面测试。</li>
</ul>
</li>
<li><p>CSS属性显示顺序。</p>
<ul>
<li>显示属性</li>
<li>元素位置</li>
<li>元素属性</li>
<li><p>元素内容属性</p>
</li>
<li><p>CSS书写顺序。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> .header {</div><div class="line"><span class="comment">/* 显示属性 */</span></div><div class="line">    display || visibility</div><div class="line">    list-style</div><div class="line">    position top || right || bottom || left</div><div class="line">    z-index</div><div class="line">    <span class="keyword">clear</span></div><div class="line">    <span class="keyword">float</span></div><div class="line"><span class="comment">/* 自身属性 */</span></div><div class="line">    width <span class="keyword">max</span>-width || <span class="keyword">min</span>-width</div><div class="line">    height <span class="keyword">max</span>-height || <span class="keyword">min</span>-height</div><div class="line">    overflow || <span class="keyword">clip</span></div><div class="line">    margin</div><div class="line">    padding</div><div class="line">    outline</div><div class="line">    border</div><div class="line">    background</div><div class="line"><span class="comment">/* 文本属性 */</span></div><div class="line">    <span class="keyword">color</span></div><div class="line">    font</div><div class="line">    <span class="keyword">text</span>-overflow</div><div class="line">    <span class="keyword">text</span>-<span class="keyword">align</span></div><div class="line">    <span class="keyword">text</span>-indent</div><div class="line">    line-height</div><div class="line">    white-space</div><div class="line">    vertical-<span class="keyword">align</span></div><div class="line">    cursor</div><div class="line">    content</div><div class="line">    };</div></pre></td></tr></table></figure>

<ul>
<li>兼容多个浏览器时，将标准属性写在底部。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">moz-border-<span class="symbol">radius:</span> <span class="number">15</span>px; <span class="regexp">/* Firefox */</span></span></div><div class="line">-<span class="ruby">webkit-border-<span class="symbol">radius:</span> <span class="number">15</span>px; <span class="regexp">/* Safari和Chrome */</span></span></div><div class="line">border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性</div></pre></td></tr></table></figure>

<ul>
<li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.hd,.bd,.td{};<span class="comment">//如这些命名</span></div></pre></td></tr></table></figure>

<p>可用上级节点进行限定。<code>.recommend-mod .hd</code></p>
<ul>
<li>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.btn,</div><div class="line">input.btn,</div><div class="line">input[<span class="keyword">type</span>=<span class="string">"button"</span>] {…};</div></pre></td></tr></table></figure>

<ul>
<li>优化CSS选择器。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="id">#header</span> <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#444</span></span></span>; <span class="rule">}</span></span>;<span class="comment">/*CSS选择器是从右边到左边进行匹配*/</span></div></pre></td></tr></table></figure>

<ul>
<li>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器</div><div class="line">不要限定id选择符，如<span class="operator">div</span><span class="comment">#header（提权的除外）</span></div><div class="line">不要限定类选择器，如ul.recommend（提权的除外）</div><div class="line">不要使用 ul li <span class="operator">a</span> 这样长的选择符</div><div class="line">避免使用标签子选择符，如<span class="comment">#header &gt; li &gt; a</span></div></pre></td></tr></table></figure>

<ul>
<li><p>使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。</p>
</li>
<li><p>尽量避免使用CSS Hack。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* 所有浏览器 */</span></div><div class="line">+<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE7 */</span></div><div class="line">_<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE6 */</span></div><div class="line">*<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE6/7 */</span></div><div class="line"><span class="tag">property</span><span class="pseudo">:value</span>\9; <span class="comment">/* IE6/7/8/9，即所有IE浏览器 */</span></div><div class="line"></div><div class="line">\* <span class="tag">html</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* IE6 */</span></div><div class="line">\*<span class="pseudo">:first-child+html</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* IE7 */</span></div><div class="line"><span class="tag">html</span>&gt;<span class="tag">body</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* 非IE6 */</span></div><div class="line"><span class="at_rule">@<span class="keyword">-moz-document</span> <span class="function">url-prefix</span>() </span>{ … }; <span class="comment">/* firefox */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio:<span class="number">0</span>) </span>{ … }; <span class="comment">/* saf3+/chrome1+ */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio:<span class="number">10000</span>),not all and (-webkit-min-device-pixel-ratio:<span class="number">0</span>) </span>{ … }; <span class="comment">/* opera */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (max-device-width: <span class="number">480px</span>) </span>{ … }; <span class="comment">/* iPhone/mobile webkit */</span></div></pre></td></tr></table></figure>

<ul>
<li>避免使用低效的选择器。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">body</span> &gt; * <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="tag">ul</span> &gt; <span class="tag">li</span> &gt; <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="id">#footer</span> &gt; <span class="tag">h3</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="tag">ul</span><span class="id">#top_blue_nav</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="id">#searbar</span> <span class="tag">span</span><span class="class">.submit</span> <span class="tag">a</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* 反面示例 */</span></div></pre></td></tr></table></figure>

<ul>
<li><p>六个不要三个避免一个使用。</p>
<ul>
<li>不要在标签上直接写样式</li>
<li>不要在CSS中使用<code>expression</code></li>
<li>不要在CSS中使用<code>@import</code></li>
<li>不要在CSS中使用<code>!important</code></li>
<li>不要在CSS中使用<code>“*”</code>选择符</li>
<li>不要将CSS样式写为单行</li>
<li>避免使用filter</li>
<li>避免使用行内<code>（inline）</code>样式</li>
<li>避免使用<code>“*”</code>设置<code>{margin: 0; padding: 0;}</code></li>
<li>使用<code>after</code>或<code>overflow</code>的方式清浮动</li>
</ul>
</li>
<li><p>减少使用影响性能的属性。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">position</span><span class="value">:absolute;</span></div><div class="line"><span class="attribute">float</span><span class="pseudo">:left</span>;<span class="comment">//如这些定位或浮动属性</span></div></pre></td></tr></table></figure>

<ul>
<li><strong>减少在CSS中使用滤镜表达式和图片repeat</strong>,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px。</li>
</ul>
<h2 id="JavaScript书写规范">JavaScript书写规范</h2>
<ul>
<li>命名规范。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">常量名</div><div class="line">    全部大写并单词间用下划线分隔</div><div class="line">    如：CSS_BTN_CLOSE、TXT_LOADING</div><div class="line">对象的属性或方法名</div><div class="line">    小驼峰式（little camel-case）</div><div class="line">    如：init、bindEvent、updatePosition</div><div class="line">    示例：Dialog.prototype = {</div><div class="line">                init: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {},</div><div class="line">                bindEvent: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {},</div><div class="line">                updatePosition: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {}</div><div class="line">                …</div><div class="line">                };</div><div class="line">类名（构造器）</div><div class="line">    <span class="comment">--&gt;小驼峰式但首字母大写</span></div><div class="line">    <span class="comment">--&gt;如：Current、DefaultConfig</span></div><div class="line">函数名</div><div class="line">    <span class="comment">--&gt;小驼峰式</span></div><div class="line">    <span class="comment">--&gt;如：current()、defaultConfig()</span></div><div class="line">变量名</div><div class="line">    <span class="comment">--&gt;小驼峰式</span></div><div class="line">    <span class="comment">--&gt;如：current、defaultConfig</span></div><div class="line">私有变量名</div><div class="line">    <span class="comment">--&gt;小驼峰式但需要用_开头</span></div><div class="line">    <span class="comment">--&gt;如：_current、_defaultConfig</span></div><div class="line">变量名的前缀</div><div class="line">    <span class="comment">--&gt;续</span></div></pre></td></tr></table></figure>

<ul>
<li>代码格式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">"()"</span>前后需要跟空格</div><div class="line"><span class="string">"="</span>前后需要跟空格</div><div class="line"><span class="string">","</span>后面需要跟空格</div><div class="line"><span class="built_in">JSON</span>对象需格式化对象参数</div><div class="line"><span class="keyword">if</span>、<span class="keyword">while</span>、<span class="keyword">for</span>、<span class="keyword">do</span>语句的执行体用<span class="string">"{}"</span>括起来</div><div class="line"><span class="keyword">if</span> (a==<span class="number">1</span>) {</div><div class="line">    <span class="comment">//代码</span></div><div class="line">};</div></pre></td></tr></table></figure>

<ul>
<li>避免额外的逗号。<code>var arr = [1,2,3,];</code></li>
<li><p><strong>for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。</strong></p>
</li>
<li><p>长语句可考虑断行。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TEMPL_SONGLIST.replace(<span class="string">'{TABLE}'</span>, da[<span class="string">'results'</span>])</div><div class="line">    .replace(<span class="string">'{PREV_NUM}'</span>, <span class="keyword">prev</span>)</div><div class="line">    .replace(<span class="string">'{NEXT_NUM}'</span>, <span class="keyword">next</span>)</div><div class="line">    .replace(<span class="string">'{CURRENT_NUM}'</span>, current)</div><div class="line">    .replace(<span class="string">'{TOTAL_NUM}'</span>, da.page_total);</div></pre></td></tr></table></figure>

<p> -为了避免和<code>JSLint</code>的检验机制冲突，“.”或“+”这类操作符放在行尾。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TEMPL_SONGLIST.replace('{TABLE}', da['results']).</div><div class="line">    <span class="operator"><span class="keyword">replace</span>(<span class="string">'{PREV_NUM}'</span>, prev).</span></div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{NEXT_NUM}'</span>, <span class="keyword">next</span>).</div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{CURRENT_NUM}'</span>, <span class="keyword">current</span>).</div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{TOTAL_NUM}'</span>, da.page_total);</div></pre></td></tr></table></figure>

<p>如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/<em>global</em>/声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/*global alert: <span class="literal">true</span>, console: <span class="literal">true</span>, top: <span class="literal">true</span>, <span class="keyword">set</span>Timeout: <span class="literal">true</span> */</div></pre></td></tr></table></figure>

<ul>
<li>使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="literal">null</span></div><div class="line"><span class="literal">undefined</span>与<span class="literal">null</span>相等</div><div class="line">字符串<span class="string">''</span></div><div class="line">数字<span class="number">0</span></div><div class="line"><span class="literal">NaN</span></div></pre></td></tr></table></figure>

<p>在==时，则会有一些让人难以理解的陷阱，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> <span class="literal">undefined</span>;</div><div class="line">    <span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></div><div class="line">    <span class="number">1</span> == <span class="literal">true</span>; <span class="comment">//true</span></div><div class="line">    <span class="number">2</span> == <span class="literal">true</span>; <span class="comment">// false</span></div><div class="line">    <span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></div><div class="line">    <span class="number">0</span> == <span class="string">''</span>; <span class="comment">// true</span></div><div class="line">    <span class="literal">NaN</span> == <span class="literal">NaN</span>;<span class="comment">// false</span></div><div class="line">    [] == <span class="literal">false</span>; <span class="comment">// true</span></div><div class="line">    [] == ![]; <span class="comment">// true</span></div><div class="line">})();</div></pre></td></tr></table></figure>

<p>对于不同类型的 == 判断，有这样一些规则，顺序自上而下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span>与<span class="literal">null</span>相等</div><div class="line">一个是<span class="built_in">number</span>一个是<span class="built_in">string</span>时，会尝试将<span class="built_in">string</span>转换为<span class="built_in">number</span></div><div class="line">尝试将<span class="built_in">boolean</span>转换为<span class="built_in">number</span></div><div class="line"><span class="number">0</span>或<span class="number">1</span></div><div class="line">尝试将<span class="built_in">Object</span>转换成<span class="built_in">number</span>或<span class="built_in">string</span></div></pre></td></tr></table></figure>

<p>而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用===。===会先判断两边的值类型，类型不匹配时为false。</p>
<ul>
<li>下面类型的对象不建议用new构造。引用对象成员用<code>obj.prop</code>代替<code>obj[“prop”]</code>，除非属性名是变量。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Object</span> <span class="comment">//用{}代替</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span> <span class="comment">//用[]代替</span></div></pre></td></tr></table></figure>

<ul>
<li>从number到string的转换。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">typeof(a); <span class="comment">//"number"</span></div><div class="line">console.log(a); <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> aa=a+'';</div><div class="line">typeof(aa); <span class="comment">//"string"</span></div><div class="line">console.log(aa); <span class="comment">//'1'</span></div><div class="line"><span class="javadoc">/** 不推荐写法*/</span></div><div class="line"><span class="keyword">new</span> String(a)或a.toString()</div></pre></td></tr></table></figure>

<p>从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line"><span class="keyword">var</span> a = '<span class="number">1</span>';</div><div class="line"><span class="keyword">var</span> aa = parseInt(a,<span class="number">10</span>);</div><div class="line">typeof(a); <span class="comment">//"string"</span></div><div class="line">console.log(a); <span class="comment">//'1'</span></div><div class="line">typeof(aa); <span class="comment">//"number"</span></div><div class="line">console.log(aa); <span class="comment">//1</span></div></pre></td></tr></table></figure>

<p>从float到integer的转换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line">Math.floor/Math.round/Math.ceil</div><div class="line"><span class="javadoc">/** 不推荐写法*/</span></div><div class="line">parseInt</div></pre></td></tr></table></figure>

<ul>
<li>字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**推荐的拼接方式array的push、join*/</span></div><div class="line">var str=[],</div><div class="line">    list=[<span class="string">'测试A'</span>,<span class="string">'测试B'</span>];</div><div class="line"><span class="keyword">for</span> (var i=<span class="number">0</span> , len=list.length; i &lt; len; i++) {</div><div class="line">    str.push( <span class="string">'&lt;div&gt;'</span>+ list[i] + <span class="string">'&lt;/div&gt;'</span>);</div><div class="line">};</div><div class="line">console.log(str.join(<span class="string">''</span>)); <span class="comment">//&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;</span></div><div class="line"><span class="javadoc">/** 不推荐的拼接方式+=*/</span></div><div class="line">var str = <span class="string">''</span>,</div><div class="line">    list=[<span class="string">'测试A'</span>,<span class="string">'测试B'</span>];</div><div class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>, len = list.length; i&lt; len; i++) {</div><div class="line">    str+=<span class="string">'&lt;div&gt;'</span> + list[i] + <span class="string">'&lt;/div&gt;'</span>;</div><div class="line">};</div><div class="line">console.log(str); <span class="comment">//&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>尽量避免使用存在兼容性及消耗资源的方法或属性。不要使用with，void，evil，eval_r，innerText。</li>
<li>注重HTML分离, 减小reflow, 注重性能。</li>
</ul>
<h2 id="图片规范">图片规范</h2>
<ul>
<li>命名应用小写英文、数字、_组合，便于团队其他成员理解。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header_btn.gif</div><div class="line"> header_btn2.gif</div></pre></td></tr></table></figure>

<ul>
<li>页面元素类图片均放入img文件夹，测试用图片放于<code>img/testimg</code>文件夹，psd源图放入img/psdimg文件夹。</li>
<li>图片格式仅限于gif、png、jpg等。</li>
<li>用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。</li>
<li>背景图片请尽可能使用<code>sprite</code>（将一个页面涉及到的所有零星图片都包含到一张大图中去）技术, 减小http请求。</li>
</ul>
<h2 id="注释规范">注释规范</h2>
<ul>
<li>JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。中间可添加如下信息：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@file</span> 文件名</div><div class="line"><span class="variable">@addon</span> 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中</div><div class="line"><span class="variable">@argument</span> 用大括号中的自变量类型描述一个自变量</div><div class="line"><span class="variable">@author</span> 函数/类作者的姓名</div><div class="line"><span class="variable">@base</span> 如果类是继承得来，定义提供的类名称</div><div class="line"><span class="variable">@class</span> 用来给一个类提供描述，不能用于构造器的文档中</div><div class="line"><span class="variable">@constructor</span> 描述一个类的构造器</div><div class="line"><span class="variable">@deprecated</span> 表示函数/类已被忽略</div><div class="line"><span class="variable">@exception</span> 描述函数/类产生的一个错误</div><div class="line"><span class="variable">@exec</span> <span class="variable">@extends</span> 表示派生出当前类的另一个类</div><div class="line"><span class="variable">@fileoverview</span> 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前</div><div class="line"><span class="variable">@final</span> 指出函数/类</div><div class="line"><span class="variable">@ignore</span> 让jsdoc忽视随后的代码</div><div class="line"><span class="variable">@link</span> 类似于<span class="variable">@link</span>标签，用于连接许多其它页面</div><div class="line"><span class="variable">@member</span> 定义随后的函数为提供的类名称的一个成员</div><div class="line"><span class="variable">@param</span> 用大括号中的参数类型描述一个参数</div><div class="line"><span class="variable">@private</span> 表示函数/类为私有，不应包含在生成的文档中</div><div class="line"><span class="variable">@requires</span> 表示需要另一个函数/类</div><div class="line"><span class="variable">@return</span> 描述一个函数的返回值</div><div class="line"><span class="variable">@see</span> 连接到另一个函数/类</div><div class="line"><span class="variable">@throws</span> 描述函数/类可能产生的错误</div><div class="line"><span class="variable">@type</span> 指定函数/成员的返回类型</div><div class="line"><span class="variable">@version</span> 函数/类的版本号</div></pre></td></tr></table></figure>

<h2 id="开发和测试工具约定">开发和测试工具约定</h2>
<ul>
<li>编码格式化，三码统一。</li>
<li>测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>from: <a href="">Github</a></p>
<h2 id="通用规范">通用规范</h2>
<ul>
<li>使用空格代替TAB，windows和Linux的Tab占位不同。</li>
<li>CSS样式属性和 JavaScript代码后边添加分号<code>;</code> ，方便断句，利于压缩。</li>
<li>文件内容编码均统一为UTF-8。</li>
<li>CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。</li>
</ul>
<h2 id="文件规范">文件规范</h2>
<ul>
<li>文件名用英文单词，多个单词用驼峰命名法。</li>
<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。<code>ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao</code><br>]]>
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《增长黑客》读书笔记]]></title>
    <link href="http://yoursite.com/2015/10/05/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/10/05/《增长黑客》读书笔记/</id>
    <published>2015-10-05T12:20:30.000Z</published>
    <updated>2015-10-05T12:39:27.000Z</updated>
    <content type="html"><![CDATA[<p>通过简书阅读：<a href="http://www.jianshu.com/p/ced81ced4b0d" target="_blank" rel="external">《增长黑客》读书笔记</a></p>
<p>国庆期间，利用两天里的空闲时间，把这本最近颇受好评的书读了一遍，感觉很有意思之余，又把把书里的干货整理了一遍。</p>
<p>书里的干货很多，案例很多，纯理论的东西不多，如果想要成为一个牛逼的 Leader , 就应当把自己培养成为T型的人才，跨界知识能力超强，某方面技术超硬，这个某方面，更多的指技术能力超硬。</p>
<p>同时，书中所提到的一些案例，某些地方是游走在规矩的边界上，还有一部分虽然很有效但是也增加了用户的恶感（如捆绑下载，插件广告等），当然这本书并不是要教你学坏。</p>
<p>在写这个读书笔记之前，我也看了一些人做的思维导图，内容很全，但是思维导图的缺点在于看的人更容易整体的浏览，一瞬接接触巨大的信息量，而无法深入的思考每一个信息点，所以我直接以正常笔记的形式进行了整理。</p>
<h2 id="第一章：概念">第一章：概念</h2>
<h4 id="定义（P6）">定义（P6）</h4>
<p>以数据驱动营销，以市场指导产品，通过技术化手段贯彻增长目标的人。</p>
<h4 id="增长目标：（P7）">增长目标：（P7）</h4>
<p><strong>『AARRR』转化漏斗模型：</strong></p>
<ul>
<li>Acquisition 获取用户</li>
<li>Activation 激发活跃</li>
<li>Retention 提高留存</li>
<li>Revenue 增加收入</li>
<li>Referral 传播推荐</li>
</ul>
<h4 id="能力特质：（P16）">能力特质：（P16）</h4>
<ul>
<li><strong>数据为王：</strong>具有数据思维，一切工作建立在数据分析之上</li>
<li><strong>专注目标：</strong>时刻围绕增长目标展开，不断的测试、改进，学习、再测试</li>
<li><strong>关注细节：</strong>对细小改动做出评估</li>
<li><strong>富于创意：</strong>缜密分析+天马行空的增长方案</li>
<li><strong>信息通透：</strong>深入理解产品用户的活跃渠道，关注新生渠道和业界趋势</li>
</ul>
<p>（Andy Johns的增长黑客生涯）：facebook小挂件，向潜在用户发邮件广告推广，Twitter的着陆页改进（关注注册登录），新用户注册推荐用户，开发内部群发邮件系统，Quora捉摸用户行为模式，归纳为标准流程，引导其他用户执行流程<br><a id="more"></a></p>
<h4 id="一切以数据说话：（P17）">一切以数据说话：（P17）</h4>
<ul>
<li><strong>明确分析目的</strong></li>
<li><strong>了解数据来源的相关信息</strong>：<ul>
<li><strong>强调核心指标</strong>：建立在品类特性和自身提供服务的核心价值之上</li>
<li><strong>确定上报机制</strong>：时机、内容、技术实践形式</li>
</ul>
</li>
<li><strong>数据分析方法</strong><ul>
<li><strong>定性分析</strong>：对事物性质进行判断</li>
<li><strong>定量分析</strong>： 对事物数量做统计</li>
</ul>
</li>
</ul>
<h4 id="团队定位（P20）">团队定位（P20）</h4>
<p>游走在产品、运营、研发、设计、用户研究之间的多面手，比产品更关注能带来数据增长的功能特性，比运营更倾向于数据中探索新的增长机会，比设计师更少关注感观层面的艺术性，长于用户研究</p>
<h4 id="招聘经验以及发展要素（P23）">招聘经验以及发展要素（P23）</h4>
<p><strong>要求</strong>：具备技术、产品、营销思维、传播和分享的精神（案例为Teambition , WIFI万能钥匙的招聘经验）<br><strong>如何培养</strong>：熟悉产品和技术的市场影响，有产品干和市场思维，培养横向跨界知识，纵向某一领域专攻。<strong>软实力</strong>为：热情、聪明、好奇、收集资源、影响力、心态开放、内心强大、轻微强迫症<br><strong>常用的工具箱：</strong>Google Analytics , Mixpanel , KissMeteics , UserCycle , Customer.io , Optimize.ly , Basscamp , 友盟 </p>
<h2 id="第二章：产品">第二章：产品</h2>
<h4 id="PMF（P40）">PMF（P40）</h4>
<p>也就是产品与市场的完美切合度，Product / market fit。从早期用户得到反馈，利用最小的成本持续改进产品。</p>
<p><strong>成功案例</strong>： instagram的转型，砍掉冗余功能，吧用户喜欢的照片分享功能拿出来做<br><strong>失败案例</strong>： 叮咚小区，前期粗暴的线下广告投放，但是产品的基础功能不完善，用户体验极差。</p>
<p>所以，应当先做好产品的验证，达到了PMF状态再全力推广。</p>
<h4 id="需求（P45）">需求（P45）</h4>
<ul>
<li><strong>需求是真实存在的还是伪需求</strong>（QQ邮箱将邮件附件单列出来，但几乎没人用）</li>
<li><strong>需求是否属于刚需</strong></li>
<li><strong>需求是否足够大</strong>：估计目标用户的基数、消费能力、意愿预算；评估进入市场的原有规模和新的规模、借助排行榜和搜索热度了解需求（YY 向视频直播平台转变）</li>
<li><strong>需求的变现能力如何</strong></li>
</ul>
<h4 id="MVP（P49）">MVP（P49）</h4>
<p>也就是最小化的可行产品来验证需求。</p>
<ul>
<li><strong>基本功能</strong>： 在最短时间内完成，如Dropbox通过仅完成宣传视频，Groupon 通过WordPress建站，排版软件制作礼券等，大众点评3天做出网页，数据来源于旅游手册，微信游戏近似于图片拼凑视觉稿。这几种常见的方式：<strong>伪造网站，不提供实际的功能；用户点击按钮后告知正在开发，留下电子邮箱；调研用户呼声最高的功能，然后成为种子用户；基于微信做MVP的开发（无需适配，分发方便，便于收集反馈，数据可以沉淀，开发成本低）</strong></li>
<li><strong>反馈渠道</strong>：内部反馈机制等</li>
<li><strong>官方公告</strong>： 群体公告 + 单用户通知</li>
<li><strong>自动升级</strong>： 启动时提示更新</li>
<li><strong>使用行为统计</strong></li>
</ul>
<p>同时应当注意，在产品早期应当尽快适配新环境，案例：多拉口袋的iOS8崩溃问题。</p>
<h2 id="第三章：获取用户">第三章：获取用户</h2>
<h4 id="种子用户（P64）">种子用户（P64）</h4>
<p>通过<strong>冷启动</strong>来获取第一批用户和制作过程，早期的种子用户的质量将决定产品初期的氛围、运营走向、以及日后的发展策略，案例如：知乎的早期邀请制度，哔哩哔哩的答题机制，小米的种子用户反馈。</p>
<p>但是一定要警惕『产品蝗虫』，也就是目标客户之外的围观群众，他们将占用原有的目标用户名额，伤害到社区的生态，抠一些没用的『细节』，行为会对产品的决策产生误导。</p>
<h4 id="从最笨的事情做起（P68）">从最笨的事情做起（P68）</h4>
<p>几个案例：</p>
<ul>
<li>聚美优品，写BB霜的软文，提供化妆品的高质量美图</li>
<li>Strikinfly，寻找超级粉丝，线上线下聊天</li>
<li>云笔记，邀请内测用户成立反馈协助群</li>
<li>Airbnb , 挨家挨户的上门拍照</li>
</ul>
<h4 id="社交红利（P72）与数据抓取（P77）">社交红利（P72）与数据抓取（P77）</h4>
<ul>
<li>与社交网络整合，获取用户量、关系链和行为数据（Spotify用facebook 登陆，Zynga用Facebook的开放平台制作社交游戏）</li>
<li>第三方社交网络的账号登陆，达成移动应用的分享和回流（啪啪，使用微博QQ登陆，挖掘关系链潜力）</li>
<li>数据抓取，可以保证产品初期启动的数据量，以及抢占先机，或者争取资源（微软关闭空间主页服务的时候，网易迅速提供『一键搬家』，追TA抓取唱吧的用户头像）</li>
</ul>
<h4 id="内容营销（P81）">内容营销（P81）</h4>
<p>其作用是<strong>吸引流量，培养潜在用户，劝诱转化</strong>，所以应当讲用户爱听的故事，如官方微博输出用户喜欢的图文（知乎）。<br><strong>注意事项</strong>：明确目标受众，持续稳定输出高质量内容，标题的撰写技巧，保证文章长度（2400），数据分享与互动（有让人讨论的空间，如知乎刊发有争议的文章），选择合适的发布渠道。</p>
<h4 id="搜索的优化（P89）">搜索的优化（P89）</h4>
<p>分为搜索引擎的优化和应用商店的优化。</p>
<p>搜索引擎的优化案例，Facebook 针对用户资料的页面优化，twitter自动提交热门标签给搜索引擎，TochCrunch通过wiki百科建立反向链接。<br>应用商店的优化案例，如大姨吗，通过副标题的修改推关键词，大众点评『更新跑得快』活动。</p>
<h4 id="文案的撰写">文案的撰写</h4>
<ul>
<li>简要概述（100字内）</li>
<li>话题事件</li>
<li>核心特色</li>
<li>主要功能</li>
<li>团队访谈</li>
<li>未来计划</li>
<li>推广活动</li>
<li>转化引导</li>
</ul>
<h4 id="更多的技巧">更多的技巧</h4>
<ul>
<li>捆绑下载：如豌豆荚捆绑下载其APP</li>
<li>排队机制，饥饿营销： Mailbox显示排队人数，Trak.io付费插队，邀请好友插队。</li>
<li>嵌入式代码和小挂件： Youtube分享</li>
<li>线上到线下</li>
<li>海外的扩张： 猎豹，Facebook等</li>
</ul>
<h2 id="第四章：激发活跃">第四章：激发活跃</h2>
<h4 id="A/B测试（P121）">A/B测试（P121）</h4>
<ul>
<li>提供两个方案并行测试，</li>
<li>变量唯一排除其他干扰因素，</li>
<li>有判定结果优劣的标准，</li>
<li>移动应用也可以借助HTML5快速验证需求。</li>
</ul>
<p>几个典型案例如37Signals 『注册高额回报账户』vs 『所有账户享受30天免费使用』，ZAGG 商品的静态图片 vs 360度图片 ， OkDork 先注册后进网站的测试，根据行为热点图去掉导航栏的测试。移动端如百姓网利用HTML5容器实现A/B测试。</p>
<p>但注意，不要过度依赖AB测试。</p>
<h4 id="独辟蹊径的技术（P133）">独辟蹊径的技术（P133）</h4>
<p>在技术瓶颈下通过巧妙的手段破除用户使用功能的障碍，降低用户活跃的门槛。几个例子都很有趣：</p>
<ul>
<li>SKype『伪立体声』，提高清晰度，击败了其他同类服务</li>
<li>QQ音乐利用专辑图片实现了IOS的『锁屏歌词』</li>
<li>WIFI万能钥匙通过截图加上OCR技术识别WIFI热点，同时利用GPS+云服务获取附近的热点</li>
</ul>
<h4 id="补贴（P137）">补贴（P137）</h4>
<p>有直接的现金补贴，快速获取用户，激发活跃度，也就是如返利和嘀嘀快的的补贴大战。<br>也有新玩法的红包补贴，通过社交关系链的传播，比如嘀嘀打车的补贴新玩法，打车红包。</p>
<h3 id="游戏化（P139）与脚本自动化运营（P146）">游戏化（P139）与脚本自动化运营（P146）</h3>
<p><strong>《游戏改变世界》提到的游戏四大特征</strong>： 目标、规则、反馈系统、自愿参与。<br>比如星巴克的线下会员成长体系，同时还开发了app把线下的游戏化搬到了线上。移动签到应用Foursquare 通过积分排名，徽章挑战和抢夺地主的游戏设计抓取用户忠诚度。滴滴打车提供的『滴米』系统等等。</p>
<p>而产品在早期社区通过团队自己来运营启动，后期就可以通过写脚本来实现自动化运营，一个有趣的运营案例是豌豆荚打造的贴吧神兽，其实就是一个自动聊天的机器人，获得了几十万的关注度。</p>
<h2 id="第五章：提高留存">第五章：提高留存</h2>
<h4 id="用户留存率">用户留存率</h4>
<p><strong>留住已有的用户胜过拓展新用户</strong><br>用户流逝的原因：</p>
<ul>
<li><strong>程序漏洞，性能瓶颈</strong>：Color基本流程都跑不通</li>
<li><strong>用户频繁被骚扰</strong>： 新浪微博的各种通知、广告、推送、话题等</li>
<li><strong>产品热度消减</strong>： 『你画我猜』的日活锐减</li>
<li><strong>更好的替代产品</strong> ： eBay被淘宝击败</li>
<li><strong>其他原因</strong></li>
</ul>
<p><strong>留存率的衡量标准</strong>：</p>
<ul>
<li>次日留存（40%）</li>
<li>7日留存（20%）</li>
<li>30日留存（10%）</li>
</ul>
<h4 id="产品性能优化">产品性能优化</h4>
<p>优化内容包括：用户终端性能、网络性能、流量压缩、安装包空间、界面设计与布局、其他。</p>
<p>如Facebook为非洲用户的优化，减少了启动速度，提供了预加载，压缩图片，优先家在适合当前分辨率的照片，优化安装包大小，其实就是前边所说的优化内容。</p>
<p>再如 Instagram 的安卓版优化，扁平化设计，重新布局精简架构专注内容，延迟加载不必要的模块（方法追踪method tracing 和时点声明 Timing Statements 技术）。</p>
<h4 id="有损服务——放下不必要的坚持">有损服务——放下不必要的坚持</h4>
<p>定义：<strong>刻意输出在品质上存在某些损失的服务，换取其他方面的优化。</strong><br>原则：</p>
<ul>
<li><strong>优先保证核心功能的运转</strong></li>
<li><strong>牺牲的特性越少越好，在条件允许的情况下</strong><br>几个经典的案例如：QQ农场在高峰期提供的静态默认列表，微信的高峰期不强求信息发送顺序的一致，小米在抢购的时候不提供剩余手机的精确统计（也有可能是饥饿营销），刀塔传奇的大版本升级采用『低清晰度版本』保证用户尽早升级。</li>
</ul>
<h4 id="引导用户上手_社交维系与社交解绑">引导用户上手 社交维系与社交解绑</h4>
<p>Twitter注册完成后的推荐用户，知乎的推荐订阅，都是引导用户快速上手的例子。</p>
<p>社交维系与社交解绑是对立的概念，前者如全民飞机大战，『啪啪』提示新加入的微博好友，Facebook在注销账号页面显示亲密好友的照片，通过社交手段维系用户留存。而same则通过解绑社交的方式，提高留存。</p>
<h4 id="唤醒机制">唤醒机制</h4>
<p>互联网产品中专为召回流失用户而设计的产品机制。</p>
<ul>
<li><strong>电子邮件召回EDM</strong><ul>
<li><strong>提供奖励</strong>，Pocket 用高级付费账户试用来吸引你</li>
<li><strong>告知进展</strong>，IFTTT增加Nest支持，Evernote推出商业版等方式</li>
<li><strong>个性化推荐</strong>，如知乎的每周精选，淘宝的同类商品。</li>
<li><strong>社交互动提示</strong>，如Twitter定期发送未处理消息，Facebook中通知用户『有一张照片中圈了你』。</li>
<li>优秀的第三方服务商包括 TinyLetter,MailChimp等，EDM要注意内容，和取消订阅方式。</li>
</ul>
</li>
<li><strong>消息推送通知</strong><ul>
<li><strong>推送授权</strong>，推荐试用简单的浮层或者弹窗提示用户获取权限后的使用目的。</li>
<li><strong>徽章通知</strong>，也就是角标，利用用户的强迫症。</li>
<li><strong>本地通知</strong>，在预设的时间点通知，如刀塔传奇每天的三个时间点推送通知。</li>
<li><strong>地理围栏通知</strong></li>
<li><strong>图片推送通知</strong></li>
<li><strong>表情文字通知</strong></li>
</ul>
</li>
<li><strong>网页内唤醒移动应用</strong>，iOS有直接的URL Scheme技术来实现，安卓上有四种方式，分别是：拦截http跳转、自定义scheme、Crome Internet ，内嵌http服务。如知乎，哔哩哔哩等。</li>
</ul>
<h2 id="第六章：增加收入">第六章：增加收入</h2>
<h4 id="免费的世界">免费的世界</h4>
<ul>
<li><strong>互联网与免费的午餐</strong><br> 互联网可以降低信息传播的承办本，海量用户摊薄了边际成本，人的本性对免费产品更感兴趣以及更喜欢『免费』的国人。</li>
<li><strong>免费又赚钱的策略</strong><ul>
<li>基本功能免费，高级功能收费的Freemium策略，比如Evernote，QQ，Flickr等等。</li>
<li>交叉补贴，《征途》的游戏免费，道具收费。</li>
<li>三方市场的流量变现，例子就是搜狗的『三级火箭』策略，通过输入法来带动搜狗浏览器下载，利用浏览器下载带动搜狗搜索的使用量（虽然我巨恶心搜狗的这个行为，但是这种变现的方式确实是最佳方式）</li>
<li>开源代码的盈利可能，如厂商定制开发收费，比如卖技术说明文档，或者接受用户捐赠（其实这个就不算是运营了，纯粹是情怀）</li>
<li>公司上市或者是被收购</li>
</ul>
</li>
<li><strong>免费午餐的终结</strong>，在产品足够好的情况下，可以试着完全掐断免费。</li>
</ul>
<h4 id="重定向广告">重定向广告</h4>
<p>也就是cookie和url分析，业界对此存在两种声音，一种认为增加了收入，另一种则担心用户隐私的泄露。</p>
<h4 id="几个营销案例">几个营销案例</h4>
<p><strong>Wet Seal </strong>：『和友人一起逛街』的社交购物，虚拟的DIY服务，Etsy根据社交资料精准推荐礼物。</p>
<p><strong>罗辑思维的微信月饼</strong>：这也是一次粉丝经济的催生，分别尝试了找人代付，多人代付，随机送礼，加入游戏思维的方式完成了一次精彩的营销。</p>
<p><strong>面对盗版的营销方式</strong>：腾讯给『非法』的QQ会员提供了八折开通会员的服务，而CleanmyMac 给盗版用户提供半价的优惠。面对盗版的变惩为奖的几个原则是：<strong>绝不责备用户，给予合理补偿，提供转化便利</strong></p>
<p><strong>建立商业智能系统</strong>：用数据可视化的方式辅助企业管理，如百姓网建立内部的数据化营销系统，提高了业务增长。</p>
<h2 id="第七章：病毒营销">第七章：病毒营销</h2>
<p><strong>凯文凯利《新经济，新规则》中说道，传真机效应，单独一台传真机没有什么价值，只有它处于一个网络中才能被赋予价值。对于拥有一台传真机的人来说，网络中的传真机越多，你的传真机价值也就越大，用户买下传真机，实则买下了整个网络。</strong></p>
<p>核心指标：</p>
<ul>
<li><strong>K因子</strong>：评判病毒传播的覆盖面，等于感染率*转化率。</li>
<li><strong>病毒传播周期</strong>： 用户发出病毒邀请，到新用户完成转化所花费的时间。（引爆点提到的个别人物法则，附着力法则和环境威力法则）。</li>
</ul>
<h4 id="几个案例">几个案例</h4>
<ul>
<li><strong>坏事传千里</strong>，百度的Bug营销，利用一个假装的bug，百度云获得了大量的新注册用户和铁杆粉丝，以及完整的流程体验，大量的用户个人文件。</li>
<li><strong>借势营销，利用时机</strong>，比如各种旅游产品借助阿里的去啊做热点营销，猎豹移动专门推出的春节抢票版。segmentFault的光棍节程序员闯关秀。（如今打开segmentfault.com/game会有一个新的闯关游戏，不过也是很难的）</li>
<li><strong>构建产品体系外的病毒循环</strong>，追TA的整蛊朋友圈游戏。三大考验：<ul>
<li><strong>创意来源</strong></li>
<li><strong>生命周期</strong></li>
<li><strong>产品契合度</strong>：知乎的财务包子铺与知乎的《金钱有术》。</li>
</ul>
</li>
<li><strong>产品内置的传播因子</strong>。外置的传播因子有几个缺陷，渠道特性与产品特性不匹配，获得的用户参差不齐；渠道传播与下载转化之间可能存在断链（朋友圈可能屏蔽一些下载）；渠道传播的策划固然成功，但是用户可能对产品本身缺乏兴趣。所以借用内置的传播因子可能更好，如AirDrop的推荐产品解锁高级功能，美图秀秀内建的可分享到朋友圈的小功能。</li>
<li><strong>邮件提醒增强传播效率</strong>： SpringSled 好友邀请提高排队名次，通过有效的邮件跟踪提高用户数量。</li>
</ul>
<h4 id="病毒传播中的用户心理把握">病毒传播中的用户心理把握</h4>
<ul>
<li><strong>喜爱</strong>：游戏，文学等大ip的作品，转化率比较高。</li>
<li><strong>逐利</strong>：如Groupon的邀请好友奖励10美元等。</li>
<li><strong>互惠</strong>： 是追逐利益的一种变体，基于理性经济人假说的传统经济学认为，经济行为主体是单纯追求个人利益最大化的，人们的复杂性为和社会参与，都基于成本收益的计算。如dropbox的推广获得额外空间。</li>
<li><strong>求助</strong>：手机游戏，免费游戏，续命或者是买体力要钱。</li>
<li><strong>炫耀</strong>： 支付宝每年一度的晒单</li>
<li><strong>稀缺</strong>： 稀缺资源会引起争抢，如Gmail，Dribbble初期仅允许被邀请者发表作品。</li>
<li><strong>害怕失去或错过</strong>： EverMemo 的互相扫描二维码解锁高级功能。</li>
<li><strong>懒惰</strong>： 严肃的商业内容，大多数用户倾向于复制部分文字和链接再发送，偏重知识性娱乐性的网站，人们优先使用分享按钮分享他们看到的东西。</li>
</ul>
<h2 id="第八章：案例集">第八章：案例集</h2>
<p>最后，作者复盘了几个完整的案例集，Airbnb ，Tinder ，Github，美丽说，外卖库，每一个都值得看几遍，了解一个成功的增长是如何做到的。</p>
<hr>
<p>整本书写的很赞，不像一些外国书，通篇的核心观点极少，统统以过分详实的案例填充那种情况。书中的干货还是非常多的，复盘的案例非常契合，分析到位。总之这是一本不错的书，至少应当读两遍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过简书阅读：<a href="http://www.jianshu.com/p/ced81ced4b0d" target="_blank" rel="external">《增长黑客》读书笔记</a></p>
<p>国庆期间，利用两天里的空闲时间，把这本最近颇受好评的书读了一遍，感觉很有意思之余，又把把书里的干货整理了一遍。</p>
<p>书里的干货很多，案例很多，纯理论的东西不多，如果想要成为一个牛逼的 Leader , 就应当把自己培养成为T型的人才，跨界知识能力超强，某方面技术超硬，这个某方面，更多的指技术能力超硬。</p>
<p>同时，书中所提到的一些案例，某些地方是游走在规矩的边界上，还有一部分虽然很有效但是也增加了用户的恶感（如捆绑下载，插件广告等），当然这本书并不是要教你学坏。</p>
<p>在写这个读书笔记之前，我也看了一些人做的思维导图，内容很全，但是思维导图的缺点在于看的人更容易整体的浏览，一瞬接接触巨大的信息量，而无法深入的思考每一个信息点，所以我直接以正常笔记的形式进行了整理。</p>
<h2 id="第一章：概念">第一章：概念</h2>
<h4 id="定义（P6）">定义（P6）</h4>
<p>以数据驱动营销，以市场指导产品，通过技术化手段贯彻增长目标的人。</p>
<h4 id="增长目标：（P7）">增长目标：（P7）</h4>
<p><strong>『AARRR』转化漏斗模型：</strong></p>
<ul>
<li>Acquisition 获取用户</li>
<li>Activation 激发活跃</li>
<li>Retention 提高留存</li>
<li>Revenue 增加收入</li>
<li>Referral 传播推荐</li>
</ul>
<h4 id="能力特质：（P16）">能力特质：（P16）</h4>
<ul>
<li><strong>数据为王：</strong>具有数据思维，一切工作建立在数据分析之上</li>
<li><strong>专注目标：</strong>时刻围绕增长目标展开，不断的测试、改进，学习、再测试</li>
<li><strong>关注细节：</strong>对细小改动做出评估</li>
<li><strong>富于创意：</strong>缜密分析+天马行空的增长方案</li>
<li><strong>信息通透：</strong>深入理解产品用户的活跃渠道，关注新生渠道和业界趋势</li>
</ul>
<p>（Andy Johns的增长黑客生涯）：facebook小挂件，向潜在用户发邮件广告推广，Twitter的着陆页改进（关注注册登录），新用户注册推荐用户，开发内部群发邮件系统，Quora捉摸用户行为模式，归纳为标准流程，引导其他用户执行流程<br>]]>
    
    </summary>
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
