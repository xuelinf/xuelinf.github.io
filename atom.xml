<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[临风|刀背藏身]]></title>
  <subtitle><![CDATA[代码是一棱刀背，幸好，有此藏身。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-10T14:59:07.897Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[临风]]></name>
    <email><![CDATA[xuelinf@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[(level 4)离奇的宽字节 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/10/-level-4-%E7%A6%BB%E5%A5%87%E7%9A%84%E5%AE%BD%E5%AD%97%E8%8A%82-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/10/-level-4-离奇的宽字节-XSS升级之路/</id>
    <published>2016-05-10T14:56:51.000Z</published>
    <updated>2016-05-10T14:58:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义，加一个斜杠。但此时忽略了编码的神奇。如果开发者在设置编码支持的时候，如果选择了GBK，gb18030,utf-8 等方式，实际上是支持十六位编码的。</p>
<p>最常见的方式，也就是在url里，在引号%27 或者是 %22 之前，加入%df, 由于0xdf 对应的大于128，所以，解析器会认为他和后边的组成了16位的编码，就会吃掉后边的字符，而后边跟着的字符，又恰恰是我们给引号添加的斜杠，%5c,于是%df 就会吃掉%5c 合并成一个字，引号重新暴露。</p>
<p>这种方法在XSS 不常见，但是如果某些XSS 在写过滤规则的时候，如果处理不当，还是有可能出现宽字节注入的情况，考虑如下url:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&t=%22;alert(1);//aaaaaa</div></pre></td></tr></table></figure>

<p>此处双引号被过滤了，变成了&amp;quot ;，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628903722866.jpg" alt=""></p>
<p>如果我们尝试一下采用宽字节注入，考虑构造成如图所示：<br>zh_CN&amp;t=%c0%22;alert(1);</p>
<p>令人惊奇的是，这次注入成功了，观察代码如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628904952071.jpg" alt=""></p>
<p>当然，此处所遇到的问题，应该并不是前边提到的传统的形式，%c0 吃掉%5c ,因为很明显，此处没有使用斜杠转义，而是转成了&amp;quot ; 只能把原因归咎于正则表达式处理的问题。</p>
<p>我们看到，即使当以注意到了问题所在的时候，仍然可能犯错误，而且是以意想不到的方式犯错，黑客渗透的方式，可能会以所有意想不到的形式进行。</p>
<p>我们将防御性代码比做成安全的城墙，那么正则过滤引擎，应该是这座安全长城的第一站，而在《Web 之困》 一书中，作者也说过，要想试图过滤掉所有的危险的编码，这几乎是不可能完成的任务。但作为开发者，比黑客再多想一些，这是应该的。</p>
<p>在XSS 界，拥有各种各样的形式去变形构造，在owasp 里，这篇<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="external">XSS Filter Evasion Cheat Sheet</a> 详细介绍了各种变形，以期能穷尽目前已知的各种变形手段，下次，我会对其中的变性手段，进行总结。但是，你想要过滤这所有的变形手段，几乎是不可能的，即使你过滤了他们，而引擎本身出现的错误，又会创造新的漏洞，上述例子就是这样的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[平凡又神奇的贝叶斯方法]]></title>
    <link href="http://yoursite.com/2016/05/07/%E5%B9%B3%E5%87%A1%E5%8F%88%E7%A5%9E%E5%A5%87%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/07/平凡又神奇的贝叶斯方法/</id>
    <published>2016-05-07T14:22:03.000Z</published>
    <updated>2016-05-07T14:24:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地方在本质上串联到了一起，这里再发一遍，表示对刘未鹏大神的敬佩。</p>
<h2 id="转载自刘未鹏博客">转载自<a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external">刘未鹏博客</a></h2>
<p>概率论只不过是把常识用数学公式表达了出来。</p>
<p>——拉普拉斯</p>
<p>记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了——这果然是个牛逼的方法。</p>
<p>——题记</p>
<h1 id="前言">前言</h1>
<p>这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。</p>
<h1 id="历史">历史</h1>
<p>托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介：</p>
<blockquote>
<p>所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。</p>
</blockquote>
<p>实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），<strong>但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。</strong></p>
<h2 id="1-1_一个例子：自然语言的二义性">1.1 一个例子：自然语言的二义性</h2>
<p>下面举一个自然语言的不确定性的例子。当你看到这句话：</p>
<blockquote>
<p>The girl saw the boy with a telescope.</p>
</blockquote>
<p>你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。</p>
<h2 id="1-2_贝叶斯公式">1.2 贝叶斯公式</h2>
<p>贝叶斯公式是怎么来的？</p>
<p>我们还是使用 wikipedia 上的一个例子：</p>
<blockquote>
<p>一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p>
</blockquote>
<p>一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p>
<p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p>
<p>我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U <em> P(Boy) </em> P(Pants|Boy) 个穿长裤的（男生）（其中 P(Boy) 是男生的概率 = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的，其中有 U <em> P(Girl) </em> P(Pants|Girl) 个女生。两者一比就是你要求的答案。</p>
<p>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U <em> P(Girl) </em> P(Pants|Girl) / [U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p>
<p><strong>P(Girl|Pants) = P(Girl) <em> P(Pants|Girl) / [P(Boy) </em> P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</strong></p>
<p>注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。</p>
<p>上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是：</p>
<p><strong>P(B|A) = P(A|B) <em> P(B) / [P(A|B) </em> P(B) + P(A|~B) * P(~B) ]</strong></p>
<p>收缩起来就是：</p>
<p><strong>P(B|A) = P(AB) / P(A)</strong></p>
<p>其实这个就等于：</p>
<p><strong>P(B|A) * P(A) = P(AB)</strong></p>
<p>难怪拉普拉斯说概率论只是把常识用数学公式表达了出来。</p>
<p>然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。</p>
<h1 id="2-_拼写纠正">2. 拼写纠正</h1>
<p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文在这里，徐宥的翻译版在这里，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。</p>
<p>首先，我们需要询问的是：“问题是什么？”</p>
<p>问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求：</p>
<p><strong>P(我们猜测他想输入的单词 | 他实际输入的单词)</strong></p>
<p>这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是</p>
<p><strong>P(我们的猜测1 | 他实际输入的单词)</strong></p>
<p>可以抽象地记为：</p>
<p><strong>P(h1 | D)</strong></p>
<p>类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为：</p>
<p><strong>P(h | D)</strong></p>
<p>运用一次贝叶斯公式，我们得到：</p>
<p><strong>P(h | D) = P(h) * P(D | h) / P(D)</strong></p>
<p>对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道：</p>
<p>P(h | D) ∝ P(h) * P(D | h) （注：那个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。）</p>
<p>这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。</p>
<p>下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。</p>
<p><strong>一点注记：</strong>Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) <em> P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) </em> P(D | h) 了——虽然我们很可能使用了一些<a href="https://book.douban.com/subject/1599035/" target="_blank" rel="external">启发法来简化计算</a>。后面我们还会提到这样的 bottom-up 的关联提取。</p>
<h1 id="3-_模型比较与奥卡姆剃刀">3. 模型比较与奥卡姆剃刀</h1>
<h2 id="3-1_再访拼写纠正">3.1 再访拼写纠正</h2>
<p>介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“为什么？”为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？</p>
<p>为了回答这个问题，一个常见的思路就是想想：非得这样吗？因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？</p>
<p>不管怎样，一个最常见的替代方案就是，选择离 thew 的编辑距离最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。</p>
<p>而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。</p>
<p>以上只是最大似然的一个问题，即并不能提供决策的全部信息。</p>
<p>最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用样条来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。</p>
<p>以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据过配（overfitting）的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓奥卡姆剃刀精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。</p>
<p>过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？</p>
<h2 id="3-2_模型比较理论（Model_Comparasion）与贝叶斯奥卡姆剃刀（Bayesian_Occam’s_Razor）">3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</h2>
<p>实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过：</p>
<p>P(h | D) ∝ P(h) * P(D | h)</p>
<p>来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 beta 分布来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是概率密度函数）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。</p>
<p>以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。</p>
<p>然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点：</p>
<p>The girl saw the boy with a telescope.</p>
<p>到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？</p>
<p>我们不妨先来看看 MacKay 在书中举的一个漂亮的例子：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301108729.jpg" alt=""></p>
<p>图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301200892.jpg" alt=""></p>
<p>很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？</p>
<p>用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！”</p>
<p>现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。</p>
<p>自然语言二义性很常见，譬如上文中的一句话：</p>
<blockquote>
<p>参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题</p>
</blockquote>
<p>就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？</p>
<p>注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。</p>
<p>这个就是所谓的<strong>贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</strong>，因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。</p>
<p>这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。</p>
<h2 id="3-3_最小描述长度原则">3.3 最小描述长度原则</h2>
<p>贝叶斯模型比较理论与信息论有一个有趣的关联：</p>
<p><strong>P(h | D) ∝ P(h) * P(D | h)</strong></p>
<p>两边求对数，将右式的乘积变成相加：</p>
<p><strong>ln P(h | D) ∝ ln P(h) + ln P(D | h)</strong></p>
<p>显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。</p>
<p>而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节）</p>
<h2 id="3-4_最优贝叶斯推理">3.4 最优贝叶斯推理</h2>
<p>所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。</p>
<p>只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。</p>
<h1 id="4-_无处不在的贝叶斯">4. 无处不在的贝叶斯</h1>
<p>以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。</p>
<h2 id="4-1_中文分词">4.1 中文分词</h2>
<p>贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述，详细请参考吴军的文章（这里）。</p>
<p>分词问题的描述为：给定一个句子（字串），如：</p>
<p>南京市长江大桥</p>
<p>如何对这个句子进行分词（词串）才是最靠谱的。例如：</p>
<ol>
<li><p>南京市/长江大桥</p>
</li>
<li><p>南京/市长/江大桥</p>
</li>
</ol>
<p>这两个分词，到底哪个更靠谱呢？</p>
<p>我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：</p>
<p><strong>P(Y|X) ∝ P(Y)*P(X|Y)</strong></p>
<p>用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串：</p>
<p><strong>W1, W2, W3, W4 ..</strong></p>
<p>的可能性呢？我们知道，根据联合概率的公式展开：P(W1, W2, W3, W4 ..) = P(W1) <em> P(W2|W1) </em> P(W3|W2, W1) <em> P(W4|W1,W2,W3) </em> .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) <em> P(W2|W1) </em> P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。</p>
<p><strong>一点注记：</strong>有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，高维诅咒就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，声称统计学习方法能够终结科学研究（原文）的说法是纯粹外行人说的话。</p>
<h2 id="4-2_统计机器翻译">4.2 统计机器翻译</h2>
<p>统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。</p>
<p>问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出：</p>
<p><strong>P(f|e) ∝ P(f) * P(e|f)</strong></p>
<p>这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如：</p>
<p><strong>John (Jean) loves (aime) Marie (Mary)</strong></p>
<p>就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算：</p>
<p>P(John|Jean) <em> P(loves|aime) </em> P(Marie|Mary)</p>
<p>即可。</p>
<p>然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。</p>
<p>一点注记：还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 HTM （Hierarchical Temporal Memory）模型正是使用了这个原则。）</p>
<h2 id="4-3_贝叶斯图像识别，Analysis_by_Synthesis">4.3 贝叶斯图像识别，Analysis by Synthesis</h2>
<p>贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303078774.jpg" alt=""></p>
<p>首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。</p>
<h2 id="4-4_EM_算法与基于模型的聚类">4.4  EM 算法与基于模型的聚类</h2>
<p>聚类是一种无指导的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303321261.jpg" alt=""></p>
<p>图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。</p>
<p>EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。</p>
<h2 id="4-5_最大似然与最小二乘">4.5 最大似然与最小二乘</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303555126.jpg" alt=""></p>
<p>学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——回归可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。</p>
<p>一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。</p>
<p>我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。</p>
<p>现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是：</p>
<p><strong>P(h|D) ∝ P(h) * P(D|h)</strong></p>
<p>又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) <em> P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) </em> P(d2|h) <em> .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] </em> EXP[-(ΔY2)^2] <em> EXP[-(ΔY3)^2] </em> .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？</p>
<h1 id="5-_朴素贝叶斯方法">5. 朴素贝叶斯方法</h1>
<p>朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。</p>
<h2 id="5-1_贝叶斯垃圾邮件过滤器">5.1 贝叶斯垃圾邮件过滤器</h2>
<p>问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求：</p>
<p><strong>P(h+|D) = P(h+) * P(D|h+) / P(D)</strong></p>
<p><strong>P(h-|D) = P(h-) * P(D|h-) / P(D)</strong></p>
<p>其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？</p>
<p>我们将 P(d1,d2,..,dn|h+)  扩展为： P(d1|h+) <em> P(d2|d1, h+) </em> P(d3|d2,d1, h+) <em> .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) </em> P(d2|h+) <em> P(d3|h+) </em> .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) <em> P(d2|h+) </em> P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考这个条目，注意其中提到的其他资料。</p>
<p><strong>一点注记：</strong>这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。</p>
<h2 id="5-2_为什么朴素贝叶斯方法令人诧异地好——一个理论解释">5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释</h2>
<p>朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper 。</p>
<h1 id="6-_层级贝叶斯模型">6. 层级贝叶斯模型</h1>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304175931.jpg" alt=""></p>
<p>层级贝叶斯模型是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。</p>
<h2 id="6-1_隐马可夫模型（HMM）">6.1 隐马可夫模型（HMM）</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304453370.jpg" alt=""></p>
<p>吴军在数学之美系列里面介绍的隐马可夫模型（HMM）就是一个简单的层级贝叶斯模型：</p>
<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>
<p>吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..）</p>
<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…)</p>
<p>其中</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而 P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。</p>
<p>这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。</p>
<h1 id="7-_贝叶斯网络">7. 贝叶斯网络</h1>
<p>吴军已经对贝叶斯网络作了科普，请直接跳转到<a href="http://googlechinablog.com/2007/01/bayesian-networks.html" target="_blank" rel="external">这里</a>。更详细的理论参考所有机器学习的书上都有。</p>
<p>参考资料</p>
<p>一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。</p>
<p>部分书籍参考《机器学习与人工智能资源导引》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地]]>
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非HTML类型文档的复仇以及插件 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/07/%E9%9D%9EHTML%E7%B1%BB%E5%9E%8B%E6%96%87%E6%A1%A3%E7%9A%84%E5%A4%8D%E4%BB%87%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/07/非HTML类型文档的复仇以及插件-《The-Tangled-Web》/</id>
    <published>2016-05-07T09:29:03.000Z</published>
    <updated>2016-05-07T09:29:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h2 id="纯文本文件">纯文本文件</h2>
<p>Content-Type: text/plain</p>
<p>除了IE，收到没有头域的HTTP/0.9 或者缺少Content-Type 的响应，默认是处理为纯文本文件，而IE会处理为HTML 文件。同时，大多数浏览器，对若干的MIME 类型，及其各种变种，text/CSS 都映射为纯文本文件，是为了方便开发人员，当然，JSON除外。</p>
<h2 id="位图图片">位图图片</h2>
<p>在缺少Content-Type 响应头的情况下，会有解析器去检测文档的头部信息，来判断类型。如果包含了Content-Type类型，那么先匹配到MIME 类型，如果无法解析，就会再检测文档头部信息，来确定类型。</p>
<p>而近期曝出的ImageMagick 的0day 漏洞，就是这样一个漏洞，漏洞发生在这款ImageMagick 的图像处理软件，它被广泛用来在网站上进行图像处理，其原理就是，用户上传图像，每个图像会有一个magic bytes，实际上就是文件头，用来表示图像类型，ImageMagick 的功能就是通过解析器，对文件头进行解析，然后进一步处理。</p>
<p>如果我们把一个含有恶意代码的文件保存为文件格式，交给ImageMagick 解析，正常是ImageMagick 无法解析的，当然漏洞就是不正常的时候了，参考如下代码：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">push graphic-context</div><div class="line"></div><div class="line">viewbox <span class="number">0</span> <span class="number">0</span> <span class="number">640</span> <span class="number">480</span></div><div class="line"></div><div class="line">fill ‘url(https:<span class="comment">//example.com/image.jpg“|ls “-la)’</span></div><div class="line"></div><div class="line">pop graphic-context</div></pre></td></tr></table></figure>

<p>将其保存为jpg 格式等，调用ImageMagick 去处理它，就会触发一个最常见的查看本地文件的漏洞，下面在说一下原因。</p>
<p>ImageMagick 在 MagickCore/constitute.c 的 ReadImage 函数中解析图片，如果图片地址是 https:// 开头的，即调用 InvokeDelegate。MagickCore/delegate.c 定义了委托。作为一个执行命令被引入的，但是，对参数的引入没有做好足够的过滤，造成了渗透的可能，比如一个默认命令是为了处理来自http 请求送来的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"wget"</span> -q -O <span class="string">"%o"</span> <span class="string">"https:%M"</span></div></pre></td></tr></table></figure>

<p>此处的%M 是真实的输入参数，如果他的值是这样的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`https://example.com<span class="string">";|ls "</span>-la`</div></pre></td></tr></table></figure>

<p>很显然，由于引号的奇怪闭合方式，这一块恰好满足了bash 的语法，通过一个通道符，我们继续调用了ls -la ，显然，这就引起了注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ convert <span class="string">'https://example.com";|ls "-la'</span> out.png</div><div class="line">total <span class="number">32</span></div><div class="line">drwxr-xr-x <span class="number">6</span> user group <span class="number">204</span> Apr <span class="number">29</span> <span class="number">23</span>:<span class="number">08</span> .</div><div class="line">drwxr-xr-x+ <span class="number">232</span> user group <span class="number">7888</span> Apr <span class="number">30</span> <span class="number">10</span>:<span class="number">37</span> ..</div></pre></td></tr></table></figure>

<p>这是基本的原因，实际上的利用漏洞过程通过上传文件，构造exploit, 上文中已经构造了一个文件，他的格式是按照mvg 格式，对于ImageMigick 存在这种漏洞的有两个格式，mvg,和svg,mvg 相对好构造一点。</p>
<p>更进一步的，通过构造exploit ，我们可以删除服务器文件，移动服务器文件，或者是读取服务器文件，其结果，你懂得。</p>
<p>具体参见这个漏洞专门成立的网站<a href="https://imagetragick.com/" target="_blank" rel="external">Imagetragick</a>, 如今在乌云上，借着这个漏洞，已经提交了无数个0day 漏洞了。</p>
<h2 id="音视频文件">音视频文件</h2>
<p>其细节内容，不做过多的深究，对于其安全隐患，也就是是否合理的消除类型错判带来的风险，和上边的图片处理有一点点相似。</p>
<p>另外，作者想了一个很有想象力的情况，如果<audio> 支持未压缩的原生音频播放，然后这个标签被指向了敏感的非音频文件，但是由于是处在这个标签下，还是会被当做原生的音频播放，虽然是混乱的声波。而在HTML5 之下，调用麦克风API，可以捕捉这些声波信息，通过这些声波信息，又重组了文件内容。OTZ…</audio></p>
<h2 id="XML_文件">XML 文件</h2>
<p>浏览器会根据收到的Content-Type 或一些其他线索，为集中特殊的XML 格式提供单一用途的XML 解析器。而绝大部分时候，和XHTML 同一个解析器。在XML 中，</p>
<ul>
<li>文档的实际含义取决于XML 文件中的xmlns 命名空间</li>
<li>xmlns 和 Content-Type 的值无关，按后者进行解析</li>
<li>可能有多个xmlns,对文档的每个段落赋予不同的含义</li>
</ul>
<h4 id="常规的XML_视图">常规的XML 视图</h4>
<p>如果没有能够识别的命名空间设定，那么浏览器会默认显示一种树状结构，如果有的话，就按照实际含义进行显示。</p>
<p>但由于这种需要显示未知用途和无法识别命名空间的XML 文档，会带来一定的容错，这种容错，可能导致XSS，比如代理未经过滤的RSS 订阅源，一般来说是有特定的解析器进行处理，但如果没有内置RSS 阅读功能的浏览器，可能会使用最常规的解析模式，而RSS 订阅源中可能存在有HTML 代码，造成XSS 漏洞。</p>
<h4 id="可缩放向量图片">可缩放向量图片</h4>
<p>这里所说的一般是SVG，在上一部分的那个例子里，已经探讨过SVG带来的灾难，一个常见的svg 表达方式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">&lt;![CDATA[</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">()</span> </span>{alert(<span class="string">"hello"</span>);}</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">circle</span> <span class="attribute">onclick</span>=<span class="value">"clicked()"</span> <span class="attribute">cx</span>=<span class="value">"50"</span> <span class="attribute">cy</span>=<span class="value">"50"</span> <span class="attribute">r</span>=<span class="value">"50"</span> <span class="attribute">fill</span>=<span class="value">"pink"</span> /&gt;</span><span class="tag">&lt;/<span class="title">svg</span>&gt;</span></div></pre></td></tr></table></figure>


<p>目前该特性已被绝大多数浏览器支持，这里的svg是完成了一个划出圆圈，同时在圆圈中点击会显示提示信息。</p>
<p>对于svg来说，这种格式的图片可以直接放在独立的XML 文档中被访问到，同时也可以放在第三方页面上用&lt; img&gt;引用到，而使用img的话，svg的脚本部分会被完全禁止掉，但是虽然会被禁止，但是还是有危险的，他所在的内置脚本仍然有可能获得图片所在域名的上下文环境权限并且执行，所以如果引入外部来源的svg,就一定要做好非常严谨的语法过滤，上文提到的ImageMagick 漏洞，就是因为在处理图片头的时候，没有做好过滤造成的。</p>
<p>除此之外，还有一些其他类型的文档，比如<strong>数学标记语言</strong>， <strong>XML用户界面语言</strong>， <strong>无线标记语言</strong>，<strong>RSS Atom订阅源</strong> 等等。</p>
<p>另外，还有一些不可显示的文件类型，如插件和扩展的安装清单列表，manifests,自动HTTP代理配置歘繁忙PAC，可安装的外观样式，整数撤销列表CRL，反恶意网站黑名单等等。</p>
<h3 id="安全工程">安全工程</h3>
<p>当需要处理的数据很可能被解析为XHTML 格式，或其他支持脚本的文档类型，不要只去根据Content-Type 响应头和最顶层的xmlns 指令来判断。同时不要再任意位置上允许出现可由用户控制的标记语言。</p>
<p>如果不需要直接访问该文件，可以在响应的响应头加上<strong>Content-Disposition:Attachment</strong>。</p>
<p>对于非HTML 类型文档，正确识别Content-Type响应头，同时正确设置字符集编码，也很重要。</p>
<h1 id="浏览器插件">浏览器插件</h1>
<p>浏览器插件林林总总，形态各异。简单来讲，一个常见的插件，是讲在浏览器中显示一种新型的文件格式，格式类似于HTML，浏览器得到后交给插件进行处理。</p>
<p>很容易可以想到，浏览器插件的安全漏洞，不仅多，而且千奇百怪，可以说针对Web 应用程序的攻击，与插件占有关系占了很大一部分。</p>
<p>对插件的调用通过几个显式的形式调用：</p>
<ul>
<li>标记 &lt; object data=…&gt; 这样的形式，或者是&lt; embed src=…&gt;.</li>
<li>type 参数，将type的参数的MIME 与浏览器里注册的有效插件的MIME类型做一个对比，如果匹配，就把它传给谍影的插件如理，如果没有匹配，理论上会出现窗口，提示用户下载，但某些时候，浏览器会根据Content-Type头域，或者URL 里文件后缀的方式猜测。</li>
<li>插件里的输入信息一般通过&lt; object&gt; 区块里嵌入&lt; param&gt; 标签来进行设置。</li>
</ul>
<p>这里我们要强调的是，在对插件Content-Type 处理时是存在风险的，若干插件实际上有自己完整的代码执行环境，而且这些可执行的应用在于他们所在源站点进行交互时拥有一系列的特权，就很容易出现CSRF 的跨站漏洞。比如已经被启用的&lt; applet&gt;标签，可用于加载java 小程序。GIFAR 漏洞在2008年诞生，就是用一个applet 中加载的java程序，偷偷的隐藏在一个GIF 图片中。</p>
<p><strong>插件的各种应用框架</strong></p>
<p>这其中藏着无数的坑待挖掘，这里只是个小引子~</p>
<ul>
<li>Flash ,不多说，如今越来越不受待见其中存在有严重的脚本注入等问题，如getURL() navigateToURL() 控制浏览器打开访问新窗口等等，他还拥有一些特殊技能，这些特殊技能都有着致命的危险：<ul>
<li>收集字体等系统识别特征</li>
<li>可以全屏，所以可以制作UI 欺诈</li>
<li>能得到麦克风和摄像头的数据</li>
<li>能忽略浏览器的安全和隐私设定，使用自己的安全设置进行数据持久化</li>
<li>默认情况下，可以直接使用浏览器的HTTP 堆栈及其管理的全局身份凭证信息。</li>
<li>可以和其他运行的Flash 交互</li>
<li>访问应用页的DOM 元素</li>
<li>FLash 自带内部简化版HTML 解析器，转义等等问题要注意</li>
<li>插件自身的设计问题等等等等等等等等等等</li>
</ul>
</li>
<li>Microsoft Sliverlight ,不懂，有机会接触的时候再详细理解吧。</li>
<li>Sun java,&lt; applet&gt; 已经因为严重的问题被抛弃了。</li>
<li>XML Browser Applications ，微软家的不怎么懂，同上上。</li>
<li>ActiveX Controls ,一度很火，如今几乎挂了，不过IE8之前，你懂得，黑客的天堂。</li>
</ul>
<h2 id="安全工程-1">安全工程</h2>
<p>提供需要让插件处理的文件时：</p>
<ul>
<li>对于来源信任的数据，还是应当避免处理用户提供的URL，也不要在小程序中产生或者试图修改用户控制的HTML。</li>
<li>对于用户控制的简单的多媒体，记得要验证文件格式，甚至是限制文件格式，使用正确的Content-Type 设置，同时要吸取各种前车之鉴，避免内容检测造成的漏洞。</li>
<li>用户控制的文档格式，虽然本质上是可以绝对安全，但是插件仍然有漏洞的可能，所以对于文档，两个解决办法，专用域名，单词有效的令牌，不要持久cookie.</li>
</ul>
<p>对于需要嵌入由插件处理的文件，无外乎就是确保type 参数明确，如果无法被识别的话，一定要做出各种限制，任何非信任站点来的东西，都不要随便接收，做好对设置的核查。</p>
<p>开发ActiveX 组件？放弃吧！</p>
<hr>
<p>由于对浏览器插件这一块不熟，而且感觉这里边有一些有趣的文章可以做，但作者又讲的很少，而且大多数是一些行将就木的过时插件的东西，所以这里我就简短的写了写。</p>
<p>至此，所有关于Web 的东西基本上结束了，回顾整个过程，我们会发现，在Web 中，存在的漏洞一方面是由于本身在协议阶段就存在不科学的地方，另一方面在浏览器等客户端在实现过程中，又由于各自为战，也存在有不统一和各自的缺陷存在，还有一个原因，就是开发者自己在开发中，并不懂自己写出来的代码会带来什么样的困扰，这大概是最可怕的，同时，由于客户端的真正操作者是对程序对代码一窍不通的人，在安全风险上，完全不能依赖他们去提供一点点的阻挡。</p>
<p>所以，一个真正想要构建安全环境的产品，是需要一个团队在整个流程里，能准确把握所有可能造成安全问题的隐患，用最稳妥的方式处理。渗透不可怕，可怕的是每次只有当渗透发生了之后，仅仅明白哪里出错，而不知道为什么会出错，为什么会被黑客抓住。</p>
<p>所以，真正的安全者，是对自己的产品每一块防护措施都了如指掌的人。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 3) HTML中的野怪 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/06/-level-3-HTML%E4%B8%AD%E7%9A%84%E9%87%8E%E6%80%AA-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/06/-level-3-HTML中的野怪-XSS升级之路/</id>
    <published>2016-05-06T03:25:54.000Z</published>
    <updated>2016-05-06T03:27:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 onXXXX=”在这里” &gt; 或者是放在伪URL 里，比如&lt; a href = “javascript:在这里”&gt; xxxx 。</p>
<p>一般这样地方的参数，很少是直接通过输入就直接放进去的，不过有时候常常是接受了用户的输入，最后输出的时候，会出现在这些位置，但如果对用户的输入没有做详尽的处理和过滤的话，就会出现明显的XSS 漏洞。来个栗子：</p>
<p>比如某网站是这样的：</p>
<p><a href="http://example.com/search.php?word=helloworld" target="_blank" rel="external">http://example.com/search.php?word=helloworld</a></p>
<p>对应在HTML 代码中，他出现在了这样的区域里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>开发者没有对helloworld进行过滤的话，我们直接构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">word=helloworld<span class="string">" onclick="</span>alert(<span class="regexp">/xss/</span>)</div></pre></td></tr></table></figure>

<p>然后在对引号括号等，使用URL 编码，直接变成如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld%22+onclick%3d%22alert(%2fxss%2f)</div></pre></td></tr></table></figure>

<p>也就完成了xss过程，不过这种漏洞现在已经非常稀少，因为它太容易过滤了，只需要将双引号过滤即可，一般做法就是将双引号过滤成HTML 实体编码，也就是&#quot; 对于HTML 解析器，它能够识别在文本节点和参数值里边的实体编码，并且在内存中创建文档树的表现形式时，透明的对这些编码进行解码。所以，在创建DOM 树结构的时候，&amp;quot(有个分号，但是markdown会直接转了); 还没有被解码成引号，而且创建文档树的内容的时，才会考虑解码，而这时，其XSS 功效已经不能发挥作用了。</p>
<p>于是，对于有过滤规则的情况下，该标签将变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld&quot; onclick=&quot;alert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>但是，仅仅是这样的过滤，显然是不够用的，还有其他的注入点可以进，继续在乌云上来看腾讯的例子，考虑这样一个网址：<br><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>我们查看输出的HTML 源码，发现bg 那里对应的是background-color,我们尝试那里用不同的字符尝试，观察其过滤情况。在这里，我让bg = “\&lt;&gt;() 就是希望观察一下它的过滤情况，基本上所有的字符都被过滤了，但是只有\ 没有被过滤<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625007746187.jpg" alt=""></p>
<p>如何只用 \ 构造利用语句呢，我们可以想到CSS 中的字符编码，CSS 提供了一套转义处理策略，一个反斜杠后边跟1~6位十六进制数字。然后利用CSS 的expression 来调用JavaScript 代码。也就是试图构造出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expression(eval(alert(/xss/))</div></pre></td></tr></table></figure>

<p>这样的代码，完整来说，就是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">style</span>=<span class="value">"... background-color:;width:expression(eval(alert(/xss/)))"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用分号来结束backgroud-color,然后 w: 后边跟上expression,如果expression 要被过滤，那就加上转义，把expression 随意变下形就可以，于是，在下边这样的代码构造下，漏洞又被利用了。</p>
<p><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>不过很遗憾的，expression 当年是微软搞出来的技术，但是一直没被其他浏览器接受，同时，甚至微软自己如今也抛弃了这种特性，它出现在IE6，IE7，和IE8的一些早期版本，因为微软官方也认为该属性不具有通用性，而且它处理的事务，如今已经能够在CSS 中正常的完成，如min-width,max-width， 这些都已经在IE8之后得到很好的支持，所以expression 也只能在这两个古老版本上起效。</p>
<p>那么，继续考虑一些别的情况，考虑下面这个网站：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa</a></p>
<p>其输出的HTML 代码中，我们可以找到它：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625022573118.jpg" alt=""></p>
<p>对于放在javascript: 中的伪URL，其效果和放在script 代码块中没有区别。在这里 aaaaaa我们可以考虑对其做点什么，很自然的，我们想到用单引号闭合，然后后边加上alert(/xss/) 这样的构造，看起来比较绕，其构造步骤是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">'...&searchvalue=aaaaaa'</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa'</span>+alert(<span class="number">1</span>)+<span class="string">''</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa&#x27;+alert(1)+&#x27;'</span></div></pre></td></tr></table></figure>

<p>如果单引号，被过滤，就要改成HTML 编码，这样，就能在源代码中javascript 伪URL那里添加了alert(1) 这样的XSS。这步骤改造完毕之后，我们将可能被过滤的&amp;-&gt; %26,#-&gt;%23 转换成URL 编码，构造成这样的URL：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27</a>;</p>
<p>至此，又完成了一次XSS 注入，但到此处，是否有一个疑问呢，还是关于编码解析的问题。在上一个栗子中，我们说，将双引号，改成&amp;quot ; 这样的形式，就不会出现异常的解析了，但是这里，我们主动的将单引号改成了&amp;#27 ; 这样的形式，反而成功的完成了XSS 呢。</p>
<p>其实，这是一个解析顺序的原因，正常的解析顺序是这样的，先对URL解码，那些用URL 编码的字符都变成解码后的参数传出去，然后是HTML 解析，HTML 解析，此时 ，是先构建DOM文档结构，然后才会对每一个文本节点，属性值内容进行解析，这时候，HTML 实体编码的部分，才会还原回来，这个时候已经不会对DOM 结构造成影响了。然后是JS 解析，此时才会执行JS 代码的内容。而此时，HTML 已经完成了解码。</p>
<p>对应上边的栗子，在JS 解析之前，HTML 已经对那些编码完成了解码，对于JS 来说，一切都写的清清楚楚的了。</p>
<p>回到那个栗子，我们利用的代码，原样是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"pagenum"</span>  <span class="attribute">class</span>=<span class="value">"inputstyle0814"</span>  <span class="attribute">onkeydown</span>=<span class="value">"if ((event.keyCode==13) && (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&searchtype_yjbg=yjjg&searchvalue_yjbg=aaaaaaaaaa'"</span>/&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></div></pre></td></tr></table></figure>

<p>当我们构造完成利用代码之后，对于页面上来说，就是要点击按钮，也就是onkeydown。 不仅要将URL 传出去，还需要用户点击按钮，这样造成的威胁小很多，不如img 标签里的onerror ，onload那样可以自动触发。</p>
<p>最后我们再考虑一下如何防守吧，上上栗子的问题，在于漏掉了斜杠的过滤，那么\ 该过滤还是要过滤的。对于上边这个栗子，可以考虑二次过滤，也就是将&amp;都过滤为 &amp;amp ;，这样不仅过滤了无编码的单引号等格式，又可以过滤掉利用实体编码想要逃过的实体编码格式。而如果只是用正则去片段&amp;#xNN..等形式，实际上是不一定搞定所有的HTML 编码形式的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 o]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS和JavaScript的烦恼 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/05/CSS%E5%92%8CJavaScript%E7%9A%84%E7%83%A6%E6%81%BC-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/05/CSS和JavaScript的烦恼-《The-Tangled-Web》/</id>
    <published>2016-05-05T14:55:53.000Z</published>
    <updated>2016-05-05T14:56:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不重要，你随便打开一个网页，翻看一下源码，就会发现，满屏幕的div, 只起到了结构的作用，Tim Berners-Lee 的语义网梦想被CSS 阻挡，因为即使全屏的div，css 仍然能通过他五花八门的指令，伪类选择器，伪函数等等实现一个美观的网页。</p>
<p>当然，这里谈CSS， 并不是讲切图的，而是在CSS 里，同样存在着种种漏洞，主要是以XSS 为主的漏洞，所以对CSS 的探讨也在所难免。</p>
<h3 id="基本语法">基本语法</h3>
<p>一般使用方法有直接在&lt; style &gt;中使用，能够全局生效。或者通过&lt; link rel=stylesheet &gt; 引入外部的css 文件。或者是直接为某个标签赋予style参数。</p>
<p>选择器，包括复杂点的伪类选择器这里就不说了，只要稍微用过的人都知道，或者去W3C shcool也能看到详细的介绍。在CSS 的规则里，属性值是其最重要的东西，大约格式有三种：</p>
<ul>
<li><strong>原始文本</strong>：主要是用于设定一些数值型的值，RGB 向量，或者名字代指的原色等，以及一些预定好的关键词，比如 absolute, left, center等等</li>
<li><strong>引号括起来的字符串</strong> ： 当CSS 属性的值不是固定的关键词时，两边用单引号括起来，但是这条规则并不总是如此，比如设置字体，或者某些URL 时候，并不需要引号，而content 属性则需要。</li>
<li><strong>函数表示法</strong>： 有一些设计参数的伪函数，比如讲独立的のRGB 颜色转换成RGB代码的 rgb() , 以及一个大多数人都能用到的url(),同时还有一些比如scale(), rotate(), skew() 等等。<strong>特别的，IE浏览器中有一个函数expression(),可以在css 中嵌入JavaScript语句，这个函数一旦被黑客控制，后果可想而知。</strong></li>
</ul>
<p><strong>@指令和 XBL绑定</strong></p>
<p>除了上边所说的选择器，属性功能，CSS 还支持一种以@ 开头的格式，允许导入独立样式，同时能够改变样式表各种设定，比如指定命名空间，设定不同的显示媒体使用的不同的样式表（如今的跨设备就是如此)。</p>
<p>有两个重要的指令：</p>
<ul>
<li>@charset 用于设置当前CSS 区块的字符集格式</li>
<li>@import 在样式表中插入一个外部文件，@import “foo.css”; @import url(‘foo.css’); @import ‘foo.css’; 这几种表示格式是一样的。</li>
</ul>
<p>关于XBL 绑定，全称叫XML Binding Language，参见<a href="https://zh.wikipedia.org/wiki/XBL" target="_blank" rel="external">XBL维基百科</a>用于描述如何将其他文档中的元素（如XPCOM的功能）绑定到部件（如XUL部件）。可以使用级联样式表（CSS）或文档对象模型（DOM）两种方式绑定，绑定可为部件创建新的行为。绑定可以包含已注册到“被绑定元素”的事件处理程序，实现对“被绑定元素”的新的方法和属性访问，包括“被绑定元素”内的“匿名内容”。</p>
<p>该语言现在算是Mozilla 专有，FireFox 中的一个特性，利用 -moz-binding ，可以从外部源载入外部内容指令，可包括一些JavaScript代码。目前该使用方式并不明朗，当然看起来其中也有着不小的XSS 风险。</p>
<p>值得注意的是，上边提到的@import, url() 都存在有引入伪URL 的安全隐患，大多数浏览器都不接受CSS 的上下文环境使用脚本，但是IE 6 却支持，可以想象，IE6 还存在有大量漏洞，而在中国这片国土，IE 6仍然有不小的占有量。</p>
<p><strong>交互过程</strong></p>
<p>之前说，CSS 和HTML 是各自独立的，也就是说在执行过程中，会先解析HTML，然后解析CSS，但是，如果在CSS 属性里包含了某些HTML 语法，就会造成问题，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="tag">some_descriptor</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(<span class="string">'http://www.example.com/</span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span><span class="tag">&lt;<span class="title">h1</span>&gt;</span>hi!');</div><div class="line">    }</div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如此这般，即使是放在了引号里，html对style 的解析也会提前结束，造成问题。</p>
<h3 id="重新同步的风险">重新同步的风险</h3>
<p>很明显的CSS 的发展之路，深受HTML 的影响，所以在CSS 的解析上，和HTML 一样存在着许多让人摸不清头脑的问题，比如，<strong>解析器碰到错误时，仍会继续工作直到碰到下一对匹配的尖括号或大括号括号恢复正常解析</strong>，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a {</div><div class="line">  fklj@#$%@$@!</div><div class="line">}</div><div class="line">img {</div><div class="line">  border: 1px solid red;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>尽管img 前边的解析的是错误的，仍然会正常解析img。利用这种特性，我们很容器就能想起一些攻击方式，比如对对某些浏览器输入一些有效的输入，对另一些浏览器，却能造成CSS 错误，利用CSS 解析器对出错CSS 的重新同步处理，到能导致一些特别的攻击行为诞生。</p>
<p>举个栗子，比如IE 的浏览器对CSS多行字符串文本支持，所以如果用户提供的CSS 字符串里边包含CR和LF 换行符的话，IE 是OK 的，所以网站开发者，不会对此进行过滤，但是对其他浏览器确实错误的，于是就导致了前边解析错误，只能解析后边恶意植入的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">some_selector {</div><div class="line">   content: 'Attacker-controller text...</div><div class="line">            } evil_rule {margin-left: -1000px;}';</div><div class="line">             }</div></pre></td></tr></table></figure>

<p>对于其他浏览器，由于前边的解析错误，css 会跳到恶意代码那里判定为正常代码执行。最简单的解决办法就是禁止它，不要对IE 姑息。</p>
<p>另外一些存在的问题是，CSS 之间兼容的we附体，比如一些老版本的解析不明白新版本的内容，比如CSS3 里的中括号，不过现在好像CSS3以前的版本已经绝迹，在此就不再赘述了。</p>
<h3 id="又见字符编码">又见字符编码</h3>
<p>字符编码似乎是围绕了整个Web 的问题，毕竟Web 是一个以内容交流为主要功能的平台，各种编码在所难免，问题也在所难免。</p>
<p>在CSS 中，为了在CSS字符串中使用一些保留字符或者有问题的字符，CSS 提僧了不太正统的策略。<strong>它使用反斜杠\ 后边跟1~6位十六进制数字</strong>的方式，再这样的策略下，比如字母e, 可以编辑成\65,\065,\000065, 一般来说，只有最后一种方法才不会产生歧义，比如说teak,编码成 t\65ak，就会转义成\65a。而css 避免这种情况的方法，不过是在每个转义序列后边加上空格。</p>
<p>存在安全问题是，很多CSS 解析器 竟然能够接受<strong>未被引号括起来的字符串里的任意转义序列</strong>，特别的在IE 中，转义的优先级还要高于伪函数语法解析，下边这样的结果是一样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">color</span>: <span class="tag">expression</span>(<span class="tag">alert</span>(1))</div><div class="line"><span class="tag">color</span>: <span class="tag">express</span>\028 <span class="tag">alert</span> \028 1 \029 \029</div></pre></td></tr></table></figure>

<p>甚至在IE 中，url() 中的反斜杠并不会解析成转义符，这仅仅是照顾那些URL 中输错了斜杠的用户的的感情~~~</p>
<h3 id="CSS_安全工程">CSS 安全工程</h3>
<ul>
<li>加载远程样式表时<ul>
<li>如果不做安全处理，就是将自身的安全性和远程样式表的域名绑在一起了，即使在样式表上下文禁止JavaScript，黑客仍然可以使用一些TCL键选择器，或者是引用url()，仍能窃取信息，尽管危险稍小。</li>
<li>如果感受到危险，宁愿去本地保存一份副本。</li>
<li>HTTPS 站点里，引用样式表也要使用HTTPS 协议。</li>
</ul>
</li>
<li>CSS 里包含有攻击者能够控制的信息<ul>
<li><strong>独立区块里的字符串和URL</strong>：请用引号括起来，对控制字符(0x00~0x1f)，以及斜杠尖括号中括号单双引号这些符号，尽量使用数字编码转义。</li>
<li><strong>在style 参数中的字符串。</strong>允许用户设置本身就是高度危险的，尽量不要这么做，即使做，也要按照上一条，做好转义。</li>
<li><strong>非字符串属性</strong>，直接使用白名单，只接受有限的输入。</li>
</ul>
</li>
<li>过滤用户提供的CSS<ul>
<li>不要保存或者产生可以用户控制的注释区，@ 指令等等。</li>
<li>验证选择器语法，不应该出现<strong>数字，字母，下划线，空格以外的字符</strong>；{ 之前的冒号，点号，都好位置要准确，否则就会引起css 解析混乱，黑客趁虚而入。或者是<strong>直接禁止复杂的选择器。</strong></li>
<li>解析和校验{…} 区块内的每个规则，可以的话，设置一个白名单，只允许你认为合法有效的规则进入。</li>
<li>如果不信任用户的输入，那最好只将他们限制在一个单独的框架里。</li>
</ul>
</li>
<li>HTML 标记里允许用户设置Class  值时，应当确保用户的CSS 设置不会和网站用到的Class 重名，或者是可以使用独立的命名空间前缀。</li>
</ul>
<hr>
<p>CSS 可以说完全吸取了 HTML 的混乱风格，在整个CSS 发展之路上，充满了风险。当然，CSS 所能造成的灾难在明面上看起来，相比于HTML 少很多，但是仍然不能小觑，因为配合着社工，黑客仍然能够建立起一次可怕的入侵。</p>
<h2 id="浏览器脚本">浏览器脚本</h2>
<h3 id="JavaScript_基本特点">JavaScript 基本特点</h3>
<p>JavaScript 的发展之路也是充满了崎岖，不再赘述，JavaScript 本身是一门相当简单的运行时解释语言，它的语法受到C 的影响，没有类的概念，有自动垃圾回收，有弱数据类型和动态类型的特点。 </p>
<p><strong>脚本处理模型</strong></p>
<p>前边也说了，对于JavaScript执行环境来说，就像一个沙箱，对每个在浏览器中的HTML 文档，都被赋予了独立的JavaScript 执行环境这些加载脚本的所有全局变量和函数都有一个独立的命名空间。</p>
<p>当然，看起来脚本隔离的规则非常的严格，跨文档的交互也必须非常显式的方式进行，和操作系统的进程隔离非常相似，不过其设计的范围还是远比进程隔离小，所以仍然会存在有一些可以利用的漏洞。</p>
<h4 id="模型的处理流程"><strong>模型的处理流程</strong></h4>
<p><strong>源码处理</strong></p>
<p>主要是检查脚本代码块里的语法，转换成中间层的二进制映像。在完成这一步骤之前，这些二进制代码不会对全局才造成影响，如果该阶段出错，那么整段问题代码都会被抛弃，继续解析下一段代码块。注意代码块之间除非正常解析，才会拼接在一起。</p>
<p><strong>函数解析</strong><br>完成了源代码处理的流程，解析器会对当前代码块里的所有具名的全局函数进行识别并注册。该阶段完成后，函数才会被执行代码调用。</p>
<p>注意每段独立的代码块并不是同时处理的，而是根据JavaScript 引擎读取代码块的先后顺序决定的，所以下边这样的写法是失败的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而下边这个写法是能够成功执行的，因为对hello() 的注册要先于第一行代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然而这样的全局名称解析模型只对函数有效，对变量却并非如此，和其他脚本语言类似，变量是按照执行出现的顺序注册的，所以下面的例子是错误的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><strong>代码执行</strong></p>
<p>由于JavaScript的异步性，在执行过程中，如果碰到错误，那些已经被正确解析的函数仍然能被调用，而且已经执行的代码产生的结果，对上下文仍然有效。</p>
<h4 id="执行顺序的控制">执行顺序的控制</h4>
<p>在同一个执行环境里，JavaScript 是按照时间顺序执行的，外部事件无法中断代码的运行，也不支持线程对任何共享内存的修改。大多数情况下，JavaScript执行时，整个浏览器至少HTML 渲染器部分基本处于不响应状态。</p>
<p>更进一步的说，JavaScript本身没有sleep(),或者pause() 这种暂停功能来释放CPU，如果希望延迟执行，需要注册一个定时器来延迟。而定时器里，也可以写一些内嵌的JavaScript代码。</p>
<p>任何死循环都会被中断退出，等价于一个未处理的异常。循环退出，引擎恢复到闲置状态，引起问题的代码仍然可以被调用，所有的计时器和事件句柄也会保持原样。</p>
<h4 id="代码和对象检视功能">代码和对象检视功能</h4>
<p><strong>检视功能</strong></p>
<p>对代码来说，对于非内置函数，可以通过toString() 和 toSource() 方法可以查看反编译后的源码。</p>
<p>对于程序运行流来说，没有多好的办法能够查看，勉强搜索本页的script代码等，但一般无法知道运行到或者是将执行到哪，在此推荐调试利器Firebug。</p>
<p><strong>eval()</strong></p>
<p>对于eval 中的文本语法错误或执行异常都会传递给调用eval 的函数。也就是说，语法解析无误后，执行过程中产生的未处理异常也会传递到调用 eval 的函数。如果没有问题，最后一行代码的执行结果将是eval 的返回值。</p>
<p><strong>延迟执行</strong></p>
<p>有多种机制可以实现延迟执行，包括定时器：setTimeout, setInterval；事件处理器: onclick, onload；HTML解析器自身的若干接口:innerHTML , document.write等。</p>
<p><strong>自省</strong></p>
<p>JavaScript的自省相对完备，可以使用常见的迭代器方式，也可以通过typeof, instanceof 或者全等符 === 或者length这样的属性获得额外信息。</p>
<h4 id="修改运行环境">修改运行环境</h4>
<p><strong>重写内置函数</strong><br>如果任由流氓脚本发挥，可做的坏事很多，删除，重写，或者屏蔽大部分JavaScript内置函数和所有浏览器的提供的I/O 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> = alert;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>

<p>这样的代码是没有问题的，但是在执行之后，Chrome,Safari，Opera 都会通过delete 操作符，删掉整个eval()函数，因为你已经重写了内置函数。</p>
<p>从此延伸开去，几乎所有的对象，包括内置对象，String，Array，都有一个能被任意修改的原型。这个原型是个master 对象，已产生的全体对象实例甚至包括还未产生的实例，方法和属性都衍生自这个主题。（此处是需要进一步学习的点）</p>
<p><strong>Setter Getter</strong><br>尽管他们不如C++ 里的运算符重载那么强大，但是这两个对象足以使得已有对象或者对象原型的行为变得困惑。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> evil_object = {</div><div class="line">    set foo() { alert(<span class="string">"hi"</span>); },</div><div class="line">    get foo() { <span class="keyword">return</span> <span class="number">2</span>; }</div><div class="line">    };</div><div class="line">    <span class="comment">/* 执行以下代码只会显示 hi.*/</span></div><div class="line">evil_object.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">/* 而此时，foo 并不等于1 */</span></div></pre></td></tr></table></figure>

<p>JavaScript 存在的潜在风险是，在特定的上下文环境里执行脚本，一旦受到了非新人内容的干扰，就没有可靠办法来检查其运行环境是否正确了。比如如果盲目信任了 location 对象，就可能导致一系列的漏洞。</p>
<p><strong>JSON</strong></p>
<p>关于JSON的话题很多,JSON 是对大括号的含义进行了重载，意味着JSON 区块里的内容不能按照独立的代码语句来执行。这样就可以防止&lt; script src=… &gt; 这样的方式进行跨站引用。</p>
<p>但是JSON 还是存在有注入风险，其中一个风险来自于eval, 有些开发者往往直接使用eval 直接来吧json 转换成js 对象，如果此时JSON 数据包中注入了恶意的数据，则直接就获得了执行。所以，正确的做法是应当<strong>分割出JSON 里包含的特殊字符，然后再解析为对象</strong>，比如下面，json2.js里的：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We split the second stage into 4 regexp operations in order to work around</span></div><div class="line"><span class="comment">// crippling inefficiencies in IE's and Safari's regexp engines. First we</span></div><div class="line"><span class="comment">// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we</span></div><div class="line"><span class="comment">// replace all simple value tokens with ']' characters. Third, we delete all</span></div><div class="line"><span class="comment">// open brackets that follow a colon or comma or that begin the text. Finally,</span></div><div class="line"><span class="comment">// we look to see that the remaining characters are only whitespace or ']' or</span></div><div class="line"><span class="comment">// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^[\],:{}\s]*$/</span>.</div><div class="line">test(text.replace(<span class="regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g</span>, <span class="string">'@'</span>).</div><div class="line">replace(<span class="regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>, <span class="string">']'</span>).</div><div class="line">replace(<span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>, <span class="string">''</span>))) {</div><div class="line"></div><div class="line"><span class="comment">// In the third stage we use the eval function to compile the text into a</span></div><div class="line"><span class="comment">// JavaScript structure. The '{' operator is subject to a syntactic ambiguity</span></div><div class="line"><span class="comment">// in JavaScript: it can begin a block or an object literal. We wrap the text</span></div><div class="line"><span class="comment">// in parens to eliminate the ambiguity.</span></div><div class="line"></div><div class="line">                j = <span class="built_in">eval</span>(<span class="string">'('</span> + text + <span class="string">')'</span>);</div></pre></td></tr></table></figure>

<p>JSON 得到了最普遍应用，另外预支竞争的有JSONP，JSONP 字面含义是填充式(padding)的JSON，它通过填充额外的内容把JSON 序列化包装起来，变成一段有效的可独立运行的JavaScript于珊珊，常见栗子包括函数调用(如 callback_funcition({…JSON data…})) 或者变量赋值(var return_value = {…json data…})), 但是这些序列化无法兼容JSON。parse()，必须使用不安全的eval.</p>
<p>而JSONP 这种的特点是使用第三方页面以&lt; script src=… &gt;形式加载这些数据时，解析不会出现错误。当然，这种情况实际上还会带来许多风险，《Web 之困》中的说明太过简单，在<a href="http://www.thespanner.co.uk/2011/05/30/json-hijacking/" target="_blank" rel="external">JSON Hijacking</a> 有更为详细的解读，以及这篇<a href="http://blog.csdn.net/hengyunabc/article/details/26305203" target="_blank" rel="external">闲扯Web安全之JSON</a>,对于其中的详细知识，还有一些漏洞，后边会继续扩充。</p>
<p>总的来说，注意这么几点：</p>
<ul>
<li>禁止手动拼接JSON字符串，一律应当用JSON库输出。也不应使用自己实现的ObjectToJson等方法，因为可能有各种没有考虑到的地方。</li>
<li>jsonp请求的callback要严格过滤，只允许”_”，0到9，a-z, A-Z，即合法的javascript函数的命名。</li>
<li>jsonp请求也要判断合法性，比如用户是否登陆（这点很容易被忽略）。</li>
<li>设置好Content-Type（这点对于调试不方便，但是提高了安全性）。</li>
<li>以jsonp方式调用第三方的接口，实际相当于引入了第三方的JS代码，要慎重。</li>
</ul>
<h3 id="标准对象层级">标准对象层级</h3>
<p>JavaScript 的运行环境都是围绕一个隐含的根对象构建起来的，这个根对象也是JavaScript程序里所有全局变量和函数的默认命名空间。</p>
<p>JavaScript 预设了一些层级模式的函数，用来实现浏览器环境里的输入输出功能，包括：对浏览器窗口的操作(open(),close(),moveTo(),resizeTo(),focus(),blur()等), JavaScript 定时器设置(setTimeout(), setInterval()等)，各种提示(alert(),prompt(),print())，以及一些浏览器开发商支持的函数等等。</p>
<p>同时，顶级对象还提供了上下文环境对象的JavaScript引用，比如父框架parent，顶层文档top, 当前窗口的源窗口opener，当前文档的子框架 frames[]，以及window和self。</p>
<p>顶级的对象结构里，除了Document 还有一些子对象，如下：</p>
<ul>
<li>location 对象： 包括读取当前文档URL 信息，或者专项新地址浏览的各种属性和方法。注意使用此对象时，新地址跳转会销毁上下文环境，同时对获取的字符串不要想当然的认为他们已经经过了转义。</li>
<li>history 对象： 不常用，能让每个窗口根据浏览记录前后切换移动，类似于前进后退。比如history.go(-1)</li>
<li>screen 对象： 检查屏幕和浏览器窗口大小等等。</li>
<li>navigator 对象： 查询浏览器版本，操作系统，插件列表等。</li>
<li>document 对象： DOM 不多说。</li>
</ul>
<p><strong>DOM</strong> 东西太多，一言难尽，其中包括转义方面的问题，注入的漏洞。等另开一篇文章讲。</p>
<h3 id="脚本字符编码">脚本字符编码</h3>
<p>JavaScript 支持很多常见的反斜杠方式的字符串编码，用于转义引号，HTML 标记 和内嵌在文本中的有问题的字符。</p>
<ul>
<li>对某些控制祖父使用C风格的表达式： \b 退格符，\t 水平制表符 , \v 垂直制表符， \f 换页符， \r 回车， \n 换行。</li>
<li>3位数字，不足位0填充，按照8位原字节八进制字符编码，无前缀。JSON 中支持此转义。栗子：\145 = e</li>
<li>2位数字，不足位0填充，8位元字节十六进制字符编码，前缀为x。栗子： \x65 = e</li>
<li>4位数字，不足位0填充，16位元字节十六进制Unicode 数值编码，前缀加u。 \u0065 = e</li>
<li>反斜杠后边跟非8进制数字，非第一条所说字符，非u 非x，可以使用反斜杠转义。就是直接的转义符。</li>
</ul>
<p>对于最后一条 值得注意的是，因为JavaScript 解析顺序要晚于HTML 解析，所以，不应该用这种方式来转义尖括号，和其他HTML 语法中的分隔符，这样HTML 解析完毕，再解析JavaScript，转义结束之后就会造成问题。这和CSS 问题一样。</p>
<p>同时以上各种方式，只有Unicode 转义方式可以用在字符串之外的位置，其他转义则不可以，而且在JavaScript里，转义编码只能出现在标示符部分，不能用在对语法有真正影响的符号上，比如括号。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\u006lert(<span class="string">"hello"</span>);</div></pre></td></tr></table></figure>

<p>上边写法是ok的，但是如果用这种方式替换圆括号或者是引号，就会失败。</p>
<h3 id="JavaScript_代码包含在哪里">JavaScript 代码包含在哪里</h3>
<p>JavaScript 代码经常包含在哪里呢？</p>
<ul>
<li>直接嵌入&lt; script&gt; 代码块。</li>
<li>通过&lt; script sr=… &gt; 加载代码。</li>
<li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li>
<li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li>
<li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li>
<li>定时器，Timer(setTimeout, setInterval)</li>
<li>eval(…) 调用。</li>
</ul>
<p>这也是所有可能发生漏洞的地方，比如定时器那里，考虑以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var value = <span class="string">"user_string"</span>;</div><div class="line"><span class="keyword">...</span></div><div class="line">setTimeout(<span class="string">"do_stuff('"</span>+value+<span class="string">"')"</span>, <span class="number">1000</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>

<p>表面上看他没有问题，对 value 只做一次转义就好了，但实际呢，考虑其解析过程，首先是HTML 解析出script 块，然后JavaScript 做第一次解析，检查setTimeout 语法，而等到1秒之后，才会解析do_stuff，如果不多做一次转义，就有可能构造成一次注入，比如user_string 中插入一个JavaScript编码的构造，截断前边函数，然后构造自己的攻击部分。</p>
<p>这种编码模式，看起来比较绕，但实际上也是JavaScript常出现问题的地方。</p>
<h3 id="安全工程">安全工程</h3>
<ul>
<li>加载远程脚本情况，和CSS 一样，这样做等于将自己和远程站点的安全性关联到了一起，所以一定要做好最高的安全措施。</li>
<li>解析从服务器端收到的JSON 数据，一定不要用eval 直接解析，或者是RFC 4627 里提供的基于eval的实现，尽量使用JSON。parse()。 特别是处理第三方返回数据时，这两种方式实际上都并不安全，可以参见前边所说的json2.js 的实现方式。</li>
<li>JavaScript 代码块包含用户输入数据的集中情况<ul>
<li><strong>&lt; script&gt; 代码块中的字符串</strong> ，依照常规，对所有控制字符（0x00~0x1f），\,左右尖括号，引号，用反斜杠加数字的形式转义处理，高位字符也应当转义处理。同时不要直接用用户提供的字符串组成HTML，选择安全的DOM 处理，也不要直接用用户提供的字符串组成参数然后传递给脚本执行功能的函数里，避免使用eval(), setTimeout() 方法。</li>
<li><strong>在独立脚本文件里的独立字符串</strong>：重点防范跨站。</li>
<li><strong>在事件处理器，或者javascript伪URL</strong>：在伪URL 里时，应当在这些位置出现用户提供数据时，做多重转义。而且尽量不要使用这种直接内嵌JavaScript 脚本的方式。如果做，首先进行JavaScript 转义，然后根据情况转义在进行HTML或者URL 参数编码方式编码。不要是用eval(),setTimeout()和 innerHTML .</li>
<li><strong>非字符串类型属性</strong>：白名单形式，并且对数字型数据进行严格验证。</li>
</ul>
</li>
<li>与客户端浏览器对象交互<ul>
<li><strong>客户端产生的HTML内容</strong>：不要使用 innerHTML, document.write() 或者是类似的处理方式，因为这样会造成跨站。构建HTML 文档，请使用 createElement(),appendChild(),安全的属性如：innerText, textContent.</li>
<li><strong>对用户控制数据的处理</strong>： 要先认为从客户端读取的数据都未经过正确转移，特别是如location 属性，以及一些外部URL来源数据，一定要自己做一些转移处理，不能直接传给自己服务器处理。</li>
</ul>
</li>
<li><strong>如果页面能加载其他用户控制的脚本</strong>，实际上，这样是极不安全的，一些可用的框架，或者是沙箱框架，可能会有帮助。</li>
</ul>
<hr>
<p>本来是想着一天写一篇的速度，刚刚好，今天看了CSS 部分，觉得内容很短，而且很多东西配合着 JavaScript看，会有一些收获，于是就把两章放在一起看了，这是个深坑，来自CSS 的问题尚少，都有迹可循，但是来自JavaScript 这个神奇的脚本语言的种种行为模式，思考起来就花费了一些时间，虽然之前JavaScript 有一些基础，但是作者短短几句指出来漏洞，倒是要花费我很多时间去思考这些漏洞到底是怎么构造起来的。</p>
<p>JavaScript 这门语言发展的太快了，而且Web 也发展的太快了，注定这是一个充满了危险的地带，再加上网络这个只用很短时间就从蛮荒时代走向了琳琅满目的东西，总是充满了各种残缺待补的东西，实际上，看如今的网络，似乎没有哪家的服务器没被脱过库了，被爆出来的也都是那些转过几手，拥有的人太多的库了。</p>
<p>由于Web 的漏洞可以来自语言，可以来自浏览器来自客户端，可以来自服务器，来自Web 程序，甚至是程序中一个小小的插件，这两天爆出来的imageTragick 漏洞，不过就是一个图像处理工具，一个小小的漏洞直接让黑客切入到心脏中。</p>
<p>而接下来的部分，也正是将流动在网络上的这些非HTML 文档，以及他们存在的风险，最后还有一个浏览器的插件。书写完成之后，将转入安全特性的探讨上，再次总结书写的过程，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML的纷争 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/04/HTML%E7%9A%84%E7%BA%B7%E4%BA%89-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/04/HTML的纷争-《The-Tangled-Web》/</id>
    <published>2016-05-04T03:31:30.000Z</published>
    <updated>2016-05-04T03:32:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 id="HTML_文档的基本概念">HTML 文档的基本概念</h2>
<p><strong>语法</strong></p>
<p>HTML 是标签组成的层级结构，文本穿插其中，而主要是使用无个字符进行约束和限制，<strong>左右尖括号，单引号，双引号，&amp;</strong>，所以说，HTML 里会有一些针对这些字符的规则：</p>
<ul>
<li>HTML 文档的绝大部分区域不应该出现单个「&amp;」符号。</li>
<li>HTML 标签内部不应该出现左右尖括号。</li>
<li>文本节点的左尖括号是危险的。</li>
<li>标签中出现引号字符串可能导致意想不到的效果。</li>
</ul>
<p>以上几条规劝，实际上就是在告诫这样书写的代码，随时会被攻击者抓住，利用代码的缺陷，构造XSS 或者是SQL注入。</p>
<p><strong>文档解析模式</strong></p>
<p>对于传统的HTML，解析器会修复大部分语法上的不合规，同时不区分大小写，参数值不一定要用括号括起来，某些标签可以隐式闭合，而对于XML 来说，标签必须严格匹配，区分大小写，可以整合其他兼容格式内容。</p>
<p>值得一提的是，对于HTML ，碰到某些标签后，会落入特殊模式，直到出现特定的终止字符才会退出状态。如style, script, textarea, xmp 直到出现反斜杠匹配，才会退出。</p>
<p>而对于XML，禁止出现单个「&lt;」和「&amp;」，还有一个特殊的语法，只要一”&lt;![CDATA[“字符串开头，以”]])”结束的，中间短路可以封装含有人以标签的任意原始文本数据。</p>
<p><strong>语义之争</strong>：Tim Berners-Lee 的语义网梦想，这里还是比较遥远，不做进一步探讨。</p>
<h2 id="HTML_解析器的行为"><strong>HTML 解析器的行为</strong></h2>
<p>对于XML 来说，不需要担心，因为解析器的错误几乎零容忍。但是，对于HTML 来说，简直就是灾难，为了最大程度的解析，HTML 会以各种让人摸不着头脑的大胆的方式猜测网页作者的用途。以下边这个标签为例：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-04-14623256480455.jpg" alt=""></p>
<p>先不考虑它没有闭合仍然正常被解析这件事，看各家解析器做出的各种支持：</p>
<ul>
<li>IE 浏览器允许吧空字节NUL（0x00） 插入到1位置</li>
<li>2，4的空白位置可以使用垂直制表符(0x0b)或者进纸换页符(0x0c)替换，令人惊奇的是FireFox 允许在2 用单个普通的正斜杠代替。</li>
<li>3，曾经WebKit 甚至允许此处有正斜杠使用。</li>
<li>位置5，在IE还能接受反引号。</li>
<li>被引号括起来的参数，后边实际上隐式的跟着一个空格符，所以位置6空格可以去掉。</li>
</ul>
<p>一个常见的攻击手段就是xss，此处借助title,我们将 hello world 替换成 hello world” onerror=”alert(1) 于是，对于原标签就变成了：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=image.jpg tile=<span class="string">"hello world"</span>onerror=<span class="string">"alert(1)"</span> <span class="keyword">class</span>=example&gt;</div></pre></td></tr></table></figure>

<p>很自然的一个脚本被我们植入进去了，一个xss 就被触发了。</p>
<p><strong>多重标签的交互</strong></p>
<p>在不正常的HTML 里，还会出现多个HTML 标签堆叠在一起，看起来就让人头疼，而浏览器在解析的时候，也会有区别，比如:</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i &lt;b&gt;</div></pre></td></tr></table></figure>

<p>大多数浏览器会先解析成<strong>‘&lt; i &gt;’</strong> ，而把&lt; b 视为无效的标签参数。</p>
<p>另外，整个文档结束时候标签未闭合的情况也让人摸不清头脑。比如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i foo=<span class="string">"&lt;b&gt;"</span> [EOF]</div></pre></td></tr></table></figure>

<p>大多数浏览器解析为i 的标签，或者是整个忽略掉，但对于IE 和 Opera 却从后往前处理，把这一串理解成 b 的标签。</p>
<p>所以假如攻击者，可以阶段加载的页面，就可以通过构造手段，让浏览器解析成完全不同的内容。</p>
<h2 id="HTML_实体编码">HTML 实体编码</h2>
<p>（由于MarkDown语言里，自动把这些编码识别出来了，包括尖括号，只好中间加空格或这种方式来书写。）</p>
<p>hTML 的实体编码格式是以&amp;开头，以分号结尾，在HTML 规范里，散步着无数这样的命名实体，比如&amp; lt; 插入左尖括号，&amp; gt;用于插入右尖括号，&amp; amp; 替换 &amp;符号自身。&amp; rarr; 代表一个Unicode箭头等等。</p>
<p>除了命名实体，还可以插入任意十进制ASCII 或者 Unicode 字符编码，样式是 &amp;#数字；<br>例如 &amp;# 60; 被识别成左尖括号，&amp;# 62; 别识别为右尖括号。而十六进制的标记符在这在编码前边加一个x,所以 &amp;# x3c; 仍然是一个左尖括号。</p>
<p>对于HTML 来说，解析器能识别在文本节点和参数值里边的实体编码，在创建文档树的时候，透明的对这些编码进行解码。</p>
<p>但是有一点疑惑的是，在识别和解析HTML 实体任务重，有一些奇怪的解析，比如传统解析中，只要实体名称后边跟着的字符不是字母数字，即使是少了分号，实体名还是被接受了。对于数字型的实体，后边可以跟任意多个0，导致一个超长的数字串，会造成出错。</p>
<h2 id="HTTP/HTML_交互语义">HTTP/HTML 交互语义</h2>
<p>一般来说，我们会在HTTP 的头域指定内容的一些信息，比如Content-Type, Content-Disposition, Transfer-Encoding等等，然而考虑如果我们不适用HTTP 传输HTML，甚至是直接从本地加载HTML，就不能依靠HTTP 的头域来确定编码等信息了。如果缺了像 MIME type 或者字符集这样关键参数，就会破事浏览器随意处置文档的编码解析问题。</p>
<p>解决办法就是文档开头声明&lt; meta http-equiv=…&gt; 指令进行编码设定，一个典型的指定是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></div></pre></td></tr></table></figure>



<p>如果多个http-equiv冲突，或者从服务器端返回HTTP 头域有冲突的话，浏览器表现就会很不一致，一般优先支持hTTP 响应头，然后支持第一个出现的charset。</p>
<h2 id="超链接与内容包含">超链接与内容包含</h2>
<p>这一块是XSS 的重灾区。</p>
<p>一个单纯的HTML 链接写法是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.example.com/"</span>&gt;</span>click me!<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>对于这个超链接，它支持指向浏览器支持的所有协议，包括伪URL，如data: javascript:。</p>
<p>同时，该语法可选的target参数有四种，<strong>_blank</strong>总是打开新窗口；<strong>_parent</strong> 转到包含发出当前链接文档的上一级视图；<strong>_top</strong> 转到浏览器最顶级窗口。<strong>_self</strong> 和没有设置这个值一样。</p>
<p><strong>表单和表单触发的请求</strong></p>
<p>XSS 重灾区。</p>
<p>一个典型的表单写法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">GET</span> <span class="attribute">action</span>=<span class="value">"/process_form.cgi"</span>&gt;</span></div><div class="line">名字：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">given</span>&gt;</span></div><div class="line">姓氏：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">family</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">submit</span> <span class="attribute">value</span>=<span class="value">"完成后提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></div></pre></td></tr></table></figure>

<p>值得注意的是，form 彼此不能嵌套，如果嵌套了，只有最外层的有效。</p>
<p>如果method 为GET，那么包含的字段名称和他们的值，会以百分号编码机制转义，但其中空格(0x20) 会被以加号代替而非%20,而所有的加号被编码成%2b 。经过编码的「名称=值」数据对用&amp; 连接付分割，组成完整的字符串。</p>
<p>如果method 是POST，分几种情况：</p>
<ul>
<li>默认情况下，application/x-www-form-urlencoded 编码方式，信息组成方式与GET 方式相同，不同的是数据会放在请求头的数据体部分提交，目标URL 查询字符串和其他部分保持不变。<strong>潜在的问题，如果查询字符串和POST 数据体参数相同，冲突，可能会造成HTTP 参数污染</strong></li>
<li>额外的把form 标签中的编码设置为enctype = “text/plain”。而采用这种做法，字段的名称和值不会以百分号编码方式进行编码，某些浏览器可能会把空格替换成加号，而原来用于分割的&amp; 以换行符替换。因此，这样格式的数据，无法明确的对赎金进行解析，因为无法完全区分换行符和等号是表单带进来的，还是浏览器加入的。</li>
<li>entype = “multipart/form-data”，通过表单提交用户选择的文件时候，要用这种模式，会产生一系列较短的MIME 消息，对应于提交的每个字段。然后每个字段会有一个由哭护短选择的特定符号分割。</li>
</ul>
<p><strong>Frame 框架</strong></p>
<p>其作用是使HTML 文档内嵌和显示另一个页面中，有独立的文档视图，甚至独立的JS 环境。对于src 值的限定，与其他链接的规则基本相同， 所以 iframe 也是一个安全隐含。</p>
<p><strong>其他特定的内容</strong></p>
<p>包括图片，层级样式表，客户端脚本，插件内容等等，这些不再赘述，他们都有XSS 的风险。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>良好的规范，良好的规范，良好的规范，毫无疑问要确保输出统一的、有效的、浏览器支持的Content-type 响应头和 charset 字符集信息，以免文档不能按照原有意思解析。</li>
<li>文档包括可被控制的信息时，应当充分考虑到漏洞的可能。<ul>
<li>针对文本部分里用户提供内容：应当以实体编码方式处理左右尖括号和&amp; ， 以及其他的各种ASCII等编码问题。同时，某些Unicode 元字符 U+202E 可能会改变之后文本的显示方向和顺序，<strong>是不是想起了微信</strong>。</li>
<li>针对style 和 on* 标签参数，要做多重编码转义处理，但这种处理往往又有可能出错，所以处处小心。</li>
<li>其他的HTML 参数值，对攻击者能够控制的输入，总是用引号来括起来，对左右尖括号和&amp; 以及任何<strong>单独出现的引号</strong>都要进行实体编码。同时，不要对URL 或其他参数有问题的值做黑名单验证，反而会造成脚本执行漏洞。</li>
<li>特殊的解析模式下，如script, style 区块里的内容，仍然是仔细处理引号字符串，左右尖括号，所有非打印字符都应做好合适的转义处理。</li>
</ul>
</li>
</ul>
<hr>
<p>HTML 部分写完，但是要想完全搞清楚HTML 编码部分的问题，简直是一件不可能完成的任务，曾经有本书叫《Web Application Obfuscation》，它企图创建出能拦截所有已知的危险模式的过滤器，同时又不会影响到其他段落的正常功能，而实际上，这是不可能完成的任务。</p>
<p>一个良好的方法是用一个解析器，把输入的文档翻译成放在内存里的层级文档树，然后去除掉那些无法识别的参数和标签，和所有不需要的标签、参数、参数值。然后在对文档树进行良好的排序和转义，这样看起来要方便和清晰许多。</p>
<p>另外，HTML 中存在问题，造成最大的影响就是XSS 和CSRF 这两个攻击手段，攻击者会绞尽脑汁的绕过开发者设置的层层障碍，他们的最终目的无论如何，都是试图通过各种混淆的代码，让解析器理解成其他意思，达成攻击效果。而XSS 的三种攻击模式，反射型，储存型，DOM 型，都是在这些修修补补的篱笆上找一个足以穿越过去的漏洞。</p>
<p>在配合上HTTP 的问题，可以创造一切可能，对于XSS 的世界，脑洞有多大，可能有多大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 i]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 2)把XSS放进脚本 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-2-%E6%8A%8AXSS%E6%94%BE%E8%BF%9B%E8%84%9A%E6%9C%AC-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-2-把XSS放进脚本-XSS升级之路/</id>
    <published>2016-05-03T13:29:18.000Z</published>
    <updated>2016-05-03T13:29:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 1)无过滤规则的XSS -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-1-%E6%97%A0%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E7%9A%84XSS-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-1-无过滤规则的XSS-XSS升级之路/</id>
    <published>2016-05-03T13:26:29.000Z</published>
    <updated>2016-05-03T13:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这一块知识聚拢一下，写成一篇文章。想了想，从简单到难，那就是一条打怪升级之路，所以就从最简单的反射型漏洞开始，一点一点提高，直到把大部分XSS 的形式找出来。</p>
<h1 id="level_1_无过滤规则的XSS">level 1 无过滤规则的XSS</h1>
<p>最简单的跨站，也就是我们说的反射型跨站，也叫作非持久型，参数型跨站脚本。这种类型的脚本出现的面非常的广，互联网上这样的漏洞非常多，一般出没在各路小站点，大站点很少出现。乌云的漏洞列表里，海量的XSS 漏洞都来自互联网上访问量不高的小站，被辛苦挖洞的XSSer 们发掘出来的。</p>
<p>站在新手村我们的，需要一个最简单的野怪刷一下，这个野怪上下无任何装备，没有一点防御。也就是说，这个XSS 漏洞对于用户的输入，不做任何过滤行为。</p>
<p>一般来说，XSS 存在的地方，一定是需要有输入和输出概念的，一般的过滤规则，也是出现在输入阶段或者是输出阶段，如果两个都没有过滤，那么很轻松的就造成了漏洞。通常来说，这种洞非常好刷，比较自动化的方式是，建立一个爬虫系统，预设一些URL，爬虫爬取网页，在网页源码中寻找用户可以输入的地方，然后在可以输入的地方，将构造好的XSS 代码以输入形式，构造成请求，然后观察响应，是否对我们的输入做了过滤策略。如果是原本的返回，那么我们就说可能存在有xss漏洞。</p>
<p>同时，有另一种更为简单的漏洞，是直接在URL 中，如果有直接赋值参数的行为，也相当于一个可输入的位置，我们直接在URL 中将XSS 代码构造在URL 中，观察返回是否做了过滤处理，如果没有，那么就是一个最简单的野怪诞生。</p>
<p>在乌云中，有不少这样的漏洞，小站很多，大站很少，因为大站一般都有完备的过滤规则，很难在这些小问题上有任何闪失，再加上如今浏览器基本上都有安全策略对此类型进行防御，所以这种威力相对较小。</p>
<p>之前在HTTP 的文章里，有详细讲过 URL的格式，其基本格式如此：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622667602815.jpg" alt=""></p>
<p>每个结构对应的含义如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<p>通常的注入发生在query 这一块，而一般一个安全的行为，就是对query 中的字符进行过滤，以防止xss。以百度的URL 为例，一个通常的URL 查询之后的造型是下面这样的：</p>
<p><a href="http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969" target="_blank" rel="external">http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969</a></p>
<p>问号之后有一大堆参数，&amp;用来分割参数，他们对应的是什么意思不是本文关注的重点，可以参见这一篇文章<a href="http://www.biaodianfu.com/baidu-url-secret.html" target="_blank" rel="external">百度搜索URL 参数解析</a>。</p>
<p>其中wd 就是我们所说的搜索关键词，也就是我们的输入，如果我们将此字符改成</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>在输出时我们看到，URL 变成了如下，可疑的部分被转义了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.baidu.com/s?wd=%22%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&rsv_spt=1&rsv_iqid=0xb3f5d3380002c15f&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&oq=%26lt%3Bscript%26gt%3Balert(%26%2339%3Bxss%26%2339%3B)%26lt%3B%2Fscript%26gt%3B&rsv_t=455e8xS9GVGwfM%2BTxjkNH6uUohEOPZHQFWlqocmOh9s1caJr5IHzVrPJJKJ1OwdTglc3&inputT=5478&rsv_sug3=27&rsv_sug1=21&rsv_sug7=100&rsv_pq=cce2beda0002a800&rsv_sug2=0&rsv_sug4=6278</span></div></pre></td></tr></table></figure>

<p>在这里举一个大站腾讯的简单的xss，是乌云上某马甲提交的，作为一个最简单的XSS 挖给大家学习。网站的网址是这样的：<br><strong><a href="http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886" target="_blank" rel="external">http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886</a></strong></p>
<p>如果我们在这个URL 里尝试修改参数，将score 参数改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>

<p>而输出的源码并没有发生变化：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673299696.jpg" alt=""></p>
<p>在网易中看到的结果就变成了这样：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673544485.jpg" alt=""></p>
<p>这很显然，就是一个xss漏洞了，将经典的xss 代码插入进去即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score=<span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">1</span> <span class="attribute">onerror</span>=<span class="value">alert(1);</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622674130351.jpg" alt=""></p>
<p>这就是一个最无防御的XSS 存在，很明显的，它简单，暴力，当然也是极容易防御的，所以在一个较高级的攻防对抗，或者是大站漏洞中，基本上不会出现这样的漏洞（然而腾讯还是有这样的问题~~）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP许多事-《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/03/HTTP%E8%AE%B8%E5%A4%9A%E4%BA%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/03/HTTP许多事-《The-Tangled-Web》/</id>
    <published>2016-05-03T01:26:05.000Z</published>
    <updated>2016-05-03T01:26:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提供任何额外的元数据交换空间</strong>，其过程非常的简单，只有一行，客户端的请求只有一行，比如以GET 开头，后跟URL 路径和查询字符串，CRLF结束，服务器端接到后立刻返回HTML 数据。</p>
<p>所以，这个版本上，有很明显的缺陷，比如无法根据浏览器用户的首选语言或者文档类型进行交互处理，找不到请求文件或返回内容不是HTML的话，无法通知客户端，比如不能做到在一个服务器用一个IP 支持多个不同主机名的网站。</p>
<p><strong>HTTP/1.0 &amp; HTTP/1.1</strong></p>
<p>下面这两个版本，修正了这些问题和缺陷，其格式在之前的HTTP 详解里，已经介绍过了，请求头里包括了具体版本信息，和许多以键值对形式存在的数据，同时一个单独的空行代表结束。响应头则包含了包含协议版本，响应码，状态信息，和一些其他的键值对形式存在的响应信息，同时以一个空行结束，随后才是要返回的具体资源。</p>
<p>很显然，这一版本就成熟了许多，但是协议里有一个要求，HTTP/1.0 的客户端必须能够理解HTTP/0.9 ，这看起来是一种向下兼容的表现，但实际上会带来许多恶果，如果攻击者想要攻击某个HTTP 客户端，攻击者会试图令客户端HTTP 降级，采用0.9的模式，而这种模式下，十分危险，返回给客户端的文件，然而在0.9中，返回的内容只有请求的文件本身，无法从这些回应的内容里，表明响应方确实可以理解HTTP 协议，以及返回内容是否是真的HTML 文件。</p>
<p>这让我想起了SSL 里的安全问题，也是由于SSL 3.0 需要向下支持SSL 2.0 ,而SSL 2.0 中存在有严重的漏洞，所以攻击者会故意引起降级到SSL 2.0，寻找漏洞。到后来，进步到TLS后，SSL 3.0也不被信任了。</p>
<p><strong>换行处理</strong></p>
<p>这是一个小细节，HTTP/1.1 要求客户端不仅要接受CRLF 和LF 换行模式，还要接受CR，然而不同的浏览器和服务器却又有不一样的支持情况，比如Apache 就不接受RFC 这条建议，而FireFox以外的客户端都能接受。</p>
<p>所以，开发人员在处理HTTP 头域的时候，不仅要考虑LF，CRLF，还要考虑CR 字符。不然就有可能产生漏洞利用，也就是在头域中注入CR ，响应拆分。</p>
<p>另外一个不安全的小细节是，HTTP/1.1 要求支持多行请求头，也就是以一个空格开头的行，认为是接上一行的内容。但是这一规定，有些浏览器和服务器支持，有些却并不支持，比如IE ，Opera 等等都不支持。这种混乱，就会造成漏洞，不过这种攻击可能性比较低一些，我也没想到它能造成什么严重的影响。</p>
<p><strong>经过代理的HTTP 请求</strong></p>
<p>这一块在HTTP 详解那里，只对代理这一部分做了基础的了解。使用代理的原因有很多，比如为了提高性能（缓存），强制某些网络的访问策略（禁止）或需要以代理方式接入某些独立的网络环境等等。</p>
<p>相比于普通语法格式，有一些不同：<strong>第一行URL 是一个完整的URL</strong>，而在Host 中也要标识出主机名，这看起来是重复的，但实际上两者是两套机制独立发展起来的，<strong>当Host 与 URL 不匹配时，代理服务器以URL为准，或用特定的URL-Host 数据对和缓存内容关联</strong></p>
<p>同时，代理服务器还允许浏览器获取非HTTP 类型的资源，比如FTP 文件或者目录。这种情况下，数据返回给用户之前，代理服务器会把HTTP 响应里返回的内容先封装整理，转换成HTML格式。而如果服务器不便于查看数据，就另做处理了。也就是Connect 方式，这样代理服务器就会进行盲转发。当时，盲转发中间存在一个疏忽，不过已经解决，处理代理服务器返回的非加密错误响应信息时，浏览器会认为是目的服务器返回的。</p>
<p>另外有一些代理服务器并不适用HTTP 方式和浏览器打交道，这些代理为了缓存内容或者强制执行某些规则，会需要检查HTTP 过程中的信息交换。比如一个透明代理，它拦截TCP/IP 层流量，但是它能看到连接的目标端IP，和主机头Host信息，但是它并不能确认，要连接的目标端IP 是否真的和Host 设定的服务器名称匹配，除非去做一次查询，确定两者是否相关，否则客户端和服务器串通好久回对代理服务器造成影响。比如，如果不检查，攻击者可以向代理服务器要求连接自己的服务器，但发送的是一个故意误导的代理的Host头，www.google.com ，这样，那些想要访问www.google.com 获得的可能是错误缓存的响应内容。</p>
<p><strong>重复或者有冲突的头域的解析</strong></p>
<p>一句话，不同的浏览器和服务端都有不同的处理，而且在协议中，对此的描述也有很多小的疏漏，比如同时有用HTTP/1.0 和1.1 相同功能但是不同名称的头域，应当如何处理，比如EXPires 和 Cache-Control。</p>
<p>另外，比如第一行的URL 和 Host 冲突时候，应当怎么处理，文档要求是不要理会Host, 但是Host 必须存在。</p>
<p><strong>以分号作分隔符的头域值</strong></p>
<p>有一些HTTP 头域，比如Cache-Control 或者Content-Disposition ，可以使用分号来分隔在同一行里的几对独立的’名称=值’数据组，允许使用这种嵌套语法，可以更加有效率和直观。</p>
<p>同时RFC 里规定了某些使用场景，这种数据组里等号右边的参数可以使用Quoted-String(双引号括起来的任意可打印字符组成的字符串，支持分号和空格)。</p>
<p>但遗憾的是有些浏览器对该语法的支持并不好，比如IE，他不能支持分号，如果””中存在分号，有分号的地方就会被截断，造成安全漏洞。</p>
<p>还有一个问题并有做统一规定，就是多次出现的名称=值，名称如果相同，应该如何处理，不同的浏览器和服务器做了不同的处理。一般以第一次出现的值为准。</p>
<p><strong>头域里的字符集和编码策略</strong></p>
<p>这又是一个令人头疼的地方，因为规则混乱，处理方式混乱，甚至可以说，没有任何一套编码方式能同时为所有的浏览器所支持。书里只是简单的举例说明了这个编码有多混乱，记录如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14620909259094.jpg" alt=""></p>
<p><strong>Referer头域的表现</strong></p>
<p>Referer 头域里包含的是，哪个URL 地址触发了对当前网页的访问，Referer头域都纠错处理有一定的帮助，但是这个头域也会泄露一定的信息，还会暴露引用页面的查询字符串参数等。</p>
<p>一般情况下，在HTTP 头域都会出现，但除了一下集中情况：</p>
<ul>
<li>地址栏直接输出新的URL</li>
<li>浏览器动作是由data: 或者javascript: 伪协议触发的</li>
<li>当前请求来自Refresh 响应头</li>
<li>从加密站点到非加密站点，<strong>注意虽然有此措施，但是还会有信息泄露（未明）</strong></li>
<li>用户可以通过调整浏览器设置或者安装隐私保护插件，选择不发送或者干脆伪造一个来源。</li>
</ul>
<h2 id="HTTP_请求类型">HTTP 请求类型</h2>
<p>这一块比较清楚，但是其中包含的各种问题有一些之前没有想到过。在此简单列举：</p>
<ul>
<li>GET 本来RFC 只要求GET 只用于索取信息，但现在浏览器和服务器基本上都依靠GET 来更多的操作。同时，Range 请求头域代表非连续请求字段，也叫断点续传。</li>
<li><strong>POST</strong>，将客户端提交的信息传递给服务端，由于POST 的动作，可能带来持久性的副作用，所以浏览器在重载包含POST 方式的数据时，浏览器都会健身的向用户确认。但POST方法，有很多服务器是默认拒绝的。</li>
<li><strong>HEAD</strong> 和GET 方向类似，但只返回头域，一般是用来自动化测试等。</li>
<li><strong>PUT</strong> 向服务器特定URL 上传文件，但是大部分浏览器都不支持该方法，一般使用POST 完成。同时，某些服务器在配置上的错误，可能导致支持PUT 请求，这也会产生安全问题。</li>
<li><strong>OPTIONS</strong> 元数据请求，返回其所支持的所有方法列表。在提议阶段的跨域请求授权协议的基础。</li>
<li><strong>DELETE</strong> 与PUT 类似。</li>
<li><strong>TRACE</strong> 主要用于在安全测试中，揭示远程网络的内部架构的。所以，这一般用户用不到，一般被禁止了。</li>
<li>CONNECT 通过HTTP 代理服务器建立非HTTP 类型连接时使用。该指令不能直接发送给目标服务器<br>，如果特定服务器上不小心设置了支持CONNECT，可能会造成安全问题，攻击者可以通过他进一步攻击。</li>
</ul>
<h2 id="HTTP_响应码">HTTP 响应码</h2>
<p>同上，此处也做过详细解释，RFC 文档里列出了几十种状态码，但是常用的大约15种，而其他的一般是为未来准备的。这些有用的，列举如下：</p>
<ul>
<li>200 OK。没什么说的</li>
<li>204 No Content。无内容，说明请求已经执行成功，但是不做任何响应。</li>
<li>206 Partial Content。部分内容，根据Range 设置返回部分请求内容。</li>
<li>301 Moved Permanently。永久移动。</li>
<li>302 Found。 找到</li>
<li>303 See Other。 参见其他。以上三个响应码都意味着，重定向同时给出新地址，一般会在Location 响应头指出。如果是POST 请求，一般会替换成GET 方法，去除POST 数据体部分，并重新发送一次。</li>
<li>304 Not Modified.无变化，告诉请求者现在请求的文档和之前请求的没有变化，该响应信息会根据If-Modified-Since 头域的设定，对最后修改时间进行条件判断。</li>
<li>307 Temporary Redirect 。 临时重定向，与302类型，但是307 方法下，浏览器不会吧POST 重置为GET 方法。</li>
<li>400 Bad Request.不合规范的请求，服务器不愿或者不能做出回应，更详细的有 411 Length Required。405 Method Not Allowed.414 Request-URL Too LOng.</li>
<li>401 Unauthorized 未授权。</li>
<li>403 FOrbidden.禁止访问。文件存在但是不允许访问。</li>
<li>404 Not Found. 文件找不到</li>
<li>500 Internal Server Error 内部服务器错误，503 Service Unavailable 服务不可用。 </li>
</ul>
<h2 id="持续会话和分段数据传输">持续会话和分段数据传输</h2>
<p>持续会话应当注意，使用KeepAlive 会话时，响应端要包含一个Content-Length 头域，用于判断还有多少数据，有可能遇上拆分漏洞，也是前边所提到的[CR][CRLF]等等的处理品混乱。</p>
<p>对于分段数据传输，RFC 提供了 Transfer-Encoding:chunked 功能，协议里讲，只要可能，产生的数据立刻作为部分内容先发送出去，单独传输的每部分长度，都以16进制整数标识放在一个单独的行里，但是整个文件的长度是不确定的，知道出现下一个0字节标志整段结束。</p>
<h2 id="缓存机制">缓存机制</h2>
<p>RFC 里说，如果没有其他服务器端指令，客户端可以默认装若干的GET请求的HTTP响应码进行缓存，只要请求方法和URL 一致。</p>
<p>当响应被缓存后，客户端都会在重用之前判断是否需要验证和重载内容。通过Data/If-Modified-Since 和 ETag/If-None-Match 判断是否重用。这些是隐式的缓存机制，存在一些问题，比如我们通过以上两组的搭配，在结合Cache-Control: private ，能方便的获得浏览器在一段时间内的访问规律和习惯。甚至，如果讲一个字符串标记嵌入和缓存的JavaScript 文件中，然后在访问该文件时候，如果请求头里包含了缓存条件，一律答复 304 Not Modified 。</p>
<p>为此，服务器更倾向于使用显示的HTTP 缓存指令。但是HTTP/1.0 和 1.1之间的处理方式有不同。</p>
<p>1.0中提供的是Expires响应头，判断Expires He  Date 之间的联系，文档没有详细的说明，不同的浏览器处理不同，FireFox，Opera 根据两者的差值，其他浏览器则是Expires和缓存服务器的系统时间进行相比。</p>
<p>同时，1.0中还提供一个Pragma: no-cache ，代理服务器如果收到该请求头，就会重新抓取。</p>
<p>1.1 中，则是在Cache-Control 中承载缓存指令，有四种区域：<strong>public</strong> 可以被公开缓存的文档。<strong>private</strong> 代理服务器不得缓存文档。<strong>no-cache</strong> 可以被缓存，不能被重用（仅能用于后退前进）。<strong>no-store</strong>, 不缓存。</p>
<p>1.0 和 1.1 处理方式的不同，造成了服务器和客户端在处理上，必须两者都兼容。</p>
<p><strong>HTTP 缓存带来的安全问题</strong></p>
<p>攻击者可以通过拦截对某些URL 的请求，想受害者返回被篡改，并且长期缓存的请求内容，这样收到污染的浏览器缓存如何在受信任的网络上被重用，被注入的内容可能就出人意料的重新浮现。甚至，攻击者可以精心选择一些敏感域，然后在其他上下文环境中再引用这些域的内容。</p>
<h2 id="HTTP_cookie">HTTP cookie</h2>
<p>cookie 是四种全局授权方式之一，其他三种是HTTP 认证，IP检查， 客户端认证。</p>
<p>cookie 是通过Set-Cookie 响应头进行设置的,其基本参数之前列举过，现在简单陈列：</p>
<ul>
<li>Expires Cookie过期时间</li>
<li>Max-age  另一种建议的过期时间</li>
<li>Domain  Cookie 的有效范围，与安全会有关联。</li>
<li>Path ，允许Cookie 在特定的请求路径内有效</li>
<li>Secure 禁止以非加密形式传输Cookie.</li>
<li>HttpOnly 禁止JavaScript的doccument.cookie API 的方式读取Cookie.</li>
</ul>
<h2 id="HTTP_认证_和_SSL">HTTP 认证 和 SSL</h2>
<p>HTTP 认证现在很少有人用了，而且会有401钓鱼的风险。</p>
<p>SSL 部分参见另一篇博文。</p>
<p>值得注意的是，出于方便和降低成本的考虑，某些机构现在只需要一张信用卡，在目标服务器放一个用于完成验证的文件就能够获得证书。这种做法导致了证书中除了cn 和 subjectAltName 两个字段，信息都不再可信了。</p>
<h2 id="安全工程">安全工程</h2>
<p>处理Content-Disposition 头域中用户提供的文件名，如果不需要非拉丁语系的文件名，通常只保留字母数字和<strong>. \ - _</strong>  ，其他字符一概移除。为了保证用户免遭有害或者欺骗文件，至少保证文件名的首字符是字母或者数字，并把所有最后一个句号外的其他句号一律用其他字符代替。</p>
<p>如果而需要用到非拉丁语系的文件名，按照RFC 文档昨说，根据浏览器的情况使用百分号编码的URL 形式作为文件名，确保过滤控制字符(0xxx~0x1f) 和对任何分号，反斜杠和引号进行转义。</p>
<p>在处理<strong>HTTP cookie 里的用户出入信息</strong>，应当对字母和数字以外的所有字符进行百分号编码，或者干脆使用base64, 因为那些引号，控制字符(0x00~0x1f)，高位字符（0x80~0xff），逗号，分号，反斜杠都可能导致Cookie注入，或是当前Cookie 含义发生变化。</p>
<p>在发送<strong>用户提供的Location 头域</strong>，应对提供的URL 进行解析和规范化处理，确保URL 对应协议的允许的白名单上，以及重定向到的指定主机是安全的。同时确保任何控制字符和高位字符得到了恰当的转义。</p>
<p>在发送<strong>用户提供的Redirect 头域</strong>，遵从与Location 主机头一样的建议，注意在这里，分号也是不安全的，而且没办法的进行可靠的转义，而分号在某些特定的URL 里又有特殊的含义，应当干脆杜绝这样的URL 或者对分号进行百分号编码。</p>
<p>构建其他类别的用户输入请求或者是响应时，一定要<strong>进行语法检查，排除头域可能导致的副作用</strong>，重点注意控制字符，高位字符，逗号，引号，反斜杠，分号。<strong>创建新HTTP客户端，服务器或代理时</strong>，一定要注意上述那些问题。</p>
<hr>
<p>HTTP 这一部分，算是吧基础的知识又一次串了一遍，很明显的，所谓Web 安全问题，都是围绕 HTTP展开的，因为任何web的交互，基本上都需要使用HTTP 协议。本篇提到的，我觉得迷惑点最多的还是混乱的编码模式，由于很难搞清楚各种编码的真谛，何处支持何种编码，拒绝何种编码，才能真正的解决那些通过各种构造形式的攻击，所以，关于编码，后边我还会再做讨论，当然，我感觉这是一个漫长的工作量，因为在任何一个犄角旮旯里，都会藏着对Web 致命威胁的点。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从URL 开始 --《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/04/29/%E4%BB%8EURL-%E5%BC%80%E5%A7%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/04/29/从URL-开始-《The-Tangled-Web》/</id>
    <published>2016-04-29T03:19:19.000Z</published>
    <updated>2016-04-29T03:20:59.000Z</updated>
    <content type="html"><![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br><a id="more"></a><br>这也是一本疯狂的吐槽书，在作者的眼里，整个Web 应用界，混乱不堪，看似繁荣却处处都是破绽，而且确实如此，因为作者随随便便便发现了数百个安全漏洞。</p>
<p>所以我以逐章节的形式，写自己的读书笔记，希望在阅读和反刍的过程中，收获到更多的信息，构建起更完善的知识体系。</p>
<h1 id="这里放一个前言">这里放一个前言</h1>
<p>Web安全为什么存在，是因为它沉寂的太久，而又崛起的太快，崛起的过程中，各方势力互相角力，争议不断，浏览器的厂家拥有强势的决定权，W3C 理事会又缺乏足够的控制能力，组织内部又常常意见不统一，造成了Web 一路发展过来，有许多千奇百怪的新东西出现又消失。再加上天然的Web 的强交互本质，其在安全上存在的风险是巨大的。</p>
<p>首先，用户是Web 应用的使用者，而大部分缺乏安全素养的个人用户，在使用Web应用的时候，怎么可能会去关注那些林林总总的安全风险问题，所以，首先web应用不应当寄希望于将安全的决策权交给用户，然而这一点上浏览器上做的并不好，虽然在逐渐改进，但是有很多忽然跳出来的选项，跳出来的专业词汇，对于小白用户来说就是一个灾难，大多数情况，小白一般就会忽略这些安全风险提示，直接操作到最后。</p>
<p>其次，Web 运行环境难以隔离，各类相关数据杂糅在一起难解难分，在其他领域，数据对象，用户层应用，操作系统内核之间界限清晰，每个应用程序的进程各自独立，相互通信，输入输出都要靠系统内核进行调配。然而在浏览器中，却不存在这样的隔离，<strong>文档和代码交融在一起，无关的应用之间无法完全隔离，因为他们常常使用了相同的全局JavaScript运行环境</strong> ，这也就造成了诸如跨站，CSRF等等的攻击。</p>
<p>同时还有一些不言而明的缺陷，比如缺乏一个统一的安全体系，在浏览器领域，<strong>同源策略</strong>算是他的一个核心安全范式了，但是这种同源策略仍然是问题多多的，比如复杂的使用场景（JavaScript DOM访问， XML HttpRequest API，HTTP Cookie, 本地存储API， FLash,java插件等等等）。比如跨浏览器交互的问题，比如客户端和服务端的区别逐渐模糊，会在如今安全仍然非常脆弱的情况下，增加复杂度，也使得设计层面更加混乱，进一步增加了风险。</p>
<h1 id="URL_开始">URL 开始</h1>
<p>我们都知道一条URL 对应的是Web 服务器上某个独一无二的资源，在简短的一行长度里，我们希望浏览器和服务器能够获取足够的信息量，RFC 文档为URL 制定了一系列规则，好让一个URL 里可以携带更多信息，所以五花八门的功能和内容也会爬上URL， 而此时由于繁多的URL 花样加上各种浏览器的不同解读方式，也让其漏洞百出，有无数安全的隐患。</p>
<p>为了让URL 拥有更多功能，于是有了伪URL ，它不是资源，而是包括了一些功能，诸如脚本引擎，集中特别的文档渲染模式等功能。但是由于URL 本身机制上的疏漏和浏览器对协议的解析机制的不同，带来了诸多安全问题。具体RFC 文档可参见，<strong>RFC3986</strong>，以及RFC 1738，2616等次要文档。</p>
<h2 id="URL_结构">URL 结构</h2>
<p>在之前的笔记里，已经整理HTTP 里的大部分内容，其中就包括URL 部分，所以一个典型的结构是：<br><strong><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></strong></p>
<h3 id="协议名称">协议名称</h3>
<p>这是第一个会出问题的地方，IANA 维护了官方认可的有效URL 地址，如http,https, ftp, 等几十项，而实际上浏览器会支持一些额外的协议，如data: , javascript:  这些都会带来安全问题。</p>
<p><strong>（此处应插入更详细解释）</strong></p>
<p>在RFC 1738 定义中，要求绝对URL 在冒号之前只能出现字母，数字，「+」 ，「-」 , 「.」。但是在实际上各个浏览器都有一些奇怪的支持和不支持方式，在书中列举的例子，我偷懒复制一下别人写的思维导图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618519826666.jpg" alt=""></p>
<p>实际测试下，我手动构造一个HTTP 请求，在协议头这个部分，他也会忽略掉空格0x00这样的字段，比如ht%20tps://www.baidu.com/index.html 仍然是能够正常解析的，我想这应该是服务器方面解析的原因了，目前不知道这上边编码的混乱如何利用制造安全问题。</p>
<h3 id="层级URL_标记符号">层级URL 标记符号</h3>
<p>仍然是我们的RFC 1738 要求我们的绝对URL 应当包含’//‘，如果没有这个东西，后边的URL 就无法正常解析了，只能把他们看成一个含糊的与某个协议有关的内容了。</p>
<p>然而文档里包含了很多含混不清的东西，比如如果一个费层级结构的URL 带有了// ，如何处理，同时如果一个协议没有带//该如何解析，这些在1738 文档里都没有讲清楚。最常见的就是http:www.google.com这样的结构，或者是javascript://www.google.com/%0Aalert(1)。不同的浏览器都有各种各样的解释方式。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618533600523.jpg" alt=""></p>
<h3 id="访问资源的身份验证">访问资源的身份验证</h3>
<p>这一块貌似是没什么重点内容了，直接挂别人的思维导图，略过：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618534589822.jpg" alt=""></p>
<h3 id="服务器地址">服务器地址</h3>
<p>这里就是放域名或者IP地址的地方，IP还有IPv4 的，或者是放在方括号里的IPv6。RFC 要求规范的IP地址写法，然而大多数应用都支持八进制，十进制，十六进制的写法，甚至还可以把其中几个或者全部8位元数据拼在一起转成单个整数的写法。所以实际上一下几个地址是一样的：</p>
<ul>
<li><a href="http://127.0.0.1/" target="_blank" rel="external">http://127.0.0.1/</a></li>
<li><a href="http://0x7f.1/" target="_blank" rel="external">http://0x7f.1/</a>  先以16进制表示标准写法的第一个八位元，剩下三个按照16进制然后拼在一起，然后再整体转换成一个十进制的数字，好绕。</li>
<li><a href="http://017700000001/" target="_blank" rel="external">http://017700000001/</a>  以0为前缀，后面是把全部4个8位元数据的十六进制拼在一起，同意转换成单个八进制整数。</li>
</ul>
<p>大部分浏览器都会忽略出现在URL 内且数值范围在 0x0a~0x0d 和 0xa0~0xad之间的控制字符。因为这些是换行符等等特殊字符。</p>
<h3 id="服务器端口">服务器端口</h3>
<p>这里可以指定端口号，作者说这里会造成一个安全问题，就是我们可以用浏览器向人以网络服务发送攻击者提供的数据，尽管浏览器并不支持这些服务的协议。作者举得例子虽然知道是什么，但实在是不知道这怎样引发安全问题，作者说后边会详细说，然而宝宝粗略的翻阅后边，没发现哪里有讲，等我找到了，我再回来补上。</p>
<h3 id="层级的文件路径">层级的文件路径</h3>
<p>这一块不用做过多解释，他是直接从UNIX 目录语义拿过来的，所以也会出现/../这种路径，作者没有提其中的安全问题，但这一块大约是安全问题比较多的，通过/../可以向上搜索文件，如果服务器没有适当的设置权限，或者是对此类的请求进行过滤的话，就有可能引起文件泄露。</p>
<h3 id="查询字符串">查询字符串</h3>
<p>用于把一串非层级格式的任意参数传递给由前边路径对应的资源。关于这一块的格式，RFC 文档里都没有任何强制性的规定，所以作为浏览器，或者是服务器，它可以以任意喜欢的方式去处理和解析。这也是在URL 上存在注入的原因之一，通过在URL 里嵌入脚本，企图注入路径上的文件，达到攻入的效果。</p>
<h2 id="保留字符，百分号编码">保留字符，百分号编码</h2>
<p>为了不破坏URL 语法，一些符号需要保留：<strong>: / ? # [] @</strong><br>同时RFC 也规定了若干底层分隔符，这些符号留给上层协议或者具体的应用去实现：<strong>! $ &amp; ‘ () * + , ; =</strong></p>
<p>以上这些都是原则性的，但是仍然允许应用有合适的使用方法，那就是对这些字符进行编码，也就是我们常说的百分号编码或URL编码，以一个百分号加上字符的ASCII编码对应的2位16进制数字替换这些字符。比如/ 编码成%2F，百分号本身也会被编码成%25,查阅wiki， 列表如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618914319078.jpg" alt=""></p>
<p>值得注意的是，中间程序在处理URL 的时候，不应当对这些URL 保留字符进行编码，以免传递下去的时候改变了URL 的含义。</p>
<p>另外，虽然禁止，但如果接收到这样的字符，浏览器方为了保证高容错率，一般都会有一套处理方式，但是RFC文档中没有明确说明，所以各家浏览器处理起来完全自由发挥。</p>
<p>同时，RFC 还规定了一批非保留字符（这个听起来有点莫名其妙了），包括字母，数字，- . _ ~ ，意思大概是说，只有这里边的字符，以及出现在正确位置的保留字符，才能够使规范的URL。但是规定里并没有说不可以对非保留字符编码，出现在URL。所以对这些保留字符进行编码，其表示的效果仍然是一样的，例子如下：</p>
<ul>
<li><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></li>
<li><a href="http://%65ample.%63om/" target="_blank" rel="external">http://%65ample.%63om/</a></li>
<li><a href="http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/" target="_blank" rel="external">http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/</a></li>
</ul>
<p>对此可以在浏览器中进行尝试，完全一样的效果。当然这种编码也是因为攻击的一种方式。而一般的，浏览器会在地址栏直接进行强制解码，让这些非必要的编码字符以规范化形式展现。</p>
<p>同时，还有一些，既不在保留字符，又不在非保留字符，RFC 文档的描述有一定的缺失，此时的处理就要看浏览器了，这里直接上图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618924205141.jpg" alt=""></p>
<p>另外，在非正常的US-ASCII 编码问题上，浏览器的解决之道各种混乱，在家这各种编码规范鱼龙混杂，这里我还没有完全搞清楚，此处留坑。</p>
<h2 id="常见_URL_协议及其功能">常见 URL 协议及其功能</h2>
<p>这里讲讲协议的两三事：</p>
<h3 id="浏览器本身支持的，与获取文档有关的协议">浏览器本身支持的，与获取文档有关的协议</h3>
<p>这就是最基本的浏览器内部直接处理，通过特定的传输协议，获取指定文档内容，通过常规的内核解析引擎的逻辑处理。最常规的协议，http,https,ftp等。</p>
<h3 id="第三方应用和插件支持的协议">第三方应用和插件支持的协议</h3>
<p>当浏览器匹配到这个协议的时候，会将处理转交给相应的第三方应用或者插件上，比如arobat:,callto: ,等一票调用第三方应用的协议，大多数情况来说，这些协议对于发起他们的Web 应用本身没有安全性的影响，但是那些第三方协议的处理程序往往是漏洞百出，并有可能导致操作系统被入侵。</p>
<h3 id="未封装的伪协议">未封装的伪协议</h3>
<p>这些伪协议，是为了访问浏览器脚本解析引擎和某些内部功能的，不需要从远程获取数据，同时一般也无法通过互联网访问到。如最常见的 javascript：，data:(不需要额外的网络请求，创建一个短小的内置式文档),这两个都是高危险的协议。</p>
<h3 id="封装过的伪协议">封装过的伪协议</h3>
<p>这类特别的伪协议，可以放在任何的URL 前面，只是将取回的内容强制进行特殊的解码或者渲染显示。比如最常见的查看源码，view-source： 同时其他浏览器还有一些各自支持的伪协议：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618948022474.jpg" alt=""></p>
<p>在这种伪协议的方式下，会隐藏最后实际有浏览器处理的真是URL ，比如 view-source:javacript: 后边跟恶意代码，就会达到攻击的目的。或者说，微软的mhtml 协议，会护绿服务器返回的HTTP 内容设置指令。</p>
<p>最后要说的是，这些协议里暗藏各种杀机，而简单的设置黑名单又很难完全杜绝，因为攻击者可以对其进行各种各样的变形，如加上制表符，将JavaScript 编程 VBScript等等，都同样会触发安全问题。</p>
<h2 id="相对URL_解析">相对URL 解析</h2>
<p>RFC里定义了，URL 字符串不是以有效协议名开始，后边没有跟冒号，或没有// ，都是相对URL。按道理讲，这讲的很明确了吧，如果有上下文环境，那就放在上下文环境里构造成安全的相对链接，如果没有正确的上下文环境，那就拒绝访问。</p>
<p>然而，事实上并没有看起来那么轻巧，各种浏览器的具体实现千差万别，有效协议名称的字符集又各不相同，以及各种替代// 的做法出现，这时候，在处理上就应当小心翼翼，因为随时可能会有黑客构造出一个URL 的变形，对你的文件资源进行攻击。</p>
<p>下面有一些情况：</p>
<p><strong>有协议名称，没有授权信息</strong></p>
<p>如： http:foo.txt 这是RFC 文档早期的疏漏，规范认为这种URL是一个无效的绝对地址，但是，提供的解析算法又会对这种地址有一些含混的解释。在现在的地址解析算法中,这种形式的URL ，协议，路径，查询字符串或者片段ID以URL 为准，授权信息以引用页面为准。这个可以在HTTP 构造包时候进行尝试。</p>
<p><strong>没有协议名，但有授权信息</strong></p>
<p>如： //example.com 这也是个奇怪的写法。此时的处理方式一般是，保留当前页面的协议，字符串作为新的授权信息字段。这个好理解。</p>
<p><strong>没有协议名，没有授权信息，有路径</strong></p>
<p>如： ../notes.txt 这里要用到一些常见的处理方式了，如果开头没有/ ，要添加到引用URL 最右边的的/ 后边，而如果初始路径形如 <a href="http://example.com/files/index.html" target="_blank" rel="external">http://example.com/files/index.html</a> ，则需要将其部分砍掉，拼接路径。</p>
<p><strong>只有片段ID</strong></p>
<p>如 ：#bunnies 这种情况，除ID 外，全部信息原封不动引用，然后替换片段ID 部分。通常这样的 构造，不会让页面重新加载。</p>
<h2 id="安全工程指导">安全工程指导</h2>
<p>如果要构建用户用户输入的全新的URL 时候，一定要慎重：</p>
<p>如果允许用户构造URL 的路径、查询或者片段ID 部分，应当注意，如果其中一部分不能正确的的转移，就有可能会产生意外的结果。所以，最好的做法是，如果要插入攻击者能控制的字段值，应当对除了字母和数字，都进行百分号编码的转义。当然，这种方法也只是部分的解决了问题，还有一些二次转义等绕过的问题。</p>
<p>如果允许用户提供协议名称或者是授权信息部分数据：这里会造成严重的代码注入问题，这时候就应当设置合理的URL 过滤器了。</p>
<p>一些常见的URL 过滤方式：</p>
<ul>
<li>相对URL ，直接禁用相对URL ，避免不必要的麻烦。 </li>
<li>协议名称，建议直接使用白名单模式，因为使用黑名单不知道会漏掉那些漏网之鱼。</li>
<li>授权信息部分，主机名部分应当只包含数字，字母，-和. 在他的后边只能跟<strong>/ ? #</strong> 或者字符串结束符号。允许其他的任何数据都会带来风险。<strong>如果需要检查主机名，确保合理的使用从右往左的截取匹配模式</strong></li>
</ul>
<p>而如果需要从接受的URL 那里进行参数解码，注意，任何从URL 里获取到的值，准备放入数据库查询前，或者是拼接成新的URL前，一定要做好过滤，这些值不一定是安全的，随时可能造成安全问题。</p>
<hr>
<p>至此，URL 部分写完了，但是中间还是留存有许多坑，后边还需要在这些坑上做修补，对细节更加理解。URL 存在的安全问题，应该是较为显眼的攻击了，几年前也许这些攻击有如家常便饭，现在在安全编码的规范下，很多人都会更加关注URL 上的问题，所以在URL 上做文章的几率也在逐渐变低。</p>
<p>所以，联系到我之前做数据挖掘方向上的网络安全分析，如果单纯的拿到服务器的日志，（对于服务器的日志格式，《HTTP权威指南》中有一定介绍，各家服务器也支持自定义）拿到默认的数据格式的数据的话，可以构造的特征值，除了时间分析，频率分析，大概也只有URL 了。虽然URL 藏有非常多的玄机，但在处理上千变万化以及莫名其妙，直接处理都有难度的情况下，还试图通过挖掘的形式直接找到玄机，可能还是不够的。所以，为了能够抓取到最够有用的信息，我们还需要在服务器上获取更多的信息，如对系统调用的日志，如每次发包的的协议头部分内容，甚至还有可能要分析实体部分。当然，目前有一个清晰地轮廓，但是内里确是模糊的，在继续看下去的过程中，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次简单的缓冲区溢出实验]]></title>
    <link href="http://yoursite.com/2016/04/27/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2016/04/27/一次简单的缓冲区溢出实验/</id>
    <published>2016-04-27T02:11:14.000Z</published>
    <updated>2016-04-27T02:11:14.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP再详解]]></title>
    <link href="http://yoursite.com/2016/04/27/HTTP%E5%86%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/27/HTTP再详解/</id>
    <published>2016-04-27T02:05:51.000Z</published>
    <updated>2016-04-27T02:07:29.000Z</updated>
    <content type="html"><![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br><a id="more"></a></p>
<h1 id="概述">概述</h1>
<p>本部分内容较为笼统，直接快速跳过，只简述极少内容。</p>
<h2 id="版本协议">版本协议</h2>
<ul>
<li>HTTP/1.0: 使得包含图片的web页面和交互表格可以实现。</li>
<li>HTTP/1.0+: 包括持久keep-alive，虚拟机支持，代理连接被加入。</li>
<li>HTTP/1.1 校正HTTP设计中的结构缺陷，明确语义，性能优化。</li>
<li>HTTP/2.0: 关注性能的提升，更强大的服务逻辑远程执行框架。</li>
</ul>
<h2 id="Web_结构组件">Web 结构组件</h2>
<p>Web 上比较重要的应用：</p>
<ul>
<li>代理，中间实体</li>
<li>缓存，HTTP仓库，常用页面的副本保存在离客户端较近的地方，CDN。</li>
<li>网关，帮助连接到特殊的Web服务器,HTTP/FTP 网关。</li>
<li>隧道，HTTP报文进行盲转发的特殊处理，SSL。</li>
<li>Agent代理，发起自动HTTP请求的半智能Web 客户端，爬虫。</li>
</ul>
<h1 id="URL">URL</h1>
<p>这是在研究WEB 安全中的重要的内容，在我们抓取到的包内容中，包含非常多的信息。</p>
<h2 id="URL_结构">URL 结构</h2>
<ul>
<li>第一部分是URL 方案，scheme，方案可以告知Web 客户端怎样访问资源。常见例子中，URL 说明要使用HTTP 协议。</li>
<li>URL 第二部分,host 主机 ，www.google.com ，指服务器的位置，也就是资源位于何处，此处通过DNS 解析可以解析到其IP 地址。</li>
<li>URL 第三部分，比如/seasonal/index.html ，是资源路径，说明了请求服务器上哪个资源。</li>
</ul>
<p>其重点在于第三部分，第三部分可以承载URL 的语法，很多的入侵行为也出现在第三部分。</p>
<h3 id="URL_语法">URL 语法</h3>
<p><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
<p>以上是一个URL 的通用格式，包含9部分内容。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<h2 id="编码机制">编码机制</h2>
<p>为了避开安全字符集（US-ASCII）表示法带来的限制，为URL 设计了一种新的编码机制，通过一种『转义』表示法来表示不安全字符，包含一个百分号和两个表示字符ASCII 码的十六进制。</p>
<p>同时，保留了一些有特殊含义的字符，这些字符与某些协议或网关会产生混淆，所以应当注意，在将其用于保留用途之外的场合时，应当对其进行编码。其中有：<strong>% / . .. # ? ; : $,+ @,&amp;,= {}|\^~[]’ &lt;&gt;”</strong></p>
<p><strong>URL 包含的内容丰富多样，但是这些字段更多的信息，在后边才会介绍到，在这里，了解了URL 的基本格式和编码机制已经基本足够，而其中包含的字段和意义，再后边会有更详细的介绍。</strong></p>
<h1 id="HTTP_报文流">HTTP 报文流</h1>
<h2 id="报文流">报文流</h2>
<p>报文的流动方向和基本的格式在此不再过多介绍，因为这一部分属于基础内容，在所有的内容中都会接触，无需记录也不会忘记，这里简要记录一下：</p>
<ol>
<li>method 方法： 如GET，HEAD，POST 等。</li>
<li>request-URL : 命名请求的资源。</li>
<li>version: HTTP 版本。</li>
<li>status-code: 状态码，描述请求过程中发生的情况，后边会有详述。</li>
<li>reason-phrase: 原因短语，仅用于人阅读，机器忽视，属于状态码的可读版本。</li>
<li>header： 有多个键值对，以一个空行结束CRLF。</li>
<li>entity-body： 实体部分，以一个空行结束。</li>
</ol>
<h2 id="起始行">起始行</h2>
<p>起始行可以分为请求行和响应行，其起始行的内容不同。对于起始行，其起始行包含有method, request-URL,version。一些常见的方法有：</p>
<ol>
<li>GET， 获取一份文档</li>
<li>HEAD，获取首部</li>
<li>POST，向服务器发送需要处理的数据</li>
<li>TRACE，对可能经过的代理服务器传送到服务器上的报文进行追踪</li>
<li>OPTIONS，决定可以在服务器上执行哪些方法</li>
<li>DELETE，从服务器上删除一份文档</li>
</ol>
<p>GET，HEAD 方法被认为是安全的，是因为这些方法不会再服务器上产生什么结果，而像POST 方法，会提交信息在服务器上，就会执行一系列动作。而安全方法并非说不会执行服务器动作，而是当出现可能不安全行为的时候，会发出警告，这些由用户决议。</p>
<p><strong>HEAD</strong>：响应中只返回头部，不返回实体，使用HEAD，可以在不获取资源的情况下了解资源的情况，判断类型等；通过查看响应状态码，确定某对象是否存在；通过查看首部，测试资源是否被修改。</p>
<p><strong>PUT</strong>： 该方法是向服务器写入文档，其语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的文档，如果已存在，就替换之。执行PUT 请求，需要先登录。</p>
<p><strong>POST</strong>： 用来向服务器输入数据，一般用来支撑HTML 表单数据，发送给服务器。</p>
<p><strong>TRACE</strong>: 该请求可能会要求穿过防火墙、代理、网关等，都会修改HTTP 内容。而其目的一般用于诊断，一般用于验证请求是否如愿穿过了请求，或者响应链。但是，目前仍然有一些缺点，比如TRACE ，不会区分不同的方法机制。TRACE 请求中不带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<p><strong>OPTION</strong>: 请求web 服务器告知其支持的各种功能，包括通常支持的方法，或者对某些特殊资源支持哪些方法。</p>
<p><strong>DELETE</strong>: 请求服务器删除URL 所指定的资源。</p>
<p><strong>扩展方法</strong>： 其他还有一些扩展的方法，LOCK 锁定资源, MKCOL 允许用户创建资源, COPY 复制资源, MOVE 服务器上移动资源。</p>
<p>对于响应行，则一般会返回状态码，和reason-phrase，状态码是人们规定的一系列表示状态的code.</p>
<ul>
<li>1开头，表示信息提示，目前定义了100，101</li>
<li>2开头的，表示成功，200~206 最常见的还是200</li>
<li>3开头，表示重定向，300~305</li>
<li>4开头，客户端错误，400~415</li>
<li>5开头，服务器错误，500~505</li>
</ul>
<p><strong>100 Continue</strong>:<br>100状态码是HTTP/1.1 之后引入的信息性状态码， 其复杂性和感知价值存在一些争论。他实际上是客户端要向服务器发送一个实体，同时愿意在发送实体前等待100 Continue 响应，所以会发送一个值为100 Continue 的Except 请求首部。但中间会有很多问题，比如服务器如果没有回复响应，客户端一定要一直等着么，所以一般客户端会设置一个超时时间，超过后客户端会直接发送实体。而服务器需要处理几种情况，一种是还没有响应就收到了实体，一种是由于错误等服务器决定结束响应。对于代理，同样应当有处理逻辑，比如兼容问题，比如错误响应等。</p>
<p><strong>200 成功状态码</strong>：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609658165005.jpg" alt=""></p>
<p>成功状态码存在的问题是，hack 可能会伪装成服务器，向客户端发送虚假的成功码，就会劫持客户，所以此处的响应码就可能包含更多的信息。</p>
<p><strong>重定向状态码</strong>：<br>对于重定向状态码来说，也是极有可能对客户端发生劫持的内容，有可能将用户导向错误的地址，以下是更为详细的内容：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609660727847.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609661357874.jpg" alt=""><br>从图中可以看出，不同的状态码其实非常相近，其实内部各有区别，对于不同版本的HTTP 都有其处理上的差别，在此不再详述，有需要时再详细识别。</p>
<p><strong>客户端错误码</strong></p>
<p>4开头的状态码大概是用户最讨厌碰见的状态码，这一部分也包含了非常多的内容，同样的，在此不详述，具体见下表。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664853726.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664914763.jpg" alt=""></p>
<p><strong>服务器错误状态码</strong></p>
<p>当服务器自身出现错误的时候，就会返回这样的状态码，同样的，不同的状态码也代表了服务器不同的状态。</p>
<ul>
<li>500 Internal server error： 服务器遇到一个妨碍它为请求提供服务的错误。</li>
<li>501 not implemented ： 客户端发起的请求超过服务器能力范围。</li>
<li>502 bad gateway: 作为代理或者网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应。</li>
<li>503 service unavailable： 目前无法提供服务，如果知道什么时候可以提供服务，会在首部包含一个retry-after，告知。</li>
<li>504 gateway timeout: 等待另一个服务器对其请求进行响应超时了。</li>
<li>505 http version not supported： 使用了它不支持的协议版本。</li>
</ul>
<h2 id="首部">首部</h2>
<p>首部其所包含的内容和属性更多，一般来说，可以分为以下几类：</p>
<ol>
<li>通用首部：可以出现在请求报文和响应报文</li>
<li>请求首部：有关请求的信息</li>
<li>响应首部：如题</li>
<li>实体首部：描述主体长度，内容，或资源自身。</li>
<li>扩展首部：规范未定义的新首部。</li>
</ol>
<p>另外，如果想让某行分出多行提高可读性，记得要在多出来的行前加入空格或者tab。</p>
<p><strong>通用首部：</strong></p>
<ul>
<li>Connection 允许客户端和服务器指定与请求/响应连接有关的选项</li>
<li>Date 提供日期和时间的标志</li>
<li>MIME-Version MIME 版本号。</li>
<li>Trailer 如果报文采用了分块传输编码，使用这个首部列出报文拖挂（trailer）部分的首部集合。</li>
<li>Transfer-Encoding 采用的编码方式。</li>
<li>Update 更新的协议和版本。</li>
<li>Via 显示经过的中间节点。</li>
</ul>
<p>强调一点，<strong>Connection</strong>首部是一个逐跳首部，只适用于单挑传输链路，他不会沿着传输链路向下传输，也就是只在两个最近连接中产生作用。<br>同时，还有两个通用的缓存首部，就是允许http应用程序缓存对象本地副本的首部。</p>
<ul>
<li>Cache-Control 用于随报文传送缓存指示</li>
<li>Pragma 另一种随报文传送指示的方式，并不专用于缓存</li>
</ul>
<p><strong>请求首部</strong></p>
<ul>
<li>Client-IP 客户端机器的IP 地址。</li>
<li>From 客户端用户的E-mail 地址。</li>
<li>Host 接受请求的服务器的主机名和端口号。</li>
<li>Referer UA-Color UA-CPU UA-Disp UA-OS UA-Pixels User-Agent</li>
</ul>
<p>后边这些，基本上很少会出现，也很难去寄希望挖掘到有用的信息。</p>
<ul>
<li>Accept 首部为客户端提供了一种将其倾向告知服务器的方式。包括了媒体类型，字符集，编码方式，语言等内容。</li>
<li>条件请求首部，则是为请求加入一些限制。</li>
<li>安全请求首部，对请求进行质询/响应认证，其中Authorization ,cookie, cookie2 首部就是这一类。</li>
<li>代理请求首部。</li>
</ul>
<p><strong>响应首部</strong></p>
<ul>
<li>Age  响应持续时间，从最初创建开始</li>
<li>Public 服务器为其资源支持的请求方法列表</li>
<li>Retry-After 资源不可用时，可响应的重试时间</li>
<li>Server 服务器应用程序软件的名称和版本</li>
<li>Title html文档标题</li>
<li>Warning 警告报文</li>
<li>协商首部，具有一定协商能力，内容包括对某资源可接受的范围和向阳发生变化的时候可选择。</li>
<li>安全响应首部，对应于前边的authenticate,cookie</li>
</ul>
<p><strong>实体首部</strong><br>此处可能会发生安全问题，比如劫持服务器，像客户发送错误的 location ，让客户链接向错误的地址。</p>
<ul>
<li>Allow 可以对实体执行的请求方法</li>
<li>Location 告知客户端实体实际上位于何处，用于接收端定向到资源的位置上去。</li>
<li>内容首部，包括Content-Base（解析主体相对URL 时使用的基础URL），对主体执行的编码方式，自然语言，主体长度，资源位置，MD5，字节范围，对象类型等。</li>
<li>实体缓存首部，对被缓存的实体添加的一些信息，如验证已缓存的副本是否仍然有效等等。其中包括了标记，不再有效的日期，最后一次被修改的时间等。</li>
</ul>
<h1 id="连接管理">连接管理</h1>
<p>本部分，介绍的是HTTP 以及其之下的TCP 的原理和内容，实际上，这也是报文流的过程结构，其中会有许多安全上的危险发生。</p>
<h2 id="TCP">TCP</h2>
<p>先列一下TCP 套接字的常用接口函数，很常用，这是在分析代码时候必要的寻找流程的几个关键节点。</p>
<ul>
<li>s = socket() 创建套接字。</li>
<li>bind(s, <ip:port>) 绑定地址和端口</ip:port></li>
<li>connect(s, <remote ip:port="">) 创建本地套接字和远程主机和端口的链接</remote></li>
<li>listen(s, …) 坚挺</li>
<li>s2 = accept(s) 等待某人建立一条道本地端口的连接。</li>
<li>n = read(s, buffer, n) 从套接字到缓冲区读取n 个字节。</li>
<li>n = write(s, buffer, n) 从缓冲区向套接字写入n 个字节。</li>
<li>close(s) 关闭</li>
<li>shutdown(s,<side>) 关闭TCP 连接的输入或输出端</side></li>
<li>getsockopt(s, ..) 读取某内部套接字配置选项的值</li>
<li>setsockopt(s, ..) 修改某内部套接字配置选项的值</li>
</ul>
<p>以下就是一个正常的HTTP 服务器和客户端交互的过程。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14610508715798.jpg" alt=""></p>
<h2 id="HTTP_TCP_性能考量">HTTP TCP 性能考量</h2>
<p><strong>HTTP 事务的时延</strong></p>
<p>在日常上网过程中，我们时常被龟一样的网速折磨，其中有很多原因，有一部分是HTTP 的事务上的，一部分是TCP 之上的。HTTP上的事务延迟可能的原因有：</p>
<ol>
<li>通过DNS 解析将主机名换成一个IP 可能会花费不小的时间。</li>
<li>TCP 连接的建立时间延迟。</li>
<li>对TCP 报文的解析和处理依靠服务器性能，有一定的时间延迟。</li>
<li>Web 响应时间延迟。</li>
</ol>
<p><strong>TCP相关的时间延迟</strong></p>
<p>此处就进入较为深入的部分了，本来在研究上不需要达到这一地步，但是出于兴趣，做以简要挖掘。</p>
<ul>
<li>TCP 建立握手。</li>
<li>TCP 慢启动拥塞控制。</li>
<li>数据聚集的Nagle 算法。</li>
<li>用于捎带确认的TCP 延迟确认算法</li>
<li>TIME_WAIT 时间延迟和端口耗尽。</li>
</ul>
<p>对于第一点，HTTP 通过保持重用现存连接来解决每次握手花费时间的问题。</p>
<p>低于第二点，不需过多解释，HTTP 为了解决在初始调谐时速度慢的问题，采用长连接，也就是持久连接的方式解决。</p>
<p>对于第三点，Nagle 算法解决的问题，是说TCP 的数据流接口，允许任意尺寸的数据放入栈中，一次一个字节也可以，但是当大量的一字节内容发送，而实际上TCP 为这一字节的内容要装在40字节的标记和首部，造成了性能的严重下降。Nagle 算法就是试图将大量TCP 数据绑在一起，提高网络效率。Nagle 算法的主旨是鼓励网络发送全尺寸段（1500字节），只有在目前所有挂起的分组都被确认了，才可以立即发送非全尺寸段。而其他时间，则是将他们缓存起来，积累到一个全尺寸分组才发出去。</p>
<p>Nagle 算法在优化网络的同时，可能会对HTTP 性能造成一定影响，因为一个小的报文，必须要等到之前所有段都确认了，才可以发送，而这段时间，会有延迟，一般来说，HTTP 会设置参数TCP_NODELAY ,来禁用。当然这里还有很多文章可以做。</p>
<p>对于第四点，在我们TCP 连接的时候，每一个发出去的报文，都期望收到一个很小的确认包，但是因为报文非常小，不值得每次都单独发送，所以有时候延迟确认算法会在一个特定的窗口内将确认包放在缓冲区，等待一个时间窗口内，看能够有输出数据分组发出，将这个确认报文捎带上，如果这段时间里没有，就单独发包。这一点上，本来是为了解决TCP 连接中频繁发小包引起的性能问题而采用的算法，但是HTTP 确实具有明显的双峰特征，就是一端会频繁输出，而另一端只是频繁接收，如果还是使用这种延迟算法，则可能会带来性能上的下降，此时就应当调整和禁止延迟确认算法，来提高性能。</p>
<p>对于第五点，TIME_WAIT 的出现时机应当都很清楚，这个状态一般需要保持一小段时间，通常使用的是<strong>最大分段使用期的两倍，2MSL，通常两分钟</strong>，来确保这个时间段不会创建具有相同地址和端口号的连接。而如果一个服务器是短连接属性的，如果一段时间有较高的访问，就会出现大量的TIME_WAIT 状态，导致端口耗尽，性能急剧下降。一般的解决办法是剪短TIME_WAIT 时间，或者是用虚拟地址，增加更多的连接组合。</p>
<p><strong>提高HTTP 性能的技术</strong></p>
<ul>
<li>并行连接，多条TCP 连接发起并发的HTTP请求。</li>
<li>持久连接，重用TCP 连接，消除连接和关闭的时间延迟。</li>
<li>管道化连接，通过共享的TCP 连接发起并发的HTTP 请求。</li>
<li>复用的连接，交替传送请求和响应报文。</li>
</ul>
<p>对于并行连接，无需过多解释，目前考虑到性能等方面，浏览器一般支持的并行连接数量是4个。</p>
<p>对于持久连接，也就是保持TCP 连接状态，HTTP/1.0+ 上采用的是keep-alive 连接，HTTP/1.1 上采用的是 persistent 连接。关于keep-alive 中有很多信息，但是没有过于复杂的知识点，都是可以理解的内容，不再赘述。</p>
<p>对于管道化连接，他是keep-alive的进一步优化。在响应到达之前，可以将多条请求放入队列，如此连续的以管道化的形式进行传输，可以降低网络上的环回时间，提高性能。<br>注意，为了实现这种高性能，实际上是有一些限制：</p>
<ul>
<li>客户端应确认连接是持久的</li>
<li>HTTP 响应不能失序，否则无法与请求匹配。</li>
<li>客户端要做好随时可能会关闭的准备，以及要重发所有未完成请求的准备。</li>
<li>不应发送产生副作用的请求，如POST。（非幂等请求）<strong>HTTP 的幂等性待搞明白，简单来说就是一次和多次请求带来的副作用应当是一样的</strong><a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html" target="_blank" rel="external">参考文章</a></li>
</ul>
<p>另外，关闭连接也包含了大量的内容，这里我不想深究了，因为在保持连接部分里边的坑就目测很深，关闭连接里边也很深，因为要涉及到冲连接，安全性，数据完整，幂等性这些东西，都会有很多需要处理的内容，待到以后需要用到，再深究吧。简单的说，关闭连接，包括内容有『任意』接触连接，content-length 和截尾操作，连接关闭容限，重试等。</p>
<h1 id="HTTP_结构">HTTP 结构</h1>
<p>这一部分，略过了一些内容，只选择有价值的一部分，另外一些可能会有更深层的信息待挖。</p>
<h2 id="响应实体">响应实体</h2>
<p>响应实体的报文通常包括：</p>
<ul>
<li>描述响应主体MIME类型的Content-Type 首部。</li>
<li>描述响应主体长度的 Content-Length 首部。</li>
<li>报文主体。</li>
</ul>
<p>其中MIME类型负责指示资源的类型，一般服务器会提供魔法分类，或者是自定义分类。</p>
<p><strong>重定向：</strong></p>
<p>一个3xx 的重定向响应一般有如下情况</p>
<ul>
<li>永久删除资源：301</li>
<li>临时删除资源：303 307</li>
<li>URL 增强，一般是重写URL用于嵌入上下文，客户端会根据这个重定向信息重新发起请求。303 307</li>
<li>负载均衡 303 307</li>
<li>服务器关联，Web 服务器可能会有某些用户的本地信息，服务器可以将客户端重定向到包含那个客户信息的服务器上去。 303 307</li>
<li>规范目录名称：也就是规范URL 名。</li>
</ul>
<h2 id="代理">代理</h2>
<p>这是一个和其他部分没有太大联系的门类，其中包含的信息非常的大，在这里，我先留个坑，不花费时间去处理这个内容，留待单开补充。</p>
<h2 id="缓存">缓存</h2>
<p>缓存是解决带宽瓶颈的一个重要的方法，以CDN 为代表的技术仍然是主流。主要解决了网络时延，带宽瓶颈，瞬间拥塞，冗余数据的问题。</p>
<p>缓存包含的技术术语有：命中与未命中（这个很常见），再验证（新鲜度检测）。</p>
<p><strong>命中与未命中</strong><br><strong>再验证</strong>，缓存对缓存的副本再验证时，会向原始服务器发送一个小的再验证请求，如果内容没有变化，服务器会响应304，这个被称作再验证命中。这种方式要与原始服务器进行核对，所以比单纯的缓存命中要慢。</p>
<p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，最常用的是 If-Modified-Since 首部。首部添加到GET 请求中，告诉服务器，只有在缓存了对象的副本，又对其进行了修改的情况下，才发送此对象。对于再验证命中，则返回304，表示仍然新鲜。如果未命中，则像正常响应200.如果已删除，返回404，缓存的副本也将删除。</p>
<p><strong>命中率</strong>，这是一个重要的考量目标，缓存提供服务所占的比率，他与缓存大小，缓存用户兴趣点的相似性，缓存数据的变化或者个性化频率，以及缓存的配置，都影响到命中率。</p>
<p><strong>字节命中率</strong>，由于有些大型对象被访问的次数可能较少，但是由于尺寸的原因，对整个数据流量的贡献却很大。所以，有时候使用字节命中率更加准确。字节命中率表示缓存提供的字节在传输的所有字节中所占的比率。</p>
<p>客户端判断命中和未命中的方法是使用Date 首部，将响应的Date首部值与当前时间比较，如果响应日期比较早，可能认为这是一条缓存的响应，也可以使用Age 首部进行判断。</p>
<p><strong>代理缓存的层次结构</strong></p>
<p>实际上，缓存还存在有层次化的结构，一级缓存二级缓存等，这是为了逐步采用更大，功能更强的缓存来装在更多的用户共享文档。</p>
<p>而更加复杂的，还有网状缓存，内容路由以及对等缓存。可以考虑现在的P2P技术与之类似。</p>
<h3 id="缓存处理的基本步骤">缓存处理的基本步骤</h3>
<ul>
<li>接收，缓存读取请求报文。</li>
<li>解析，提取URL 和首部。</li>
<li>查询，查看是否有本地副本可用，没有就获取一份副本，将其保存本地。</li>
<li>新鲜度检测，如果已有，就验证是否新鲜，如果不新鲜，则请求服务器是否有更新。</li>
<li>创建响应，缓存构建响应报文。</li>
<li>发送</li>
<li>日志</li>
</ul>
<p>下图是一个新鲜的缓存命中<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200094685.jpg" alt=""></p>
<p>以一个更为一般化的流程图做以描述：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200650513.jpg" alt=""></p>
<p>服务器可以通过HTT 定义集中方式来控制缓存：Cache-Control ，Expires 首部等等，里边的内容包括max-age，详细的不再纠结。</p>
<p>后边关于缓存还有更多的知识点，甚至还有一些算法，比如使用期的算法，新鲜生存期算法，新鲜度算法等等。</p>
<h1 id="集成点：_网关，隧道，中继">集成点： 网关，隧道，中继</h1>
<h2 id="网关">网关</h2>
<p>网关的概念可以作为某种翻译器理解，抽象出了一种能够到达资源的方法。更形象的讲，网关就是一个门，用用程序可以通过接口请求网关来处理请求，网关提供响应。同时网关可以向数据库发送查询语句，生成动态内容等。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613152822853.jpg" alt=""></p>
<p>Web 网关在一侧使用HTTP 协议，在另一侧则使用另一种协议。例如当网关收到了一个对FTP 资源的请求，客户端实际上发送的是HTTP 请求，而网关则会打开一条到原始服务器的FTP 端口，通过FTP 协议去获取对象。完成之后，将对象放在HTTP 响应中返回给客户端。</p>
<p>再比如，客户端以普通的HTTP 形式浏览Web 内容，而网关可以自动加密用户对话，这是常见的HTTP/HTTPS 安全网关。而另外一种客户端安全加速网关则是反过来的HTTPS/HTTP 网关，这是为了确保在客户端和网关连接中途发生安全问题。</p>
<p>而最常见的网关，则是为了在客户端通过HTTP 通信的时候，能够与服务器端的应用程序相连，这时候就是需要调用服务器上应用程序的API ，来实现应用程序的调用。<strong>最早期的应用程序网关API 是CGI</strong>，而纯CGI 来写的人已经很少了，因为注入ASP，PHP 已经将CGI 包装好，实现了其特性，本质上CGI 就像一个非常简单的协议，人们更习惯使用更加简单易读的PHP 等语言。</p>
<p>在CGI 初始，由于CGI 是分离的，服务器要为每条CGI 请求引发一个新进程，这会极大的限制服务器的性能，为解决这个问题，人们开发的新语言FastCGI ，这个接口模拟CGI，作为持久守护进程运行的，消除了每个请求简历和拆除进程带来的性能损耗。当然实际上，现在还是PHP 这些语言的天下。</p>
<p>时至今天，应用程序和Web服务的接口越来越多，甚至我们也看到了Chrome Book 甚至可以仅仅将一个浏览器就可以作为一个操作系统的入口。这时候，HTTP 其实可以作为一种连接应用程序的基础软件来看待，而此时，将HTTP 协议与其他应用程序的协议之间的协商和接口，都成为了重要的内容。</p>
<h2 id="隧道">隧道</h2>
<p>接上一个话题，刚才说的是通过HTTP 协议，与应用程序之间建立接口，而HTTP 还有另一个用法，就是为应用程序之间建立通信，这就是隧道（Web tunnel）。通过隧道，非HTTP 协议可以在HTTP 协议包装下，穿过只允许Web 流量的防火墙了。</p>
<p>常见的隧道建立方式是通过<strong>Connect</strong> 建立的，CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的TCP 连接，并对客户端和服务器之间后继数据进行盲转发。下图就是以建立SSL 隧道为例，注意看其中的请求，则是以CONNECT 为首，主机号和端口号取代了URI，响应短语经常为Connection Established。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613168465645.jpg" alt=""></p>
<p>为什么我们要实现SSL 的隧道呢，因为对于传统的代理服务器，SSL 的信息是加密的，防火墙无法识别，就会被HTTP 防火墙拦截。而实现了隧道化的SSL ，加密数据放入正常的HTTP 报文中，就能通过防火墙了。在隧道的起点用HTTP 封装SSL ，然后以普通HTTP 报文的形式通过防火墙，然后在对报文解封，继续进行普通的SSL 连接。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613176934946.jpg" alt=""></p>
<p>SSL 隧道与我们刚才所讲的网关实现HTTP/HTTPS 有一定的差别。相比于隧道，网关实现方式有几个缺点：</p>
<ol>
<li>客户端到网关之间的连接是普通的HTTP，因为只有普通的http 才可以通过防火墙。</li>
<li>尽管代理是已认证的主体，但客户端无法对远端的服务器执行SSL 客户端认证 X509证书。</li>
<li>网关要支持完整的SSL 实现。</li>
</ol>
<p>同时，隧道为了安全考虑，也需要将代理的认证支持与隧道配合使用，对客户端使用隧道权利进行认证，过程如图。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613179676011.jpg" alt=""></p>
<p>出于对隧道安全的考虑，因为我们在传输过程中，不知道其内容是什么，所以有些人就可能通过诸如SSL 隧道，越过防火墙传递其他流量，包含一些恶意信息等，所以一般情况下，网关只对特定的端口和特定的内容开发端口，如443.</p>
<h2 id="中继">中继</h2>
<p>中继的内容不多，理解为一个没有完全遵循HTTP 规范的HTTP 代理。中继在两个连接之间，只进行盲转发。当然，我们也可以在中继上部署一些简单的过滤，诊断和内容转换的功能。</p>
<p>但是，中继上存在一个严重的问题，它无法正确处理Connection 首部，所以有潜在挂起 keep-alive 连接的可能。因为Connection 它是逐跳首部，只适用于单条传输链路，中继仅仅是盲转发，无法理解，也无法让他沿着链路一直传送下去，但是对于服务器和客户端，双方都以为建立了keep-alive 长连接，但实际上并非如此。所以，就陷入了麻烦。当然，现代的方法，采用了更加智能的判断方式，来消除这一个风险。</p>
<h1 id="Web_robot">Web robot</h1>
<h2 id="爬虫">爬虫</h2>
<p>爬虫是一个有趣的门类，他看起来很简单，似乎也有很多现成的解决方案，但是在实际的场景中，却又会有很多新的问题要解决，爬虫和反爬虫之间的斗争也一直在延续。本质上，在网络上活跃的自动化脚本，都可以叫做爬虫，他们日夜不停的执行着任务，为自己的老板收集大量的有用的内容。</p>
<p>下面是围绕到爬虫的一些必要的内容，当然，这是与HTTP 相关的内容：</p>
<h3 id="连接提取和相对链接标准化"><strong>连接提取和相对链接标准化</strong></h3>
<p>很简单，我们爬去的URL ，有些可能是相对链接，所以我们要根据其父亲结点，将相对链接标准化，处理成能够规范整理的信息。</p>
<h3 id="环路避免"><strong>环路避免</strong></h3>
<p>为了避免出现循环和重复，对那些访问过的URL ，我们要用特殊的结构保存起来，以确保在爬取的是新的URL，一般采用下面这些技术：</p>
<ul>
<li><strong>树和散列表</strong>，使用树形结构和散列表的结构，去寻找已访问的URL，提高了一定的速度，但在空间上仍然是巨大的。</li>
<li><strong>有损的存在位图</strong>，这里用的就是位图的概念，建立一个存在位数组，对每个URL 都转换为一个定长的数字，这个数字对应在数组的位置就是存在位，爬行过之后，该位置就置位。由于URL 潜在数量是近乎无限的，但是给予的空间总是有限的，所以很可能有两个不同的URL 对应于一个存在位，所以就可能会有部分URL 被忽略，所以是有损的。</li>
<li><strong>本地化列表</strong>，URL 列表应保存一份在本地硬盘，防止机器人崩溃，前功尽弃。</li>
<li><strong>分类</strong>，实际上就是采用了爬虫集群，分工的形式对某URL 片进行爬取，个体之间可能还需要相互通信，实现更复杂的功能。</li>
</ul>
<p>注意，不仅在URL 上可能会有环路问题，在文件系统连接上也会存在环路，在目录层次上可能会进入深度无限的假象。比如一个subdir 的链接链接到上层文件夹，就会让层级无限深入下去。</p>
<p>而在爬虫和反爬虫的斗争中，网管甚至还会创造一些虚假信息，他们会发布一个看起来是普通的文件，实际上却是网关应用程序，这是很容易的，当爬虫去请求了这个URL，服务器就会捏造一个新的HTML页面和一个新的虚构的URL ，以此让爬虫在这个看似都不同的URL 陷阱里越陷越深。如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613267668464.jpg" alt=""></p>
<p>在斗智斗勇的路上，爬虫也会进化：</p>
<ul>
<li>规范化URL，以此来避免别名带来的URL 重复</li>
<li><strong>广度优先</strong>，采用此策略，可以降低环路带来的影响，因为不像深度优先一样爬进一个坑里出不来。</li>
<li><strong>节流</strong>， 为防止在一个URL 站点里越陷越深，适当的限制重复的页面总数和对服务器访问总数来截至该操作。</li>
<li>限制URL 大小，某些情况，可能会让URL 无限增长，最简单的办法就是限制一个URL 的长度。一般1kb</li>
<li>URL 黑名单，建立一个列表，维护那些曾经让机器人陷入回路和陷阱的站点列表，所爬取的时候，就绕过他们。</li>
<li><strong>模式检测</strong>，造成环路陷阱的一般都会有一定的模式，比如固定模式循环出现，某组件重复出现超过三次等等。</li>
<li><strong>内容指纹</strong>，这是更加复杂的方法，爬虫爬取某页面，会通过提取部分字节建立指纹，指纹压缩存储起来，爬取新页面的时候，提取其校验和，与指纹库比较，如果以前见过，就不再爬取，这样就避免了仅依靠URL 做判断的方法。</li>
<li><strong>人工审计</strong>，这是最无奈的方法。</li>
</ul>
<h3 id="别名的判断"><strong>别名的判断</strong></h3>
<p>有些时候，同一地址的URL 可能会不同，叫做别名，比如URL 上添加不添加端口号，比如URL 编码，比如使用标签，服务器文件大小写，默认页面写不写，ip地址和域名地址等。</p>
<p>所以在别名的判断时候，有时就会对URL 进行规范，比如加上指定端口，把所有的转义字符用等价字符表示，删除#标签。</p>
<h2 id="爬虫与HTTP">爬虫与HTTP</h2>
<p>一个良好的爬虫，是受网站欢迎的，比如搜索引擎的爬虫爬取网站的基本信息，提供给人们搜索，可以提高网站访问，所以遵循道德准则的爬虫往往是放行的。而一个爬虫在爬取网页时，它也需要像正常请求一个，使用HTTP 请求，请求页面内容，只是在爬取的阶段中，可以在http 的首部告知自己的身份，也可以在Accept 里写明自己想要爬取什么样的内容，图片，文本等。</p>
<p>在使用HTTP 发出请求的时候，应当注意一些细节：</p>
<ul>
<li>一定要携带Host,如果遇到一个服务器提供两个站点，而发送请求没有携带Host， 服务器可能只会返回默认的那个站点。</li>
<li>爬虫辛苦爬到的站点，可能随时会改变内容，爬虫应当对时间戳或者是实体标签进行比较，来确认获取的版本是否升级，这方法类似于缓存查看机制。</li>
<li>对响应做处理，比如状态码，常见状态码，和一些特别的状态码。</li>
<li>实体部分，有些响应的实体中，可能会包含一些重定向等信息，包含在元标签如 http-equiv 等，<meta></li>
</ul>
<p>不良爬虫的特点：</p>
<ul>
<li>失控，访问速度太快，造成站点服务器过载，会被当做ddos攻击的爬虫。</li>
<li>失效URL ，没有更新URL，总是使用失效的URL 向服务器进行访问，也会对服务器的开销造成影响。</li>
<li>很长又错误的URL，同样造成web服务器性能下降。而且这两个都会让审计日志变得杂乱。</li>
<li>不小心访问了私有的URL地址。</li>
<li>保留了一些已经被删除的信息。</li>
</ul>
<p>由于有不良爬虫的存在，但是良好的爬虫仍然是有益的，所以人们约定在服务器文档根目录上提供一个可选的文件，robots.txt ，里边包含了对机器人的一些约束，也提供给良好的爬虫，让其更加方便的爬取信息。所以，一个良好的爬虫，首先要做的就是试图去获取站点的robots.txt 资源，并根据响应码做出下一步的反应，比如200，则拿到robots.txt， 就必须进行解析，依照规则爬取；如果404，说明不受限；如果401或403，表示该站完全不欢迎爬虫；如果503，则应稍后重试；如果3xx，则重定向方向去爬取。</p>
<p>至于robots.txt 的格式，很简单，不再赘述，因为我还没有想做一个站长，而且现在很多成熟的爬虫，会有自动化工具给予采用。而且，现在的站点，为了优化自己让搜索引擎更快的更新站点信息，会提供一个sitemap.txt 的文件，让爬虫直接顺着内容爬取即可，这样双方受益，效率可观。</p>
<h2 id="搜索引擎">搜索引擎</h2>
<p>爬虫有很多终极目的，而搜索引擎可以说是最重要的应用之一。搜索引擎相比于爬虫，还要多提供全文索引，本地内容存储的功能。因为为了给用户提供关键词的搜索，搜索引擎必须对它所搜索到的页面建立一个『全文索引』的复杂本地数据库，用户发送查询请求的时候，他应当在自己的数据库中找到所有的包含该关键词的文档。</p>
<p>更复杂的，搜索引擎还应当对匹配的结果进行排名，这一部分就包含了更多的东西，在这里不是重点了，有机会更深一步的时候，再进行理解。</p>
<h1 id="HTTP，识别、认证、安全">HTTP，识别、认证、安全</h1>
<h2 id="cookie_机制">cookie 机制</h2>
<p>在cookie机制之前，我们还会介绍另外一些识别机制，各有优劣，先列如下：</p>
<ul>
<li>HTTP 首部承载用户信息</li>
<li>客户端 IP地址跟踪，通过IP 进行识别。</li>
<li>用户登录，根据用户认证识别用户。</li>
<li>胖URL， 一种在URL 中嵌入识别信息的技术。</li>
<li>cookie</li>
</ul>
<p><strong>HTTP 首部承载信息</strong></p>
<p>在HTTP 首部中有七个常见可承载信息的首部：</p>
<ul>
<li>From 用户Email.</li>
<li>User-Agent 用户浏览器软件</li>
<li>Referer 用户是从这个页面上依链接条转过来的。</li>
<li>Authorization 用户名和密码</li>
<li>Client-IP 客户端IP。</li>
<li>X-Forwarded-For 客户端IP地址。</li>
<li>Cookie 服务器产生的ID 标签。</li>
</ul>
<p>实际上其中可用的信息实际上是后三个：</p>
<p><strong>客户端IP</strong></p>
<p>首先应说，Client-IP 首部并不一定是存在的，但是我们仍然可以调用诸如 UNIX 下 getpeername 的函数来返回客户端IP ,但是实际上，客户端IP 很难作为识别用户的方式。</p>
<ul>
<li>客户端IP描述的是机器，不是用户。</li>
<li>很多服务商是动态分配IP，每次登陆会得到不同的地址，所以现在利用IP 识别的，也一般仅仅是识别一个IP段，去做某种操作。</li>
<li>有些防火墙会通过NAT 网络地址转换方式，转换成一个防火墙共享IP 来访问。</li>
<li>有些会从HTTP 代理或网关出重新发出TCP 连接。</li>
</ul>
<p><strong>用户登录</strong><br>如果服务器希望在用户提供对站点访问之前，先行登陆，就会响应一个401 状态码，Login Required，然后显示一个登陆对话框，在随后的请求中会添加Authorization 首部。</p>
<p>其实这种方法已经不怎么用了，因为安全性太低了，现在也会出现有401钓鱼的行为，用户的登录信息虽然会加密，但是加密信息实在是太好破了，而且如果劫持了用户的信息，还可以放在自己的首部伪装成用户登录。</p>
<p><strong>胖URL</strong></p>
<p>有些站点利用对URL 添加特定的URL 版本，来追踪用户身份，比如一些商务网站，通过针对每个用户在URL 后边生成特定的标示符，可以实现对用户浏览的追踪。通过胖URL 可以将Web服务器上的若干个HTTP 事务绑定在一个会话和访问上，用户首次访问某站点，生成一个ID ，服务器通过识别ID 的方式，添加到URL 中去，然后将客户端导向到那个胖URL 上去。不论什么时候，只要服务器收到了胖URL 请求，都可以查找那个用户ID 相关的操作，增量状态等，然后重写输出超链接，让其成为胖URL，维护用户ID。</p>
<p>但是，这样的操作，我们也很明显看出了其中的问题：</p>
<ul>
<li>URL 丑陋，不说了</li>
<li>URL 无法共享，因为它包含了特定用户的一些信息。仅在部分情况下可以，就比如邀请人链接，刚好是需要这样的识别。</li>
<li>破坏缓存，每个用户的URL 都生成特定的版本，那么意味着没有公共可访问的URL 需要缓存了。</li>
<li>服务器负荷，重写HTML 和 生成胖URL。</li>
<li>逃逸，如果用户逃离了严格修改的URL 链接，就会失去了他所有的进展。</li>
<li>会话期间非持久，除非用户收藏了特定的URL， 否则用户删除之后，再也找不回来了。</li>
</ul>
<p>当然，胖URL 技术还是有很多应用的，这就要应对许多新的场景，展开更丰富的联想，也可以通过加入其它手段来克服其中的缺点，总之，不要放弃任何一种方法，有时候都是会起死回生。</p>
<p><strong>cookie</strong></p>
<p>cookie 可以分为两类： <strong>会话cookie 和 持久cookie</strong></p>
<p>对于会话cookie， 它是一种临时的cookie， 记录了用户访问站点时候的设置和偏好，用户退出浏览器，会话cookie 就会删除掉。而持久cookie 显然是生存周期更久的一种。常见的，如果cookie 设置了Discard 参数，没有设置Expires 或者 Max-Age 参数来说明扩展过期时间，那么一般就是一个会话cookie.</p>
<p>cookie 包含了一个由名字和值 组成的信息构成，通过Set-Cookie,Set-Cookie2 HTTP响应首部来给用户。下边这只是一个例子，cookie 的格式又服务器决定：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613325046800.jpg" alt=""></p>
<p>cookie 罐的概念，就是浏览器在本地管理cookie 信息的形式，浏览器要负责储存这些信息，一般统称为<strong>客户端侧状态</strong>，这种规范叫HTTP状态管理机制。不同的浏览器，会有不同的cookie 的储存机制。储存起来的cookie 包含了一些名称变量过期安全等考量，具体可查看每种浏览器的cookie格式。</p>
<p>虽然我们说，cookie 只会发给那些之前对应的服务器，但是某些无量的广告商，他们会发送持久cookie ，一些站点会委托同一个广告公司提供服务（比如百度），那么浏览器会将持久的cookie 发过来，广告公司通过将此技术和referer 结合，暗地里构建了一个用户档案和浏览习惯的详尽数据集。</p>
<p>cookie 将包含一些必要的信息，有些信息是可选的，其中具体的内容，这里不再赘述，具体可参见RFC 2965：</p>
<ul>
<li>cookie 域属性，Domain 属性将控制哪些站点可以得到那个cookie.</li>
<li>cookie 路径属性，cookie 规范允许用户将cookie 与部分 Web站点关联起来。Path 属性来实现功能，在这个属性下列出的URL 前缀下所有的cookie 都是有效的。</li>
<li>安全属性，可选</li>
<li>日期属性，可选</li>
</ul>
<p>而在cookie 的扩展版本中，引入了Set-Cookie2首部 和Cookie2 首部，做出了一些新的改进，它能够与cookie 互操作。</p>
<p>而 Set-Cookie2 属性包括有：</p>
<ul>
<li>NAME=VALUE 强制</li>
<li>Version 强制，规范版本。</li>
<li>Comment 可选，说明服务器如何使用cookie.</li>
<li>CommentURL  可选，策略文档。</li>
<li>Discard 可选，客户端程序终止时，指示客户端放弃cookie.</li>
<li>Domain 可选，域。</li>
<li>Max-Age 可选，生存期，秒为单位。</li>
<li>Path 可选，路径。</li>
<li>Port 可选，可以应用cookie 的端口列表。</li>
<li>Secure 可选，使用SSL才可以发送的指示。</li>
</ul>
<h3 id="cookie_与会话跟踪">cookie 与会话跟踪</h3>
<p>一张图，讲所有：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613368816595.jpg" alt=""></p>
<p>Web 通过一系列的重定向，URL 重写，和cookie 设置来附加标识信息。</p>
<h3 id="cookie_与缓存">cookie 与缓存</h3>
<p>目前还不需要用到相关业务，暂且不表。</p>
<h2 id="认证">认证</h2>
<p>HTTP 通过一组可定制的控制首部，为不同的认证协议提供一个可扩展的框架。主要分<strong>基本认证和摘要认证</strong></p>
<ul>
<li>质询 WWW-Authentiacate，服务器以401状态码拒绝请求，说明需要提供用户名和密码。</li>
<li>授权 Authorization 客户端重新发送请求，但这一次会负责为一个Authorization 首部，用来说明认证算法，用户名和密码。 属于GET</li>
<li>成功 Authentication-Info 如果授权书正确，服务器会将文档返回，授权算法在该首部返回一些与授权会话相关的信息。 200 OK。</li>
</ul>
<p>下面是相关的流程示意图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614015756784.jpg" alt=""></p>
<p><strong>安全域</strong></p>
<p>在上边的质询里有一个realm 他就是安全域，也就是你试图访问的安全域，需要哪个授权。</p>
<h3 id="基本认证">基本认证</h3>
<p>基本认证就是我们刚刚讲的质询响应，用户请求的资源位于某个安全域中，服务器会返回一个401，质询，并提供安全域。用户只有将用户名密码（base64 处理）后返回，才可以获得正确响应。</p>
<h3 id="代理认证">代理认证</h3>
<p>中间的代理服务器也可以实现认证功能，这样我们就可以在代理服务器上对访问策略进行集中管理。代理认证的首部有所不同，对应的返回码也是不同的。</p>
<ul>
<li>代理服务器返回 407</li>
<li>Proxy-Authenticate 对应 WWW-Authenticate</li>
<li>Proxy-Authorization 对应 Authorization</li>
<li>Proxy-Authentication-Info 对应 Authentication-Info</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<p>基本认证的缺陷很明显，所以现代的服务器基本不是这样处理了，缺陷有这么几点：</p>
<ol>
<li>基本认证通过网络发送用户名和密码，bash-64 没有安全可言。</li>
<li>即使密码是更难解码的方式加密，第三方用户仍然可以捕获修改过的用户名和密码，重放攻击。</li>
<li>即使将基本认证用于一些不重要的应用程序，如内部网络访问控制和个性化的访问，但捕获这些密码，可以构建撞库的可能。</li>
<li>基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，如果他们不修改认证首部，但是修改了报文的其他部分，仍然是严重的。</li>
<li>假冒服务器容易骗过基本认证，这也就是401钓鱼。</li>
</ol>
<h2 id="摘要认证">摘要认证</h2>
<p>摘要认证是另一种HTTP 认证协议，修复了一些严重的缺陷，一般有如下改进：</p>
<ul>
<li>永远不会以明文方式在网络上发送密码</li>
<li>可以防止恶意用户捕获并重放认证的握手过程</li>
<li>可以有选择的防止对报文内容的篡改</li>
<li>防范集中常见的攻击方式，如重放攻击等。</li>
</ul>
<p>单向摘要，实际上就是我们常用的MD5 ，SHA-1 了。<br>而为了防止重放攻击，服务器和客户端使用随机数这样的特殊令牌，客户端在计算摘要前将随机数附加上去，这样每次发送的信息，都会有一个随时间变化的随机数。</p>
<p>摘要算法的核心是对公共信息，保密信息，和有时限的随机值的摘要。核心是三个组件：</p>
<ul>
<li>单向散列函数H(d) 摘要KD(s, d)组成的一对函数。s表示密码，d表示数据。</li>
<li>包含安全信息的の数据块A1，包括密码。</li>
<li>包含请求报文中非保密属性的数据块，A2。</li>
</ul>
<p>其中A1 的数据块是密码，和受保护信息的产物，包含有用户名，密码，保护域，随机数的内容。一般是MD5.<br>A2 表示的是与报文自身有关的信息，比如URL，请求方法和报文实体部分。A2主要是防止方法，资源，报文被篡改。当qop = 「auth」 只包含HTTP 请求方法和URL。qop=’auth-int’ ，添加了报文的实体主题部分，提供一定程度的报文完整性检测。<br>摘要认证的过程及其内容看起来像是一个弱化版的SSL，所以在这里不再赘述，一个图大约够了。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614149936666.jpg" alt=""></p>
<p>稍微补充几个概念：</p>
<ul>
<li>预授权，正常来说，如果按照上边的说法，每次的请求，都要做一次质询，但如果我们采用授权模式，如果一次请求授权成功之后，每次服务器会返回一个随机数，客户利用随机数再发出下一次的请求，和授权，这样就节省了很多交互。</li>
<li>随机数的产生，是一个只有服务器知道的数据。</li>
<li>不仅可以有单向的认证，还可以采用对称形式的认证。</li>
</ul>
<p>下面则是讨论一下这个认证一些重要的实际问题和安全性问题：</p>
<ol>
<li>多重质询，因为服务器不知道客户端可以做到哪种能力的认证，所以可以又提供基本认证质询，又提供摘要认证质询。</li>
<li>差错处理，如果某个指定其值不正确或缺少必要指令，应当返回400 bad request。而且某些时候，连续的差错可能代表了某种攻击行为。</li>
<li>保护空间，也就是提供授权访问的区域。对于基本认证，考虑URL 之下的所有子路径都是同一保护空间。对于摘要认证，服务器会提供一个URI 的列表。</li>
<li>缓存，Cache-Control 指令为must-revalidate 和 public 会有不一样的处理。</li>
</ol>
<p>安全性的考量：</p>
<ol>
<li>首部篡改，这里的认证机制，实际上只是一个首部防篡改系统，对数据并起不到多少的保护作用。</li>
<li>重放攻击，也是前边一直力图解决的问题，防止中间人利用截获的认证证书用于其他事务。最重要的实际上应当是防止POST 请求和PUT 请求，可能会篡改服务器的内容。上边内容的缺陷在于面对代理集群传输的时候，会遇上麻烦，而且攻击者伪造IP 也是有可能的。而一种完全可以避免重放共及的方式就是为每个事务提供唯一的随机数，发布的随机只对指定的事务有效，而且只在超时区间内有效，这样中间人即使是篡改了报文，但随机数只对某事务有效，它仍然无法成功，当然这会造成服务器的负担。</li>
<li>多重认证机制，因为服务器支持多重认证，攻击者可能会采用某些方法，让服务器采用最弱的基本认证机制，而基本认证机制会有一些安全上的脆弱，所以，解决办法也只能是不允许降级。其实主动降级攻击这在攻击表里很常见，例如对SSL 的攻击了，就是试图去让SSL 退化到早先的版本，然后利用其中的漏洞进行攻击。</li>
<li>词典攻击，大部分是针对弱密码，采用复杂密码或者是密码过期策略之外，没有更好的办法。</li>
<li>中间人，恶意代理。客户端和服务器之间的代理，在处理客户端的报文时，故意降级，采用较弱的认证方式，实现前边所说的攻击。</li>
<li>选择明文攻击，这里是一个恶意的服务器，伪装成服务器，预先使用一个随机数和一个常见密码变化形式形成一组响应，创建一个词典。一旦有了规模可观的词典，攻击服务器或代理就可以完成对流量的封锁，向客户发送预先确定的随机数。攻击者从客户端得到一个响应时，会搜索生成的字典，寻找匹配项。找到对应的匹配项，就能获取密码了。另外，暴力枚举现在能力也很强大，他不使用预设的字典去匹配了，直接在指定空间内枚举全部可能，直接暴力破解。</li>
<li>服务器保存了密码文件，用来与用户响应的内容比较，如果密码文件被侵入，那该域中文件就不再安全了。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式探索之路（下）]]></title>
    <link href="http://yoursite.com/2016/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/12/设计模式探索之路（下）/</id>
    <published>2016-03-12T13:50:01.000Z</published>
    <updated>2016-03-12T13:51:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="组合模式(Composite_Pattern)">组合模式(Composite Pattern)</h2>
<p>我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>组合模式</strong>： 允许你将对象组合成树形结构来表现『整体/部分』的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br><a id="more"></a><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901208629.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901303514.jpg" alt=""></p>
<p> <strong>抽象构件（Component）</strong>: 这是一个抽象角色，它给参加组合的对象定义出公共的接口以及默认行为，可以用来管理所有的子对象。在安全式的组合模式里，构件角色并不是定义出管理子对象的方法，这一定义由树枝构件对象给出。<br> <strong>树叶构件（Leaf）</strong> : 树叶对象是没有下级子对象的方法，定义出参加组合的原始对象的行为。<br> <strong>树枝构建（Compositic）</strong>: 代表参加组合的有下级子对象的对象。树枝对象给出所有的管理子对象的方法，比如add(),remove(),getChild()等。</p>
<p>组合模式的实现根据所实现接口的区别分为两种形式，分别称为安全模式和透明模式。组合模式可以不提供父对象的管理方法，但组合模式必须在合适的地方提供子对象的管理方法（诸如：add、remove、getChild等）。</p>
<p><strong>透明模式</strong>： 在Component里面声明所有的用来管理子类对象的方法，包括add（）、remove（），以及getChild（）方法。这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端可以同等同的对待所有的对象。这就是透明形式的组合模式。</p>
<p>这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此add（）、remove（）以及getChild（）方法没有意义，是在编译时期不会出错，而只会在运行时期才会出错或者说识别出来。针对这个，我们常常用throw 抛出异常。</p>
<p><strong>安全方式</strong>： 是在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，因为树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。<br>这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。</p>
<p>上边的图安全方式的组合模式的类图结构和样例实现，透明方式就是在叶子节点的add()/remove()/GetChild()均有实现，不过是无意义的实现。大部分应用都是基于透明模式的，因为这样代码可以重用。</p>
<p>下面看一个实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Menu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> Menu    </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> ~Menu();  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Add(Menu*);  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Remove(Menu*);  </div><div class="line">    <span class="keyword">virtual</span> Menu* GetChild(<span class="keyword">int</span>);  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Display() = <span class="number">0</span>;  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    Menu();  </div><div class="line">    Menu(std::<span class="built_in">string</span>);  </div><div class="line">    std::<span class="built_in">string</span> m_strName;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//Menu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line">  </div><div class="line">Menu::Menu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu::Menu(std::<span class="built_in">string</span> strName) : m_strName(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu::~Menu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Menu::Add(Menu* pMenu)  </div><div class="line">{}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Menu::Remove(Menu* pMenu)  </div><div class="line">{}  </div><div class="line">  </div><div class="line">Menu* Menu::GetChild(<span class="keyword">int</span> index)  </div><div class="line">{  </div><div class="line">    <span class="keyword">return</span> NULL;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="comment">//SubMenu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> SubMenu : <span class="keyword">public</span> Menu    </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SubMenu();  </div><div class="line">    SubMenu(std::<span class="built_in">string</span>);  </div><div class="line">    <span class="keyword">virtual</span> ~SubMenu();  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> Display();  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//SubMenu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "SubMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line">SubMenu::SubMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">SubMenu::SubMenu(<span class="built_in">string</span> strName) : Menu(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">SubMenu::~SubMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> SubMenu::Display()  </div><div class="line">{  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; m_strName &lt;&lt; endl;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="comment">//CompositMenu.h  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> CompositMenu : <span class="keyword">public</span> Menu  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    CompositMenu();  </div><div class="line">    CompositMenu(std::<span class="built_in">string</span>);  </div><div class="line">    <span class="keyword">virtual</span> ~CompositMenu();  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> Add(Menu*);  </div><div class="line">    <span class="keyword">void</span> Remove(Menu*);  </div><div class="line">    Menu* GetChild(<span class="keyword">int</span>);  </div><div class="line">    <span class="keyword">void</span> Display();  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;Menu*&gt;</span> m_vMenu;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">//CompositMenu.cpp  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompositMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line">  </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line">CompositMenu::CompositMenu()  </div><div class="line">{  </div><div class="line">      </div><div class="line">}  </div><div class="line">  </div><div class="line">CompositMenu::CompositMenu(<span class="built_in">string</span> strName) : Menu(strName)  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line">CompositMenu::~CompositMenu()  </div><div class="line">{  </div><div class="line">  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Add(Menu* pMenu)  </div><div class="line">{  </div><div class="line">    m_vMenu.push_back(pMenu);  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Remove(Menu* pMenu)  </div><div class="line">{  </div><div class="line">    m_vMenu.erase(&pMenu);  </div><div class="line">}  </div><div class="line">  </div><div class="line">Menu* CompositMenu::GetChild(<span class="keyword">int</span> index)  </div><div class="line">{  </div><div class="line">    <span class="keyword">return</span> m_vMenu[index];  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> CompositMenu::Display()  </div><div class="line">{  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> &lt;&lt; m_strName &lt;&lt; endl;  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Menu*&gt;</span>::iterator it = m_vMenu.begin();  </div><div class="line">    <span class="keyword">for</span> (; it != m_vMenu.end(); ++it)  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"|-"</span>;  </div><div class="line">        (*it)-&gt;Display();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Menu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "SubMenu.h"  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompositMenu.h"  </span></div><div class="line">  </div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])  </div><div class="line">{  </div><div class="line">    Menu* pMenu = <span class="keyword">new</span> CompositMenu(<span class="string">"国内新闻"</span>);  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"时事新闻"</span>));  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"社会新闻"</span>));  </div><div class="line">    pMenu-&gt;Display();  </div><div class="line">    pMenu = <span class="keyword">new</span> CompositMenu(<span class="string">"国际新闻"</span>);  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"国际要闻"</span>));  </div><div class="line">    pMenu-&gt;Add(<span class="keyword">new</span> SubMenu(<span class="string">"环球视野"</span>));  </div><div class="line">    pMenu-&gt;Display();  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>几个要点：</strong></p>
<ul>
<li>组合模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。</li>
<li>组合模式在具体实现中，可以让父对象中的子对象反向追溯，这样做的话，当需要删除子节点的时候，通过父节点就更容易操作一些。</li>
<li>如果父对象有频繁的遍历需求，那么就可以使用缓存的技巧来改善效率。</li>
<li>将“客户代码与复杂的对象容器结构”解耦是组合模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复内部实现结构——发生依赖关系，从而更能“应对变化”。</li>
<li>客户端尽量不要直接调用树叶类的方法，而是借助其父类（Component）的多态性，完成调用，这样可以增加代码的复用性。</li>
</ul>
<h2 id="状态模式（State_Pattern）">状态模式（State Pattern）</h2>
<p><strong>状态模式</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901470388.jpg" alt=""></p>
<p>就像我们平时用的开关，开关有两个状态，开启和关闭，当它处于不同的状态的时候它的行为是不一样的，当我们遇到了更多的状态的时候，就需要动用到了这个状态模式。</p>
<p><strong>Context 上下文环境</strong>： 它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的具体状态对象来处理。<br><strong>Stata 抽象状态</strong>: 定义了一个接口以封装使用上下文环境的一个特定状态相关的行为。<br><strong>Concrete State 具体状态</strong>： 实例抽象状态定义的接口。</p>
<p>下面例子以游戏中坦克为例，坦克架起的时候，攻击力加强，不能移动。收起的时候，可攻击可移动。c++ 实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="keyword">class</span> SiegeTank;  </div><div class="line"><span class="keyword">class</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack() = <span class="number">0</span>;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> SiegeState : <span class="keyword">public</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SiegeState(SiegeTank* pTank): m_pTank(pTank){}  </div><div class="line">      </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't move in siege mode."</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attacking for 40"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    SiegeTank* m_pTank;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> TankState : <span class="keyword">public</span> ISiegeTankState  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    TankState(SiegeTank* pTank): m_pTank(pTank){}  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move to ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attacking for 20"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    SiegeTank* m_pTank;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">class</span> SiegeTank  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    SiegeTank()  </div><div class="line">    {  </div><div class="line">        m_pTankState = <span class="keyword">new</span> TankState(<span class="keyword">this</span>);  </div><div class="line">        m_pSiegeState = <span class="keyword">new</span> SiegeState(<span class="keyword">this</span>);  </div><div class="line">        m_pSiegeTankState = m_pTankState;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> enterTankMode()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = m_pTankState;  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Switch to tank mode"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> enterSiegeMode()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = m_pSiegeState;  </div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Switch to siege mode"</span> &lt;&lt; std::endl;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> attack()  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState-&gt;attack();  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">void</span> move(<span class="keyword">int</span> x, <span class="keyword">int</span> y)  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState-&gt;move(x, y);  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">void</span> setState(ISiegeTankState* pSiegeTankMode)  </div><div class="line">    {  </div><div class="line">        m_pSiegeTankState = pSiegeTankMode;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    TankState* m_pTankState;  </div><div class="line">    SiegeState* m_pSiegeState;  </div><div class="line">    ISiegeTankState* m_pSiegeTankState;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    SiegeTank tank;  </div><div class="line">    tank.enterTankMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">1</span>, <span class="number">1</span>);  </div><div class="line">  </div><div class="line">    tank.enterSiegeMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">2</span>, <span class="number">2</span>);  </div><div class="line">  </div><div class="line">    tank.enterTankMode();  </div><div class="line">    tank.attack();  </div><div class="line">    tank.move(<span class="number">3</span>, <span class="number">3</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>状态模式与策略模式</strong>：<br>状态模式中，我们将一群行为封装在状态对象中，context 的行为随时可委托到那些状态对象中的一个。当前状态在状态对象的集合中游走改变，反映出context 内部的状态，context的行为也因此跟着改变。<br>策略模式中，客户通常主动指定Context 所要组合的策略对象是哪一个。</p>
<p>一般来说，策略模式是一个弹性替代继承的一种方案。状态模式则是弹性替代了过多的条件判断。</p>
<p>状态模式主要解决的是党当控制一个状态转换的条件表达式过于复杂的时候，把状态的判断逻辑转移到表示不同状态的一个系列类中，可以吧复杂的判断逻辑简单化。当一个对象行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。</p>
<h2 id="代理模式（Proxy_Pattern）">代理模式（Proxy Pattern）</h2>
<p><strong>代理模式</strong>： 为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901592239.jpg" alt=""></p>
<ul>
<li><strong>抽象主题角色（Subject）</strong>：生命了真是主体和代理主题的共同接口，这样一来在任何使用真实主题的地方，都可以使用代理主题。</li>
<li><strong>代理主题角色（Proxy）</strong>: 代理主题角色内部含有对真实主题的引用，从而可以在任何时候操作真实主题对象；代理主题角色提供一个真实主题相同的接口，以便在任何时候都可以代替真实主题；控制真实主题的应用，负责在需要的时候创建真实主题；代理角色通常在讲客户端调用传递给真实主题之前或之后，都要执行某个操作，而不是单纯地将调用传递给真实主题对象。</li>
<li><strong>真实主题角色（RealSubject）：</strong> 定义了代理角色所代表的真实对象。</li>
</ul>
<p><strong>代理模式的分类</strong>：</p>
<ul>
<li><strong>远程代理</strong>： 为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可以是在另一个机器中。远程代理又叫大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的对象是局域的而不是远程的，而代理对象承担了大部分的网络通讯工作。</li>
<li><strong>虚拟代理</strong>：根据需要创建一个资源消耗较大的对象，使得此对象只在需要的时候才会被真正的创建，使用虚拟代理模式的好处就是代理对象可以在必要的时候才被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块在加载十分耗费资源的情况下，虚拟代理的好处就非常明显了。</li>
<li><strong>Copy-on-Write（写入时复制代理）</strong>： 虚拟代理的一种，把复制（克隆）拖延到只有客户端需要时，才真正采取行动。</li>
<li><strong>保护代理（Protector Access）</strong>： 控制一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。保护代理的好处是它可以在运行时对用户的有关权限进行检查，然后在核实后决定将调用传递给被代理的对象。</li>
<li><strong>Cache 代理</strong>： 为某一个目标操作的结果提供临时的储存空间，以便多个客户端可以共享这些结果。</li>
<li><strong>防火墙（Firewall）代理</strong>： 保护目标，不让恶意用户接近。</li>
<li><strong>同步化代理（Synchronization）</strong>： 使几个用户能够使用一个对象而没有冲突。</li>
<li><strong>智能引用代理（SmartReference）</strong>： 当一个对象被引用的时候，提供一些额外的操作，比如将此对象调用的次数记录下来等等。</li>
<li><strong>缓存代理</strong>： 为开销大的运算结果提供暂时存储；它允许多个客户共享结果，以减少计算或网络延迟。<br><strong>复杂隐蔽代理（Complexity Hiding Proxy）</strong> : 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理（Facade Proxy），复杂隐藏代理和外观代理是不一样的，因为代理控制访问，而外观模式只是提供另外一组接口。<br>其中，远程代理，虚拟代理，智能引用代理，保护代理最为常见。</li>
</ul>
<p>在C++ 中，智能指针采用引入计数器的方法可以帮助管理内存，而其使用的设计模式就是代理模式，代码重现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include "stdafx.h"  </span></div><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;  </span></div><div class="line">  </div><div class="line"><span class="preprocessor">#define KSAFE_DELETE(p) \  </span></div><div class="line">    <span class="keyword">if</span> (p)           \  </div><div class="line">        {                \  </div><div class="line">        delete p;    \  </div><div class="line">        p = <span class="type">NULL</span>;    \  </div><div class="line">        }  </div><div class="line"><span class="class">  </span></div><div class="line"><span class="keyword">class</span> <span class="type">KRefCount</span>  </div><div class="line">{  </div><div class="line">public:  </div><div class="line">    <span class="type">KRefCount</span><span class="container">()</span>:m_nCount<span class="container">(0)</span>{}  </div><div class="line">  </div><div class="line">public:  </div><div class="line">    void <span class="type">AddRef</span><span class="container">()</span>{m_nCount++;}  </div><div class="line">    int <span class="type">Release</span><span class="container">()</span>{return <span class="comment">--m_nCount;}  </span></div><div class="line">    void <span class="type">Reset</span><span class="container">()</span>{m_nCount=0;}  </div><div class="line">  </div><div class="line">private:  </div><div class="line">    int m_nCount;  </div><div class="line">};  </div><div class="line">  </div><div class="line">template &lt;typename <span class="type">T</span>&gt;  </div><div class="line"><span class="keyword">class</span> <span class="type">KSmartPtr</span>  </div><div class="line">{  </div><div class="line">public:  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="title">void</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="type">NULL</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span><span class="container">()</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="type">T</span>* <span class="title">pValue</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="title">pValue</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span><span class="container">()</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span><span class="container">(<span class="title">const</span> <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& <span class="title">sp</span>)</span>  </div><div class="line">        : m_pData<span class="container">(<span class="title">sp</span>.<span class="title">m_pData</span>)</span>  </div><div class="line">        , m_pReference<span class="container">(<span class="title">sp</span>.<span class="title">m_pReference</span>)</span>  </div><div class="line">    {  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">    ~<span class="type">KSmartPtr</span><span class="container">(<span class="title">void</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    inline <span class="type">T</span>& operator*<span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        return *m_pData;  </div><div class="line">    }  </div><div class="line">    inline <span class="type">T</span>* operator-&gt;<span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        return m_pData;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& operator=<span class="container">(<span class="title">const</span> <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& <span class="title">sp</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">this</span> != &<span class="title">sp</span>)</span>  </div><div class="line">        {  </div><div class="line">            if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">            {  </div><div class="line">                <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">                <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">            }  </div><div class="line">  </div><div class="line">            m_pData = sp.m_pData;  </div><div class="line">            m_pReference = sp.m_pReference;  </div><div class="line">            m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">        }  </div><div class="line">  </div><div class="line">        return *this;  </div><div class="line">    }  </div><div class="line">    <span class="type">KSmartPtr</span>&lt;<span class="type">T</span>&gt;& operator=<span class="container">(<span class="type">T</span>* <span class="title">pValue</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span> && <span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">        m_pData = pValue;  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">  </div><div class="line">        return *this;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="type">T</span>* <span class="type">Get</span><span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        <span class="type">T</span>* ptr = <span class="type">NULL</span>;          </div><div class="line">        ptr = m_pData;  </div><div class="line">  </div><div class="line">        return ptr;  </div><div class="line">    }  </div><div class="line">    void <span class="type">Attach</span><span class="container">(<span class="type">T</span>* <span class="title">pObject</span>)</span>  </div><div class="line">    {  </div><div class="line">        if <span class="container">(<span class="title">m_pReference</span>-&gt;<span class="type">Release</span>()</span> == 0)  </div><div class="line">        {  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pData</span>)</span>;  </div><div class="line">            <span class="type">KSAFE_DELETE</span><span class="container">(<span class="title">m_pReference</span>)</span>;  </div><div class="line">        }  </div><div class="line">  </div><div class="line">        m_pData = pObject;  </div><div class="line">        m_pReference = new <span class="type">KRefCount</span>;  </div><div class="line">        m_pReference-&gt;<span class="type">AddRef</span><span class="container">()</span>;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="type">T</span>* <span class="type">Detach</span><span class="container">()</span>  </div><div class="line">    {  </div><div class="line">        <span class="type">T</span>* ptr = <span class="type">NULL</span>;  </div><div class="line">  </div><div class="line">        if <span class="container">(<span class="title">m_pData</span>)</span>  </div><div class="line">        {             </div><div class="line">            ptr = m_pData;  </div><div class="line">            m_pData = <span class="type">NULL</span>;  </div><div class="line">            m_pReference-&gt;<span class="type">Reset</span><span class="container">()</span>;  </div><div class="line">        }  </div><div class="line">        return ptr;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">private:  </div><div class="line">    <span class="type">KRefCount</span>* m_pReference;  </div><div class="line">    <span class="type">T</span>* m_pData;  </div><div class="line">};</div></pre></td></tr></table></figure>

<p>适配器为适配对象提供了不同的接口，而代理模式则是提供了相同的接口。<br>装饰者为对象添加多个功能，而代理模式则是控制对对象的访问。<br><strong>在软件系统中</strong>，加一个中间层使我们常用的解决方法，常常就是使用的代理模式。</p>
<h2 id="设计模式之王—MVC（Model_-_View_-_Controller）">设计模式之王—MVC（Model - View - Controller）</h2>
<p>MVC 模式是复合模式的经典例子，也是现在开发中最常用到的设计模式，下面对它进行一一划分，因为C++ 中的没有现成的例子（或者说我的C++ 水平还很菜，没有意识到~MFC 比较接近），HeadFirst 设计模式中是以java为例写的，iOS开发中也常常用到。</p>
<p><strong>Model</strong>： 模型存储数据。对应了 Swift 中的 Album 这个类。<br><strong>View</strong>： 负责模型的可视化展示，并且负责和用户交互，在 Swift 开发中，对应了UIView 这个类。<br><strong>Controller</strong>: 控制器是整个系统的掌控者，它连接了模型层和数据层，并且吧数据在视图中展示出来，监听各种事件，负责数据的各种操作。对应Swift中的 ViewController 类。</p>
<p>下面这个是斯坦福大学公开课中给的MVC 的类图，非常的形象，被各种使用：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577901805125.jpg" alt=""></p>
<p>view中射出的箭头，指向target，代表在ios中对界面上的操作，反馈给了controller中去。<br>model 中的小发射塔，设定观察者，当model发生改变，会给观察者们以反馈。典型的例子就是iOS中的键盘呼出。<br><strong>Model</strong>: 它是应用数据和应用的状态，可能是一个数据库，也可能是你发动时创建的内存，或是你从网络得到的东西，它本质上是应用程序的数据，它基本上什么事情都不做。</p>
<p><strong>View</strong>：在界面上看到的东西，是互动的对象，它代表着你所使用的界面相称的用户模型，但它不清楚数据本身，视图允许你操纵数据，如果我有一个能改变磁盘上数据的滑动条，这个滑动条就是视图，他不存储任何数据，他们完全是动态的，他们被创建后，使用完就会清楚，他们很容易配置，如表格视图，他不了解数据，只代表数据。</p>
<p><strong>Model</strong>：Model是你的应用中数据的存储或数据的表现，相同的模型应该可以在不同的界面中重复使用和未作改变，如果你有代表一些数据集合的应用，假设这是个代表人口和选举信息的数据，这个数据本身，这个模型并不清楚信息是如何展示给用户，因此这个模型能够运用于不同的平台，他能用在不同的应用上，这个的前提是它独立的如何展现</p>
<p><strong>Controller</strong>：可以管理并把数据展示给视图，同样的，当视图想要操作数据，控制器会是视图能这样做的管道。在这个基础上，视图和模型永远不应该相互知道或相互交谈，控制器是管理，演示和控制的媒介。控制器基本是告诉视图关于数据的改变以及在视图需要时改变数据，大部分你的应用逻辑都会在控制器中。</p>
<p>那么MVC模式都复合了上边了解过的那些模式呢？</p>
<ul>
<li><strong>策略模式</strong>：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略。视图只关心系统中的可视部分，对于任何界面行为，都委托给控制器处理。使用策略模式也可以让视图和模型之间的关系解耦，因为控制器负责和模型交换来传递用户的请求。对于工作是怎么完成的，视图毫不知情。</li>
<li><strong>观察者模式</strong>： 为模型设立观察者，当模型发生变化的时候，会将变化反馈给所有的观察者，也就是控制器，做出相应的改变。</li>
<li><strong>组合模式</strong>： 视图是GUI组件的组合。顶层的组件包含其他组件，一直到叶子节点。</li>
</ul>
<p><strong>由于我们使用的是上帝视角，所以其实以上部分，谁与谁之间不能对话，不能调用显得没有那么强硬，我们在编码的过程中，实际上可以实现任何操作，但是，应当遵循的原则，是按照图片中所说的，让model 和 View 尽量解耦，所有的操作应当在Controller中完成。</strong></p>
<p>因为目前没有学习 Java ，Swift 也只是简单的上了下手，对MVC 模型的实战留在日后，而MVC 与web的操作在适配MVC 这一模式，使它更符合浏览器 / 服务器的模型，人们叫它 Model 2，以后有时间继续深挖。</p>
<h2 id="只是个开始">只是个开始</h2>
<p>至此，Headfrist 设计模式中提到的14种设计模式被我用了大约一周多的时间过了一遍，书讲的很通俗很入门，但缺点就是比较浅，没法对每一种模式有更深入的认识。另外，作为凌驾于所有语言之上的设计模式，认真学习它是必须和刻不容缓的。在此基础上，从这本书开始，我应当继续探索设计模式的内容，以贴近实践的方式体会和理解设计模式给开发带来的优势，下边是对这些设计模式的一个分类和一句话总结。</p>
<p><strong>创建型</strong>（4，5未提及）用来处理对象的创建过程：</p>
<ol>
<li><strong>单例模式(Singleton Pattern)</strong>： 确保有且只有一个对象被创建，提供一个访问它的全局访问点。</li>
<li><strong>工厂方法模式(Factory Method Pattern)</strong>： 定义一个创建产品对象的工厂接口，而由子类决定要创建的具体类是哪一个，也就是将实际创建工作推迟到子类中去。</li>
<li><strong>抽象工厂模式(Abstract Factory Pattern)</strong>： 提供一个创建一些列相关或者相互依赖的接口，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder pattern）</strong>:  讲一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype Pattern）</strong>： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
</ol>
<p><strong>结构型</strong>用来处理类或对象的组合：</p>
<ol>
<li><strong>适配器模式（Adapter Pattern）</strong>： 讲一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容不能一起工作的那些类可以一起工作。</li>
<li><strong>组合模式（Composite Pattern）</strong>： 将对象组合成树形结构以表示『部分-整体』的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li>
<li><strong>外观模式（Facade Pattern）</strong>： 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li><strong>装饰者模式（Decorator Pattern ）</strong>： 动态的给一个对象添加一些额外的职责，就增加功能来说，这一模式比生成子类更为灵活。（包装一个对象，提供新的行为）。</li>
<li><strong>代理模式（Proxy Pattern）</strong>： 为其他对象提供一种代理以控制对这个对象的访问。</li>
<li><strong>桥接模式（Bridge Pattern）</strong>： 将抽象部分与实际部分分离，使他们可以独立的变化。</li>
<li><strong>享元模式（Flyweight Pattern）</strong>： 以共享的方式高效的支持大量的细粒度的对象。</li>
</ol>
<p><strong>行为型</strong>用来对类和对象怎样交互和分配职责进行描述：</p>
<ol>
<li><strong>命令模式（Command Pattern）</strong>： 将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</li>
<li><strong>迭代器模式（Iterator Pattern）</strong>： 提供一个方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象内部的表示。</li>
<li><strong>观察者模式（Observer Pattern）</strong>： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</li>
<li><strong>状态模式（State Pattern）</strong>: 允许一个对象在其内部改变时改变它的行为，使对象看起来似乎修改了它的类。封装基本状态的行为，并使用委托在行为之间切换。</li>
<li><strong>策略模式</strong>： 准备一组算法，并将每个算法封装起来，使用委托来决定使用哪一个。</li>
<li><strong>模板方法模式（Template Method Pattern）</strong>： 子类在不改变一个算法的结构情况下，可以重定义该算法的某些特定步骤。</li>
<li><strong>责任链模式（Chain of Responsibility Pattern）</strong>： 在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上某一个对象决定处理此请求，使得系统可以在不影响客户端的情况下动态的重新组织链和分配责任。</li>
<li><strong>解释器模式（Interpreter Pattern）</strong>： 描述了如何为简单的语言顶一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。</li>
<li><strong>中介者模式（Mediator Pattern） </strong>： 定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示的相互调用，从而使其耦合性松散，而且可以独立的改变他们之间的交互。</li>
<li><strong>备忘录模式（Memento Pattern）</strong>： 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
<li><strong>访问者模式（Visitor Pattern）</strong>： 表示一个作用于某对象结构中的各个元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ol>
<p>最后，是几个奉劝：</p>
<ul>
<li>学会用模式去思考</li>
<li>保持一切越简单越好</li>
<li>设计模式不是银弹，不是万灵丹</li>
<li>你应当知道何时需要模式</li>
<li>重构的时间，其实就是运用模式的时间</li>
<li>拿掉你不需要的设计模式</li>
</ul>
<p>设计模式的魅力是无穷的，而设计模式的学习和体悟，需要通过不断的实践去反思和体会的，旅途刚刚开始，Keep Moving…</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="组合模式(Composite_Pattern)">组合模式(Composite Pattern)</h2>
<p>我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>组合模式</strong>： 允许你将对象组合成树形结构来表现『整体/部分』的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br>]]>
    
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式探索之路（上）]]></title>
    <link href="http://yoursite.com/2016/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/12/设计模式探索之路（上）/</id>
    <published>2016-03-12T13:44:48.000Z</published>
    <updated>2016-03-12T13:51:39.000Z</updated>
    <content type="html"><![CDATA[<p>这篇学习加总结的文章写了很久了，但是因为之前是使用马克飞象来写的，其中的图片保存在本地，再上传到博客上非常麻烦，于是就一直趴在电脑里。后来使用了MWeb之后，Mweb推出了图床的功能，懒癌的我找到了最爱，终于可以开心的将一些文章扔博客里去了。鉴于这篇文章太长，大约有两万五千多字，拆分成两篇，作为设计模式的学习理解。设计模式这个东西，说他厉害他确实在工程里占有很高的地位，但是不应当过分的信仰这种东西，他其实只是解决工程问题的有效途径，但并不一定是最佳的途径。</p>
<p>当然试图去寻找到最佳的途径，显示是要先对这些人们已经充分认同的设计模式有所理解。<br><a id="more"></a></p>
<h2 id="策略模式（引子）">策略模式（引子）</h2>
<p>重新设计类结构，创造更多接口，而不是简单地增加进程。比如我们建立一个鸭子的超类，超类中拥有呱呱叫和飞的两个函数。因为我们认为鸭子普遍是可以飞和叫的。当我们在分别建立绿头鸭红头鸭子类的时候，可以直接继承了两种方法。但是此时如果要建立橡皮鸭呢?建立木头鸭呢？这个时候，我们就面临着这个超类的可复用的弹性问题了。所以，我们采用的方法是，把呱呱叫和飞行封装，形成借口，封装的行为里，定义一组行为，有可以飞不可以飞，呱呱叫吱吱叫或者是完全不叫，这一组行为，可以叫一个『算法族』。这样就大大提高了系统的弹性。</p>
<p>简单来讲，定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。<br><strong>设计的原则：</strong></p>
<ol>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。（使用组合建立系统具有更大弹性）</li>
</ol>
<h2 id="观察者模式">观察者模式</h2>
<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。当两个对象<strong>松耦合</strong>，他们依然可以交互，但是不清楚彼此的细节。</p>
<p>有多个观察者的时候，不可以依赖特定的通知次序。</p>
<p>Java API 内置了观察者模式，java.util 包内包含了最基本的 Observer 接口和 Observalbe 类。不过 java.util.Observable 是一个类而不是接口，所以在实现上，他还有一些问题，限制了它的使用和福永，所以在使用中应当注意。（OBservable 是一个类，必须设计一个类继承它，如果某个类想要同时具有Observable 类和另外一个超类的行为，就会陷入两难，因为 Java 不支持多重继承。）</p>
<p>JDK 中 Swing 大量使用了观察者模式，很多GUI 框架也是如此。</p>
<p>我们常听说的MVC 其实就是观察者模式中的代表人物。 </p>
<p><strong>设计的原则（增）：</strong></p>
<ol>
<li>（找出变化，独立出来）在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这叫前提规则。</li>
<li>（针对接口编程，而非针对实现）主题与观察者都是用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点。</li>
<li>（多用组合，少用继承）观察者利用『组合』将许多观察者组合进主题中，对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。</li>
<li>为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</li>
</ol>
<h2 id="装饰者模式">装饰者模式</h2>
<p>首先了解一个开放-关闭原则，是装饰者模式的一个重要设计原则，我们的目标是允许类更容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。如能实现这样的目标，这样的设计就具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>
<p><strong>装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</strong></p>
<p><strong>以咖啡馆为例</strong>：咖啡馆提供各种饮料，现在要设计一个订单系统，来优化他们的饮料供应要求。如果我们用最基本的类设计，让一个超类具有提供通用的方法，子类继承并实现cost() 等方法，这样我们就看到一个爆炸式的类继承图。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577898209517.jpg" alt=""></p>
<p>所以，这个时候我们考虑装饰者模式，如果一个顾客需要摩卡和奶泡深焙咖啡，那么我们就先拿一个深焙咖啡对象，然后用摩卡对象装饰它（包起来），以奶泡对象装饰它，最后调用 cost（）方法，一来委托将调料的价钱加上去。如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899539183.jpg" alt=""></p>
<ul>
<li>装饰着和被装饰者对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象的场合，可以用装饰过的对象来代替他。</li>
<li><strong>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态的不限量的把你喜欢的装饰者来装饰对象。<br>这是修改成装饰者模式的框架：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899646754.jpg" alt=""></li>
</ul>
<p>在 Java 中， java.io 包就是一个使用装饰者模式最好的例子。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>因为在设计中加入了大量的小类，所以导致不容易理解这种设计方式。</li>
<li>类型问题。人们在客户代码中依赖某种特殊类型，然后忽然导入装饰者，就会出现各种状况。</li>
<li>采用装饰者在实例化组件时，将增加代码的复杂度。</li>
</ol>
<p><strong>设计原则：</strong></p>
<ol>
<li>类应该对扩展开放，对修改关闭。</li>
</ol>
<h2 id="工厂模式">工厂模式</h2>
<p>人们普遍认为工厂模式分三类，简单工厂模式，工厂方法模式，和抽象工厂模式，不过要澄清一下，其实简单工厂模式只是在概念上符合了工厂模式，而其实还存在有缺陷。简单工厂就是最简单的创造了一个工厂，在实例化对象的时候，由工厂来决定实例化哪一种对象。</p>
<p>以下面代码为例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> CTYPE {COREA, COREB};     </div><div class="line">class SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//单核A    </span></div><div class="line">class SingleCoreA: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore A"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//单核B    </span></div><div class="line">class SingleCoreB: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore B"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断    </span></div><div class="line">class Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:     </div><div class="line">    SingleCore* <span class="title">CreateSingleCore</span>(<span class="keyword">enum</span> CTYPE ctype)    </div><div class="line">    {    </div><div class="line">        <span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断    </span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA(); <span class="comment">//生产核A    </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)    </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); <span class="comment">//生产核B    </span></div><div class="line">        <span class="keyword">else</span>    </div><div class="line">            <span class="keyword">return</span> NULL;    </div><div class="line">    }    </div><div class="line">};</div></pre></td></tr></table></figure>

<p>这个设计的缺点在于，如果我们要增加新的类型，就需要进入工厂类中去修改，这就违反了我们上次提到的原则：<strong>类应当向扩展开放，向修改封闭</strong>。</p>
<p>所以，此时我们的工厂方法模式就出现了，工厂方法模式的定义是：<strong>工厂模式的特点就是我们定义一个创建对象的接口，但是由子类来决定实例化的类是哪一个。工厂方法就是让类把实例化推迟到了子类。</strong> 工厂方法用来处理对象的创建，然后将这个行为封装到子类中去，本身并不进行实例化，这样的话，客户程序中关于超类的代码，就和子类对象创建的代码解耦了。</p>
<p>结合实例讲解就是，这家生产处理器核为自己设立了一个总厂，总厂并不做生产的活动，而是再开设一个工厂专门用来生产B型号的单核，和另一个工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面这个是代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//单核A    </span></div><div class="line">class SingleCoreA: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore A"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line"><span class="comment">//单核B    </span></div><div class="line">class SingleCoreB: <span class="keyword">public</span> SingleCore    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">void</span> <span class="title">Show</span>() { cout&lt;&lt;<span class="string">"SingleCore B"</span>&lt;&lt;endl; }    </div><div class="line">};    </div><div class="line">class Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span>() = <span class="number">0</span>;  </div><div class="line">};    </div><div class="line"><span class="comment">//生产A核的工厂    </span></div><div class="line">class FactoryA: <span class="keyword">public</span> Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    SingleCoreA* <span class="title">CreateSingleCore</span>() { <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; }    </div><div class="line">};    </div><div class="line"><span class="comment">//生产B核的工厂    </span></div><div class="line">class FactoryB: <span class="keyword">public</span> Factory    </div><div class="line">{    </div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    SingleCoreB* <span class="title">CreateSingleCore</span>() { <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; }    </div><div class="line">};</div></pre></td></tr></table></figure>

<p>在《HeadFirst设计模式》书中，利用另外一个例子讲述了这个问题，有一家披萨店，在纽约和芝加哥开了披萨的分店，而每个分店为了满足当地人的口味，有着当地口味的各种披萨。于是我们就看到了这个UML图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577899825102.jpg" alt=""></p>
<p>这里边工厂方法是创造一个框架，让子类去决定如何实现。在工厂方法中，<code>orderPizza()</code> 方法提供了一般框架，以便创建披萨，<code>orderPizza()</code>方法依赖工厂方法创建具体类，然后制造出具体的披萨出来。而简单工厂的做法是可以将对象的创建封装起来，但是不具备工厂方法的弹性。这种方法，相比于简单工厂的模式，拥有了更多的弹性。</p>
<p>下面我们再引入一个原则：<br><strong>设计原则：</strong></p>
<ol>
<li>要依赖抽象，不要依赖具体类。（依赖倒置原则 Dependency Inversion Principle）无论是高层组件，和低层组件，都应当依赖于抽象，而非具体的类。</li>
</ol>
<p>下面几个指导方针，可以避免在设计中违反依赖倒置原则：</p>
<ul>
<li>变量不可以持有具体类的引用。（如果使用一个new，就会持有具体类的引用，可以改用工厂方法来避开这种做法）</li>
<li>不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类）</li>
<li>不要覆盖基类中已经实现的方法。（如果覆盖了基类中已经实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已经实现的方法，应该由所有的子类共享）</li>
</ul>
<p>那么，下面我们就能引入抽象工厂模式，<strong> 抽象工厂模式，提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</strong>。下面这张图将有助于理解其中的关系。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900057893.jpg" alt=""></p>
<p>我们看到，抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包括了一组方法用来生产产品。下面回到那个披萨店的问题，下面这张图就更加复杂，而其中抽象出来的披萨原料工厂接口，正是整个抽象工厂概念的精髓。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900183155.jpg" alt=""><br><img src="./1444916335159.png" alt="Alt text"></p>
<p>具体的披萨工厂负责生产披萨原料，每个工厂都知道如何产生符合自己区域的正确对象，而披萨店有两个具体事例，纽约披萨店和芝加哥披萨店，他们就是抽象工厂的客户。</p>
<p><strong>工厂方法模式和抽象工厂模式的区别</strong>：<br><strong>工厂方法在创建对象的方法是利用继承，而抽象工厂是通过对象的组合。</strong>这意味着，利用工厂方法创建对象，需要扩展一个类，并覆盖它的工厂方法，这个工厂方法用来创建对象，而整个工厂方法模式，不过就是通过子类来创建对象，用户在使用时候，只需要知道他们所使用的抽象类型就可以了。而抽象工厂提供了一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被生产的方法。要想使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中去。</p>
<p>所以，当你需要创建一个产品将组，想让制造的相关产品集合起来的时候，可以使用抽象工厂模式。而当你目前还不知道到底需要实例化哪些具体类，可以使用工厂方法模式，因为扩展和修改很快。</p>
<h2 id="单件模式（Singleton_Pattern）">单件模式（Singleton Pattern）</h2>
<p>看完了一个相当复杂的工厂模式，下面转入一个比较简单的模式，单件模式。定义如下：</p>
<p><strong>单件模式确保一个类只有一个实例，并提供一个全局访问点。</strong></p>
<p>有一些对象其实我们只需要一个，比方说：<strong>线程池（threadpool）、缓存（cache）、对话框、处理偏好设置、注册表（registry）的对象、日志对象、打印机显卡等设备的对象。</strong>  由于普通的全局变量，必须在程序已开始就创建好对象，那么如果这个对象非常的消耗资源，而在程序的运行过程中一直没有用到它，不就形成了浪费了么。所以使用单件模式，就可以在需要的时候去创建这个对象。</p>
<p><strong>适用性</strong>：</p>
<ol>
<li>对于一个类，如果他比较大，而且这些资源可以被全局共享，就可以设计成单件模式。</li>
<li>对于一个类，需要对实例进行计数。可以在 Instance 中进行，并可以对实例的个数进行限制。</li>
<li>对于一个类，需要对其实例的具体行为进行控制。例如，期望返回的实例实际上是自己子类的实例。这样可以通过单件模式，对客户端代码保持透明。</li>
</ol>
<p>单件模式，没有公开的构造器，是私有的。当为了取得实例，必须请求得到一个实例，而不是自行实例化得到一个一个实例。类中有一个静态方法 ，叫做GetInstance() ，调用这个方法，就可以让这个唯一的实例现身，这个实例也许是第一次创建，也许是已经创建了。下面是一个单件模式的通用写法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">作用：保证一个class只有一个实体（instance），并为它提供一个全局唯一的访问点 </div><div class="line">*/  </div><div class="line">class singleton  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ~<span class="title">singleton</span>()  </div><div class="line">    {<span class="comment">//析构时使用  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">static</span> singleton* getInstance()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(_instance == NULL)  </div><div class="line">        {  </div><div class="line">            _instance = <span class="keyword">new</span> singleton();  </div><div class="line">        }  </div><div class="line">        <span class="keyword">return</span> _instance;  </div><div class="line">    }  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">static</span> singleton *_instance;  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">//最好将所有此类的实例化的进口全部堵死  </div><div class="line">    <span class="title">singleton</span>()  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">    singleton(<span class="keyword">const</span> singleton&)  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">    singleton& operator=(<span class="keyword">const</span> singleton &)  </div><div class="line">    {  </div><div class="line">  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">singleton *singleton::_instance = NULL;</div></pre></td></tr></table></figure>

<p>看起来很美好，不过这个代码仍然存在问题。</p>
<ol>
<li>释放的问题，上述例子中的<code>_instance</code>，不会自动释放，而需要手动去释放，尤其是做借口时候，需要告知使用方调用 <code>delete singleton::getInstance()</code>语句。</li>
<li>多线程使用的环境下，极有可能会出现同时创造了前后不一致的对象，失去了单件模式的本意，这个问题就严重了。</li>
</ol>
<p><strong>解决方法：</strong><br>针对释放问题的解决方法：</p>
<ol>
<li>调用 <code>delete singleton::getInstance()</code>语句。</li>
<li>注册一个<code>atexit()</code>函数，将释放内存的方法放进去，此方法可以将多个单件放在一起调用。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void <span class="function">releasefun</span>()  </div><div class="line">{  </div><div class="line">    delete singleton<span class="value">::<span class="function">getInstance</span>();</span>  </div><div class="line">}  </div><div class="line"><span class="comment">//在使用完成后调用  </span></div><div class="line"><span class="function">atexit</span>(releasefun);</div></pre></td></tr></table></figure>

<ol>
<li>使用智能指针，C++ STL中的<code>auto_ptr</code>就是一个。<code>static auto_ptr&lt;singleton&gt; _instance;</code> </li>
<li>利用c++ 内嵌类和一个静态成员自动释放机制，将这个类嵌入到单件模式的类中去。然后在<code>getInstance（）</code> 中声明一个静态的实例对象。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class clearer  </div><div class="line">    {  </div><div class="line">    public<span class="value">:  </span></div><div class="line">        <span class="function">clearer</span>(){}  </div><div class="line">        ~<span class="function">clearer</span>()  </div><div class="line">        {  </div><div class="line">            <span class="function">if</span>(singleton::<span class="function">getInstance</span>())  </div><div class="line">            {  </div><div class="line">                delete singleton::<span class="function">getInstance</span>();  </div><div class="line">            } }  };</div></pre></td></tr></table></figure>

<p><strong>针对多线程的问题：</strong><br>在这里引入一个著名的双检测锁机制，看到代码，一定会觉得非常的有想法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> singleton* getInstance()  </div><div class="line">{  </div><div class="line">    <span class="keyword">if</span>(_instance == <span class="keyword">NULL</span>)  </div><div class="line">    {  </div><div class="line">        <span class="comment">//加入临界区  </span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">NULL</span> == _instance)  </div><div class="line">        {  </div><div class="line">            _instance = <span class="keyword">new</span> singleton();  </div><div class="line">        }  </div><div class="line">        <span class="comment">//释放临界区  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">return</span> _instance;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里边这个临界区的思路，正好解决了多线程的问题。</p>
<p>同时，如果有多个类加载器存在的时候，很有可能创建各自不同的单件实例，这个时候，就要小心，应该自行指定类加载器，并指定同一个类加载器。</p>
<h2 id="命令模式（Command_Pattern）">命令模式（Command Pattern）</h2>
<p><strong>命令模式将『请求』封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</strong></p>
<p>一个简单的生活中的例子就是，我们去餐厅吃饭，通过服务员来点餐，具体谁来做这些菜还什么时候完成这些菜我们并不知道。而服务员则只是将我们下的订单，传递给厨师，具体的做菜过程是由厨师完成的。所以，『菜单请求者』和『菜单实现者—厨师』之间是解耦的。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900365661.jpg" alt=""></p>
<p>图中的几个角色有：</p>
<ul>
<li><strong>客户（Client）角色：</strong>创建了一个具体命令(ConcreteCommand)对象并确定其接收者。</li>
<li><strong>请求者（Invoker）角色：</strong>负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
<li><strong>命令（Command）角色：</strong>声明了一个给所有具体命令类的抽象接口。这是一个抽象角色。</li>
<li><strong>具体命令（ConcreteCommand）角色：</strong>定义一个接受者和行为之间的弱耦合；实现Execute()方法，负责调用接收考的相应操作。Execute()方法通常叫做执行方法。调用者只需要调用<code>excute()</code>就可以发出请求。</li>
<li><strong>接收者（Receiver）角色：</strong>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ul>
<p>在刚才那个餐厅的例子，我们建立一一的对应关系，这样理解起来就更加容易了。</p>
<ul>
<li>女招待 &lt;—&gt; <code>invoker</code></li>
<li>快餐厨师 &lt;—&gt; <code>Receiver</code></li>
<li><code>orderUp()</code> &lt;—&gt; <code>execute()</code></li>
<li>订单 &lt;—&gt; <code>command</code></li>
<li>顾客 &lt;—&gt; <code>Client</code></li>
<li><code>takeOrder()</code> &lt;—&gt; <code>setCommand()</code></li>
</ul>
<p>下面我们看一个实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">// 烤肉师傅  </span></div><div class="line"><span class="keyword">class</span> RoastCook  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> MakeMutton() { <span class="built_in">cout</span> &lt;&lt; <span class="string">"烤羊肉"</span> &lt;&lt; endl; }  </div><div class="line">    <span class="keyword">void</span> MakeChickenWing() { <span class="built_in">cout</span> &lt;&lt; <span class="string">"烤鸡翅膀"</span> &lt;&lt; endl; }  </div><div class="line">};  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">// 抽象命令类  </span></div><div class="line"><span class="keyword">class</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    Command(RoastCook* temp) { receiver = temp; }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() = <span class="number">0</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    RoastCook* receiver;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 烤羊肉命令  </span></div><div class="line"><span class="keyword">class</span> MakeMuttonCmd : <span class="keyword">public</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    MakeMuttonCmd(RoastCook* temp) : Command(temp) {}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() { receiver-&gt;MakeMutton(); }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 烤鸡翅膀命令  </span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> MakeChickenWingCmd : <span class="keyword">public</span> Command  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    MakeChickenWingCmd(RoastCook* temp) : Command(temp) {}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ExecuteCmd() { receiver-&gt;MakeChickenWing(); }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// 服务员类  </span></div><div class="line"><span class="keyword">class</span> Waiter  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> SetCmd(Command* temp);  </div><div class="line">  </div><div class="line">    <span class="comment">// 通知执行  </span></div><div class="line">    <span class="keyword">void</span> Notify();  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Command*&gt;</span> m_commandList;  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Waiter::SetCmd(Command* temp)  </div><div class="line">{  </div><div class="line">    m_commandList.push_back(temp);  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"增加订单"</span> &lt;&lt; endl;  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">void</span> Waiter::Notify()  </div><div class="line">{  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Command*&gt;</span>::iterator it;  </div><div class="line">    <span class="keyword">for</span> (it=m_commandList.begin(); it!=m_commandList.end(); ++it)  </div><div class="line">    {  </div><div class="line">        (*it)-&gt;ExecuteCmd();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    <span class="comment">// 店里添加烤肉师傅、菜单、服务员等顾客  </span></div><div class="line">    RoastCook* cook = <span class="keyword">new</span> RoastCook();  </div><div class="line">    Command* cmd1 = <span class="keyword">new</span> MakeMuttonCmd(cook);  </div><div class="line">    Command* cmd2 = <span class="keyword">new</span> MakeChickenWingCmd(cook);  </div><div class="line">    Waiter* girl = <span class="keyword">new</span> Waiter();  </div><div class="line">  </div><div class="line">    <span class="comment">// 点菜  </span></div><div class="line">    girl-&gt;SetCmd(cmd1);  </div><div class="line">    girl-&gt;SetCmd(cmd2);  </div><div class="line">    <span class="comment">// 服务员通知  </span></div><div class="line">    girl-&gt;Notify();  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>命令模式有几个常见的可适用功能：</p>
<ul>
<li>当系统需要支持撤销的命令（undo）。类中加入一个新的实例变量，命令对象使用它追踪那个最后被调用的命令，不管何时撤销按钮被按下，我们都可以调出这个命令然后实现undo。</li>
<li><strong>宏命令</strong>，我们可以制造一个新的命令，用来执行其他一堆命令，形成一个命令的集合。</li>
<li><strong>队列请求</strong>，一个命令对象和原先的请求发送者可以有不同的生命期。换言之，原先的请求发送者可能已经不存在了，而命令对象本身仍然在活动中。这时，命令的接受者可以是在本地，也可以是网络的另外一个地址。命令对象可以在串行化之后传送到另一台机器上。</li>
<li><strong>日志请求</strong>，如果一个系统想要将系统中的所有数据更新到日志中，以便在系统崩溃的时候，可以根据日志回读所有的数据来更新命令，从新调用<strong>*excute()</strong>方法一条一条的执行这些命令，从而恢复系统在崩溃之前所有的数据更新。</li>
</ul>
<h2 id="适配器模式和外观模式（the_Adapter_and_Facade_Patterns）">适配器模式和外观模式（the Adapter and Facade Patterns）</h2>
<p>比如我们中国的电压是220v，而美国的电压是110v，为了一个中国的电脑，能在美国使用，就必须需要一个变压器转换电压之后才可以使用，这就是真实世界里的适配器。而我们OO世界里的适配器和它是一个道理，就是<strong>将一个接口转换成另一个接口，以符合客户的期望。适配器让原本接口不兼容的类可以合作。</strong></p>
<p>客户使用适配器的过程：</p>
<ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口。</li>
<li>客户接受到调用的结果，并未察觉到这一切是适配器在起转换作用。</li>
</ol>
<p>下面是它的类图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900527574.jpg" alt=""></p>
<p>Adaptee类没有Request方法，而客户期待这个方法。为了使客户能够使用Adaptee类，提供一个中间环节，即类Adapter类，Adapter类实现了Target接口，并继承自Adaptee，Adapter类的Request方法重新封装了Adaptee的SpecificRequest方法，实现了适配的目的。</p>
<p>以下是一个简单的c++ 实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">// "ITarget"  </span></div><div class="line"><span class="keyword">class</span> Target  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Methods  </span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> Request(){};  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// "Adaptee"  </span></div><div class="line"><span class="keyword">class</span> Adaptee  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Methods  </span></div><div class="line">    <span class="keyword">void</span> SpecificRequest()  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Called SpecificRequest()"</span>&lt;&lt;endl;  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="comment">// "Adapter"  </span></div><div class="line"><span class="keyword">class</span> Adapter : <span class="keyword">public</span> Adaptee, <span class="keyword">public</span> Target  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="comment">// Implements ITarget interface  </span></div><div class="line">    <span class="keyword">void</span> Request()  </div><div class="line">    {  </div><div class="line">        <span class="comment">// Possibly do some data manipulation  </span></div><div class="line">        <span class="comment">// and then call SpecificRequest    </span></div><div class="line">        <span class="keyword">this</span>-&gt;SpecificRequest();  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">    </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    <span class="comment">// Create adapter and place a request  </span></div><div class="line">    Target *t = <span class="keyword">new</span> Adapter();  </div><div class="line">    t-&gt;Request();  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>适配器分为对象的适配器，和类的适配器。上边给出的类图，是对象适配器的图。而类适配器与其的差别是适配器继承了Target和Adaptee。而对象适配器利用组合的方式将请求传送给被适配者。下边是类适配器。由于类适配器使用了多重继承，所以在java上不能实施。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900649733.jpg" alt=""></p>
<p>我们看到适配者模式的几个要点：</p>
<ol>
<li>适配者模式主要用于『希望复用一些现存的类，但是接口又与复用环境要求不一致的情况』，在遗留代码复用，类库迁移等方面非常有用。</li>
<li>适配者模式有对象适配器和类适配器两种形式的实现结构，但是类适配器采用的是『多继承』的实现方式，带有不良的高耦合，所以一般不推荐采用。对象适配器采用『对象组合』的方式，更符合松耦合的精神。</li>
<li>适配者模式的实现可以非常的灵活，不必拘泥于两种结构，例如完全可以将适配者模式中的『现存对象』作为新的接口方法参数，来达到适配的目的。</li>
<li>适配者模式本身要求我们尽可能的使用『面向接口的编程』风格，这样才能在后期很方便的进行适配。</li>
</ol>
<p>而与适配者模式很相近的一个模式，叫外观模式。而实际上他的作用其实是为了简化接口。比如我们建立了一套家庭影院，这套家庭影院里拥有各种各样的方法类，但是当我们想要看电影的时候，去逐个完成准备的动作，将变得非常的繁琐。而有效的方式，则是将一系列的任务和在一起，外观类将家庭影院的诸多组件视为一个子系统，通过调用这个子系统，来实现一个方法，这个方法包含了子系统的各种方法。</p>
<p>所以，我们知道，外观类并未将原来的子系统阻隔起来，只是提供了更简洁的接口，这种方法，也可以将客户从组件的子系统中解耦。</p>
<p><strong>新的设计原则</strong>：</p>
<ol>
<li>最少知识原则，只和你的密友谈话。（意思是，当你设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。）不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他的部分。  </li>
</ol>
<p>最后我们再看一下 ，适配者模式，装饰模式，外观模式的区别：<br><strong>适配者模式</strong>将一个对象包装起来以改变其接口；<strong>装饰者</strong>将一个对象包装起来以增加新的行为和责任。<strong>外观</strong>将一群对象包装起来以简化其接口。</p>
<h2 id="模板方法模式（Template_Method_Pattern）">模板方法模式（Template Method Pattern）</h2>
<p>《设计模式》对模板方法模式的定义是：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以再不改变算法结构的情况下，重新定义算法中的某些步骤。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900837995.jpg" alt=""></p>
<p><strong>抽象模板角色（AbstractClass）：</strong><br>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，他们是一个顶级逻辑的组成步骤。定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体的方法。这个就是我们定义了我们固定的操作顺序。</p>
<p><strong>具体模板角色(ConcreteClass):</strong><br>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。<br>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<p>来自Head First 设计模式中的一个例子的c++实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> CaffeineBeverage  <span class="comment">//咖啡因饮料  </span></div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> PrepareRecipe() <span class="comment">//咖啡因饮料冲泡法  </span></div><div class="line">    {  </div><div class="line">        BoilWater();  <span class="comment">//把水煮沸  </span></div><div class="line">        Brew();    <span class="comment">//冲泡  </span></div><div class="line">        PourInCup();  <span class="comment">//把咖啡因饮料倒进杯子  </span></div><div class="line">        AddCondiments(); <span class="comment">//加调料  </span></div><div class="line">    }  </div><div class="line">    <span class="keyword">void</span> BoilWater()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"把水煮沸"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {<span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;Brew();}  </div><div class="line">    <span class="keyword">void</span> PourInCup()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"把咖啡倒进杯子"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {<span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;AddCondiments();}  </div><div class="line">};  </div><div class="line"><span class="keyword">class</span> Coffee : <span class="keyword">public</span> CaffeineBeverage&lt;Coffee&gt;  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"用沸水冲泡咖啡"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"加糖和牛奶"</span> &lt;&lt; std::endl;}  </div><div class="line">};  </div><div class="line"><span class="keyword">class</span> Tea : <span class="keyword">public</span> CaffeineBeverage&lt;Tea&gt;  </div><div class="line">  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">void</span> Brew()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"用沸水浸泡茶叶"</span> &lt;&lt; std::endl;}  </div><div class="line">    <span class="keyword">void</span> AddCondiments()  </div><div class="line">    {std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"加柠檬"</span> &lt;&lt; std::endl;}  </div><div class="line">};  </div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)  </div><div class="line">{  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"冲杯咖啡:"</span> &lt;&lt; std::endl;  </div><div class="line">    Coffee c;  </div><div class="line">    c.PrepareRecipe();  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; std::endl;  </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"冲杯茶:"</span> &lt;&lt; std::endl;  </div><div class="line">    Tea t;  </div><div class="line">    t.PrepareRecipe();  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>其实在模板父类里，我们可以定义一个『默认不做事』的方法，我们称这种方法为『Hook』钩子，子类可以视情况决定要不要覆盖它们。这就让子类在实现的时候有了更多的灵活性。<br><strong>钩子</strong>： </p>
<ul>
<li>钩子可以让子类实现算法中的可选部分，或者钩子对于子类的实现并不重要的时候， 子类可以对钩子置之不理。</li>
<li>让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤做出反应。比如说justReOrderedList（） 的钩子方法允许子类在内部列表重新组织后执行某些动作。</li>
<li>可以让子类有能力为其抽象类做一些决定。</li>
</ul>
<p>适用性：</p>
<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 </li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 </li>
<li>控制子类扩展。模板方法只在特定点调用“Hook”操作，这样就只允许在这些点进行扩展。</li>
</ol>
<p><strong>新的设计原则</strong>：<br>戏称为<strong>好莱坞原则</strong>，别调用我们，我们会调用你。我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。模板方法模式就是典型的好莱坞原则。其他还有工厂方法，观察者等等。</p>
<h2 id="迭代器（Iterator_Pattern）">迭代器（Iterator Pattern）</h2>
<p>现在有两种储存数据的模式，一种用的是ArrayList , 而另一种则用的是数组，两种结构所拥有的方法各不相同。假如我们想要将两种数据存储方式整合在一起，然后用相同的方法使用遍历它们的时候，这个时候就要用到了鼎鼎大名的迭代器了。</p>
<p>当我们说『集合』（collection）的时候，我们指的是一群对象。其储存方式可以使各种各样的数据结构，如，列表，数组，散列表。无论用什么方式，一律可以视为集合，有时候也称为『聚合』（aggregate）。</p>
<p>迭代器模式的精髓：提供一个方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-12-14577900977664.jpg" alt=""></p>
<p>重要角色：<br><strong>迭代器角色</strong>：迭代器负责定义访问和遍历元素的接口。<br><strong>具体迭代器角色（Concrete Iterator）</strong> ： 具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。<br><strong>集合角色（Aggregate）</strong>: 集合角色负责提供创建具体迭代器角色的接口。<br><strong>具体集合角色（Concrete Aggregate）</strong>: 具体集合角色实现创建具体迭代器角色的接口——这个具体迭代器角色与该集合的结构有关。</p>
<p>回到实例中去看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;  </span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> Iterator  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> next()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> Item* currentItem()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> isDone()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> ~Iterator(){}  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteAggregate;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteIterator : <span class="keyword">public</span> Iterator &lt;Item&gt;  </div><div class="line">{  </div><div class="line">    ConcreteAggregate&lt;Item&gt; * aggr;  </div><div class="line">    <span class="keyword">int</span> cur;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ConcreteIterator(ConcreteAggregate&lt;Item&gt;*a):aggr(a),cur(<span class="number">0</span>){}  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first()  </div><div class="line">    {  </div><div class="line">        cur=<span class="number">0</span>;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> next()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(cur&lt;aggr-&gt;getLen())  </div><div class="line">            cur++;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> Item* currentItem()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">if</span>(cur&lt;aggr-&gt;getLen())  </div><div class="line">            <span class="keyword">return</span> &(*aggr)[cur];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> NULL;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> isDone()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> (cur&gt;=aggr-&gt;getLen());  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> Aggregate  </div><div class="line">{  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">virtual</span> Iterator&lt;Item&gt;* createIterator()=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">virtual</span> ~Aggregate(){}  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Item&gt;  </div><div class="line"><span class="keyword">class</span> ConcreteAggregate:<span class="keyword">public</span> Aggregate&lt;Item&gt;  </div><div class="line">{  </div><div class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;Item &gt;</span>data;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    ConcreteAggregate()  </div><div class="line">    {  </div><div class="line">        data.push_back(<span class="number">1</span>);  </div><div class="line">        data.push_back(<span class="number">2</span>);  </div><div class="line">        data.push_back(<span class="number">3</span>);  </div><div class="line">    }  </div><div class="line">    <span class="keyword">virtual</span> Iterator&lt;Item&gt;* createIterator()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;Item&gt;(<span class="keyword">this</span>);  </div><div class="line">    }  </div><div class="line">    Item& <span class="keyword">operator</span>[](<span class="keyword">int</span> index)  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> data[index];  </div><div class="line">    }  </div><div class="line">    <span class="keyword">int</span> getLen()  </div><div class="line">    {  </div><div class="line">        <span class="keyword">return</span> data.size();  </div><div class="line">    }  </div><div class="line">};  </div><div class="line">  </div><div class="line"><span class="keyword">int</span> main()  </div><div class="line">{  </div><div class="line">    Aggregate&lt;<span class="keyword">int</span>&gt; * aggr =<span class="keyword">new</span> ConcreteAggregate&lt;<span class="keyword">int</span>&gt;();  </div><div class="line">    Iterator&lt;<span class="keyword">int</span>&gt; *it=aggr-&gt;createIterator();  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(it-&gt;first();!it-&gt;isDone();it-&gt;next())  </div><div class="line">    {  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;*(it-&gt;currentItem())&lt;&lt;endl;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">delete</span> it;  </div><div class="line">    <span class="keyword">delete</span> aggr;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>迭代器</strong>的特点：</p>
<ul>
<li>迭代抽象： 访问一个聚合对象而无需暴露它的内部表示。</li>
<li>迭代多态： 为遍历不同的集合结构，提供了一个统一的借口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑： 遍历的同时要更改迭代器所在的集合结构，会导致问题。<br>C++ 下有 STL Iterator 实现，Java 下有 java.util.Iterator 和 java.util.Enumeration。 </li>
</ul>
<p><strong>新的设计原则</strong>：<br><strong>单一责任</strong>： 一个类应该只有一个引起变化的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇学习加总结的文章写了很久了，但是因为之前是使用马克飞象来写的，其中的图片保存在本地，再上传到博客上非常麻烦，于是就一直趴在电脑里。后来使用了MWeb之后，Mweb推出了图床的功能，懒癌的我找到了最爱，终于可以开心的将一些文章扔博客里去了。鉴于这篇文章太长，大约有两万五千多字，拆分成两篇，作为设计模式的学习理解。设计模式这个东西，说他厉害他确实在工程里占有很高的地位，但是不应当过分的信仰这种东西，他其实只是解决工程问题的有效途径，但并不一定是最佳的途径。</p>
<p>当然试图去寻找到最佳的途径，显示是要先对这些人们已经充分认同的设计模式有所理解。<br>]]>
    
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinyhttpd analysis]]></title>
    <link href="http://yoursite.com/2016/03/12/Tinyhttpd-analysis/"/>
    <id>http://yoursite.com/2016/03/12/Tinyhttpd-analysis/</id>
    <published>2016-03-12T13:28:57.000Z</published>
    <updated>2016-03-12T13:31:26.000Z</updated>
    <content type="html"><![CDATA[<p>这是个不错的源码，用C 语言写的一个超轻量的HttpServer, 开发应该是用不上了，但是对于学习Unix 网络编程，套接字，进程等等来说相当够用。源代码大约500行，属于一个比较容易理解的代码量。</p>
<p>阅读C 源码的好处在于你不必去考虑类和对象，不用花时间去看类里有哪些成员变量和成员函数，不用费力去构建类图。只需要按照过程阅读就好了。</p>
<p>在源码上我进行了注释，在这里我对其中涉及到的Unix知识进行一点解释，也算是给啃UNP做一个预热。</p>
<p>打开httpd.c，这一长串函数，最重要的就是 <strong>startup</strong>, <strong>accept_request</strong>, 和 <strong>execute_cgi</strong>，以及<strong>get_line</strong>。 下面是每个函数的功能。<br><strong>accept_request</strong>:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。<br><a id="more"></a></p>
<ul>
<li><strong>bad_request</strong>: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.</li>
<li><strong>cat</strong>: 读取服务器上某个文件写到 socket 套接字。</li>
<li><strong>cannot_execute</strong>: 主要处理发生在执行 cgi 程序时出现的错误。</li>
<li><strong>error_die</strong>: 把错误信息写到 perror 并退出。</li>
<li><strong>execute_cgi</strong>: 运行 cgi 程序的处理，也是个主要函数。</li>
<li><strong>get_line</strong>: 读取套接字的一行，把回车换行等情况都统一为换行符结束。</li>
<li><strong>headers</strong>: 把 HTTP 响应的头部写到套接字。</li>
<li><strong>not_found</strong>: 主要处理找不到请求的文件时的情况。</li>
<li><strong>sever_file</strong>: 调用 cat 把服务器文件返回给浏览器。</li>
<li><strong>startup</strong>: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。</li>
<li><strong>unimplemented</strong>: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</li>
</ul>
<p>下面找到main函数，开始往下读。因为没有学习过Unix网络编程，所以中间一大把时间都花在了wiki的扩展。</p>
<p>首先将流程讲一下。</p>
<ol>
<li><strong>startup</strong>（）启动服务器，在指定的端口绑定httpd服务。</li>
<li>因为打开了listen, 当accept 到HTTP 请求时，那么久派生出一个进程去运行<strong>accept_request()</strong></li>
<li>在<strong>accept_request</strong>（） 中，取出HTTP 请求，获取它的method(可能是GET 或 POST)和url 。对于GET来说，若这个GET 请求带有参数，那么久会存在于url 中的「？」之后，将它保存在<strong>query_string</strong>中。</li>
<li>然后格式化url，将它保存到path数组中，也就是浏览器请求的服务器文件路径，如果url以<strong>/</strong>结尾，那就在路径结尾默认加上index.html，用来表示访问主页。</li>
<li>检验这个路径，如果不合法则返回错误。如果合法，再如果是一个没有参数的GET 请求，那我们直接输出服务器中的文件到浏览器就可以了，也就是用HTTP 格式写到套接字上，然后就可以直接结束了。对于其他情况（有参数的GET， POST， url是可执行文件），那么久继续调用 excute_cgi 来执行cgi.</li>
<li>进入excute_cgi(),读取HTTP请求，然后丢弃，如果他是一个POST 请求，那么有一个Content-Length, 找出来，然后把HTTP 200 状态码写到套接字。</li>
<li>用pipe建立两个管道,<strong>cgi_input</strong>,<strong>cgi_output</strong>，等下fork一个进程。管道是用来父进程和子进程通信的。</li>
<li>子进程中，STDOUT 也就是 1， 重定向到<strong>cgi_output</strong>的写入端，也就是<strong>cgi_output</strong>[1], STDIN 也就是 0， 重定向到<strong>cgi_input</strong>的读取端，也就是<strong>cgi_input</strong>[0]。子进程中关闭<strong>cgi_input</strong>的写入端，<strong>cgi_output</strong>的读取端。</li>
<li>仍然是在子进程中，设置<strong>request_method</strong>的环境变量，如果是GET 的话设置<strong>query_string</strong> 的环境变量，POST的话设置<strong>content_length</strong> 的环境变量，这个变量的作用是让cgi调用，在管道里进行通信，然后execl运行cgi，进行通信。</li>
<li>在父进程中，关闭<strong>cgi_input</strong>的读取端，<strong>cgi_output</strong>的写入端，如果请求是POST 的话，就把POST 写入<strong>cgi_input</strong>,在子进程中，他被重定向到了STDIN，读取<strong>cgi_output</strong>的管道输出到客户端，这个管道的输入被重定向到了STDOUT。然后关闭所有管道，等待子进程结束。</li>
<li>最后结束，关闭连接，完成了一次HTTP请求与回应。</li>
</ol>
<p>关于CGI 技术，现在并不需要详细的学习CGI，只需要了解一下四点：</p>
<ol>
<li>web-server将POST数据重定向到CGI的标准输入，读用户POST的数据可以直接读stdin</li>
<li>web-server将Http头设置成CGI的环境变量，所有读Http头信息可以通过getenv函数</li>
<li>web-server将GET数据设置成CGI的环境变量，可以通过getenv(“QUERY_STRING”)得到</li>
<li>web-server将CGI的标准输出重定向到浏览器，所以CGI输入内容直接向stdout输出就可以了。</li>
</ol>
<p>未完待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是个不错的源码，用C 语言写的一个超轻量的HttpServer, 开发应该是用不上了，但是对于学习Unix 网络编程，套接字，进程等等来说相当够用。源代码大约500行，属于一个比较容易理解的代码量。</p>
<p>阅读C 源码的好处在于你不必去考虑类和对象，不用花时间去看类里有哪些成员变量和成员函数，不用费力去构建类图。只需要按照过程阅读就好了。</p>
<p>在源码上我进行了注释，在这里我对其中涉及到的Unix知识进行一点解释，也算是给啃UNP做一个预热。</p>
<p>打开httpd.c，这一长串函数，最重要的就是 <strong>startup</strong>, <strong>accept_request</strong>, 和 <strong>execute_cgi</strong>，以及<strong>get_line</strong>。 下面是每个函数的功能。<br><strong>accept_request</strong>:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。<br>]]>
    
    </summary>
    
      <category term="Unix" scheme="http://yoursite.com/tags/Unix/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The different means of Stack]]></title>
    <link href="http://yoursite.com/2016/03/10/The-different-means-of-Stack/"/>
    <id>http://yoursite.com/2016/03/10/The-different-means-of-Stack/</id>
    <published>2016-03-10T05:40:05.000Z</published>
    <updated>2016-03-10T05:45:02.000Z</updated>
    <content type="html"><![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。<a id="more"></a>

</li>
</ul>
<h3 id="代码存放的区域">代码存放的区域</h3>
<p>stack 的另一种含义是存放数据的一种内存区域，参考<a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" target="_blank" rel="external">维基百科</a> ，我们知道，程序包含几个区域，静态区，堆区，栈区。</p>
<ul>
<li><strong>栈区（stack）</strong>— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li>
<li><strong>堆区（heap）</strong> — 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)。 - 程序结束后由系统释放</li>
<li><strong>文字常量区</strong> — 常量字符串就是放在这里的。 程序结束后由系统释放</li>
<li><strong>程序代码区</strong>— 存放函数体的二进制代码。</li>
</ul>
<p>下面这是个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">main.cpp </div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>; 全局初始化区 </div><div class="line"><span class="keyword">char</span> *p1; 全局未初始化区 </div><div class="line">main() </div><div class="line">{ </div><div class="line"><span class="keyword">int</span> b; 栈 </div><div class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>; 栈 </div><div class="line"><span class="keyword">char</span> *p2; 栈 </div><div class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="number">123456</span>在常量区，p3在栈上。 </div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； 全局（静态）初始化区 </div><div class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </div><div class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </div><div class="line">分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。 </div><div class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="number">123456</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">"123456"</span>优化成一个地方。 </div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于stack 来说，stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；但是heap 是没有结构的，数据可以任意的存放，因此，stack 的寻址速度要快于heap。</p>
<p>而且，一般来说，对每个线程会分配一个stack ,每个进程分配一个heap 。那么stack 就是线程独占的，而heap 则是线程共用的。stack 在创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap 的大小是不确定的，需要的话，可以不断的增加。</p>
<p>所以，只要是局部的，占用空间确定的数据，都会存放在stack 里边，其他的不确定的，动态生成的，就存放在heap 里去。</p>
<p>比如我们的创建新的对象，就会存放在heap中，因为stack 在使用完后会又编译器自动释放，但是heap 如果不去有效的清理，等待系统的垃圾清理机制去将这块内存清理，就很容易发生内存溢出。</p>
<p>更多详细的解释，可以参考<a href="http://blog.csdn.net/chenke1988/article/details/7273375" target="_blank" rel="external">这篇文章</a></p>
<h3 id="代码运行的方式-_调用栈">代码运行的方式- 调用栈</h3>
<p>第三种含义可以是调用栈，call stack 。它用的就是栈的思路，表示函数或者子例程像堆积木一样存放，以实现层层调用。</p>
<p>对于调用栈的方式，我们举个例子，该例子来自<a href="http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/" target="_blank" rel="external">java 8 stack and heap</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Student{</div><div class="line">    <span class="keyword">int</span> age;              </div><div class="line">    String name;      </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Student</span>(<span class="keyword">int</span> Age, String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.age = Age;</div><div class="line">        setName(Name);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.name = Name;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">            Student s;           </div><div class="line">            s = <span class="keyword">new</span> Student(<span class="number">23</span>,<span class="string">"Jonh"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其调用main 方法时候，需要生成一个student实例，于是调用student 构造函数，在构造函数中又调用了setName方法。如图（来自阮一峰）：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575871473636.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSL 图解]]></title>
    <link href="http://yoursite.com/2016/03/10/SSL-%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/10/SSL-图解/</id>
    <published>2016-03-10T03:22:20.000Z</published>
    <updated>2016-03-10T03:23:36.000Z</updated>
    <content type="html"><![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br><a id="more"></a><br>SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。SSL 包括的工作原理有，<strong>握手协议，记录协议，报警协议。</strong></li>
</ul>
<h3 id="握手协议">握手协议</h3>
<p>握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。</p>
<p>每个握手协议包含以下3个字段</p>
<ul>
<li>Type：表示10种消息类型之一</li>
<li>Length：表示消息长度字节数</li>
<li>Content：与消息相关的参数<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575301594684.jpg" alt=""></li>
</ul>
<p>比如我们在发送已加密的 HTTP 报文之前,客户端和服务器要进行一次 SSL 握手,在这个握手过程中,它们要完成以下工作:</p>
<ul>
<li>交换协议版本号;</li>
<li>选择一个两端都了解的密码;</li>
<li>对两端的身份进行认证;</li>
<li>生成临时的会话密钥,以便加密信道。</li>
</ul>
<p>我这里引述阮一峰在博客中举得alice and Bob 的例子。</p>
<ol>
<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>
<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ol>
<p>下面再进一步详解每一部分：</p>
<p><strong>第一和第二步，建立安全能力</strong></p>
<p>SSL握手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。<br>Client hello消息包括Version，Random，Session id，Cipher suite，Compression method等信息。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575307943892.jpg" alt=""></p>
<p>ClientHello 客户发送CilentHello信息，包含如下内容：</p>
<ul>
<li>客户端可以支持的SSL最高版本号</li>
<li>一个用于生成主秘密的32字节的随机数。</li>
<li>一个确定会话的会话ID。</li>
<li>一个客户端可以支持的密码套件列表。</li>
<li>一个客户端可以支持的压缩算法列表。</li>
</ul>
<p>密码套件格式：每个套件都以“SSL”开头，紧跟着的是密钥交换算法。用“With”这个词把密钥交换算法、加密算法、散列算法分开，例如：SSL_DHE_RSA_WITH_DES_CBC_SHA, 表示把DHE_RSA(带有RSA数字签名的暂时Diffie-HellMan)定义为密钥交换算法；把DES_CBC定义为加密算法；把SHA定义为散列算法。</p>
<p>而ServerHello服务器用ServerHello信息应答客户，包括下列内容</p>
<ul>
<li>一个SSL版本号。取客户端支持的最高版本号和服务端支持的最高版本号中的较低者。</li>
<li>一个用于生成主秘密的32字节的随机数。（客户端一个、服务端一个）</li>
<li>会话ID</li>
<li>从客户端的密码套件列表中选择的一个密码套件</li>
<li>从客户端的压缩方法的列表中选择的压缩方法</li>
</ul>
<p>这个阶段之后，客户端服务端知道了下列内容：</p>
<ul>
<li>SSL版本</li>
<li>密钥交换、信息验证和加密算法</li>
<li>压缩方法</li>
<li>有关密钥生成的两个随机数。</li>
</ul>
<p><strong>第二阶段，服务器鉴别与密钥的交换</strong></p>
<p>服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：</p>
<ul>
<li>证书：服务器将数字证书和到根CA(Certification Authority)整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。</li>
<li>服务器密钥交换（可选）：这里视密钥交换算法而定</li>
<li>证书请求：服务端可能会要求客户自身进行验证。</li>
<li>服务器握手完成：第二阶段的结束，第三阶段开始的信号</li>
</ul>
<p>这一步在刚才的例子中被合并在第二步里。其重点在于服务端的验证和密钥的交换。在SSL 中密钥交换算法有6种：无效（没有密钥交换）、RSA、匿名Diffie-Hellman、暂时Diffie-Hellman、固定Diffie-Hellman、Fortezza。</p>
<p>在阶段一那里，双方已经协商确定使用哪种算法。而且CA 证书里包含了公钥。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575744280354.jpg" alt=""></p>
<p>比如我们协商使用了RSA 交换密钥，那么过程是这样的：<br>这个方法中，服务器在它的第一个信息中，发送了RSA加密/解密公钥证书。不过，因为预备主秘密是由客户端在下一个阶段生成并发送的，所以第二个信息是空的。注意，公钥证书会进行从服务器到客户端的验证。当服务器收到预备主秘密时，它使用私钥进行解密。服务端拥有私钥是一个证据，可以证明服务器是一个它在第一个信息发送的公钥证书中要求的实体。</p>
<p><strong>第三阶段，客户机鉴别与密钥交换</strong></p>
<p>在这一阶段，主要是我们的客户机启动，发送消息，服务器是唯一的接收方。分为三个阶段：</p>
<ul>
<li>证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。</li>
<li>客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。</li>
<li>证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。</li>
</ul>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575746918586.jpg" alt=""></p>
<p>这里的重点就是，我们的客户端把自己的公钥发给服务端，方便服务端用公钥加密，然后通过服务端之间发过来的证书里的公钥，加密自己的随机数和预备秘密，又保证了秘密的私密性，又证明了它拥有证书的公钥。</p>
<p><strong>第四阶段</strong></p>
<p>刚才服务端收到了用公钥加密的第三个随机数，这时服务端和客户端就可以使用三个随机数生成本次的会话密钥，双方通过计算得到本次使用的会话密钥。然后互相发送：</p>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>握手结束通知，表示握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供互相校验。</li>
</ul>
<p>而这三个随机数要获得总共六个加密秘密：四个密钥（客户公钥私钥 和服务器公钥私钥），两个IV（initialization vector 初始向量，与区块加密模式有关）。加密过程如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575782242346.jpg" alt=""></p>
<p>首先利用之前发送的预备主秘密，双方发送的随机数等组合散列并获得MD5值，得到一个主秘密。再对主秘密进行处理，得到一串散列值，这个散列值可以拆分成四个密钥和两个IV。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791281572.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791478878.jpg" alt=""></p>
<h3 id="记录协议">记录协议</h3>
<p>刚才讲的只是在完成了握手协议，下面在握手成功后，双方如何互传信息呢。就需要使用记录协议。记录协议提供了两个服务：</p>
<ul>
<li>保密性，使用握手协议定义的秘密密钥实现</li>
<li>完整性，握手协议定义了MAC， 用于保证信息完整性</li>
</ul>
<p>整个记录协议的过程如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575792771159.jpg" alt=""></p>
<h3 id="警报协议">警报协议</h3>
<p>当客户和服务器发现出现错误的时候，就需要处理这个错误。于是，就向对方发送一个警报信息。如果是致命错误，那么就会立即关闭SSL 连接，而且双方还会删除相关的会话号，秘密和密钥。这就是警报协议，每个警报的信息共有两个字节，第一个字节表示错误类型，如果是警报，置1，如果是致命错误，置2.第二个字节指定实际的错误类型。</p>
<p>相关扩展：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">DH加密方法</a></p>
<p><a href="http://www.openssl.org/" target="_blank" rel="external">OpenSSL</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP/IP 完全解读之传输层协议]]></title>
    <link href="http://yoursite.com/2016/03/09/TCP-IP-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB1/"/>
    <id>http://yoursite.com/2016/03/09/TCP-IP-完全解读1/</id>
    <published>2016-03-09T09:29:23.000Z</published>
    <updated>2016-03-09T09:36:38.000Z</updated>
    <content type="html"><![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br><a id="more"></a></p>
<h3 id="1-1_多路复用/分解">1.1 多路复用/分解</h3>
<p>在阐述这个问题之前，我们先来简单谈一下不同主机应用程序<strong>进程间通信</strong>的问题。我们知道不同应用程序之间的交互实际上是进程间的交互，在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。在这个过程中，通信间进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送和接收报文，套接字是同一台主机内应用层与传输层之间的接口（因此套接字也称为应用程序和网络之间的API）。在网络中，主机地址由IP地址标识，一个发送进程要将报文送往另一台主机的接收进程，除了要知道主机IP地址外，还要知道接收进程的接收套接字，这个接收套接字对应一个目的地<strong>端口号（port number）</strong>。</p>
<p>对于传输层传输的每个报文，其中都有一些字段，传输层检查这个字段，进而把报文定向到正确的接收套接字。将运输层报文段中的数据交付到正确的套接字的工作就称为<code>多路分解</code>。与之对应，源主机从不同套接字收集数据块，并为每个数据块封装上首部信息（用于以后分解）从而生成报文段，并将报文段传递到网络层的工作称为<code>多路复用</code>。</p>
<p>实际中，这些特殊的字段是<strong>源端口号</strong>字段和<strong>目的端口号</strong>字段，端口号是一个16bit的数，大小在0—65535之间，其中0—1023范围称为<strong>周知端口号（well-known port number）</strong>，保留给诸如HTTP（80端口）、FTP（控制：21端口，数据：20端口）、telnet（23端口），SMTP（25端口），POP3（110端口），NNTP（119端口）等周知的应用层协议使用。查看周知端口号可前往：<a href="www.iana.org">www.iana.org</a></p>
<p>下这张图给出了一个多路复用和分解的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-1.png" alt="1"></p>
<h4 id="1-1-1_无连接的多路复用/分解">1.1.1 无连接的多路复用/分解</h4>
<p>UDP采用无连接的多路复用与分解，一个UDP套接字是由一个二元组（源端口号，目的端口号）来标识的，该二元组包含一个目的IP地址和目的端口号，两个UDP报文只要有相同的IP地址和目的端口号，那么这两个报文就将通过相同的目的套接字被定向到相同的目的进程。在下面的例子中，主机A中的一个进程具有UDP端口号19157，它要发送一个应用程序数据块给位于主机B的另一进程，该进程具有UDP端口号46428。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-2.png" alt="2"></p>
<h4 id="1-1-2_有连接的多路复用/分解">1.1.2 有连接的多路复用/分解</h4>
<p>TCP采用有连接的多路复用与分解，一个TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，与UDP不同，即使两个TCP报文有相同的目的IP地址和目的端口号，如果它们源IP地址或源端口号不同，就会被定向到两个不同的套接字。例子如下：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-3.png" alt="3"></p>
<h2 id="2_UDP">2 UDP</h2>
<p>UDP（User Datagram Protocol）指用户数据报协议，简单来讲，UDP无非就是对网络层协议增加了多路复用/分解功能而已（还有少量差错检测）。</p>
<p>使用UDP时，在发送报文之前，发送方和接收方的运输层实体间没有握手，因此UDP被称为<strong>无连接的</strong>。UDP无法提供可靠的数据传输，它有以下特点：</p>
<blockquote>
<ul>
<li>只要应用程序将数据传递给UDP，UDP就会将此数据打包进UDP报文并立即将其传递给网络层（相比之下TCP有拥塞控制机制）。由于实时应用通常要求最小发送速率，不希望过分延迟报文段的传送，且能容忍一些数据丢失，因此这些应用可以采用UDP实现。</li>
<li>无需建立连接，TCP在开始数据传输之前要经过三次握手，而UDP不需要任何准备即可传输数据，因此UDP不会引入建立连接的时延（正是由于这个原因，DNS使用UDP而不是TCP）。</li>
<li>无需维护连接状态，TCP要在端系统间维护连接状态（接收/发送缓存，拥塞控制参数，序号，确认号），而UDP不维护连接状态，因此也不需要这些参数。对于一些应用而言，相比TCP，UDP能支持更多的活跃用户。</li>
<li>分组首部开销小，每个TCP报文有20字节的首部开销，而UDP仅有8字节，更节约流量带宽。</li>
<li>由于UDP缺乏拥塞控制机制，因此发生拥塞时可能导致发送方和接收方的高丢包率，并会挤垮TCP会话。</li>
</ul>
</blockquote>
<h3 id="2-1_UDP报文段结构">2.1 UDP报文段结构</h3>
<p>UDP定义在RFC 768中，如下图所示，UDP首部只有四个字段（源端口号，目的端口号，长度，检验和），每个字段由两个字节组成。长度字段指示了UDP报文段中的字节数（首部+数据），检验和提供了差错检验功能。</p>
<p><em>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。</em><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-4.png" alt="4"><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-32.png" alt="32"></p>
<blockquote>
<ol>
<li>源端口：16bits，该数据报的发出端口。发送进程将在此端口发送数据包。</li>
<li>目标端口：16bits，该数据报的接收端口。接收进程将在此端口处进行接收。</li>
<li>总长度：整个UDP报文的长度，即UDP头部和数据的长度。</li>
<li>校验和：一个16位补码，是由伪IP头，UDP头（由于校验和字段本身就在UDP头部中，因此使用UDP头计算时先假设校验和为0），UDP数据形成的。其中，伪IP头的协议号为17。如果要求接收方忽略校验和，发送方不计算校验和，直接把校验和设置为0。对伪IP头的说明见下一小节。</li>
</ol>
</blockquote>
<h3 id="2-2_UDP检验和">2.2 UDP检验和</h3>
<p>根据RFC 768，<strong>检验和的计算方法如下：</strong><br>图中给出了伪IP头的格式，注意，<code>TCP与UDP计算检验和的方式是一样的。</code><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-0.png" alt="0"></p>
<blockquote>
<p>发送方<code>对伪IP头，UDP头（校验和为0），UDP数据的所有16bits字的和进行反码运算，求和时遇到的所有溢出都被回卷</code>（即忽略最高位的进位溢出），得到的结果放在检验和字段。在接收方，将全部字段之和与检验和字段相加，如果没有引入差错，则这个结果应当是全1的，如果有任何&gt;一位为0，则说明传输出现了差错。（参见下图）<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-5.png" alt="5"></p>
</blockquote>
<p>这里还有一个问题要说明，<strong>虽然UDP提供差错检测，但它对差错的恢复无能为力</strong>，对于出错的报文段，UDP的接收方有两种选择：</p>
<blockquote>
<ol>
<li>丢弃受损的报文段。</li>
<li>将受损的报文段交给应用程序并给出警告。</li>
</ol>
</blockquote>
<h2 id="3_可靠数据传输原理">3 可靠数据传输原理</h2>
<h3 id="3-1_可靠数据传输">3.1 可靠数据传输</h3>
<p>借助于可靠信道，传输数据比特不会受到损坏或丢失，而且所有数据都是按其顺序进行交付，我们将实现这种服务的抽象称为可靠数据传输协议（reliable data transfer protocol）（注意：可靠数据传输协议的下层协议也许是不可靠的），下面两图给出了一个可靠数据传输协议所提供的服务及其概要实现，其中rdt表示可靠数据传输协议，理解这两张图是理解TCP的基础。</p>
<p><strong>可靠数据传输协议提供的服务和实现：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片1.png" alt="图片1"></p>
<p><strong>详细说明：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片2.png" alt="图片2"></p>
<p>接下来我们逐步讨论实现可靠数据传输协议的几个要点，在讨论过程中，我们会用到<strong>FSM</strong>（有限状态机，finite-state machine），其中初始状态用虚线指出，箭头代表从一个状态变化到另一个状态，每个箭头旁会附有引起变迁的事件（横线上方）及事件发生时所采取的行动（横线下方），符号\^表示空集（横线上方表示条件为空/横线下方表示所采取的行动为空）。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-11.png" alt="11"></p>
<p>为了能更深入的理解TCP，我们先在研究TCP之前改概略的研究以下协议：<strong>rdt1.0-&gt;rdt2.0-&gt;rdt3.0</strong>，它们从最理想的网络情况切入，一步步拓展到真实网络环境，其中rdt1.0假设传输信道完全可靠，rdt2.0假设传输信道会有比特差错但不会丢包，rdt3.0假设传输信道不仅会有比特差错，还会丢包（和真实网络情况一致）。</p>
<blockquote>
<p><strong>rdt1.0:假设发送双方经完全可靠信道传输</strong>，这种情况下我们不必担心任何差错，因为我们假定信道是完全可靠的，且假定接收方接收速率和发送方发送速率一样快。</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-12.png" alt="12"></p>
<blockquote>
<p><strong>rdt2.0:假设经有比特差错但不会丢包的信道传输</strong>，一个分组在传输、传播、缓存的过程中都可能出现差错，这种情况下，我们需要在rdt1.0的基础上引入以下三种功能来解决。</p>
<ol>
<li>差错检验：利用<code>检验和</code>使接收方能够检测到数据分组是否出错。</li>
<li>接收方反馈：如果没有出错，则返回肯定确认（ACK）给发送方，如果检测到出错，则返回否定确认（NAK），即引入<code>肯定和否定</code>分组。</li>
<li>重传：如果发送方收到NAK，则重传该分组。</li>
</ol>
</blockquote>
<p><strong>由此我们得到rdt2.0如下：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-13.png" alt="13"></p>
<p>在上图中，只有发送方收到来自接收方的ACK，才会发送下一个分组，如果收到NAK，则重发当前分组。这之中用到了停等协议（stop-and-wait）的思想。但rdt2.0存在以下问题：<strong>没有考虑到ACK或NAK在发送过程中受损的问题</strong>。如果ACK或NAK受损，rdt2.0的发送方就无法判断该进入哪个状态。解决这一问题的思路是：作为发送方如果不确定收到的是ACK还是NAK，只需重传当前分组（注意：这种方法在信道中引入了<strong>冗余分组</strong>），但是新的问题来了，如果采取这种方法，作为接收方如何判断自己收到的分组是新的还是一次重传？为了解决这一问题，我们引入<code>序号</code>字段。即在数据分组中增加一个序号字段，让发送方对其发送的数据进行编号，对于停等协议，这个序号1比特就足够了（使用0、1两个状态轮流标记发送分组），由此我们得到了改进版的rdt2.5，可以看到，此时接收方可以根据序号识别这个一个新的分组还是一次重传。!</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-14.png" alt="14"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-15.png" alt="15"></p>
<blockquote>
<p><strong>rdt3.0:假设经有比特差错且会丢包的信道传输</strong>，这是真实网络的情况，为了能处理丢包，我们必须解决以下两个问题：如何检测丢包及发生丢包后该做些什么。第二个问题的答案是显然的，因为其实在引入<code>检验和</code>、<code>序号</code>、<code>肯定和否定分组</code>及<code>重传</code>机制后，只要能检测到丢包，我们就可以通过通过重传解决这个问题。<br>解决第一个问题的办法是引入一个定时器，即选定一个合适的时间值，以判定可能发生了丢包（虽然不能确保是丢包），如果在这个时间内没有收到ACK，则重传该分组。（注意：如果一个分组经历了一个特别大的时延，即使该数据分组及其ACK都没有丢失，发送方也会重传该分组，这在信道中引入了<strong>冗余数据分组</strong>，但正如rdt2.0中讨论的那样，我们已有的机制可以处理这种冗余，即：可以判断收到的分组是新的还是一次重传。）</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-16.png" alt="16"></p>
<h3 id="3-2_ARQ">3.2 ARQ</h3>
<p>如果在协议中，发送方在准备下一个数据项目之前先等待一个肯定的确认，则这样的协议称为ARQ（Automatic Repeat Request，自动重传请求协议）。自动重传请求（Automatic Repeat Request），通过接收方请求发送方重传出错的数据报文来恢复出错的报文，是通信中用于处理信道所带来差错的方法之一，传统自动重传请求分成为三种，即<strong>停等协议</strong>(stop-and-wait），<strong>回退n帧</strong>（go-back-n），以及<strong>选择性重传</strong>（selective repeat）。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为流水线ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。接下来停等协议我们已经在之前粗略的提到过，接下来我们分别对这三个协议进行讨论。</p>
<h4 id="3-2-1_停等协议（stop-and-wait）">3.2.1 停等协议（stop-and-wait）</h4>
<p>我们在上述讨论中提到的rdt3.0也被称为比特交替协议（alternating-bit protocol），尽管它是一个功能正确的协议，但其性能并不令人满意，其性能问题的核心在于它是一个停等协议，下面两张图分别给出了停等协议在<strong>无丢包</strong>、<strong>分组丢失</strong>、<strong>ACK丢失</strong>和<strong>过早超时</strong>4种情况的过程：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-17.png" alt="17"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-18.png" alt="18"></p>
<p>停等协议的性能不佳主要集中表现在它对信道的利用率很低，假设两个距离很远的端系统间的RTT大约为30ms，分组长度为1000字节（8000bits）的数据通过发送速率为1Gbps的信道传输，根据下图的说明和给出的公式计算可知信道利用率只有万分之2.7，停等协议极大的限制了底层网络硬件所能提供的能力，事实上，如果再考虑上发送方与接收方之间路由器的处理时间和排队时延，性能将更加糟糕。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-19.png" alt="19"></p>
<p>停等协议的性能问题的根源在于每次只能发送一个分组，为了解决其存在的性能问题，我们可以采用流水线技术，即允许发送方一次发送多个分组而无需等待确认，但这也引入一些新的问题：</p>
<blockquote>
<ol>
<li>由于每个传输中的分组必须有一个唯一的序号，因此必须<code>增加序号的范围</code>。</li>
<li>发送方和接收方两端必须能<code>缓存多个分组</code>，具体而言，发送方最低限度应当能缓存那些已经发送但还没有确认的分组，接收方，而接收方可能需要缓存那些已正确接收的分组（具体取决于采用GBN还是SR）。</li>
<li>解决流水线下的差错恢复。</li>
</ol>
</blockquote>
<p><strong>解决流水线差错恢复的两种基本方法分别是：GBN和SR</strong>。</p>
<h4 id="3-2-2_GBN（go-back-n）">3.2.2 GBN（go-back-n）</h4>
<p>在GBN中，允许发送方发送多个分组而不需要等待确认，但这里有一个限制，即在流水线中未确认的分组数不能超过某个最大允许数N（N即为窗口长度），下图中，我们定义base为最早的未确认分组号，定义nextseqnum为最小的未使用序号（也即下一个待发分组的序号），则[0，base-1]对应已经发送并被确认的分组，[base,nextseqnum-1]对应已经发送但未被确认的分组，[nextseqnum,base+N-1]内的序号能用于那些要被立即发送的分组，而大于等于base+N的序号是不能使用的。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-21.png" alt="21"></p>
<p>在未被确认的分组被确认后，窗口向前滑动，因此GBN也被称为滑动窗口协议，分组序号承载在分组首部一个固定长度的字段中（如果分组序号的比特数是k,则序号范围是$[0，2^k-1]$），关于GBN需要理解以下几点：</p>
<blockquote>
<ol>
<li>当上层要发送数据时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组，如果窗口未满，则产生一个分组并将其发送，并相应的更新变量，如果窗口已满，发送方缓存这些数据或使用同步机制让上层在仅当窗口不满时才能调用rdt_send()请求发送。</li>
<li>在GBN中，对序号为n的分组采取累积确认的方式，接收方丢弃所有收到的失序分组，知道收到期待接收的分组n，然后为分组n返回一个ACK，作为发送方，一旦收到分组n的ACK，就表明n及n之前的所有分组都已被正确接收。</li>
<li>发送方仅使用一个定时器，这个定时器是最早的已发送但未被确认的分组适用的定时器。出现超时时，发送方重传所有已发送但还未被确认的分组，即回退n步，并重启计时器。</li>
</ol>
</blockquote>
<p>一个GBN的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-24.png" alt="24"></p>
<p>GBN的优点是接收缓存简单，缺点是单个分组的差错就可能引起大量本没有必要重传的分组重传。</p>
<p><strong>实现了GBN的rdt4.0：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-22.png" alt="22"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-23.png" alt="23"></p>
<h4 id="3-2-3_SR（selective_repeat）">3.2.3 SR（selective repeat）</h4>
<p> 在GBN中，随着信道差错率的增加，信道可能会被不必要重传的分组所充斥，而SR则可以避免这一问题，选择重传协议通过让发送方重传那些它怀疑在接收方出错的分组而避免不必要的重传，关于SR需要理解以下几点：</p>
<blockquote>
<ol>
<li>接收方确认一个正确接收的分组而不管其是否按序，失序的分组将被缓存直到所有序号更小的分组都被收到为止。</li>
<li>具体而言有三种情况：如果一个分组的序号落在接收方的窗口内时，如果该分组以前没有收到过，则缓存该分组，回发ACK；如果该分组序号等于接收窗口的基序号（rcv_base），则该分组及其之后缓存的序号连续的分组被交付给上层，而后接收方窗口向后滑动；如果该分组已经被缓存，则也必须回发一个ACK（否则如果上一次回发的该分组的ACK丢失，则发送方将永远无法向后移动窗口）。</li>
</ol>
</blockquote>
<p> 一个SR的例子：<br> <img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-25.png" alt="25"></p>
<p>SR协议看起来比BNG优秀很多，但它也引入了新的问题，即：由于发送方和接收方窗口间缺乏同步，如果SR接受窗口太大，会带来下图中的问题：接收方在最后收到具有序号0的分组时，无法区分它是第1个分组的重传还是第5个分组的首次传输。<br><strong>这里要首先补充一点：</strong>由于序号空间是一个长度为$2^k$的环（即序号$2^k-1$之后的序号为0）。</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-26.png" alt="26"></p>
<p>为了避免上述问题，通常我们规定窗口长度必须小于序号空间大小的一半。</p>
<h2 id="4_TCP">4 TCP</h2>
<h3 id="4-1_TCP概述">4.1 TCP概述</h3>
<p>与UDP不同，TCP是面向连接的，两个端系统的进程在通信前首先要经过三次握手建立连接。TCP提供全双工服务，是点对点的（如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向A的同时，也从A流向B）。在发送方，当应用层有数据要发送时，客户进程通过套接字传递数据流，TCP将这些数据流引导到发送缓存中（发送缓存在三次握手初期设置），之后TCP会从发送缓存中取出一块数据，加上40字节的首部形成TCP报文段（TCP segment）下传给网络层。当TCP在另一端收到一个报文后，将其存入接收缓存，而后接收方应用程序从此缓存中读取数据流。</p>
<p>这里我们谈到“TCP会从发送缓存中取出一块数据”，所谓一块究竟是多大呢？TCP可从缓存中取出并放入报文段中的数据量受限于<strong>最大报文段长度（maximum segment size，MSS）</strong>，而MSS通常根据最大链路层帧长度，即最大传输单元（maximum transmission unit，MTU）来设置。以太网和PPP链路层协议都具有1500字节的MTU，除去TCP40字节的首部，因此MSS的典型值为1460字节。</p>
<h3 id="4-2_TCP报文段结构">4.2 TCP报文段结构</h3>
<p>TCP定义在RFC 793中，下图显示了TCP报文段的结构：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-31.png" alt="31"></p>
<p><strong>下面我们逐个分析这些字段：</strong></p>
<blockquote>
<ol>
<li>源端口号/目的端口号：各长16bits，分别标识了源端口号和目的端口号。</li>
<li>序号：32bits，是该报文段首字节的字节流编号。</li>
<li>确认号：32bits，主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</li>
<li>首部长度：4bits，该字段指示了以32bits的字为单位的TCP首部的长度，由于选项字段的原因，TCP首部长度是可变的，通常选项字段为空，因此TCP首部典型长度为20字节。</li>
<li>保留未用：6bits，必须全0。</li>
<li>标志（flag）：6bits，其中ACK用于确认号字段中的值是有效的，即该报文包括一个对已被成功接收报文段的确认；RST，SYN，FIN比特用于连接的建立和拆除（这一点我们在之后对三次握手的讨论中会详细阐述）；PSH比特被置位时，指示接收方应立即将数据交给上层；URG比特用来指示报文段中有被发送端上层实体置位紧急的数据（紧急数据的最后一个字节由16比特的紧急数据指针字段指出，当紧急数据存在且给出紧急数据尾的指针时，TCP必须通知上层实体）。注意，在实际中PSH，URG和紧急数据指针并没有被使用。</li>
<li>窗口大小：通告接收缓冲区空闲块大小（确认字节之后还可以发送多少字节）。</li>
<li>检验和：一个16位补码，是由伪IP头，TCP头，TCP数据形成的。伪IP头与UDP类似，其中的协议号为6。</li>
<li>紧急数据指针：与标志URG一起用来取出紧急数据或指出记录边界。</li>
<li>选项：最大数据段长度(Maximum Segment Size，MSS)：为TCP有效载荷的最大长度；窗口比例(Scale): 乘以通知窗口大小；允许选择性确认(SACK-Permitted；选择性确认(SeletiveACK,SACK): 已收到数据段的序号集合；时间戳等等。Unix系统的默认值：MSS为536，SACK-Permitted为False。Windows 的默认值MSS为1460，SACK-Permitted为True。</li>
</ol>
</blockquote>
<p><strong>详细说明：</strong></p>
<blockquote>
<ul>
<li>URG: Urgent Pointer field significant（紧急(Urgent)指针标志，表示本数据段包含紧急数据，位于数据段前部，直到紧急指针指向的位置（从0开始）。可以用来在字节流中指明记录的边界。）</li>
<li>ACK: Acknowledgment field significant（确认号有效标志。）</li>
<li>PSH: Push Function（告知接收方发送方执行了推送(Push)操作，接收方需要尽快将这些数据交给接收进程，不要将其放在缓冲区。另外，PSH还实现了段的立即传输，不用等待构建一个大的数据段再发送。当缓冲区中出现回车后，系统会自动设置PSH。因此，PSH在发送端和接收端均起作用。）</li>
<li>RST: Reset the connection（重置(Reset)连接。因为出现了错误，通知对方立即中止连接并释放与连接有关的资源。）</li>
<li>SYN: Synchronize sequence numbers（同步(Synchronous)序号标志，用来发起一个TCP连接。）</li>
<li>FIN: No more data from sender（结束(Finish)标志，表示发送方完成了所有发送任务，要求释放连接。）<br><code>（* 所有标志为1有效。）</code></li>
</ul>
</blockquote>
<h3 id="4-3_往返时间（RTT）的估计与超时">4.3 往返时间（RTT）的估计与超时</h3>
<h4 id="4-3-1_RTT的估计">4.3.1 RTT的估计</h4>
<p>TCP通过如下方式估计发送方与接收方的往返时间：<br>我们定义SampleRTT为某报文段被发出到对报文段的确认被收到之间所用的时间，同时TCP维持一个SampleRTT的均值EstimatedRTT。TCP每隔一段时间测量一次SampleRTT，并根据以下公式更新EstimatedRTT。<br>$$EstimatedRTT = (1- α)<em>EstimatedRTT + α</em>SampleRTT$$<br><strong>RFC 6298给出α的参考值为0.125</strong></p>
<p>EstimatedRTT是一个加权平均值，这个加权平均值对最近的样本赋予的权值要大于对老样本赋予的权值，因为越近的样本越能反应当前网络的拥塞情况。除了估算RTT外，测量RTT的变化也是有价值的，RFC 6298定义RTT偏差：DevRTT，用于估算SampleRTT偏离EstimatedRTT的程度：<br>$$DevRTT = (1-β)<em>DevRTT + β</em>|SampleRTT-EstimatedRTT|$$<br><strong>RFC 6298给出α的参考值为0.25</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-41.png" alt="41"></p>
<h4 id="4-3-2_超时">4.3.2 超时</h4>
<p>给出SampleRTT和EstimatedRTT的定义后，我们不妨考虑，TCP超时间隔应该选取什么值呢？我们定义这个值为TimeoutInterval为超时时间间隔。（显然，TimeoutInterval应当大于EstimatedRTT，否则会造成不必要的重传，但也不能比EstimatedRTT大太多，否则报文丢失时将无法很快的重传丢失报文）根据下面公式计算TimeoutInterval：<br>$$TimeoutInterval = EstimatedRTT + 4*DevRTT$$<br>RFC 6298推荐的TimeoutInterval初始值为1秒，并在超时后将TimeoutInterval加倍，直到报文收到确认后就使用上面的公式计算TimeoutInterval。</p>
<h3 id="4-4_可靠数据传输">4.4 可靠数据传输</h3>
<p>TCP在IP不可靠的尽力而为的服务之上提供了可靠的数据传输服务，确保了一个进程从其接收缓存读取的数据是<strong>无损坏，无间隔，非冗余和按序</strong>的数据流。接下来我们将具体讨论TCP是如何做到这一点的，我们将会看到，它与我们之前讨论的rdt3.0再很多细节上有所不同。</p>
<p>在之前rdt3.0的讨论中，为了解决丢包的问题，我们实际上为每个分组都引入了一个计时器，一旦计时器超时，就重传该分组，但这样做我们要为计时器的管理付出巨大开销，因此，TCP实际上只采用单一的重传计时器（即使有多个已发送但还未被确认的报文段），这个计时器具体的工作方式我们会在下面逐步给出。</p>
<h4 id="4-4-1_超时间隔加倍">4.4.1 超时间隔加倍</h4>
<p>在大多数TCP的实现中，对TimeoutInterval的取值并不总是按照4.3.2中的公式进行计算，而是这样一个过程：<br>每当超时时间发生时，TCP重传具有最小序号的还未被确认的报文段，并将TimeoutInterval的值设为之前的两倍，而不是使用4.3.2中的公式计算，因此，TimeoutInterval会成指数增长，但是，如果遇到<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>事件时，定时器会重新启动，此时启动的定时器将按照4.3.2中的公式计算TimeoutInterval。</p>
<p>之所以这么做是出于以下考虑：如果发生超时，则很可能是由于网络拥塞造成的，而频繁的重传分组会使得拥塞更加严重，因此在没有<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>时，TCP使用加倍TimeoutInterval的方式，让重传经过越来越长的时间间隔进行。</p>
<h4 id="4-4-2_快速重传">4.4.2 快速重传</h4>
<p>如果我们仅依赖是否超时来判断是否丢包，则对于这个真正丢失的分组，发送方必须在超时之后才会重传它，如果超时周期较长，重传会被延迟。为了优化这个问题，TCP引入了<strong>快速重传</strong>机制。</p>
<p>假设接收方期待接收序号为n的报文段但却收到了序号大于n的报文段，我们就说此时它检测到了数据流的一个间隔，造成间隔的原因可能是报文段丢失或报文段被重新排序，由于TCP不使用否定确认，它会对已经收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK），作为发送方如果收到对同一个数据的<strong>3个冗余ACK</strong>（即第4次收到这个数据的ACK），即使当前计时器还没有超时，TCP也立即重传这个分组，这就是快速重传机制。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-43.png" alt="43"></p>
<h4 id="4-4-3_累积确认">4.4.3 累积确认</h4>
<p>TCP返回的ACK实际上是它期待（从发送方）接收的下一个分组号，TCP的确认是累积式的，正确接收但失序的报文会被缓存但不会被逐个确认（确认号都是其期待接收的下一个分组号，即前面提到的冗余ACK）。发送方只需要维护已发送但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum），对于发送方的一组报文1,2，…，N，假设报文段n丢失（n&lt;N），但它之前的全部报文和它之后的全部报文在超时前到达了接收方，则超时后TCP只会重传至多一个报文段（而GBN则会重发n及n之后的分组）。如果对报文段n+1的确认在n超时前到达，即使对n的确认还没有到达，发送方也可以知道接收方已经正确接收报文n了，这是因为TCP采取累积确认，收到对n+1的确认就意味着n+1之前的分组接收方都收到了。</p>
<p>附：RFC 5681对产生TCP ACK的建议：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-44.png" alt="44"></p>
<h3 id="4-5_流量控制">4.5 流量控制</h3>
<h4 id="4-5-1_流量控制的实现">4.5.1 流量控制的实现</h4>
<p>一条TCP连接每一侧主机都为该连接设置了接收缓存，如果应用程序读取数据相对缓慢，而发送方发送的太多太快，发送的数据就会时接收缓存溢出。TCP为应用程序提供<strong>流量控制服务（flow-control service）</strong>以消除发送方使接收方缓存溢出的可能性，因此流量控制是一个速度匹配服务。</p>
<p>TCP通过让发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量来提供流量控制（接收窗口告诉发送方该接收方还有多少缓存空间）。因为TCP是全双工通信，因此在连接两端的发送方都各自维护一个接收窗口。<br>定义：LastByteRead为主机B上应用程序从缓存读出的数据流的最后一字节的编号，LastByteRcvd为从网络中到达主机B并且已经放入主机B接收缓存中的数据流的最后一个字节的编号。则为了不使缓存溢出，下面式子必须成立：<br>$$LastByteRcvd - LastByteRead≤RcvBuffer$$<br>用rwnd表示接收窗口大小，则：<br>$$rwnd=RcvBuffer-（LastByteRcvd - LastByteRead）$$<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-45.png" alt="45"></p>
<p>为了不使主机B接收缓存溢出，主机A只需轮流跟踪2个变量：LastByteSent和LastByteAcked，注意到LastByteSent - LastByteAcked就是主机A发送到连接中但未被确认的数据量，通过将未被确认的数据量控制在rwnd以内，就可以保证主机B的缓存不会溢出。</p>
<h4 id="4-5-2_死锁处理">4.5.2 死锁处理</h4>
<p>在上面的讨论中，如果主机B接收缓存已满，即rwnd=0，在将这一信息告诉主机A后，如果B没有任何数据要发送给A，就会发生死锁，因为此时即使B将缓存中的数据取走，A也无法得知这一事实。为了解决这一问题，我们采用“聪明的发送方/笨拙的接收方”，即发送方定期(Persist Timer)发送一个字节数据，以使接收方响应以获得通知窗口的大小。接收方响应采用下一个期待接收的字节。</p>
<h3 id="4-6_连接管理">4.6 连接管理</h3>
<h4 id="4-6-1_三次握手">4.6.1 三次握手</h4>
<p>建立连接的过程需要三步，称为<strong>三次握手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个SYN报文段，不含应用层数据，SYN=1，客户端会随机选择一个初始序号x。</li>
<li>服务器收到客户端的SYN报文段后，为TCP连接分配缓存和变量，返回一个SYNACK报文段，SYN=1，ACK=1，ACKNum=x+1，同时服务器选择自己的初始序号y。</li>
<li>在收到SYNACK报文段后，客户端也分配缓存和变量，并回发一个报文段进行确认，SYN=0，ACK=1，ACKNum=y+1，可以在负载中携带数据。</li>
</ol>
</blockquote>
<p><strong>超时重发：</strong>每一步均采用超时重发，多次重发后将放弃。重发次数与间隔时间依系统而不同。<br><strong>数据字节序号：</strong>客户和服务器发送的第一个数据字节的序号分别为x+1和y+1。<br><strong>选项：</strong>头两个数据段给出选项：SACK-Permited，Scale，MSS。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-46.png" alt="46"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-47.png" alt="47"></p>
<h4 id="4-6-2_四次挥手">4.6.2 四次挥手</h4>
<p>中断连接的过程需要四步，称为<strong>四次挥手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个FIN报文段，FIN=1，seq=x，客户端进入FIN_WAIT_1状态。</li>
<li>服务器收到客户端的FIN报文段后，返回一个ACK报文段，ACK=1，ACKNum=x+1，客户端收到后进入FIN_WAIT_2状态。</li>
<li>服务器TCP向客户端TCP发送一个FIN报文段，FIN=1，seq=y。</li>
<li>客户端收到服务器的FIN报文段后向服务器发送一个确认，ACK=1，ACKNum=y+1，并进入TIME_WAIT状态，假设ACK丢失，TIME_WAIT状态会使客户端重传最后的报文。</li>
</ol>
</blockquote>
<p><strong>释放连接：</strong>先发FIN一方在ACK发送完毕后需要等待2MSL(Maximum Segment Lifetime)的时间才完全关闭。TCP标准中MSL采用60秒，Unix采用30秒。<br><strong>超时重发：</strong>超时未收到确认，则超时自动重发，在若干次重发后依然没有收到确认，则发送RST后强行释放连接。不同的系统重发方法不同。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-48.png" alt="48"></p>
<h4 id="4-6-3_SYN洪泛攻击">4.6.3 SYN洪泛攻击</h4>
<p>在三次握手的过程中，如果客户端不发送ACK完成第三步，则服务器将在一段时间内出于半开连接的状态，并在这一时间之后才断开连接并收回资源，如果攻击方发送大量TCP SYN连接但又不完成第三步，就会导致服务器的连接资源最终被耗尽。这种攻击方式被称为SYN Flood Attack，是一种经典的DOS攻击方式，我们可以采用SYN cookie（RFC 4987）来避免它。</p>
<h3 id="4-7_拥塞控制">4.7 拥塞控制</h3>
<p>TCP发送方法可能因为IP网络的拥塞而被遏制，这种对发送方的控制称为拥塞控制。由于IP层不向端系统提供显式的网络拥塞反馈，因此TCP必须使用端到端的拥塞控制。TCP拥塞控制的方法大致可描述为根据发送方所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果TCP发送方感知到路径上没有拥塞，则增加发送速率，反之则降低发送速率。<br>运行在发送方的拥塞控制机制需要跟踪一个额外的变量，即拥塞窗口（congestion window），不妨定义它为cwnd，发送方中未被确认的数据量不能超过cwnd和rwnd中的较小值，即：<br>$$LastByteRcvd - LastByteRead≤min{cwnd , rwnd}$$<br><strong>TCP拥塞控制算法主要包括三个部分：慢启动，拥塞避免，快速恢复。</strong>其中慢启动和拥塞避免是TCP的强制部分，快速恢复是可选部分。</p>
<h4 id="4-7-1_慢启动">4.7.1 慢启动</h4>
<p>当一条TCP连接开始时，在慢启动（slow-start）状态，cwnd的值以1个MSS开始，并且每当传输的报文段被首次确认就增加一个MSS，这样每经过一个RTT发送速率就会翻倍，因此，采用慢启动算法，TCP发送速率起始慢，但在慢启动阶段以指数增长。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-51.png" alt="51"></p>
<p>我们记ssthresh为“慢启动阈值”，在以下三种情况发生时，结束慢启动过程：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，TCP发送方将ssthresh设置为cwnd/2（即当检测到拥塞时将ssthresh值置位拥塞窗口的一半），将cwdn设置为1，并重启慢启动算法。</li>
<li>当cwnd等于ssthresh时，结束慢启动算法，转移到<strong>拥塞避免</strong>模式。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，此时TCP执行快速重传并转入<strong>快速恢复</strong>状态。</li>
</ol>
</blockquote>
<h4 id="4-7-2_拥塞避免">4.7.2 拥塞避免</h4>
<p>进入拥塞避免状态时，cnwd的值大约是上次遇到拥塞时值的一半，此时TCP采取一种较为保守的方法，每到达一个新的确认，就将cwnd增加一个<strong>MSS*(MSS/cwnd)</strong>字节，即每个RTT只将cwnd的值增加一个MSS（线性增长）。<br>在以下两种情况发生时，结束拥塞避免的线性增长：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，TCP发送方将cwnd的值减半，将ssthresh设置为cwnd/2，进入<strong>快速恢复</strong>状态。<h4 id="4-7-3_快速恢复">4.7.3 快速恢复</h4>
<strong>注意：</strong>快速恢复只是TCP推荐但非必须的构件。<br>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK（最少为3个，但可能不止3个），cwnd的值都增加一个MSS（最少增加3个MSS），不妨设因为冗余ACK而增加的MSS数为k。<br>在以下两种情况发生时，结束快速恢复：</li>
<li>当丢失报文段的一个ACK到达时，TCP将cnwd减去k后进入拥塞避免状态。</li>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
</ol>
</blockquote>
<p>一个可能的TCP拥塞窗口变化图如下（图中画出了Reno版TCP与Tahoe版TCP拥塞窗口的变化情况，其中Reno使用了快速恢复而Tahoe没有使用快速恢复）：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-52.png" alt="52"></p>
<p>TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，每出现3个冗余ACK时cwnd减半，因此TCP拥塞控制也被称为加性增，乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）拥塞控制方式。如下图所示：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-53.png" alt="53"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[薛定谔的2016]]></title>
    <link href="http://yoursite.com/2016/01/11/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%842016/"/>
    <id>http://yoursite.com/2016/01/11/薛定谔的2016/</id>
    <published>2016-01-11T12:37:27.000Z</published>
    <updated>2016-01-11T12:40:08.000Z</updated>
    <content type="html"><![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的转变，因为我认识到自己性格里的不成熟和缺陷，认识到大约二十年的无知以及自以为是。这算是一份特别的工作带给我的最大收获。</p>
<hr>
<p>回头将自己2015年的日记回看了一遍，就像又走了一遍2015年，看着自己一点一点的变化。看自己从迷茫到坚定，到焦虑，到淡定，到迟疑，到沉默…</p>
<p>年初的时候，我给自己定下了许多规划，试图去重建自己的生活习惯，比如坚持写日记，硬规定阅读量，坚持为记录时间，完善GTD。我试着去打破过去二十年懒惰的自己，重构出一个不一样的自己，这个过程，艰难，但显得自然而然。</p>
<p>而到了八月份，回到这个久违的荒岛（当然，现在已经商业开发的不再是荒岛了），度过最初的适应之后，那种期盼中的生活慢慢的展开，时间就真变成了离弦的箭，因为所有想要做的事情都展开了，在这个过程中，过去半年所规划的生活也被我重新调整。当然，在这个过程里，各种好的坏的习惯被改变，有很多过去无法完成的事情成了自然而然的一件小事。</p>
<p>在这接下来的半年里，从纠结的选择到淡定，从焦虑到从容。每天沉浸在实验室，感觉时间的每个节点，都被放大成了一个波澜不惊的平面，在这些平面上，我可以做许多事情。而且，我更珍惜每一个时间的断面，想要做更多的事情。</p>
<p>回到15年年初给自己定下的规划：</p>
<ul>
<li>关于阅读：一百本书的量基本完成，后半段大量的技术文档和文章可以填补本来的规划。</li>
<li>关于日记：止步于开学后不久，因为将精力投入到做事中，无暇记录。</li>
<li>关于知识结构：基本满意。</li>
<li>关于自控力：提高明显。</li>
<li>关于时间管理：不满意，使用了数种GTD 方法，均弃。</li>
<li>关于性格：有进步，但缺点明显，仍未改变。</li>
<li>关于健身：基本满意，身体素质提高，需坚持。</li>
<li>关于未来：有了更多的期许。</li>
</ul>
<p>所以，实际上，我的2015年看似是我变动最大的一年，也是环境变化最剧烈的一年，但似乎又是理所当然和波澜不惊的，我预想了一整年的状态，也预料到了这些波澜不惊。</p>
<p>实际上，2015年带给我的最大最大的收获，是我认识到，未来，哪怕是短短的一年两年，都应当是不可预测的。而如果未来是可测的，那人生一定是可悲的，因为那是一条毫无意义的路，你看不到不一样的风景，看不到未知，看不到未知里所藏匿着的壮美。去年，我一篇日志里写，追赶时间最佳的方式只有阅读，因为每本书实际上都是一段时间线的扩展，它可以将二维的时间提升到三维，四维…在更高的维度下，理解世界的方式在变化，认识人生轨迹的方式也在变化。</p>
<p>对于2016年，我所要面对的生活，将会有更大的变化，我甚至无法预测在未来的某个时间节点，我会在哪里出现，我在做什么。所以，我把我的二零一六称为薛定谔的二零一六，因为所有的可能都存在，在我没有打开盒子的时候，我不会知道我将为自己创造一个怎样的2016。所以，关于规划，我只写期望。</p>
<ul>
<li>关于阅读： 因为阅读量代表的是时间的量，我希望时间越长越好，所以仍然会给自己留下一百本的要求，按照2015年经验，平均每月8+本阅读，每本10w+字数，一个月的阅读量100w+ 难度不高。但鉴于书籍的选择我会尽量筛去口水化严重的书，那就需要花费更多的时间反思和内化，所以最后的实际期望在80~100本之间。2015的后半程没有坚持把每一本书都记录和总结出来，在2016年，一定要坚持将每一本书记录下来。</li>
<li>关于日记：我希望整合进时间管理中去，2015年有一大部分日记是用来思考和反省的，花费了较多时间。而2016年我希望，日记能作为一种行为习惯，与时间规划一起，用来整理人生。所以，选择一个优秀的APP或者自己开发一个应用，回顾事件和时间。日记的另一部分，用极简的话，记录收获。</li>
<li>关于自控力：自控力就像肌肉，只有锻炼，才能保持，否则只会越来越差。只要记住这句就好了。</li>
<li>关于时间管理：是2015年的最大遗憾，也是因为糟糕的时间管理能力，让一整年很多事情做起来毫无头绪，并行多线程互抢资源的情况经常发生。所以，新的一年，结合日记和一个合适的GTD方法，管理自己的时间，将是重点关注的事情。</li>
<li>关于健身：两天一次。</li>
<li>关于性格：藏拙，克己，平心，助人。</li>
<li>关于知识结构：结合时间管理，有计划的补充知识点。就技术而言，两向发展，技术内核学习一个方向，实践coding另一个方向。就知识面而言，依兴趣点规划，比如心理学方面把荣格的作品看完。</li>
<li>关于写作：2015年，其实总结了不少文章，但是因为懒惰，也因为感觉没有时间去整理，就没有挂在博客上。2016年，我还是应当学会用清晰的文字表达自己的学习内容，研究问题，学会表达。</li>
</ul>
<p>整个2015年，我认识到的另一件重要事，也是非常浅显的道理：所有的预想和规划，都无法代替真正的经历和体会，只有实践才能给出答案。所有对2016年的规划，都不过是一种期许，在新的一年，也许自己会面对新的挑战，不期而遇的变化，所有的计划都追赶不上变化，而我唯一要做的，就是努力将时光铺陈在所有美好的事物上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的]]>
    </summary>
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Python写一个虚拟解释器]]></title>
    <link href="http://yoursite.com/2015/11/09/%E7%94%A8Python%E5%86%99%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://yoursite.com/2015/11/09/用Python写一个虚拟解释器/</id>
    <published>2015-11-09T13:18:08.000Z</published>
    <updated>2015-11-09T13:20:14.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br><a id="more"></a></p>
<h2 id="0-_解释器到底是什么">0. 解释器到底是什么</h2>
<p>前边解释了一些，但解释的并不清楚，在<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a>中，做一个比较不错的解释。</p>
<blockquote>
<p>首先我们来谈一下解释器是什么。说白了解释器跟计算器差不多。它们都接受一个“表达式”，输出一个 “结果”。比如，得到 ‘(+ 1 2) 之后就输出 3。不过解释器的表达式要比计算器的表达式复杂一些。解释器接受的表达式叫做“程序”，而不只是简单的算术表达式。从本质上讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p>
<p>需要注意的是，我们的解释器接受的参数是一个表达式的“数据结构”，而不是一个字符串。这里我们用一种叫“S-expression”的数据结构来表示表达式。比如表达式 ‘(+ 1 2) 里面的内容是三个符号：’+, ‘1 和 ‘2，而不是字符串“(+ 1 2)”。从结构化的数据里面提取信息很方便，而从字符串里提取信息很麻烦，而且容易出错。</p>
<p>从广义上讲，解释器是一个通用的概念。计算器实际上是解释器的一种形式，只不过它处理的语言比程序的解释器简单很多。也许你会发现，CPU 和人脑，从本质上来讲也是解释器，因为解释器的本质实际上是“任何用于处理语言的机器”。</p>
</blockquote>
<h2 id="1-_学习写一个解释器的另一个原因">1. 学习写一个解释器的另一个原因</h2>
<p>在《编程珠玑》的第十章，提到代码空间技术，如何节省足够的空间，讲到了解释程序。他说，远古时代，有时候空间的瓶颈不在于数据，而在于程序本身的规模。比如一开始一个图形程序，有如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">17</span>, <span class="number">43</span>]</span> set(<span class="built_in">i</span>, <span class="number">68</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">18</span>, <span class="number">42</span>]</span> set(<span class="built_in">i</span>, <span class="number">69</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">81</span>, <span class="number">91</span>]</span> set(<span class="number">30</span>, <span class="built_in">j</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">82</span>, <span class="number">92</span>]</span> set(<span class="number">31</span>, <span class="built_in">j</span>)</div></pre></td></tr></table></figure>

<p>其中，set(i,j)表示点亮屏幕（i, j）处的像素，也就是说这实际上是一个绘制直线的程序。而当我们使用了适当的函数，比如用于绘制水平线的hor函数和垂直线的ver函数，就可以替代上述代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">hor</span><span class="params">(<span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span>)</span></span></div><div class="line"><span class="title">hor</span><span class="params">(<span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span>)</span></div></pre></td></tr></table></figure>

<p>而上述代码又可以利用一个解释器来替换，这个解释程序可以从下面的数组中读取命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">h</span> <span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span></div><div class="line">h <span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span></div><div class="line">v <span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span></div><div class="line">v <span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span></div></pre></td></tr></table></figure>

<p>至此，我们已经将空间减小了很多了，但如果你还想减少，那么就可以为命令h 或 v分配两个位，为后边的三个数字，每个数字，分配10个位置，这样一个32位的数字，表示一行命令了。这就是代码空间技术的运用。</p>
<p>当然，今天我们谈起节省空间，好像已经成了笑话，但是，当我们面对巨量数据，也就是我们今天所说的大数据的时候，空间，时间，效率的话题又一次被提起来。当我们面对着像混乱电流一样的数据时，尝试将自己的头脑想象成计算机，学会用更加底层的方式去思考，对对理解数据处理将有更深刻的认识。</p>
<p>为什么我们时常提起像机器一样思考呢？那是因为机器远比我们人类严谨，也是所有检验逻辑最严格的关卡，他不容许一点点错误，一个毫不起眼的bug，都会让程序完全崩溃。而程序是写给计算机的语言，所以，程序的严谨性就应当像计算机一样严谨。所以我们时常劝告自己要像计算机一样思考。</p>
<p>正如『正义的花生』在<a href="http://www.jianshu.com/p/f0863846b7e8" target="_blank" rel="external">数学与编程</a>中提到的一样：</p>
<blockquote>
<p>普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。</p>
</blockquote>
<p>诚然，大牛作者在思想上有很多偏执的地方，但是往往他的观点我都有着不小的认同感。前边那篇『怎样写一个解释器』也是他的文章。</p>
<p>所以，学习写一个解释器，可以带给我更多的思考，从效率，空间，机器等等方面进一步认识程序运行的本质，将这种认识正反馈到实际编程中，将潜移默化的带来影响。当然，这篇文章试着依葫芦画瓢的写完一个解释器，显然仅仅算是摸了摸门道，想要继续探索，还有更多的事情可以做。做更多的事情，可以参考上边提到的开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。</p>
<h2 id="1-_构建堆栈机">1. 构建堆栈机</h2>
<p>堆栈机的执行原理很简单，将需要处理的值放进堆栈中，然后执行。Python， Java这些高级语言将它作为自己的虚拟机。</p>
<p>所以我们利用了堆栈的方式存放指令。首先，我们需要一个指令指针栈，它能够储存返回地址。这个返回地址就是当我们执行一个子程序（如函数）的时候，需要用它跳回到开始调用该函数的地方。</p>
<p>我们将这个复杂的问题简洁化。比如有一个数学表达式：<code>（2+3）*4</code> ，这个表达式的意思就是依次推入<code>2 3 + 4 *</code>, 将2 和3 依次推入栈中，接下来要推入的指令是 <code>+</code>， 将两个数字弹出，令他们执行加法运算，然后将结果入栈。然后继续进行下去，直到计算出结果。</p>
<p>依靠这个原理，我们开始建立一个栈，我们使用python 中的一个类 collections.deque。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(deque)</span>:</span> <span class="comment"># 定义一个栈</span></div><div class="line">    push = deque.append  <span class="comment"># 添加元素</span></div><div class="line">    <span class="comment"># 返回最后一个元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self[-<span class="number">1</span>]</div></pre></td></tr></table></figure>

<p>deque 中自带pop 方法，所以我们就不用再定义 pop .</p>
<p>接下来我们继续构建一个虚拟机的类 Machine。 我们需要两个栈和一段储存代码的内存空间。一个栈储存数据，一个栈储存地址。得益于Python 动态类型，因此我们可以往列表里面存储任何东西，但是我们不能区分列表里面的内置函数和字符串，正确的做法是将Python 内置函数单独存放在一个列表。这里我们使用字典方法，键值分别对应字符串和函数。另外，我们需要一个指令指针，用来指向代码中下一个需要被执行的模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Machine</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, code)</span>:</span> <span class="comment"># 预先定义一个初始化函数</span></div><div class="line">       self.data_stack = Stack()</div><div class="line">       self.return_addr_stack = Stack()</div><div class="line">       self.code = code</div><div class="line">       self.instruction_pointer = <span class="number">0</span> </div><div class="line">    <span class="comment"># 再创建一些栈结构中必备的函数</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.pop()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.data_stack.push(value)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.top()</div></pre></td></tr></table></figure>

<p>为了执行操作码，而这个操作码并非实际意义上的操作码，它只是一种动态类型，所以我们建立一个dispatch 函数，在这之前，我们创建一个解释器的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>   <span class="comment"># 代码运行的条件</span></div><div class="line">    <span class="keyword">while</span> self.instruction_pointer &lt; len(self.code):</div><div class="line">         opcode = self.code[self.instruction_pointer]</div><div class="line">         self.instruction_pointer += <span class="number">1</span></div><div class="line">         self.dispatch(opcode)</div></pre></td></tr></table></figure>

<p>它的原理很简单： 获取下一个指令，指令指针自增1 然后基于操作码执行dispatch 函数，下面就是dispatch函数的定义。而对解释器的扩展增强基本在这个函数中实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, op)</span>:</span></div><div class="line">    dispatch_map = {</div><div class="line">        <span class="string">"%"</span>:        self.mod,</div><div class="line">        <span class="string">"*"</span>:        self.mul,</div><div class="line">        <span class="string">"+"</span>:        self.plus,</div><div class="line">        <span class="string">"-"</span>:        self.minus,</div><div class="line">        <span class="string">"/"</span>:        self.div,</div><div class="line">        <span class="string">"=="</span>:       self.eq,</div><div class="line">        <span class="string">"cast_int"</span>: self.cast_int,</div><div class="line">        <span class="string">"cast_str"</span>: self.cast_str,</div><div class="line">        <span class="string">"drop"</span>:     self.drop,</div><div class="line">        <span class="string">"dup"</span>:      self.dup,</div><div class="line">        <span class="string">"if"</span>:       self.if_stmt,</div><div class="line">        <span class="string">"jmp"</span>:      self.jmp,</div><div class="line">        <span class="string">"over"</span>:     self.over,</div><div class="line">        <span class="string">"print"</span>:    self.print_,</div><div class="line">        <span class="string">"println"</span>:  self.println,</div><div class="line">        <span class="string">"read"</span>:     self.read,</div><div class="line">        <span class="string">"stack"</span>:    self.dump_stack,</div><div class="line">        <span class="string">"swap"</span>:     self.swap,</div><div class="line">        }</div><div class="line">    <span class="keyword">if</span> op <span class="keyword">in</span> dispatch_map:</div><div class="line">        dispatch_map[op]()</div><div class="line">    <span class="keyword">elif</span> isinstance(op, int):  <span class="comment"># 如果指令是整形数据，就将数据存放到数据栈中</span></div><div class="line">        self.push(op)</div><div class="line">    <span class="keyword">elif</span> isinstance(op, str) <span class="keyword">and</span> op[<span class="number">0</span>]==op[-<span class="number">1</span>]==<span class="string">'"'</span>:</div><div class="line">        <span class="comment"># 如果是字符串类型，就将字符串内容存放到数据栈中</span></div><div class="line">        self.push(op[<span class="number">1</span>:-<span class="number">1</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError( <span class="string">"Unknown opcode: '%s'"</span> % op)</div></pre></td></tr></table></figure>

<p>上边的指令的意思是，当输入一段指令后，该函数就会根据这段指令在字典中找到对应的方法。比如符号<code>*</code>对应的是self.mul 。而这个self.mul 也是我们定义的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self)</span>:</span></div><div class="line">    self.push(self.pop() * self.pop())</div></pre></td></tr></table></figure>

<p>其他的函数定义也如此。</p>
<p>搭建好环境之后，下面继续进行。一个语言解释器包括两个部分：</p>
<ol>
<li>解析：解析部分接受一个由字符序列表示的输入指令，然后将输入字符分解成一系列的词法单元</li>
<li>执行： 程序内部的解释器根据语义规则进一步处理词法单元，进而执行原指令的实际运算。</li>
</ol>
<p>这是流程图：</p>
<figure class="highlight flow"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 指令</div><div class="line">op1=&gt;operation: 解析器</div><div class="line">op2=&gt;operation: 词法单元</div><div class="line">op3=&gt;operation: 执行运算</div><div class="line">e=&gt;end: 结果</div><div class="line"></div><div class="line">st<span class="variable">-&gt;op1</span><span class="variable">-&gt;op2</span><span class="variable">-&gt;op3</span><span class="variable">-&gt;e</span></div></pre></td></tr></table></figure>

<h2 id="2-_下面我们创建一个简单的解析器">2. 下面我们创建一个简单的解析器</h2>
<p>使用<a href="https://docs.python.org/3/library/tokenize.html" target="_blank" rel="external">tokenize</a>模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tokenize</div><div class="line"><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="comment"># 将text以StringIO的形式读入内存</span></div><div class="line">    <span class="comment"># 以字符串形式返回刀generate_tokens()函数中。</span></div><div class="line">    tokens = tokenize.generate_tokens(StringIO(text).readline)</div><div class="line">    <span class="comment"># generate_tokens 生成器生成一个5元组：标记类型、标记字符串、标记开始位置二元组、标记结束位置二元组以及标记所在的行号</span></div><div class="line">    <span class="comment"># 下面大写的单词都属于token模块的常量</span></div><div class="line">    <span class="keyword">for</span> toknum, tokval, _, _, _ <span class="keyword">in</span> tokens:</div><div class="line">        <span class="keyword">if</span> toknum == tokenize.NUMBER:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> toknum <span class="keyword">in</span> [tokenize.OP, tokenize.STRING, tokenize.NAME]:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> tokun == tokenize.ENDMARKER:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"Unknown token %s: '%s'"</span> % (tokenize.tok_name[toknum], tokval))</div></pre></td></tr></table></figure>

<p>关于token常量，查看<a href="https://docs.python.org/3/library/token.html#module-token" target="_blank" rel="external">官方文档</a>。</p>
<p>其中还有一个关键字 <code>yield</code>，它是用来定义生成器(Generator)，具体功能是可以当return 使用，从函数理返回一个值，不同之处是用yield 返回之后，可以让函数从上回yield 返回的地点继续执行。也就是说，yield 返回函数，交给调用者一个返回值，然后再移动回去，让函数继续运行下去，知道下一个yield语句再返回一个新的值。举个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def test_yield():</div><div class="line">...     yield 1</div><div class="line">...     yield 2</div><div class="line">...     yield (1,2)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; a = test_yield()</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">1</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">2</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">(1, 2)</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">StopIteration</div></pre></td></tr></table></figure>

<p>我们用生成器产生一个Fibonacci数列的函数就会更加直观：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></div><div class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></div><div class="line">    <span class="keyword">while</span> a &lt; max:</div><div class="line">        <span class="keyword">yield</span> a</div><div class="line">        a, b = b, a+b</div><div class="line"> </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> fab(<span class="number">20</span>):</div><div class="line"><span class="prompt">... </span>    <span class="keyword">print</span> i,<span class="string">","</span>,</div><div class="line">...</div><div class="line"><span class="number">0</span> , <span class="number">1</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">5</span> , <span class="number">8</span> , <span class="number">13</span> ,</div></pre></td></tr></table></figure>

<h2 id="3-_简单优化：_常量折叠">3. 简单优化： 常量折叠</h2>
<blockquote>
<p>常量折叠是其中一种被很多现代编译器使用的编译器最优化技术。常量折叠是在编译时间简单化常量表达的一个过程。简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表。可以算作一种编译优化。</p>
</blockquote>
<p>也就是我们最早举例子的时候说的，将2，3放入栈中，+ 进来的时候，2 3取出来进行运算，然后将运算结果放入栈中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_fold</span><span class="params">(code)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="comment"># 指令中找到两个连续的数字以及一个运算符</span></div><div class="line">        <span class="keyword">for</span> i, (a, b, op) <span class="keyword">in</span> enumerate(zip(code, code[<span class="number">1</span>:], code[<span class="number">2</span>:])):</div><div class="line">            <span class="keyword">if</span> isinstance(a, int) <span class="keyword">and</span> isinstance(b, int) <span class="keyword">and</span> op <span class="keyword">in</span> {<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>}:</div><div class="line">                m = Machine((a, b, op))</div><div class="line">                m.run()</div><div class="line">                code[i:i+<span class="number">3</span>] = [m.top()]</div><div class="line">                print(<span class="string">"Constant-folded %s%s%s to %s"</span> % (a, op, b, m.top()))</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> code</div></pre></td></tr></table></figure>

<h2 id="读取-求值-输出循环">读取-求值-输出循环</h2>
<blockquote>
<p>“读取-求值-输出”循环（英语：Read-Eval-Print Loop，简称REPL）是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境，但也能指代命令行的模式和例如APL、BASIC、Clojure、F#、Haskell、J、Julia、Perl、PHP、Prolog、Python、R、Ruby、Scala、Smalltalk、Standard ML、Tcl、Javascript这样的编程语言所拥有的类似的编程环境。这也被称做交互式顶层构件（interactive toplevel）。</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" target="_blank" rel="external">read-eval-print loop</a><br>这个名字来自于以下几个Lisp用来实现这种机制的内置函数：</p>
<ul>
<li>读入函数接收一个来自于用户的表达式，将其解析成数据结构并存入内存。例如，用户可能会输入一个s-表达式　(+ 1 2 3)，这句话会被解析成一个包含四个元素的链表。</li>
<li>求值函数　负责处理内部的数据结构并对其求值。在Lisp中，求一个以函数名开头的ｓ－表达式意味着对接下来的参数调用那个函数。所以函数”+”被在参数1 2 3上调用，产生结果6。</li>
<li>输出函数接受求值结果，并呈现将其给用户。尽管当前的结果“6”并不具有复杂的格式，但如果是一个较为复杂的表达式，那么它将会被精心处理，以便于更方便地被理解。</li>
</ul>
<p>代码应当这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Hit CTRL+D or type "exit" to quit.'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            source = raw_input(<span class="string">"&gt; "</span>)</div><div class="line">            code = list(parse(source))</div><div class="line">            code = constant_fold(code)</div><div class="line">            Machine(code).run()</div><div class="line">        <span class="keyword">except</span> (RuntimeError, IndexError) <span class="keyword">as</span> e:</div><div class="line">            print(<span class="string">"IndexError: %s"</span> % e)</div><div class="line">        <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">            print(<span class="string">"\nKeyboardInterrupt"</span>)</div></pre></td></tr></table></figure>

<h2 id="再思考">再思考</h2>
<p>这样，基本上的我们就完成了一个简单的解释器，实际上它的能力很弱小，但是作为一个锻炼思考的方式，是一个不错的实践。接下来，可以给这个解释器添加更多的功能。</p>
<p>另外，推荐几个其他的文章：<br><a href="http://python.jobbole.com/82206/" target="_blank" rel="external">用 Python 从零开始写一个简单的解释器</a><br><a href="http://blog.jobbole.com/88152/" target="_blank" rel="external">一起来写个简单的解释器</a><br><a href="http://blog.jobbole.com/47659/" target="_blank" rel="external">如何使用Python编写一个Lisp解释器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
</feed>
