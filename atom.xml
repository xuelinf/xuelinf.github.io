<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[临风|刀背藏身]]></title>
  <subtitle><![CDATA[代码是一棱刀背，幸好，有此藏身。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-24T13:16:13.768Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[临风]]></name>
    <email><![CDATA[xuelinf@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[(level 9)深入源码，遇见eval和iframe -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/24/-level-9-%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%EF%BC%8C%E9%81%87%E8%A7%81eval%E5%92%8Ciframe-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/24/-level-9-深入源码，遇见eval和iframe-XSS升级之路/</id>
    <published>2016-05-24T13:15:16.000Z</published>
    <updated>2016-05-24T13:16:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="深入源码，邂逅eval和iframe">深入源码，邂逅eval和iframe</h1>
<p>前边的分析过程，看起来还是比较浅，不论是直接在源码中出现的，还是在elements 中出现的，他们都是通过JavaScript 的document.write 或者是 innerHTML 输出到网页去了，所以还是可以轻松的在开发者工具那里看到输出的位置。但是，如果一部分输出，最终没有流向innerHTML 或者是 document.write，就需要安心下来慢慢挖掘了。</p>
<p>腾讯的栗子：<br><a href="http://kf.qq.com/search_app.shtml?key=aaaaa" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key=aaaaa</a></p>
<p>跑去源码和开发者工具里搜索一通，都没有搜索到，下面，我们换个思路，进入console 中，看能否发现一些。我们按照往常，在URL 的参数里，构造一些特殊字符，单引号，双引号，尖括号，斜杠，一般来说，双引号单引号都会最早被过滤，所以一般斜杠的几率还大一些。我们构建之后，查看结果返回一个错误的信息：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640909121568.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640909234736.jpg" alt=""></p>
<p>右边能点开帮助文档，能看到源文件，那我们进源文件好好看看到底哪里出错了，有没有机会绕过。我们定位到代码的位置，上下文大约如此：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getarg = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line"></div><div class="line">{</div><div class="line">	<span class="keyword">var</span> url = <span class="built_in">window</span>.location.href;</div><div class="line">	<span class="keyword">var</span> allargs = url.split(<span class="string">"?"</span>)[<span class="number">1</span>];</div><div class="line">	<span class="keyword">if</span> (allargs!=<span class="literal">null</span> && allargs.indexOf(<span class="string">"="</span>)&gt;<span class="number">0</span>)</div><div class="line">	{</div><div class="line">		<span class="keyword">var</span> args = allargs.split(<span class="string">"&"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;args.length; i++)</div><div class="line">		{</div><div class="line">			<span class="keyword">var</span> arg = args[i].split(<span class="string">"="</span>);</div><div class="line">			<span class="built_in">eval</span>(<span class="string">'this.'</span>+arg[<span class="number">0</span>]+<span class="string">'="'</span>+arg[<span class="number">1</span>]+<span class="string">'";'</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">};</div></pre></td></tr></table></figure>

<p>这就是最简单的从URL 中获取参数的代码，url 是原始的url,allargs 是问号之后的参数部分，然后通过&amp; 分割的开来，然后对URL 中每一个参数键值对，用一个eval 来执行记录操作，也就是执行了eval(‘this.key’=”aaaa”;’)，eval(‘this.’+arg[0]+’=”‘+arg[1]+’”;’);两个参数分别对应了等号左右的键和值，虽然我们没有在页面里看到输出，但是它实际上还是输出了。</p>
<p>那么，我们不仅可以对值进行替换，还可以对键进行替换尝试，我们先替换一下arg[0] 试试：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">this</span>.key;alert(<span class="number">1</span>);<span class="comment">//="aaaa";</span></div></pre></td></tr></table></figure>

<p>变成上式那样的，就可以弹窗了，双斜杠形成注释，截掉了后边的内容。测试一下这个URL：<br><a href="http://kf.qq.com/search_app.shtml?key;alert(1);//=aaaa" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key;alert(1);//=aaaa</a></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640923929508.jpg" alt=""></p>
<p>弹弹弹，那么后边的值部分可以不可以呢。</p>
<p>按照惯常思路，使用双引号闭合，然后加入利用函数：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">this</span>.key=<span class="string">"aaaa"</span>;alert(<span class="number">1</span>);<span class="comment">//";</span></div></pre></td></tr></table></figure>

<p>构造出来的URL：<br><a href="http://kf.qq.com/search_app.shtml?key=aaa&quot;;alert(1);//" target="_blank" rel="external">http://kf.qq.com/search_app.shtml?key=aaa&quot;;alert(1);//</a></p>
<p>但是，对于chrome等非IE 浏览器，实际上，对于URL 出现的双引号，会将其进行URL 编码，在HTML 解析的时候，无法完成正常的语法结构，也就失效了，不过上述代码在IE下是有效的。</p>
<p>下面我们再发现输出在iframe中的，因为iframe 后边可以跟src ，有时候为了方便嵌套小框架，会从URL里读取参数，然后构造成地址，输出在iframe 的src 中，形如：&lt; iframe src=”[输出]”&gt;&lt; /iframe&gt;。</p>
<p>但是，对于src 来说，我们可以插入伪URL ，来执行JS 代码，常见的插入在前边也说过，对于iframe 可以有以下几种：</p>
<ul>
<li>&lt; iframe onload=”alert(1)”&gt;&lt; /iframe&gt;</li>
<li>js伪url: &lt; iframe src=”javascript:alert(1)”&gt;&lt; /iframe&gt;</li>
<li>IE下的vbscript执行代码： &lt; iframe src=”vbscript:msgbox(1)”&gt;&lt; /iframe&gt; </li>
<li>Chrome 下data的协议执行代码：&lt; iframe src=”data:text/html,&lt; script&gt;alert(1)&lt; /script&gt;”&gt;&lt; /iframe&gt;</li>
<li>如果尖括号被屏蔽，还可以使用HTML 实体编码：&lt; iframe src=”data:text/html,&amp;lt ;script&amp;gt ;alert(1)&amp;lt ;/script&amp;gt ;”&gt;&lt; /iframe&gt;</li>
<li>以及Chrome下srcdoc属性:&lt; iframe srcdoc=”&amp;lt ; script&amp;gt ;alert(1)&amp;lt ;/script&amp;gt ;”&gt;&lt; /iframe&gt;</li>
</ul>
<p>下面继续从乌云上的栗子开始学习：<br><a href="http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=aaaaaa&amp;gid=yl&amp;cid=68&amp;from=" target="_blank" rel="external">http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=aaaaaa&amp;gid=yl&amp;cid=68&amp;from=</a></p>
<p>仍然使用最简单的方式去开发者工具里找输出，看到被带到了iframe 的src 中去：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640940633944.jpg" alt=""></p>
<p>尝试用最简单的方式构造一个弹窗：<br><a href="http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=javascript:alert(1);&amp;gid=yl&amp;cid=68&amp;from=" target="_blank" rel="external">http://helper.qq.com/appweb/tools/tool-detail.shtml?turl=javascript:alert(1);&amp;gid=yl&amp;cid=68&amp;from=</a><br>结果失效：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-24-14640940998030.jpg" alt=""></p>
<p>看来是被过滤掉了，那么寻找到这个iframe 的处理操作，去找找问题，在js 源码里，找到了相关的处理：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">OpenFrame</span><span class="params">(url)</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (url.toLowerCase().indexOf(<span class="string">'http://'</span>) != <span class="string">'-1'</span> || url.toLowerCase().indexOf(<span class="string">'https://'</span>) != <span class="string">'-1'</span> || url.toLowerCase().indexOf(<span class="string">'javascript:'</span>) != <span class="string">'-1'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"toolframe"</span>).src = url;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际上，他做了最简单的过滤，仅仅是不允许JavaScript 伪URL，而url 参数，我们寻找turl 参数，源码中，并没再做更多操作：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tool_url = getQueryStringValue(<span class="string">"turl"</span>);</div><div class="line">...</div><div class="line">openFrame(tool_url);</div></pre></td></tr></table></figure>

<p>那么我们就可以用上边说的使用VBScript来在IE 下XSS，可以在Chrome 中用date 来构造XSS。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IE： http://helper.qq.com/appweb/tools/tool-detail.shtml?<span class="variable">turl=</span>vbscript:msgbox(<span class="number">1</span>)'&<span class="variable">gid=</span>yl&<span class="variable">cid=</span><span class="number">68</span>&<span class="variable">from=</span></div><div class="line"></div><div class="line">Chrome: http://helper.qq.com/appweb/tools/tool-detail.shtml?<span class="variable">turl=</span>data:text/html,&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;'&<span class="variable">gid=</span>yl&<span class="variable">cid=</span><span class="number">68</span>&<span class="variable">from=</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h1 id="深入源码，邂逅eval和iframe">深入源码，邂逅eval和iframe</h1>
<p>前边的分析过程，看起来还是比较浅，不论是直接在源码中出现的，还是在elements 中出现的，他们都是通过JavaScript 的document.write 或者是 i]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ace-Editor 上手及调用方法]]></title>
    <link href="http://yoursite.com/2016/05/24/Ace-Editor-%E4%B8%8A%E6%89%8B%E5%8F%8A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/24/Ace-Editor-上手及调用方法/</id>
    <published>2016-05-24T09:05:34.000Z</published>
    <updated>2016-05-24T09:06:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Ace-Editor_上手及调用方法">Ace-Editor 上手及调用方法</h1>
<p>因为最近一个项目的需要，需要一个网页端的代码显示，可编辑，高亮，显行，方便跳转等功能。试着想了想怎么写，越想越麻烦，本着不重复造轮子的想法，找到了C9 在线编辑器的base 版，也就是这个Ace-Editor, Ace-Editor 功能很强大，我配置使用了一下，能够满足各种需求了。</p>
<h1 id="上手">上手</h1>
<p>主页：<a href="https://ace.c9.io" target="_blank" rel="external">Ace-editor</a><br>Github: <a href="https://github.com/ajaxorg/ace-builds/" target="_blank" rel="external">ace-builds</a></p>
<p>clone 下builds 文件，这些已经是generated files 了，如果要进一步了解，对编辑器本身做改造，可以访问源头<a href="https://github.com/ajaxorg/ace" target="_blank" rel="external">ace</a>。</p>
<p>使用代码编辑器很简单，下载完builds files之后，在html 文件插入如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>ACE in Action<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="id">#editor</span> <span class="rules">{ </span></div><div class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</div><div class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">        <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">    <span class="rule">}</span></div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"editor"</span>&gt;</span>function foo(items) {</div><div class="line">    var x = "All this is syntax highlighted";</div><div class="line">    return x;</div><div class="line">}<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/ace-builds/src-noconflict/ace.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> editor = ace.edit(<span class="string">"editor"</span>);</div><div class="line">    editor.setTheme(<span class="string">"ace/theme/monokai"</span>);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>).style.fontSize=<span class="string">'12px'</span>;</div><div class="line">    editor.getSession().setMode(<span class="string">"ace/mode/javascript"</span>);</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>其中只需要引入工程文件下的ace.js， 然后将编辑器div 用edit 绑定成一个编辑器，后边的诸多功能，都是从这个对象开始的。上边的例子中，指定了主题，设置了语言模式。ace 支持百种语言模式。</p>
<p>一些最初操作，如设置主题，以及语言模式，如上例子，直接用获得的对象调用，setTheme, getSession().setMode()，以及利用DOM 操作来制定字体大小。<br>所以，一个常规的注册过程应当是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> editor = ace.edit(<span class="string">"xxx"</span>);</div><div class="line"><span class="keyword">var</span> session = editor.getSession();</div></pre></td></tr></table></figure>

<p>实际上，这一块有一些API 搞得不是很清晰，有些函数是在editor 上操作，有些是在session上操作的，有些是editor 和session 都可以。所以一个良好的办法就是开始初始化的时候把两个都先初始化。</p>
<h1 id="常用操作">常用操作</h1>
<p>设置和获取代码区内的代码，这是我的项目里要用的比较多的操作，因为涉及到频繁的文件跳转，读取和写入操作。他的使用非常简单。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">editor.setValue(<span class="string">"the new text here"</span>); <span class="comment">// or session.setValue</span></div><div class="line">editor.getValue(); <span class="comment">// or session.getValue</span></div></pre></td></tr></table></figure>

<p>此处editor 和 session 都是可以的，建议直接使用editor。</p>
<p>获取选中的范围，做片段代码检测和替换的时候，可能会用到这个api,不需要指定参数，就根据代码区选中的代码部分，做操作就可以了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.session.getTextRange(editor.getSelectionRange());</div></pre></td></tr></table></figure>

<p>在光标处插入字符串：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.insert(<span class="string">"Something cool"</span>);</div></pre></td></tr></table></figure>

<p>获取当前光标所在的行和列，定义一个函数，监听代码区内的鼠标点击操作，然后获取行列，这个用处较多。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.selection.getCursor();</div></pre></td></tr></table></figure>

<p>定位到某一行，配合上一个使用，可以实现两个编辑器的同步跳转操作，以此方法，也可以实现markDown 编辑器的制作了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.gotoLine(lineNumber);</div></pre></td></tr></table></figure>

<p>只读文本，两块代码区，有一块是只读的，所以将该设置定位true.</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">editor.setReadOnly(<span class="literal">true</span>);</div></pre></td></tr></table></figure>

<p>搜索功能，可以给搜索定制比较多的参数，然后实现替换等功能。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">editor.find(<span class="string">'needle'</span>,{</div><div class="line">    backwards: <span class="literal">false</span>,</div><div class="line">    wrap: <span class="literal">false</span>,</div><div class="line">    caseSensitive: <span class="literal">false</span>,</div><div class="line">    wholeWord: <span class="literal">false</span>,</div><div class="line">    regExp: <span class="literal">false</span></div><div class="line">});</div><div class="line">editor.findNext();</div><div class="line">editor.findPrevious();</div></pre></td></tr></table></figure>

<p>其中可以指定的参数：</p>
<ul>
<li>needle: The string or regular expression you’re looking for</li>
<li>backwards: Whether to search backwards from where cursor currently is. Defaults to false.</li>
<li>wrap: Whether to wrap the search back to the beginning when it hits the end. Defaults to false.</li>
<li>caseSensitive: Whether the search ought to be case-sensitive. Defaults to false.</li>
<li>wholeWord: Whether the search matches only on whole words. Defaults to false.</li>
<li>range: The Range to search within. Set this to null for the whole document</li>
<li>regExp: Whether the search is a regular expression or not. Defaults to false.</li>
<li>start: The starting Range or cursor position to begin the search</li>
<li>skipCurrent: Whether or not to include the current line in the search. Default to false.</li>
</ul>
<p>然后使用，find,replace,relaceall ，就可以做替换了。</p>
<p>监听代码区的变化，这个是重要的功能，省去了一些自己写监听函数的功夫，一般来说，ace 中的监听函数都形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object.on(<span class="string">"change"</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{});</div></pre></td></tr></table></figure>

<p>最常用的监听会话的变化，进一步来讲就是监听当前光标的变化，选择的内容的变化等。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">editor.getSession().on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// e.type, etc</span></div><div class="line">    <span class="comment">// To listen for an onchange:</span></div><div class="line">});</div><div class="line">editor.getSession().selection.on(<span class="string">'changeSelection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// To listen for an selection change:</span></div><div class="line">});</div><div class="line">editor.getSession().selection.on(<span class="string">'changeCursor'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="comment">// To listen for a cursor change:</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>绑定快捷键操作，这个算是功能完善之后的小功能点了</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">editor.commands.addCommand({</div><div class="line">    name: <span class="string">'myCommand'</span>,</div><div class="line">    bindKey: {win: <span class="string">'Ctrl-M'</span>,  mac: <span class="string">'Command-M'</span>},</div><div class="line">    exec: <span class="function"><span class="keyword">function</span><span class="params">(editor)</span> </span>{</div><div class="line">        <span class="comment">//...</span></div><div class="line">    },</div><div class="line">    readOnly: <span class="literal">true</span> <span class="comment">// false if this command should not apply in readOnly mode</span></div><div class="line">});</div></pre></td></tr></table></figure>

<h1 id="更多功能">更多功能</h1>
<p>ace 作为一个在线编辑器的底层模板，实现了非常多的底层功能，报错词法分析，分词器都做到了，在此基础之上，还可以制作自己的语法高亮系统，以及语法处理，依托这个功能，还可以实现自己的Markdown编辑器。不过，我现在要做的功能不是实现一个markdown编辑器，所以这一部分功能不涉及。</p>
<p>另外，在Document 里可以查到他的API Reference， 总共可以分为以下这些类别，需要的时候，可以查阅文档：</p>
<ul>
<li>Anchor</li>
<li>BackgroundTokenizer</li>
<li>Document</li>
<li>EditSession</li>
<li>Editor</li>
<li>Range</li>
<li>Scrollbar</li>
<li>Search</li>
<li>Selection</li>
<li>TokenIterator</li>
<li>Tokenizer</li>
<li>UndoManger</li>
<li>VirtualRenderer</li>
</ul>
<h1 id="可以拿来做什么">可以拿来做什么</h1>
<p>在ace-editor 的基础上实现的C9 在线IDE非常强大，实现了一个IDE 应该有的全部功能，这也当是ace 的强大所在。</p>
<p>ace 可以用来做一个Markdown编辑器，现在做这个不麻烦，主要是不能有bug，网上可以找到一些已有的语法分析方案，然后可以实现一套自己的方案。进一步的话，麻烦一些的就是实现一个自己的文件夹系统，来管理文件。</p>
<p>我现在使用它要做的功能，是两个代码编辑框，从一个代码编辑框中任意位置，会根据代码中的内容，定位到另一个文件中的位置。关键的技术问题就是后台实现一个文件管理的功能，前端能够读取光标所在行，分析所在行标记的另一个文件的路径和文件中的位置，并在另一个代码编辑框中显示，并定位到该行。</p>
<p>再下一步是要能够对代码某一个range，做替换操作。替换完成后，还应当能够确保本地得以修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Ace-Editor_上手及调用方法">Ace-Editor 上手及调用方法</h1>
<p>因为最近一个项目的需要，需要一个网页端的代码显示，可编辑，高亮，显行，方便跳转等功能。试着想了想怎么写，越想越麻烦，本着不重复造轮子的想法，找到了C9 在线编辑器的bas]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 8)DOM XSS寻踪 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/19/-level-8-DOM-XSS%E5%AF%BB%E8%B8%AA-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/19/-level-8-DOM-XSS寻踪-XSS升级之路/</id>
    <published>2016-05-19T13:33:28.000Z</published>
    <updated>2016-05-19T13:34:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DOM_XSS寻踪">DOM XSS寻踪</h1>
<p>让我们继续寻找DOM XSS，在上一节里，在地址栏里输入的内容，很容易出现在了源代码里，然后我们发现源代码里是一个DOM 操作，通过js 的Unicode 转义，我们将利用代码植入到了innerHTML 指向的内容中，同时绕过了过滤。</p>
<p>关于编码的顺序问题，可以参考我之前总结的一篇文章，比较清晰。</p>
<p>那么，如果我们在源代码里，定位不到我们在URL 里的参数呢，其实这并没有太多不同。只是因为网页直接通过脚本，通过DOM 操作，修改了或者添加了某些标签，源码中看不到。但只需要进入调试工具里，就能找到了。</p>
<p>这里拉来一个老漏洞，现已修复：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://qt.qq.com/video/play_video.htm?sid=aaaaaa</div></pre></td></tr></table></figure>

<p>这样一个地址，我们跑去源代码里，是不会直接找到输出的，其实这也是更为常见的情况：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636624184026.jpg" alt=""></p>
<p>此时我们应该去到调试工具里找，在审查元素里，我们看到了输出的位置：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636624575899.jpg" alt=""></p>
<p>按照以往的方法，我们仍然是使用常识构造的方式，去看那些写法是被过滤的，然后尝试去构造攻击模式。另一种方法，则是去resources 中，去查看脚本，是那个脚本执行了什么操作，让变量进入了标签，了解清楚了之后，可以对症下药的创造攻击向量。</p>
<p>我们直接对sid 这个参数在resource 中搜索，会找到响应的处理函数。在这里，是一个叫getUrlPara 的函数：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636628056657.jpg" alt=""><br>进一步，定位到该函数的定义，通过分析该函数，我们能了解脚本在获得该参数后的操作，在该函数里，我们发现，该函数对 location.href 中的尖括号和引号已经进行了过滤处理，但实际上，这段代码实际上是不太正确。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-19-14636630231700.jpg" alt=""></p>
<p>因为在进行处理之前，拿到的href 已经经过了URL 编码，该函数不会对任何符号进行处理。即使是浏览器不做编码处理，如果我们预先对它进行编码处理，也会跳过函数中的过滤。然后让我们再回到函数调用之后的上下文。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sid=getUrlPara(<span class="string">"sid"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!sid || sid==<span class="string">""</span>){</div><div class="line"></div><div class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-10px;"&gt;抱歉，视频不存在！&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">	<span class="keyword">var</span> flash_ver=GetSwfVer();</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(flash_ver == -<span class="number">1</span>){</div><div class="line"></div><div class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-30px;"&gt;抱歉，您还没有安装flash插件&lt;br/&gt;请&lt;a target="_blank" href="http://www.macromedia.com/go/getflashplayer"&gt;下载&lt;/a&gt;10.0以上的flash播放器&lt;br/&gt;安装flash后，请&lt;a href="javascript:location.reload();"&gt;点此刷新&lt;/a&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">	}<span class="keyword">else</span> <span class="keyword">if</span>(flash_ver.split(<span class="string">'.'</span>)[<span class="number">0</span>]&lt;<span class="number">10</span>){</div><div class="line"></div><div class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-30px;"&gt;抱歉，您的flash版本过低&lt;br/&gt;请&lt;a target="_blank" href="http://www.macromedia.com/go/getflashplayer"&gt;下载&lt;/a&gt;10.0以上的flash播放器&lt;br/&gt;安装flash后，请&lt;a href="javascript:location.reload();"&gt;点此刷新&lt;/a&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">	}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">		sid=<span class="built_in">decodeURIComponent</span>(sid).trim().replace(<span class="regexp">/([\'\"])/g</span>,<span class="string">'\\\\$1'</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(!is_valid_sid(sid)){</div><div class="line"></div><div class="line">			<span class="built_in">document</span>.getElementById(<span class="string">"dv_video"</span>).innerHTML=<span class="string">'&lt;div class="errmsg" style="margin-top:-10px;"&gt;无法打开视频文件，视频地址不合法！&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">		}<span class="keyword">else</span>{</div><div class="line"></div><div class="line">			insertFlash(<span class="string">"dv_video"</span>,<span class="string">"f"</span>,sid,<span class="string">"100%"</span>,<span class="string">"100%"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里，通过decodeURLComponent 将编码后的参数，又解码成了原符号，而后边调用的insertFlash 操作，未经过滤的将sid 写进了页面：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertFlash</span><span class="params">(elm, eleid, url, w, h)</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">document</span>.getElementById(elm)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line"></div><div class="line">    str += <span class="string">'&lt;object width="'</span> + w + <span class="string">'" height="'</span> + h + <span class="string">'" id="'</span> + eleid + <span class="string">'" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0"&gt;'</span>;</div><div class="line"> </div><div class="line">    str += <span class="string">'&lt;param name="movie" value="'</span> + url + <span class="string">'" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="allowScriptAccess" value="never" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="allowFullscreen" value="true" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="wmode" value="transparent" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;param name="quality" value="autohigh" /&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;embed width="'</span> + w + <span class="string">'" height="'</span> + h + <span class="string">'" name="'</span> + eleid + <span class="string">'" src="'</span> + url + <span class="string">'" quality="autohigh" swLiveConnect="always" wmode="transparent" allowScriptAccess="never" allowFullscreen="true" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;&lt;/embed&gt;'</span>;</div><div class="line">    str += <span class="string">'&lt;/object&gt;'</span>;</div><div class="line">    <span class="built_in">document</span>.getElementById(elm).innerHTML = str</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们很容易的想象到了构造&lt; img src=# onerror=alert(1)&gt;，对尖括号进行URL 编码就可以了。实际上，就这一个漏洞，我们不仅可以使用URL 编码的方式。结合我之前说的浏览器的解析顺序，在这里，从URL 获得的参数，进入脚本，脚本调用DOM 操作，修改DOM 树，所以我们用Unicode编码也能最后得到解析。</p>
<p>我们始终说，安全编码是一个不容易的技术，因为一步疏漏就会在最终造成满盘皆输。所以，对于开发者，想要真正构建安全的程序，就必须对程序所涉及的技术框架了如指掌。比如对于Web,应该对浏览器的原理，HTTP/HTTPS,各种编码原理，JS&amp;CSS&amp;HTML，PHP&amp;ASP，的安全部分都有一定了解，才能在构建程序的时候，抓住最关键的部分，确保不出问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DOM_XSS寻踪">DOM XSS寻踪</h1>
<p>让我们继续寻找DOM XSS，在上一节里，在地址栏里输入的内容，很容易出现在了源代码里，然后我们发现源代码里是一个DOM 操作，通过js 的Unicode 转义，我们将利用代码植入到了innerHTML 指]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码与解码 -- 浏览器做了什么]]></title>
    <link href="http://yoursite.com/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2016/05/18/编码与解码-浏览器做了什么/</id>
    <published>2016-05-18T08:50:28.000Z</published>
    <updated>2016-05-18T08:51:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="浏览器是如何解码的">浏览器是如何解码的</h1>
<p>无论是作为开发，还是作为黑客，企图从Web 端注入SQL，或者是XSS 的时候，编码和解码都是一个重要的问题、作为一个浏览器，有URL解析引擎，有HTML解析引擎，还有JS 解析引擎。其执行的先后顺序往往决定了输出的结果。这种多标签语言互相嵌入的，同时又需要客户端服务器交互的技术，正是给了XSS 可趁之机。下面我们要做的，是去了解浏览器到底如何解码，该如何在解码过程中避免漏洞的产生。在此之上，我更愿意揭开整个浏览器的工作流程，了解其本质。</p>
<p>这里有篇神文<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="external">How browsers work</a>， 也是本篇文章的重要参考。</p>
<h2 id="浏览器基本的工作流程">浏览器基本的工作流程</h2>
<p>进入主话题之前，先闲扯一些废话，先罗列一下浏览器的主要构成：</p>
<ol>
<li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS解释器－ 用来解释执行JS代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li>
</ol>
<p>其组件架构是这样的：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635395450775.jpg" alt=""></p>
<p>值得一提的是，对于Chrome 浏览器来说，Chrome 为每个Tab 都分配了各自的渲染引擎，每个Tab 都是一个独立的进程。</p>
<p>实际上，我们重点关注的就是其中的Rendering engine 和 JavaScript Interpreter ，渲染引擎和解释器。说了那么多废话，我们开始了解浏览器的主流程。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635418258357.jpg" alt=""></p>
<p>这是浏览器从接收代码，到渲染完成的过程，从开头我们能看到它有三个主要部分：</p>
<ol>
<li>HTML/SVG/XHTML 解析，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li>
<li>CSS 解析，解析CSS会产生CSS规则树。</li>
<li>Javascript DOM，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li>
</ol>
<p>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。在此基础上，JavaScript DOM API 参与进来，可以对DOM 树进行修改，改变DOM树的结构和内容。而此时，CSS解析器则解析外部CSS 文件以及Style 标签中的样式内容，这些信息将搭配HTML 中的可见指令构建起一个Rendering Tree。</p>
<p>这里CSS 解析器在构造Redering Tree 之前，为了辅助会有CSS Rule Tree，他是为了完成匹配，然后把CSS Rule 附加给Rendering Tree 上的每个element，也就是每个DOM 节点。其中有一个layout/reflow 的过程，就是为了计算每个frame 位置等信息。</p>
<p>当然，个人并不是一个Web 开发者，无意在CSS 这一块花费巨大的时间，下面这个视频会很形象的让你感受到layout/reflow 的过程。<a href="http://v.youku.com/v_show/id_XMzI5MDg0OTA0.html" target="_blank" rel="external">Gecko reflow visualization</a></p>
<p>完成布局之后，使用UI 后端完成每个节点的绘制，完成显示。</p>
<h2 id="编码和解码发生的顺序">编码和解码发生的顺序</h2>
<p>在看完浏览器工作流程之后（当然，这个流程讲的有点简单了），我们来看一下编码和解码的顺序，对应着工作流程就很容易记清楚了。</p>
<h3 id="URL_解析">URL 解析</h3>
<p>在这些所有工作流程开始之前，浏览器一定需要有一个URL 来指示资源的位置，为什么刚才没有说呢，因为这个URL 是浏览器发送给服务器的请求信息，其处理工作并不是浏览器的工作。比如我们考虑一段简单的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;?php echo $_GET['input'];?&gt;');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>input 内容参数为： %26lt%5cu4e00%26gt</p>
<p>该值构造在URL 里，浏览器直接发送给服务器，服务器接收之后，先进行URL 解析，看到了% 这个符号，于是URL 解码，input 内容变成了&amp;lt\u4e00&amp;gt，所以对于浏览器从服务器端获取的页面数据来说，此时test 对应的标签变成了如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt\u4e00&gt');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>这一步完成在所有的工作之前，URL 解码发生在第一部，而且它基本上都发生在服务器上。</p>
<h3 id="HTML_解析">HTML 解析</h3>
<p>浏览器接收到页面数据，于是开始进行HTML 解析，构造DOM树。构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。</p>
<p>解析过程是迭代的，解析器从词法分析器处取道一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p>
<p>而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的。对于以下一个最常见的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span></div><div class="line">          Hello DOM</div><div class="line">        <span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">”example.png”</span> /&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>它将转换为下面的DOM 树：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635438180995.jpg" alt=""></p>
<p>所以，HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，这一块，HTML 不会做解码的工作，因为它做不了。所以，试图这样构造利用漏洞，是不可能的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>&#<span class="attribute">x3d</span>;"<span class="attribute">http:</span>//<span class="attribute">www.example.com</span>"&gt;</span></div></pre></td></tr></table></figure>

<p>因为在构建DOM 树的时候，这样是无法识别的，也就破坏了标签本身的结构。而HTML 解码，是在DOM树结构OK，对节点内容解析的时候，会进行转码，所以以下两种写法，是完全一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://www.example.com"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"ht&#x74;p&#x3a;//www.example.com"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>所以，在DOM 树构建完毕之后，这些HTML 实体编码的内容就会被解码。JS 的解释器还没有走进战场。不过由于DOM 的存在，JavaScript还是参与了DOM Tree 的构建过程，这时候，编码的解析就变得绕了一些。在此我们先忽略掉这一个，先继续讲主过程讲完，继续考虑这个代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt\u4e00&gt');"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>HTMl 解析器构建DOM Tree, href中的内容，如果识别为实体编码的，会透明的解码，于是它就变成了这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;\u4e00&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<h2 id="CSS_的编码问题">CSS 的编码问题</h2>
<p>一般来说，CSS 解析器会做接下来的工作，不过一般来说，为了考虑到更好的体验和性能，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>当然CSS不会干扰到DOM 树的建立，他会结合CSS文件和style 标签，以及HTML中的课件指令来构建起reder tree。这里JavaScrit 的 CSSOM api 也会出一些力。</p>
<p>CSS 编码解析是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p>
<p>同时，CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p>
<p>由于CSS 转义规定的语焉不详，许多解析器会对本该用引号括起来的字符串进行任意的转义，特别的，在IE 浏览器里，这种转义优先级高于伪函数语法，于是下边两种情况的写法是一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">color:expression(alert(1))</div><div class="line">color:expression\028 alert \028 1 \029 \029</div></pre></td></tr></table></figure>

<p>如果对该部分内容感兴趣，可以阅读开始提到的那篇文章，或者是我之前写的一些文章。</p>
<h2 id="JS_解释器">JS 解释器</h2>
<p>上边提到了style ，是建立reder tree 的时候使用的，它怎么工作的呢。考虑到我们的浏览器为了让不同的解析器来工作处理不同的内容，实际上，在处理诸如&lt; script&gt; &lt; style&gt; 这样的标签，解析器会自动切换到特殊解析模式，而src href 后边加入的JavaScript 伪URL，也会进入JS 的解析模式。而进入该解析模式的时候，该DOM节点已经建立起来了。</p>
<p>还是上边的例子，经过HTML 的解码，代码已经变成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;\u4e00&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>javascript 出发了JS 解释器，JS会先对内容进行解析，里边有一个转义字符\u4e00,前导的 \u 表示他是一个Unicode 字符，根据后边的数字，解析为’一’，于是在完成JS的解析之后变成了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert('&lt;一&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后JS 解释器执行alert(“&lt; 一&gt;”)，这句话会交给浏览器渲染，最终弹窗。</p>
<p>这里边会有一个看起来让人有些疑惑的东西，仍以上一段代码为例，假如我们编码的位置不是括号里，而是在alert上，我们知道，js 是会对它进行逆转义的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:\u0061lert('&lt;一&gt;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而另一方面，如果想用这种方式来替换掉圆括号，或者引号，会判定为失败。同时，<strong>主要注意的方式，上边这种直接在字符串外进行专一的方式，只有Unicode 转义方式呗支持，其他转义方式则不行</strong>。其实，这样的策略是正确的，因为对于JavaScript，转义编码应当只出现在标示符部分，不能用于对语法有真正影响的符号，也就是括号，或者是引号。其实，这样的处理方法，反而是比CSS 更加合理的。</p>
<p>在一个页面中，可以出发JS 解析器的方式有这么几种：</p>
<ul>
<li>直接嵌入&lt; script&gt; 代码块。</li>
<li>通过&lt; script sr=… &gt; 加载代码。</li>
<li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li>
<li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li>
<li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li>
<li>定时器，Timer(setTimeout, setInterval)</li>
<li>eval(…) 调用。</li>
</ul>
<p>我们看到，这些藏匿在HTML 便签中的各种JS 调用，就可以想到Web 开发者的头有多大了，我们举一个简单的栗子：</p>
<p>比如定时器那里，考虑以下代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt; script&gt;</div><div class="line"><span class="keyword">var</span> value = <span class="string">"user_string"</span>;</div><div class="line">...</div><div class="line">setTimeout(<span class="string">"do_stuff('"</span>+value+<span class="string">"')"</span>, <span class="number">1000</span>);</div><div class="line"><span class="xml"><span class="tag">&lt; /<span class="attribute">script</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>表面上看他没有问题，对 value 只做一次转义就好了，但实际呢，考虑其解析过程，首先是HTML 解析出script 块，然后JavaScript 做第一次解析，检查setTimeout 语法，而等到1秒之后，才会解析do_stuff，如果不多做一次转义，就有可能构造成一次注入，比如user_string 中插入一个JavaScript编码的构造，截断前边函数，然后构造自己的攻击部分。</p>
<p>下面我们说一说DOM，我们知道常见的DOM 操作：</p>
<p>DOM 常见的方法有：</p>
<ul>
<li>获取节点<ul>
<li>getElementsById()</li>
<li>getElementsByTagName()</li>
<li>getElementsByClassName()</li>
</ul>
</li>
<li>新增结点<ul>
<li>document.createElement()  创建节点对象，参数是字符串也就是html标签</li>
<li>createTextNode  创建文本节点，配合上一个使用</li>
<li>appendChild(element)  把新的结点添加到指定节点下，参数是一个节点对象</li>
<li>insertChild()  在指定结点钱插入新的节点</li>
</ul>
</li>
<li>修改节点<ul>
<li>replaceChild()  节点交换</li>
<li>setAttribute()  设置属性</li>
</ul>
</li>
<li>删除节点<ul>
<li>removeChild(element)  删除节点，要先获得父节点然后再删除子节点</li>
</ul>
</li>
<li>一些属性<ul>
<li>innerHTML 节点内容，可以获取或者设置</li>
<li>parentNode  当前节点的父节点</li>
<li>childNode  子节点</li>
<li>attributes  节点属性</li>
<li>style  修改样式</li>
</ul>
</li>
</ul>
<p>这样就有一些疑惑了，之前，我们说了，基本的解析顺序是这样的，URL 解析器，HTML 解析器， CSS 解析器，JS解析器，如果安安静静的按照这个顺序下去，应该很容易理清楚。然而DOM 操作里我们可以看到可以新增节点，也可以修改节点属性，节点的内容和样式都可以修改。那么假如我们使用innerHTML 修改了某节点的内容，让其构成了一个新的节点，那么会有什么效果呢？我在Chrome 上做了一些实验，代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>hello<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">#</span> <span class="attribute">onerror</span>=<span class="value">"&#97;lert(1)"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&#35; on\u0065rror=&#97;lert&#40;1)&gt;"</span>;  </div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--&lt;script&gt;</span></div><div class="line">document.getElementById("1").innerHTML = "&#60;img src=&#34;1&#34; onerror=&#34;alert(1)&#34;&#62;";  </div><div class="line">&#38;&#35;&#57;&#55;&#59;</div><div class="line">&lt;/script&gt;--&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>一个正常的容易理解的过程是这一行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">#</span> <span class="attribute">onerror</span>=<span class="value">"&#97;lert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>HTML 解析到标签，建立DOM 树，然后对节点内容进行实体解码，&amp;#97； 就变成a, 随后在js 解析阶段，正常的触发了弹窗，先后顺序OK。</p>
<p>但对于下面这段代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&#35; on\u0065rror=&#97;lert&#40;1)&gt;"</span>;  </div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>使用了DOM 操作，修改前边标签中的内容，添加了一个img 内容，因为进入了script 进入了JavaScript的特殊解析模式，所以此处HTML 不得干扰，首先JavaScript解析器，会先对其中编码的内容解码，于是onerror 就还原回来了，于是正常的执行了JS 语句，在HTML 文档中，将hello 变成了img。 </p>
<p>那么问题来了，如上那样，对onerror 的内容作了HTML 实体编码，会不会弹窗呢？ 答案是显然的，该标签传回给HTML，HTML 建立DOM节点，透明的解码节点内容，onerror 又会执行其中的JS 脚本，弹出窗口。</p>
<p>其实，这里也不难理解，因为HTML 是从上到下解析，遇到&lt; script&gt; 于是进入了特殊的解析模式，使用JS 解析器，做了一个DOM 操作，该DOM 操作修改了前边的DOM 树，该块内容，需要使用HTML 解析重塑DOM 树，那么节点内容中的实体编码就会被解码，然后onerror 中触发脚本，JS 又会对内容进行一次解析。</p>
<p>这一点很好理解：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="string">"1"</span> onerror=<span class="string">"&#97;l\u0065rt(1)"</span> /&gt;</div></pre></td></tr></table></figure>

<p>如上，内容中有HTML实体编码，还有js 的Unicode 编码，正常弹窗没有问题。</p>
<p>总结说来，实际上，DOM 操作实际上是js强势介入 HTML 和CSS 的结果，使用DOM 操作，对DOM Tree 造成了改变，会调用到HTML 解析器重新对其解析，于是流程又会返回到最开始说的那个解析流程里去。这样反复的情况，再加上编码的重叠，很容易让开发者无所适从，考虑下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;p id="1"&gt;hello&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;img src="1" onerror="&#97;l\u0065rt(1)" /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">document.getElementById("1").innerHTML = "bye";</div><div class="line"></div><div class="line">function a(){</div><div class="line">document.getElementById("1").innerHTML = "&lt;img src=# on\u0065rror=&#97;&#108;&#101;&#114;&#116;(1)&gt;";</div><div class="line">}</div><div class="line"></div><div class="line">function timedMsg()</div><div class="line">{</div><div class="line">var t=setTimeout("a()",5000)</div><div class="line">}</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;input type="button" value="111" onClick = "timedMsg()" /&gt;</div></pre></td></tr></table></figure>

<p>整个页面渲染完毕，而当点击按钮之后，会触发DOM操作的脚本，五秒钟之后，弹窗。</p>
<p>如果想要修改的内容中有脚本，内容中的脚本部分使用JS编码，再使用HTML 编码，然后再使用JS Unicode编码，那么解码的过程就是先JS 解码，再HTML 解码，再JS 解码，然后执行。</p>
<h2 id="总结">总结</h2>
<p>其实总的来说，其道理还是易于理解的，只是由于一些特别的操作，造成了一些困扰，于是在编码上，会理不清头绪，如果再此基础上我们再使用String.fromCharCode() 这个一直以来容易被开发者忽略的功能，更会摸不清头脑。</p>
<p>而正是由于这种摸不清头脑的开发之下，黑客们才有可趁之机，制造各种变体，绕过孱弱的过滤器。</p>
<p>总体来说，在编码这件事上，只要理清楚，URL解码，HTML解码，CSS解码，JS解码，以及DOM 操作在其中扮演的角色，就基本上能理清楚了。作为一个开发者，安全编码是必须要重视的内容，所以，对于编码，不可以逃避，在构建安全的过滤规则的时候，一定要考虑清楚各种可能的编码绕过的方式,以避免损失。</p>
<p>如何避免这些漏洞的产生，我会再以后继续写，关于浏览器的解码过程就写到这里吧。对这一问题，仍然还有一些问题有待解决，个人能力有限，其中也有可能存在错误和疏漏，请谅解~</p>
<p>PS. 参考：开头提到的文章，W3cschool 上各种函数，各种编码。《The Tangled Web》这本神书，和一堆谷歌搜索。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="浏览器是如何解码的">浏览器是如何解码的</h1>
<p>无论是作为开发，还是作为黑客，企图从Web 端注入SQL，或者是XSS 的时候，编码和解码都是一个重要的问题、作为一个浏览器，有URL解析引擎，有HTML解析引擎，还有JS 解析引擎。其执行的先后顺序往往决]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM XSS启程 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/17/DOM-XSS%E5%90%AF%E7%A8%8B-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/17/DOM-XSS启程-XSS升级之路/</id>
    <published>2016-05-17T15:00:38.000Z</published>
    <updated>2016-05-17T15:01:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DOM_XSS启程">DOM XSS启程</h1>
<p>之前提到的漏洞内容，都是反射型XSS，攻击性一般来说比较低，即用即消，难以持久，而且一般来说，如果cookie 设置成httponly，你就不能通过document.cookie 的方式获取cookie了，在做其他一些事情，反射型xss就显得乏力了。不过，如果没有设置成httponly，还是有方法获取到海量的用户cookie,简单的利用方法就是在一个自己可控的站点，控制一个iframe，然后链接到主站可xss利用的站点，在URL 里写好脚本，做好接受，就能源源不断的接受来自用户的信息了。</p>
<p>比如说新浪微博或者是腾讯微博存在XSS反射漏洞，我们在自己的站点中写好利用的iframe，然后在自己的微博上写一个吸引人的标题，然后附一个经过短链接转义过得链接。如果别人点进去，就会自动触发我们的XSS 脚本。以前Twitter 上也有这样的漏洞，短时间让黑客的粉丝暴涨百万，实际上只是自动执行了关注黑客的脚本。</p>
<p>下面我们进入下一个XSS类型，DOM XSS。所谓DOM 操作，就是利用JavaScript 的DOM 操作来进行利用。关于DOM树，DOM操作的基础，可以参见<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" target="_blank" rel="external">wikipedia</a> ，可以查看更多信息。</p>
<p>DOM 常见的方法有：</p>
<ul>
<li>获取节点<ul>
<li>getElementsById()</li>
<li>getElementsByTagName()</li>
<li>getElementsByClassName()</li>
</ul>
</li>
<li>新增结点<ul>
<li>document.createElement()  创建节点对象，参数是字符串也就是html标签</li>
<li>createTextNode  创建文本节点，配合上一个使用</li>
<li>appendChild(element)  把新的结点添加到指定节点下，参数是一个节点对象</li>
<li>insertChild()  在指定结点钱插入新的节点</li>
</ul>
</li>
<li>修改节点<ul>
<li>replaceChild()  节点交换</li>
<li>setAttribute()  设置属性</li>
</ul>
</li>
<li>删除节点<ul>
<li>removeChild(element)  删除节点，要先获得父节点然后再删除子节点</li>
</ul>
</li>
<li>一些属性<ul>
<li>innerHTML 节点内容，可以获取或者设置</li>
<li>parentNode  当前节点的父节点</li>
<li>childNode  子节点</li>
<li>attributes  节点属性</li>
<li>style  修改样式</li>
</ul>
</li>
</ul>
<p>下面我们回到XSS 上，如何利用一个显式的DOM XSS。</p>
<p>这样一个URL：<br><a href="http://datalib.ent.qq.com/cgi-bin/search?libid=1&amp;keyvalue=aaaaaaa&amp;attr=133&amp;stype=2&amp;tname=star_second.shtml" target="_blank" rel="external">http://datalib.ent.qq.com/cgi-bin/search?libid=1&amp;keyvalue=aaaaaaa&amp;attr=133&amp;stype=2&amp;tname=star_second.shtml</a></p>
<p>我们在代码中寻找其输出：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634946364874.jpg" alt=""></p>
<p>发现了很多个，将其代码格式化之后如下，我们会实际上，被执行的只有一个：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;strong id=<span class="string">"titleshow"</span>&gt;按职业<span class="number">1</span>检索：aaaaaaa &lt;<span class="regexp">/strong&gt;&lt;/</span>div&gt;</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></span></div><div class="line"><span class="keyword">if</span>(<span class="string">"aaaaaaa"</span>==<span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按地区检索：全部明星"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业1"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业2"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"职业1"</span>==<span class="string">"职业3"</span>)</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"titleshow"</span>).innerHTML=<span class="string">"按职业检索：aaaaaaa"</span>;</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>我们先测试几个特殊字符，发现尖括号被过滤了，但是\ 没有被过滤，而这里又是JS 代码，我们可以十三月Unicode 编码来代替尖括号，仍然可以实现代码利用。\u003c \003e 分别代表尖括号，\0020 代表空格。 而这里其实有一个比较关键的知识点，为什么有时候转义可以，有时候转义不行，编码解码的顺序到底是怎样的，具体可以看下一条文章。</p>
<p>所以，我们构造的完整URL 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://datalib.ent.qq.com/cgi-bin/search?<span class="variable">libid=</span><span class="number">1</span>&<span class="variable">keyvalue=</span>\u003Cimg\<span class="variable">u0020src=</span><span class="number">1</span>\<span class="variable">u0020onerror=</span>alert(<span class="number">1</span>)\u003e&<span class="variable">attr=</span><span class="number">133</span>&<span class="variable">stype=</span><span class="number">2</span>&<span class="variable">tname=</span>star_second.shtml</div></pre></td></tr></table></figure>

<p>但是，左右尖括号的Unicode表示已经被过滤：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634949862018.jpg" alt=""></p>
<p>但仔细观察一下，我们发现，\u0020 都没有被转义，说明开发者的转义是非常局限的，指哪打哪，很有可能有别的方法可以利用。而Unicode 编码也有多种书写方式，比如 \x3c \x3e 就可以代表左右尖括号。那么我们值得一试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://datalib.ent.qq.com/cgi-bin/search?<span class="variable">libid=</span><span class="number">1</span>&<span class="variable">keyvalue=</span>\x3Cimg\<span class="variable">u0020src=</span><span class="number">1</span>\<span class="variable">u0020onerror=</span>alert(<span class="number">1</span>)\x3e&<span class="variable">attr=</span><span class="number">133</span>&<span class="variable">stype=</span><span class="number">2</span>&<span class="variable">tname=</span>star_second.shtml</div></pre></td></tr></table></figure>

<p>令人惊奇的是竟然没有转义：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-17-14634951065021.jpg" alt=""></p>
<p>这样，弹窗就是必然的了。</p>
<p>这是一次简单的DOM XSS 过程，后边会有更加复杂的XSS等待挖掘。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DOM_XSS启程">DOM XSS启程</h1>
<p>之前提到的漏洞内容，都是反射型XSS，攻击性一般来说比较低，即用即消，难以持久，而且一般来说，如果cookie 设置成httponly，你就不能通过document.cookie 的方式获取cookie了，]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 6)符号的进阶 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/16/-level-6-%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BF%9B%E9%98%B6-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/16/-level-6-符号的进阶-XSS升级之路/</id>
    <published>2016-05-16T03:04:34.000Z</published>
    <updated>2016-05-16T03:05:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="符号的进阶">符号的进阶</h1>
<p>上一次是反斜杠发挥的妙用，它默默地转义了一个双引号，还有一些其他有意思的符号，比如换行符也能发挥妙用，这次是来自换行符的一发偷袭。</p>
<p>看这样一个地址：<br><a href="http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=aaaaaaaaaa" target="_blank" rel="external">http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=aaaaaaaaaa</a></p>
<p>逐个测试注入点，我们发现最后的FilterValueAND 的输入点在源码中找到了输出点：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633225014088.jpg" alt=""></p>
<p>它出现在JS 语句里，一上来就感觉有戏。接下来尝试写入特殊字符，测试过滤情况。正常的情况下，尖括号，双引号：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633226756194.jpg" alt=""></p>
<p>但是令人奇怪的是，最后一个输出点竟然是在一大段注释里，这应该是开发的一个失误：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633227582291.jpg" alt=""></p>
<p>看到注释想到了什么呢？如果这里插进来一个换行符，那么应该被注释的部分就不是注释了。那后边再跟注入语句，就能够执行了。然后我们在用一个双斜杠来注释后边的无用部分。利用代码如下：<br><a href="http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=%0aalert(/xss/);//" target="_blank" rel="external">http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=%0aalert(/xss/);//</a></p>
<p>直接就弹窗了。</p>
<p>这一次利用的太过简单，看起来应该是开发的一时疏忽，将一大段内容注释了，而注释里原本好包含了输出，那就有可能出问题了。</p>
<p>那么下面再看一个更综合的例子，地址如下：<br><a href="http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaaaaaaaaaa" target="_blank" rel="external">http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaaaaaaaaaa</a></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633230686974.jpg" alt=""></p>
<p>看一下源码，先测试双引号，妥妥的被过滤，HTML标签里的东西没希望了。往后边看，第二个又出现在了注释里，看来开发还是很希望遗留这些漏洞的，我们直接用一个换行符。</p>
<p>但问题是注释那里被注释掉了，但是接下来的var searchOrder=”….”;这一句就麻烦了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//document.getElementById("order_select").value="aaa</div><div class="line">alert(/xss/); //";</div><div class="line"></div><div class="line">var searchOrder="aaa</div><div class="line">alert(1);//";</div></pre></td></tr></table></figure>

<p>第一个是OK 了，第二个语法错误了。那么又想到什么了呢，在JavaScript 语法里，一个反斜杠可以让语法让换行的内容接起来，形成多行写法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sarchOrder=<span class="string">"aaa\</span></div><div class="line">alert(/xss/);//";</div></pre></td></tr></table></figure>

<p>于是，语法上又恢复了正常，而这一部分内容我们不用管它，只要上一个有效就可以了。但问题是，反斜杠被过滤了，过滤的方法是被转义了。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633235895962.jpg" alt=""></p>
<p>两个反斜杠就没法让JavaScript成立了，怎么办呢？记得之前采用的宽字符的战术，看一眼网页的编码格式,gb2312，说明宽字节是有效的。那我们就用128以上的字符，去吃掉一个反斜杠：</p>
<p><a href="http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaa%c0%5c%0aalert(1);//" target="_blank" rel="external">http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaa%c0%5c%0aalert(1);//</a></p>
<p>从结果上看，%c0吃掉了一个%5c，留下了一个反斜杠。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-16-14633239849141.jpg" alt=""></p>
<p>语法完全ok, 于是弹窗。</p>
<p>至此，这种反射型的XSS 基本上就这么些内容了。想要挖XSS 的洞，非常的耗费功夫，因为即使是没有安全编码尝试的开发者，也基本知道一些必须过滤的字符一定要过滤，另外在PHP 这些语言中，也有专门的函数诸如魔术引号来过滤处理。</p>
<p>不过学习这种XSS 类型，将扩宽思路，不仅是从注入的角度来看，能想到各种有意思的注入和XSS 利用，更重要的是从安全编码的角度看待开发，如何保证代码的安全实际上是比效率更加重要的点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="符号的进阶">符号的进阶</h1>
<p>上一次是反斜杠发挥的妙用，它默默地转义了一个双引号，还有一些其他有意思的符号，比如换行符也能发挥妙用，这次是来自换行符的一发偷袭。</p>
<p>看这样一个地址：<br><a href="http://datalib.ga]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 5)被忽略的反斜杠 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/14/-level-5-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/14/-level-5-被忽略的反斜杠-XSS升级之路/</id>
    <published>2016-05-14T14:40:25.000Z</published>
    <updated>2016-05-14T14:40:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这一块知识聚拢一下，写成一篇文章。想了想，从简单到难，那就是一条打怪升级之路，所以就从最简单的反射型漏洞开始，一点一点提高，直到把大部分XSS 的形式找出来。</p>
<h1 id="level_1_无过滤规则的XSS">level 1 无过滤规则的XSS</h1>
<p>最简单的跨站，也就是我们说的反射型跨站，也叫作非持久型，参数型跨站脚本。这种类型的脚本出现的面非常的广，互联网上这样的漏洞非常多，一般出没在各路小站点，大站点很少出现。乌云的漏洞列表里，海量的XSS 漏洞都来自互联网上访问量不高的小站，被辛苦挖洞的XSSer 们发掘出来的。</p>
<p>站在新手村我们的，需要一个最简单的野怪刷一下，这个野怪上下无任何装备，没有一点防御。也就是说，这个XSS 漏洞对于用户的输入，不做任何过滤行为。</p>
<p>一般来说，XSS 存在的地方，一定是需要有输入和输出概念的，一般的过滤规则，也是出现在输入阶段或者是输出阶段，如果两个都没有过滤，那么很轻松的就造成了漏洞。通常来说，这种洞非常好刷，比较自动化的方式是，建立一个爬虫系统，预设一些URL，爬虫爬取网页，在网页源码中寻找用户可以输入的地方，然后在可以输入的地方，将构造好的XSS 代码以输入形式，构造成请求，然后观察响应，是否对我们的输入做了过滤策略。如果是原本的返回，那么我们就说可能存在有xss漏洞。</p>
<p>同时，有另一种更为简单的漏洞，是直接在URL 中，如果有直接赋值参数的行为，也相当于一个可输入的位置，我们直接在URL 中将XSS 代码构造在URL 中，观察返回是否做了过滤处理，如果没有，那么就是一个最简单的野怪诞生。</p>
<p>在乌云中，有不少这样的漏洞，小站很多，大站很少，因为大站一般都有完备的过滤规则，很难在这些小问题上有任何闪失，再加上如今浏览器基本上都有安全策略对此类型进行防御，所以这种威力相对较小。</p>
<p>之前在HTTP 的文章里，有详细讲过 URL的格式，其基本格式如此：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622667602815.jpg" alt=""></p>
<p>每个结构对应的含义如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<p>通常的注入发生在query 这一块，而一般一个安全的行为，就是对query 中的字符进行过滤，以防止xss。以百度的URL 为例，一个通常的URL 查询之后的造型是下面这样的：</p>
<p><a href="http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969" target="_blank" rel="external">http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969</a></p>
<p>问号之后有一大堆参数，&amp;用来分割参数，他们对应的是什么意思不是本文关注的重点，可以参见这一篇文章<a href="http://www.biaodianfu.com/baidu-url-secret.html" target="_blank" rel="external">百度搜索URL 参数解析</a>。</p>
<p>其中wd 就是我们所说的搜索关键词，也就是我们的输入，如果我们将此字符改成</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>在输出时我们看到，URL 变成了如下，可疑的部分被转义了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.baidu.com/s?wd=%22%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&rsv_spt=1&rsv_iqid=0xb3f5d3380002c15f&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&oq=%26lt%3Bscript%26gt%3Balert(%26%2339%3Bxss%26%2339%3B)%26lt%3B%2Fscript%26gt%3B&rsv_t=455e8xS9GVGwfM%2BTxjkNH6uUohEOPZHQFWlqocmOh9s1caJr5IHzVrPJJKJ1OwdTglc3&inputT=5478&rsv_sug3=27&rsv_sug1=21&rsv_sug7=100&rsv_pq=cce2beda0002a800&rsv_sug2=0&rsv_sug4=6278</span></div></pre></td></tr></table></figure>

<p>在这里举一个大站腾讯的简单的xss，是乌云上某马甲提交的，作为一个最简单的XSS 挖给大家学习。网站的网址是这样的：<br><strong><a href="http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886" target="_blank" rel="external">http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886</a></strong></p>
<p>如果我们在这个URL 里尝试修改参数，将score 参数改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>

<p>而输出的源码并没有发生变化：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673299696.jpg" alt=""></p>
<p>在网易中看到的结果就变成了这样：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673544485.jpg" alt=""></p>
<p>这很显然，就是一个xss漏洞了，将经典的xss 代码插入进去即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score=<span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">1</span> <span class="attribute">onerror</span>=<span class="value">alert(1);</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622674130351.jpg" alt=""></p>
<p>这就是一个最无防御的XSS 存在，很明显的，它简单，暴力，当然也是极容易防御的，所以在一个较高级的攻防对抗，或者是大站漏洞中，基本上不会出现这样的漏洞（然而腾讯还是有这样的问题~~）。</p>
<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 onXXXX=”在这里” &gt; 或者是放在伪URL 里，比如&lt; a href = “javascript:在这里”&gt; xxxx 。</p>
<p>一般这样地方的参数，很少是直接通过输入就直接放进去的，不过有时候常常是接受了用户的输入，最后输出的时候，会出现在这些位置，但如果对用户的输入没有做详尽的处理和过滤的话，就会出现明显的XSS 漏洞。来个栗子：</p>
<p>比如某网站是这样的：</p>
<p><a href="http://example.com/search.php?word=helloworld" target="_blank" rel="external">http://example.com/search.php?word=helloworld</a></p>
<p>对应在HTML 代码中，他出现在了这样的区域里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>开发者没有对helloworld进行过滤的话，我们直接构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">word=helloworld<span class="string">" onclick="</span>alert(<span class="regexp">/xss/</span>)</div></pre></td></tr></table></figure>

<p>然后在对引号括号等，使用URL 编码，直接变成如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld%22+onclick%3d%22alert(%2fxss%2f)</div></pre></td></tr></table></figure>

<p>也就完成了xss过程，不过这种漏洞现在已经非常稀少，因为它太容易过滤了，只需要将双引号过滤即可，一般做法就是将双引号过滤成HTML 实体编码，也就是&#quot; 对于HTML 解析器，它能够识别在文本节点和参数值里边的实体编码，并且在内存中创建文档树的表现形式时，透明的对这些编码进行解码。所以，在创建DOM 树结构的时候，&amp;quot(有个分号，但是markdown会直接转了); 还没有被解码成引号，而且创建文档树的内容的时，才会考虑解码，而这时，其XSS 功效已经不能发挥作用了。</p>
<p>于是，对于有过滤规则的情况下，该标签将变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld&quot; onclick=&quot;alert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>但是，仅仅是这样的过滤，显然是不够用的，还有其他的注入点可以进，继续在乌云上来看腾讯的例子，考虑这样一个网址：<br><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>我们查看输出的HTML 源码，发现bg 那里对应的是background-color,我们尝试那里用不同的字符尝试，观察其过滤情况。在这里，我让bg = “\&lt;&gt;() 就是希望观察一下它的过滤情况，基本上所有的字符都被过滤了，但是只有\ 没有被过滤<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625007746187.jpg" alt=""></p>
<p>如何只用 \ 构造利用语句呢，我们可以想到CSS 中的字符编码，CSS 提供了一套转义处理策略，一个反斜杠后边跟1~6位十六进制数字。然后利用CSS 的expression 来调用JavaScript 代码。也就是试图构造出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expression(eval(alert(/xss/))</div></pre></td></tr></table></figure>

<p>这样的代码，完整来说，就是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">style</span>=<span class="value">"... background-color:;width:expression(eval(alert(/xss/)))"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用分号来结束backgroud-color,然后 w: 后边跟上expression,如果expression 要被过滤，那就加上转义，把expression 随意变下形就可以，于是，在下边这样的代码构造下，漏洞又被利用了。</p>
<p><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>不过很遗憾的，expression 当年是微软搞出来的技术，但是一直没被其他浏览器接受，同时，甚至微软自己如今也抛弃了这种特性，它出现在IE6，IE7，和IE8的一些早期版本，因为微软官方也认为该属性不具有通用性，而且它处理的事务，如今已经能够在CSS 中正常的完成，如min-width,max-width， 这些都已经在IE8之后得到很好的支持，所以expression 也只能在这两个古老版本上起效。</p>
<p>那么，继续考虑一些别的情况，考虑下面这个网站：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa</a></p>
<p>其输出的HTML 代码中，我们可以找到它：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625022573118.jpg" alt=""></p>
<p>对于放在javascript: 中的伪URL，其效果和放在script 代码块中没有区别。在这里 aaaaaa我们可以考虑对其做点什么，很自然的，我们想到用单引号闭合，然后后边加上alert(/xss/) 这样的构造，看起来比较绕，其构造步骤是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">'...&searchvalue=aaaaaa'</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa'</span>+alert(<span class="number">1</span>)+<span class="string">''</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa&#x27;+alert(1)+&#x27;'</span></div></pre></td></tr></table></figure>

<p>如果单引号，被过滤，就要改成HTML 编码，这样，就能在源代码中javascript 伪URL那里添加了alert(1) 这样的XSS。这步骤改造完毕之后，我们将可能被过滤的&amp;-&gt; %26,#-&gt;%23 转换成URL 编码，构造成这样的URL：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27</a>;</p>
<p>至此，又完成了一次XSS 注入，但到此处，是否有一个疑问呢，还是关于编码解析的问题。在上一个栗子中，我们说，将双引号，改成&amp;quot ; 这样的形式，就不会出现异常的解析了，但是这里，我们主动的将单引号改成了&amp;#27 ; 这样的形式，反而成功的完成了XSS 呢。</p>
<p>其实，这是一个解析顺序的原因，正常的解析顺序是这样的，先对URL解码，那些用URL 编码的字符都变成解码后的参数传出去，然后是HTML 解析，HTML 解析，此时 ，是先构建DOM文档结构，然后才会对每一个文本节点，属性值内容进行解析，这时候，HTML 实体编码的部分，才会还原回来，这个时候已经不会对DOM 结构造成影响了。然后是JS 解析，此时才会执行JS 代码的内容。而此时，HTML 已经完成了解码。</p>
<p>对应上边的栗子，在JS 解析之前，HTML 已经对那些编码完成了解码，对于JS 来说，一切都写的清清楚楚的了。</p>
<p>回到那个栗子，我们利用的代码，原样是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"pagenum"</span>  <span class="attribute">class</span>=<span class="value">"inputstyle0814"</span>  <span class="attribute">onkeydown</span>=<span class="value">"if ((event.keyCode==13) && (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&searchtype_yjbg=yjjg&searchvalue_yjbg=aaaaaaaaaa'"</span>/&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></div></pre></td></tr></table></figure>

<p>当我们构造完成利用代码之后，对于页面上来说，就是要点击按钮，也就是onkeydown。 不仅要将URL 传出去，还需要用户点击按钮，这样造成的威胁小很多，不如img 标签里的onerror ，onload那样可以自动触发。</p>
<p>最后我们再考虑一下如何防守吧，上上栗子的问题，在于漏掉了斜杠的过滤，那么\ 该过滤还是要过滤的。对于上边这个栗子，可以考虑二次过滤，也就是将&amp;都过滤为 &amp;amp ;，这样不仅过滤了无编码的单引号等格式，又可以过滤掉利用实体编码想要逃过的实体编码格式。而如果只是用正则去片段&amp;#xNN..等形式，实际上是不一定搞定所有的HTML 编码形式的。</p>
<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义，加一个斜杠。但此时忽略了编码的神奇。如果开发者在设置编码支持的时候，如果选择了GBK，gb18030,utf-8 等方式，实际上是支持十六位编码的。</p>
<p>最常见的方式，也就是在url里，在引号%27 或者是 %22 之前，加入%df, 由于0xdf 对应的大于128，所以，解析器会认为他和后边的组成了16位的编码，就会吃掉后边的字符，而后边跟着的字符，又恰恰是我们给引号添加的斜杠，%5c,于是%df 就会吃掉%5c 合并成一个字，引号重新暴露。</p>
<p>这种方法在XSS 不常见，但是如果某些XSS 在写过滤规则的时候，如果处理不当，还是有可能出现宽字节注入的情况，考虑如下url:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&t=%22;alert(1);//aaaaaa</div></pre></td></tr></table></figure>

<p>此处双引号被过滤了，变成了&amp;quot ;，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628903722866.jpg" alt=""></p>
<p>如果我们尝试一下采用宽字节注入，考虑构造成如图所示：<br>zh_CN&amp;t=%c0%22;alert(1);</p>
<p>令人惊奇的是，这次注入成功了，观察代码如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628904952071.jpg" alt=""></p>
<p>当然，此处所遇到的问题，应该并不是前边提到的传统的形式，%c0 吃掉%5c ,因为很明显，此处没有使用斜杠转义，而是转成了&amp;quot ; 只能把原因归咎于正则表达式处理的问题。</p>
<p>我们看到，即使当以注意到了问题所在的时候，仍然可能犯错误，而且是以意想不到的方式犯错，黑客渗透的方式，可能会以所有意想不到的形式进行。</p>
<p>我们将防御性代码比做成安全的城墙，那么正则过滤引擎，应该是这座安全长城的第一站，而在《Web 之困》 一书中，作者也说过，要想试图过滤掉所有的危险的编码，这几乎是不可能完成的任务。但作为开发者，比黑客再多想一些，这是应该的。</p>
<p>在XSS 界，拥有各种各样的形式去变形构造，在owasp 里，这篇<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="external">XSS Filter Evasion Cheat Sheet</a> 详细介绍了各种变形，以期能穷尽目前已知的各种变形手段，下次，我会对其中的变性手段，进行总结。但是，你想要过滤这所有的变形手段，几乎是不可能的，即使你过滤了他们，而引擎本身出现的错误，又会创造新的漏洞，上述例子就是这样的。</p>
<h1 id="被忽略的反斜线">被忽略的反斜线</h1>
<p>通常，过滤XSS 就是要考虑过滤各种特殊的控制字符，比如尖括号，引号等，而如果过滤一旦漏过了某些符号，那就有可能通过各种转义，构造出一个绕过的XSS，下面就是一个例子。</p>
<p>看这样一个网站：<br><a href="http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=aaa&amp;from=bbb&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1" target="_blank" rel="external">http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=aaa&amp;from=bbb&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1</a></p>
<p>杂乱无章，我们对照网页的源码，逐个尝试看能够注入，首先是先定位这些变量对应的位置，主要关注的还是前三个，vt=pass, ss=aaa, form=bbb, 构造完成之后我们在源码中寻找他们的位置如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632350242002.jpg" alt=""></p>
<p>定位到位置之后，我们把这一堆能使用的符号都拉进去尝试，包括引号，破折号，反斜杠等，这里如果能直接利用，最好是有双引号，它可以直接闭合前边的语法，从而构造新的语法，但是，很遗憾双引号这种头号仇恨还是第一时间被过滤了，但是漏过了反斜杠。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632351345985.jpg" alt=""></p>
<p>我们详细分析一下这一部分，考虑一下，看怎么注入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"/cgi-bin/loginpage?autologin=n&errtype=1&verify=&clientuin="</span>+<span class="string">"&t="</span>+<span class="string">"&alias="</span>+<span class="string">"&regalias="</span>+<span class="string">"&delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%252Fcgi-bin%252Fsetting10%253Faction%253Dlist%2526t%253Dsetting10%2526ss%253Dindex%2526Mtype%253D1%2526clickpos%253D20%2526loc%253Ddelegate%252Cwebmap%252C%252C1"</span>+<span class="string">"&title="</span>+<span class="string">"&url=%2Fcgi-bin%2Flogin%3Fvt%3Dpassport%26ss%3Daaa%2522%26from%3Dbbb%5C%26delegate_url%3D%252Fcgi-bin%252Fframe_html%253Furl%253D%2525252Fcgi-bin%2525252Fsetting10%2525253Faction%2525253Dlist%25252526t%2525253Dsetting10%25252526ss%2525253Dindex%25252526Mtype%2525253D1%25252526clickpos%2525253D20%25252526loc%2525253Ddelegate%2525252Cwebmap%2525252C%2525252C1"</span>+<span class="string">"&org_fun="</span>+<span class="string">"&aliastype="</span>+<span class="string">"&ss=aaa"</span>+<span class="string">"&from=bbb"</span>+<span class="string">"&param="</span>+<span class="string">"&sp=6fa57ce5b3047ebMTM1NTQwOTA2Mg"</span>+<span class="string">"&r=3ec785174fff5206ed6f0cf4a8c5e3c5"</span>+<span class="string">"&ppp="</span>+<span class="string">"&secpp="</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>核心部分，就是下边那小部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"......"</span>+<span class="string">"&ss=aaa"</span>+<span class="string">"&from=bbb"</span>+<span class="string">"&param="</span>+<span class="string">"....."</span>;</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如果我们使用了反斜杠，那么双引号就被转义了，语法就变化了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">getTop().location.href=<span class="string">"......"</span>+ <span class="string">"&ss=aaa\"+"</span> &from=bbb <span class="string">"+"</span> &param= <span class="string">"+"</span> .....<span class="string">";</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>有一点点机会突破，但是后边的语法就太奇怪了，有语法错误了。肿么办，我们在试试正斜杠，发现也没有被屏蔽，perfect，我们用正斜杠来讲后边直接注释掉，让语法正常。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from=<span class="number">1</span><span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>但是还有一个问题，&amp; 在这里，被考虑成了一个与操作，优先级是高于 =号的，变成了(“字符串”&amp;from)=1 的语法，这仍然是错误的。但是，如果我们再测试一下，= 号会不会被屏蔽呢，=号也可以用，那么我们改变一下语法，添加一个等号，变成 ==：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span><span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>于是语法编程了(“string”)&amp;(from==1)的样式，from 变成了一个bool操作，但现在又面临了新的问题，如果你在URL 里本来该是一个定义的操作，却变成了一个判断的操作，from 就变成了未定义的状态了，语法仍然会报错，这我们就要进一步理解JavaScript的语法了，如果我们把from 当做一个变量或者是方法，如果是方法，无论在何处定义，都会被拉到最简便，所以我们在from 的部分再添加一个步骤：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">from</span><span class="params">()</span></span>{}<span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>这样，from 就不会被当成是未定义的了，但问题又来了，我们现在添加了许多东西，而添加的这些东西，包含了许多特殊字符，会不会通过呢，经过实际测试，还真是悲剧了，空格符被转义了：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-14-14632360553284.jpg" alt=""></p>
<p>空格符被转义了怎么办呢，我们找到新的替换品，那就是/**/, 这是一个注释符，之前我们也测试过了，斜杠不会被过滤，那么这个注释符，成功的顶替了空格，形成了正常的语法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">"........."</span>+<span class="string">"&ss=aaaa\"+"</span>&from==<span class="number">1</span>;<span class="function"><span class="keyword">function</span>/**/<span class="title">from</span><span class="params">()</span></span>{}<span class="comment">//"+"&param=";</span></div></pre></td></tr></table></figure>

<p>从语法上看，这样就OK 了，我们的攻击代码可以放function 的前边，直接用alert(/xss/)；测试，最终代码：<br><a href="http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=\&amp;from==0;alert(1);function/**/from(){};//&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1" target="_blank" rel="external">http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=\&amp;from==0;alert(1);function/**/from(){};//&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi-bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526clickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1</a></p>
<p>结果毫无疑问弹了窗。</p>
<p>那么回到源头去搜索整个注入的过程，我们发现，注入的过程，颇有几分SQL 的风采，都是利用各种语法上的技巧，在我们的SQL注入中，一些常见的技巧，比如基于重言式，这和XSS 的试图闭合语法相似，比如联合查询法，试图借助未转义的字符，来完成注入。</p>
<p>这个漏洞的挖掘过程，就是从一个狭小的入口进入，借助了字符过滤不完整的漏洞，挖开了深层的内容。所以，在实际编程开发中，对特殊字符的控制，是需要慎之又慎的，一旦有一个小小的漏洞，就会被随时攻破。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内容隔离逻辑 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/11/%E5%86%85%E5%AE%B9%E9%9A%94%E7%A6%BB%E9%80%BB%E8%BE%91-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/11/内容隔离逻辑-《The-Tangled-Web》/</id>
    <published>2016-05-11T08:48:45.000Z</published>
    <updated>2016-05-11T08:52:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="内容隔离逻辑">内容隔离逻辑</h1>
<p>在最开始，阐述浏览器安全的时候，我们提到了浏览器的隔离措施，虽然浏览器试图通过内容隔离逻辑，来保证不同源的文件之间访问的控制，但是这样的策略仍然是非完全安全的，从这一部分开始，我们就开始探讨关于Web应用，特别是浏览器的各种安全特性。</p>
<h2 id="DOM_同源策略">DOM 同源策略</h2>
<p>同源策略Same-Origin Policy 其实规则非常直接：<strong>除非JavaScript所处的两个页面的协议，DNS域名，端口完全一致，否则两个独立的JavaScript运行环境不能访问彼此的DOM</strong>，其他任何跨域文档JavaScript DOM 访问都会失败。</p>
<p>这个同源策略看起来非常易于理解，但其中包含的问题也不少。</p>
<p>首先是DNS，这里的问题是，浏览器在判断同源的时候，只对DNS域名进行判断，而非IP地址，假如某个特定主机的IP地址发生了变化，就有可能造成漏洞产生，这种攻击行为叫做DNS 重绑定攻击。</p>
<p>我们再看这个URL，浏览器代码里包含有多套独立的URL 解析处理，如果HTTP 堆栈里对源的解析和JavaScript对源的判断产生了误差，就可能导致问题。在各种浏览器中，有可能产生不少由于URL 刻意变形导致的SOP 绕过漏洞。</p>
<p>同时对于IE浏览器早期版本，甚至在做同源检查的时候，可能会忽略端口，后果可想而知。</p>
<p>同源策略在一开始只是针对DOM 的，但是后来这个策略逐渐扩散到了保护从JavaScript的根对象开始的其他敏感数据。不过<strong>非同源的脚本还是可以这任意窗口或者框架使用location.assign(), location.replace()</strong></p>
<p>同时，同源策略还存在一些障碍，比如无法隔离本来属于两个用户的网页（因为无法给每个用户单独分配域名），另一种情况，这个策略也会使得原本合法的同站点域名不能无缝交换数据。比如login.exp.com 和 payment.exp.com。当然，修复的方法广泛支持的是document.domain 和 postMessage()。</p>
<p><strong>document.domain</strong></p>
<p>javaScript 通过设置document.domain 来覆盖同源检查策略中的主机名匹配，不过只是允许具有相同顶级域名，比如exp.com 甚至是 .com。赋值形式如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">"exp.com"</span></div></pre></td></tr></table></figure>

<p>但需要注意的是，一个设置了document.domain 的页面是不能访问一个没有设置的页面，这样有可能造成本来是同源的页面，反而变成了隔离，虽然有时候有人试图使用这条规则，或者是给两个同源页面设置不同的document.domain，但实际上这种伪隔离域仍然支持对另一个设定进行 javascript:URL 跳转动作。</p>
<p>另外，由于场景不清晰，本来只是打算让两个页面同源，但此时会招来另一个页面，通过设置domain 一样能够同源，这样，实际上就是告诉我们，设置domain,实际上是将整个域的安全，交给了整个域中最不安全的那一个了。</p>
<p><strong>postMessage(…)</strong></p>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>postMessage(data,origin)方法接受两个参数:</p>
<ol>
<li>data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</li>
<li>origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ol>
<p>考虑一下场景，在payments.exp.com 的根路径 下有两个页面，需要把用户登录信息显示在该页面上。为达到这个目的，payments.exp.com 这个页面加载一个纸箱login.exp.com 的子框架。这个子框架发送以下指令：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parent.postMessage(<span class="string">"user=bob"</span>, <span class="string">"https://payment.exp.com"</span>)</div></pre></td></tr></table></figure>

<p>只有当payment.exp.com 确认是指定的信任源，浏览器才会发送postMessage 消息出于根路径下的接收方也需要确认消息的正确性，这样就确保了整个机制的健壮。</p>
<p><strong>与浏览器身份验证的交互</strong></p>
<p>在了解完DOM 相关的同源策略后，我们应当记住<strong>同源策略无法和全局身份认证，SSL 状态，网络上下文环境，以及众多浏览器管理涉及安全的其他参数同步</strong>。这里有一个很绕的例子：</p>
<p>某站点的登陆表单有CSRF 的漏洞，攻击者首先在框架里嵌入目标此网站上的一个敏感页面，然后诱使受害者登录到该站一个由攻击者控制的账号里，然后执行目标网站其他应用上的跨站攻击。进入HTTP 的身份验证信息已经改变了，但是后一个步骤里的代码注入却会对之前加载的子框架具有完全的访问权限，也会导致数据被窃取。这是一个很绕的攻击过程，不过不难理解，正是由于DOM 的同源和这些身份认证，状态等信息无法同步的原因造成的。</p>
<h2 id="XMLHttpRequest_同源策略">XMLHttpRequest 同源策略</h2>
<p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
<li>所有现代的浏览器都支持 XMLHttpRequest 对象。</li>
</ul>
<p>而这个机制的关键是他会用到浏览器的HTTP 堆栈及其组件，包括全局身份认证，缓存机制，持续会话等。XMLHttpRequest 的同源机制，和浏览器的默认同源机制差不多，不过因一点点不同，比如XMLHttpRequest.open（）里设定的目标URL 地址必须与发起的页面完全同源。</p>
<p>用户对于发送的请求头域有绝对的控制，其优点就是，通过插入一些自定义的请求头，可以确认特定的请求来源。但是问题就是<strong>插入某些请求头则可能对目标服务器端或者代理服务器的解析产生影响</strong>，比如设定错误的Content-Length 可能导致攻击者在原该浏览器维护的HTTP 持续会话里偷偷加入第二个请求。</p>
<p>考虑下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">x.open(<span class="string">"POST"</span>, <span class="string">"http://www.exp.com"</span>,<span class="literal">false</span>);</div><div class="line"><span class="comment">// 下边会替换掉自动记录出来的长度</span></div><div class="line">x.setRequestHeader(<span class="string">"Content-Length"</span>, <span class="string">"7"</span>);</div><div class="line"><span class="comment">// 当长度超过之后，会截断，剩下的，会被认为是第二个独立的请求。</span></div><div class="line">x.send(</div><div class="line">    <span class="string">"Gotcha!\n"</span>+</div><div class="line">    <span class="string">"GET /evil.html HTTP/1.1\n"</span>+</div><div class="line">    <span class="string">"HOST: www.unnyoulet.com\n\n"</span></div></pre></td></tr></table></figure>

<p>一般，面对这种风险的方式，就是，设置一个黑名单，比如Content-Length, Host, Referer ，而对譬如User-Agent,Cookie, Origin ， If-Modified-Since 的处理却各有不同。</p>
<h2 id="Web_Storage_同源">Web Storage 同源</h2>
<p>Web Storage 是浏览器中实现的一个简单的数据存储功能，目前有两个JavaScript对象， localStorage , sessionStorage。前者是可以进行持久存储的，后者则是绑定当前浏览器，提供临时的缓存机制。</p>
<h2 id="Cookie_安全策略">Cookie 安全策略</h2>
<p>Cookie 的默认有效范围是域名，但是并没有办法吧Cookie 范围限制在单个主机名上，可以吧Cookie 里的Domain 设置为当前主机名上，但实际上访问该主机名的子域名，也会认为是有效的。</p>
<p>所以就形成了一个有意思的现象，当我们完全不设置domain 的时候，反而在某些浏览器上会将Cookie 的范围局限在主机名之内，但对IE 来说确实无效的。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-11-14629533767415.jpg" alt=""></p>
<p>那么如何有效的设置范围呢，cookie 中使用的是path. 只有请求的路径与cookie 的path 参数吻合，才会发送cookie。</p>
<p>但实际上，无论cookie 如何设定，对于同源策略来说，是不会检查URL 路径的，JS 代码还是可以随意访问同意主机上的不同URL，那么cookie 的path实际上不能作为有效的安全边界。</p>
<p>另外还有两个标记，分别是httponly，secure 。前者通过设置，可以禁止document.cookie 访问页面的cookie, 后者则要求cookie 不能用于非加密通道。</p>
<p>这么看起来稳妥了很多，然而还是有问题的，<strong>因为这可以防止数据不被读取，但是无法防止不被覆盖</strong>，通过js代码，我们可以使某域名对应的Cookie 池发生溢出，然后设置新的不带secure 的cookie 。对此的解决办法是，将cookie 池内容隔离，分为Httponly cookie 和普通的cookie,但是如果cookie 允许名字相同，在碰到匹配请求的时候，这些cookie 会被浏览器一起发送。</p>
<p>如此，我们可以看到，cookie和同源机制实际上是会相互影响到的，比如前边提到的同源机制影响了cookie 的路径范围机制，而另一方面讲，cookie 更加严重的影响了同源策略，因为cookie 经常被用作身份认证信息，如果cookie信息被获取，就相当于绕过了同源策略。</p>
<p><strong>域名限制的问题</strong></p>
<p>由于Cookie 的有效范围设置，容易造成安全问题，那么避免cookie 的域名错误，就是需要解决的问题。目前支持的方法是，数点号的个数。一般化的要求是，<strong>只有处于具体域名的主机名范围内，才能设置该域名对应的Cookie, 这个域名包括至少2个或3个点号，才能避免出现诸如.com .edu vas.us 这样的形式</strong>，特别的，对于域名属于7种特定格式的定居于明，那么需要包含2个点，除此之外则是3个点，但问题在于域名设置各式各样，比如有.com， .com.cn 但还可以直接.cn ，所以浏览器们基本上都是使用了各自的的过滤方法来处理，但是，如今域名的形式越来越多，相信cookie 的这一机制也面临各种挑战。</p>
<p><strong>Cookie 与 合法DNS 劫持</strong></p>
<p>这个实际上在中国非常广泛，运营社对于不存在的域名，会返回其广告页。那如果这个看起来非常破的广告页，如果存在漏洞，那么利用漏洞，可以获得任意域的上下文环境执行权限。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>对全部站点都要使用可靠地安全策略，为保护用户，应该在最顶层的crossdomain.xml 文件设定permitted-cross-domain-policies 参数项为master-only 或者是by-content-type ，实际这个站点没有用的Flash,这样做可以组织由攻击者控制的无关内容被错误的当做另一个crossdomain.xml 文件，对同源策略产生影响。</li>
<li>当依赖HTTP cookies 来作身份验证时<ul>
<li>使用httponly 标签，不要让JavaScript 直接访问到身份授权的cookie 信息，对于敏感的cookie 的有效范围越小越好，或者是不设置domain。</li>
<li>如果应用基于https, 那么cookie 标记为secure， 同时防止cookie 被注入。</li>
</ul>
</li>
<li>处理JavaScript 跨域通信的时候<ul>
<li>不要是document.domain， 尽量使用postMessage(), 以此来确保目标源的设置是正确的，对于域名的判断不要直接使用简单的截断匹配方式: msg.origin.indexOf(“.exp.com”)</li>
<li>小心postMessage() 绕过的方法。</li>
</ul>
</li>
</ul>
<hr>
<p>内容隔离是浏览器为Web 安全竖起的一道长城，然而由于 Web 本身的种种特点，造成了这个长城有非常多的漏洞，能够让长城两端以各种形式自由出入，这里边，关于插件部分，被我跳过了，主要是因为这一块比较陌生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="内容隔离逻辑">内容隔离逻辑</h1>
<p>在最开始，阐述浏览器安全的时候，我们提到了浏览器的隔离措施，虽然浏览器试图通过内容隔离逻辑，来保证不同源的文件之间访问的控制，但是这样的策略仍然是非完全安全的，从这一部分开始，我们就开始探讨关于Web应用，特别是浏览器]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 4)离奇的宽字节 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/10/-level-4-%E7%A6%BB%E5%A5%87%E7%9A%84%E5%AE%BD%E5%AD%97%E8%8A%82-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/10/-level-4-离奇的宽字节-XSS升级之路/</id>
    <published>2016-05-10T14:56:51.000Z</published>
    <updated>2016-05-10T14:58:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义，加一个斜杠。但此时忽略了编码的神奇。如果开发者在设置编码支持的时候，如果选择了GBK，gb18030,utf-8 等方式，实际上是支持十六位编码的。</p>
<p>最常见的方式，也就是在url里，在引号%27 或者是 %22 之前，加入%df, 由于0xdf 对应的大于128，所以，解析器会认为他和后边的组成了16位的编码，就会吃掉后边的字符，而后边跟着的字符，又恰恰是我们给引号添加的斜杠，%5c,于是%df 就会吃掉%5c 合并成一个字，引号重新暴露。</p>
<p>这种方法在XSS 不常见，但是如果某些XSS 在写过滤规则的时候，如果处理不当，还是有可能出现宽字节注入的情况，考虑如下url:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&t=%22;alert(1);//aaaaaa</div></pre></td></tr></table></figure>

<p>此处双引号被过滤了，变成了&amp;quot ;，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628903722866.jpg" alt=""></p>
<p>如果我们尝试一下采用宽字节注入，考虑构造成如图所示：<br>zh_CN&amp;t=%c0%22;alert(1);</p>
<p>令人惊奇的是，这次注入成功了，观察代码如图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-10-14628904952071.jpg" alt=""></p>
<p>当然，此处所遇到的问题，应该并不是前边提到的传统的形式，%c0 吃掉%5c ,因为很明显，此处没有使用斜杠转义，而是转成了&amp;quot ; 只能把原因归咎于正则表达式处理的问题。</p>
<p>我们看到，即使当以注意到了问题所在的时候，仍然可能犯错误，而且是以意想不到的方式犯错，黑客渗透的方式，可能会以所有意想不到的形式进行。</p>
<p>我们将防御性代码比做成安全的城墙，那么正则过滤引擎，应该是这座安全长城的第一站，而在《Web 之困》 一书中，作者也说过，要想试图过滤掉所有的危险的编码，这几乎是不可能完成的任务。但作为开发者，比黑客再多想一些，这是应该的。</p>
<p>在XSS 界，拥有各种各样的形式去变形构造，在owasp 里，这篇<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="external">XSS Filter Evasion Cheat Sheet</a> 详细介绍了各种变形，以期能穷尽目前已知的各种变形手段，下次，我会对其中的变性手段，进行总结。但是，你想要过滤这所有的变形手段，几乎是不可能的，即使你过滤了他们，而引擎本身出现的错误，又会创造新的漏洞，上述例子就是这样的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_4_离奇的宽字节">level 4 离奇的宽字节</h1>
<p>搞过SQL 注入的，应该是比较了解宽字节注入的，由于某些SQL 注入的核心是提前出线单引号来闭合前边的输入，然后在后边可以插入别的语句，联合查询等等。所以比较一般的过滤方式是将单引号转义]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[平凡又神奇的贝叶斯方法]]></title>
    <link href="http://yoursite.com/2016/05/07/%E5%B9%B3%E5%87%A1%E5%8F%88%E7%A5%9E%E5%A5%87%E7%9A%84%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/07/平凡又神奇的贝叶斯方法/</id>
    <published>2016-05-07T14:22:03.000Z</published>
    <updated>2016-05-07T14:24:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地方在本质上串联到了一起，这里再发一遍，表示对刘未鹏大神的敬佩。</p>
<h2 id="转载自刘未鹏博客">转载自<a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external">刘未鹏博客</a></h2>
<p>概率论只不过是把常识用数学公式表达了出来。</p>
<p>——拉普拉斯</p>
<p>记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了——这果然是个牛逼的方法。</p>
<p>——题记</p>
<h1 id="前言">前言</h1>
<p>这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。</p>
<h1 id="历史">历史</h1>
<p>托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介：</p>
<blockquote>
<p>所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。</p>
</blockquote>
<p>实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），<strong>但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。</strong></p>
<h2 id="1-1_一个例子：自然语言的二义性">1.1 一个例子：自然语言的二义性</h2>
<p>下面举一个自然语言的不确定性的例子。当你看到这句话：</p>
<blockquote>
<p>The girl saw the boy with a telescope.</p>
</blockquote>
<p>你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。</p>
<h2 id="1-2_贝叶斯公式">1.2 贝叶斯公式</h2>
<p>贝叶斯公式是怎么来的？</p>
<p>我们还是使用 wikipedia 上的一个例子：</p>
<blockquote>
<p>一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p>
</blockquote>
<p>一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p>
<p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p>
<p>我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U <em> P(Boy) </em> P(Pants|Boy) 个穿长裤的（男生）（其中 P(Boy) 是男生的概率 = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl) 个穿长裤的，其中有 U <em> P(Girl) </em> P(Pants|Girl) 个女生。两者一比就是你要求的答案。</p>
<p>下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U <em> P(Girl) </em> P(Pants|Girl) / [U <em> P(Boy) </em> P(Pants|Boy) + U <em> P(Girl) </em> P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到</p>
<p><strong>P(Girl|Pants) = P(Girl) <em> P(Pants|Girl) / [P(Boy) </em> P(Pants|Boy) + P(Girl) * P(Pants|Girl)]</strong></p>
<p>注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。</p>
<p>上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是：</p>
<p><strong>P(B|A) = P(A|B) <em> P(B) / [P(A|B) </em> P(B) + P(A|~B) * P(~B) ]</strong></p>
<p>收缩起来就是：</p>
<p><strong>P(B|A) = P(AB) / P(A)</strong></p>
<p>其实这个就等于：</p>
<p><strong>P(B|A) * P(A) = P(AB)</strong></p>
<p>难怪拉普拉斯说概率论只是把常识用数学公式表达了出来。</p>
<p>然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。</p>
<h1 id="2-_拼写纠正">2. 拼写纠正</h1>
<p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文在这里，徐宥的翻译版在这里，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。</p>
<p>首先，我们需要询问的是：“问题是什么？”</p>
<p>问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求：</p>
<p><strong>P(我们猜测他想输入的单词 | 他实际输入的单词)</strong></p>
<p>这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是</p>
<p><strong>P(我们的猜测1 | 他实际输入的单词)</strong></p>
<p>可以抽象地记为：</p>
<p><strong>P(h1 | D)</strong></p>
<p>类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为：</p>
<p><strong>P(h | D)</strong></p>
<p>运用一次贝叶斯公式，我们得到：</p>
<p><strong>P(h | D) = P(h) * P(D | h) / P(D)</strong></p>
<p>对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道：</p>
<p>P(h | D) ∝ P(h) * P(D | h) （注：那个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。）</p>
<p>这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。</p>
<p>下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。</p>
<p><strong>一点注记：</strong>Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) <em> P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) </em> P(D | h) 了——虽然我们很可能使用了一些<a href="https://book.douban.com/subject/1599035/" target="_blank" rel="external">启发法来简化计算</a>。后面我们还会提到这样的 bottom-up 的关联提取。</p>
<h1 id="3-_模型比较与奥卡姆剃刀">3. 模型比较与奥卡姆剃刀</h1>
<h2 id="3-1_再访拼写纠正">3.1 再访拼写纠正</h2>
<p>介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“为什么？”为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？</p>
<p>为了回答这个问题，一个常见的思路就是想想：非得这样吗？因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？</p>
<p>不管怎样，一个最常见的替代方案就是，选择离 thew 的编辑距离最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。</p>
<p>而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。</p>
<p>以上只是最大似然的一个问题，即并不能提供决策的全部信息。</p>
<p>最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用样条来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。</p>
<p>以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据过配（overfitting）的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓奥卡姆剃刀精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。</p>
<p>过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？</p>
<h2 id="3-2_模型比较理论（Model_Comparasion）与贝叶斯奥卡姆剃刀（Bayesian_Occam’s_Razor）">3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</h2>
<p>实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过：</p>
<p>P(h | D) ∝ P(h) * P(D | h)</p>
<p>来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 beta 分布来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是概率密度函数）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。</p>
<p>以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。</p>
<p>然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点：</p>
<p>The girl saw the boy with a telescope.</p>
<p>到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？</p>
<p>我们不妨先来看看 MacKay 在书中举的一个漂亮的例子：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301108729.jpg" alt=""></p>
<p>图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626301200892.jpg" alt=""></p>
<p>很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？</p>
<p>用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！”</p>
<p>现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。</p>
<p>自然语言二义性很常见，譬如上文中的一句话：</p>
<blockquote>
<p>参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题</p>
</blockquote>
<p>就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？</p>
<p>注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。</p>
<p>这个就是所谓的<strong>贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）</strong>，因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。</p>
<p>这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。</p>
<h2 id="3-3_最小描述长度原则">3.3 最小描述长度原则</h2>
<p>贝叶斯模型比较理论与信息论有一个有趣的关联：</p>
<p><strong>P(h | D) ∝ P(h) * P(D | h)</strong></p>
<p>两边求对数，将右式的乘积变成相加：</p>
<p><strong>ln P(h | D) ∝ ln P(h) + ln P(D | h)</strong></p>
<p>显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。</p>
<p>而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节）</p>
<h2 id="3-4_最优贝叶斯推理">3.4 最优贝叶斯推理</h2>
<p>所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。</p>
<p>只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。</p>
<h1 id="4-_无处不在的贝叶斯">4. 无处不在的贝叶斯</h1>
<p>以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。</p>
<h2 id="4-1_中文分词">4.1 中文分词</h2>
<p>贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述，详细请参考吴军的文章（这里）。</p>
<p>分词问题的描述为：给定一个句子（字串），如：</p>
<p>南京市长江大桥</p>
<p>如何对这个句子进行分词（词串）才是最靠谱的。例如：</p>
<ol>
<li><p>南京市/长江大桥</p>
</li>
<li><p>南京/市长/江大桥</p>
</li>
</ol>
<p>这两个分词，到底哪个更靠谱呢？</p>
<p>我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得：</p>
<p><strong>P(Y|X) ∝ P(Y)*P(X|Y)</strong></p>
<p>用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串：</p>
<p><strong>W1, W2, W3, W4 ..</strong></p>
<p>的可能性呢？我们知道，根据联合概率的公式展开：P(W1, W2, W3, W4 ..) = P(W1) <em> P(W2|W1) </em> P(W3|W2, W1) <em> P(W4|W1,W2,W3) </em> .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) <em> P(W2|W1) </em> P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。</p>
<p><strong>一点注记：</strong>有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，高维诅咒就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，声称统计学习方法能够终结科学研究（原文）的说法是纯粹外行人说的话。</p>
<h2 id="4-2_统计机器翻译">4.2 统计机器翻译</h2>
<p>统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。</p>
<p>问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出：</p>
<p><strong>P(f|e) ∝ P(f) * P(e|f)</strong></p>
<p>这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如：</p>
<p><strong>John (Jean) loves (aime) Marie (Mary)</strong></p>
<p>就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算：</p>
<p>P(John|Jean) <em> P(loves|aime) </em> P(Marie|Mary)</p>
<p>即可。</p>
<p>然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。</p>
<p>一点注记：还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 HTM （Hierarchical Temporal Memory）模型正是使用了这个原则。）</p>
<h2 id="4-3_贝叶斯图像识别，Analysis_by_Synthesis">4.3 贝叶斯图像识别，Analysis by Synthesis</h2>
<p>贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303078774.jpg" alt=""></p>
<p>首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。</p>
<h2 id="4-4_EM_算法与基于模型的聚类">4.4  EM 算法与基于模型的聚类</h2>
<p>聚类是一种无指导的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303321261.jpg" alt=""></p>
<p>图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。</p>
<p>EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。</p>
<h2 id="4-5_最大似然与最小二乘">4.5 最大似然与最小二乘</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626303555126.jpg" alt=""></p>
<p>学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——回归可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。</p>
<p>一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。</p>
<p>我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。</p>
<p>现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是：</p>
<p><strong>P(h|D) ∝ P(h) * P(D|h)</strong></p>
<p>又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) <em> P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) </em> P(d2|h) <em> .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] </em> EXP[-(ΔY2)^2] <em> EXP[-(ΔY3)^2] </em> .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？</p>
<h1 id="5-_朴素贝叶斯方法">5. 朴素贝叶斯方法</h1>
<p>朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。</p>
<h2 id="5-1_贝叶斯垃圾邮件过滤器">5.1 贝叶斯垃圾邮件过滤器</h2>
<p>问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求：</p>
<p><strong>P(h+|D) = P(h+) * P(D|h+) / P(D)</strong></p>
<p><strong>P(h-|D) = P(h-) * P(D|h-) / P(D)</strong></p>
<p>其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？</p>
<p>我们将 P(d1,d2,..,dn|h+)  扩展为： P(d1|h+) <em> P(d2|d1, h+) </em> P(d3|d2,d1, h+) <em> .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) </em> P(d2|h+) <em> P(d3|h+) </em> .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) <em> P(d2|h+) </em> P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考这个条目，注意其中提到的其他资料。</p>
<p><strong>一点注记：</strong>这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。</p>
<h2 id="5-2_为什么朴素贝叶斯方法令人诧异地好——一个理论解释">5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释</h2>
<p>朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper 。</p>
<h1 id="6-_层级贝叶斯模型">6. 层级贝叶斯模型</h1>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304175931.jpg" alt=""></p>
<p>层级贝叶斯模型是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。</p>
<h2 id="6-1_隐马可夫模型（HMM）">6.1 隐马可夫模型（HMM）</h2>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-07-14626304453370.jpg" alt=""></p>
<p>吴军在数学之美系列里面介绍的隐马可夫模型（HMM）就是一个简单的层级贝叶斯模型：</p>
<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>
<p>吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..）</p>
<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…)</p>
<p>其中</p>
<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而 P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。</p>
<p>这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。</p>
<h1 id="7-_贝叶斯网络">7. 贝叶斯网络</h1>
<p>吴军已经对贝叶斯网络作了科普，请直接跳转到<a href="http://googlechinablog.com/2007/01/bayesian-networks.html" target="_blank" rel="external">这里</a>。更详细的理论参考所有机器学习的书上都有。</p>
<p>参考资料</p>
<p>一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。</p>
<p>部分书籍参考《机器学习与人工智能资源导引》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="平凡而又神奇的贝叶斯方法">平凡而又神奇的贝叶斯方法</h1>
<p>偶然又看到有人推荐刘未鹏《暗时间》这篇文章，几年前看这文章的时候，没接触机器学习，对其感触不是很深，就觉得对贝叶斯解释的非常到位。现在有一些数据挖掘基础之后，再看一遍，还是感觉收获巨大，把很多地]]>
    </summary>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非HTML类型文档的复仇以及插件 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/07/%E9%9D%9EHTML%E7%B1%BB%E5%9E%8B%E6%96%87%E6%A1%A3%E7%9A%84%E5%A4%8D%E4%BB%87%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/07/非HTML类型文档的复仇以及插件-《The-Tangled-Web》/</id>
    <published>2016-05-07T09:29:03.000Z</published>
    <updated>2016-05-07T09:29:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h2 id="纯文本文件">纯文本文件</h2>
<p>Content-Type: text/plain</p>
<p>除了IE，收到没有头域的HTTP/0.9 或者缺少Content-Type 的响应，默认是处理为纯文本文件，而IE会处理为HTML 文件。同时，大多数浏览器，对若干的MIME 类型，及其各种变种，text/CSS 都映射为纯文本文件，是为了方便开发人员，当然，JSON除外。</p>
<h2 id="位图图片">位图图片</h2>
<p>在缺少Content-Type 响应头的情况下，会有解析器去检测文档的头部信息，来判断类型。如果包含了Content-Type类型，那么先匹配到MIME 类型，如果无法解析，就会再检测文档头部信息，来确定类型。</p>
<p>而近期曝出的ImageMagick 的0day 漏洞，就是这样一个漏洞，漏洞发生在这款ImageMagick 的图像处理软件，它被广泛用来在网站上进行图像处理，其原理就是，用户上传图像，每个图像会有一个magic bytes，实际上就是文件头，用来表示图像类型，ImageMagick 的功能就是通过解析器，对文件头进行解析，然后进一步处理。</p>
<p>如果我们把一个含有恶意代码的文件保存为文件格式，交给ImageMagick 解析，正常是ImageMagick 无法解析的，当然漏洞就是不正常的时候了，参考如下代码：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">push graphic-context</div><div class="line"></div><div class="line">viewbox <span class="number">0</span> <span class="number">0</span> <span class="number">640</span> <span class="number">480</span></div><div class="line"></div><div class="line">fill ‘url(https:<span class="comment">//example.com/image.jpg“|ls “-la)’</span></div><div class="line"></div><div class="line">pop graphic-context</div></pre></td></tr></table></figure>

<p>将其保存为jpg 格式等，调用ImageMagick 去处理它，就会触发一个最常见的查看本地文件的漏洞，下面在说一下原因。</p>
<p>ImageMagick 在 MagickCore/constitute.c 的 ReadImage 函数中解析图片，如果图片地址是 https:// 开头的，即调用 InvokeDelegate。MagickCore/delegate.c 定义了委托。作为一个执行命令被引入的，但是，对参数的引入没有做好足够的过滤，造成了渗透的可能，比如一个默认命令是为了处理来自http 请求送来的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"wget"</span> -q -O <span class="string">"%o"</span> <span class="string">"https:%M"</span></div></pre></td></tr></table></figure>

<p>此处的%M 是真实的输入参数，如果他的值是这样的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`https://example.com<span class="string">";|ls "</span>-la`</div></pre></td></tr></table></figure>

<p>很显然，由于引号的奇怪闭合方式，这一块恰好满足了bash 的语法，通过一个通道符，我们继续调用了ls -la ，显然，这就引起了注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ convert <span class="string">'https://example.com";|ls "-la'</span> out.png</div><div class="line">total <span class="number">32</span></div><div class="line">drwxr-xr-x <span class="number">6</span> user group <span class="number">204</span> Apr <span class="number">29</span> <span class="number">23</span>:<span class="number">08</span> .</div><div class="line">drwxr-xr-x+ <span class="number">232</span> user group <span class="number">7888</span> Apr <span class="number">30</span> <span class="number">10</span>:<span class="number">37</span> ..</div></pre></td></tr></table></figure>

<p>这是基本的原因，实际上的利用漏洞过程通过上传文件，构造exploit, 上文中已经构造了一个文件，他的格式是按照mvg 格式，对于ImageMigick 存在这种漏洞的有两个格式，mvg,和svg,mvg 相对好构造一点。</p>
<p>更进一步的，通过构造exploit ，我们可以删除服务器文件，移动服务器文件，或者是读取服务器文件，其结果，你懂得。</p>
<p>具体参见这个漏洞专门成立的网站<a href="https://imagetragick.com/" target="_blank" rel="external">Imagetragick</a>, 如今在乌云上，借着这个漏洞，已经提交了无数个0day 漏洞了。</p>
<h2 id="音视频文件">音视频文件</h2>
<p>其细节内容，不做过多的深究，对于其安全隐患，也就是是否合理的消除类型错判带来的风险，和上边的图片处理有一点点相似。</p>
<p>另外，作者想了一个很有想象力的情况，如果<audio> 支持未压缩的原生音频播放，然后这个标签被指向了敏感的非音频文件，但是由于是处在这个标签下，还是会被当做原生的音频播放，虽然是混乱的声波。而在HTML5 之下，调用麦克风API，可以捕捉这些声波信息，通过这些声波信息，又重组了文件内容。OTZ…</audio></p>
<h2 id="XML_文件">XML 文件</h2>
<p>浏览器会根据收到的Content-Type 或一些其他线索，为集中特殊的XML 格式提供单一用途的XML 解析器。而绝大部分时候，和XHTML 同一个解析器。在XML 中，</p>
<ul>
<li>文档的实际含义取决于XML 文件中的xmlns 命名空间</li>
<li>xmlns 和 Content-Type 的值无关，按后者进行解析</li>
<li>可能有多个xmlns,对文档的每个段落赋予不同的含义</li>
</ul>
<h4 id="常规的XML_视图">常规的XML 视图</h4>
<p>如果没有能够识别的命名空间设定，那么浏览器会默认显示一种树状结构，如果有的话，就按照实际含义进行显示。</p>
<p>但由于这种需要显示未知用途和无法识别命名空间的XML 文档，会带来一定的容错，这种容错，可能导致XSS，比如代理未经过滤的RSS 订阅源，一般来说是有特定的解析器进行处理，但如果没有内置RSS 阅读功能的浏览器，可能会使用最常规的解析模式，而RSS 订阅源中可能存在有HTML 代码，造成XSS 漏洞。</p>
<h4 id="可缩放向量图片">可缩放向量图片</h4>
<p>这里所说的一般是SVG，在上一部分的那个例子里，已经探讨过SVG带来的灾难，一个常见的svg 表达方式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">&lt;![CDATA[</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">()</span> </span>{alert(<span class="string">"hello"</span>);}</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">circle</span> <span class="attribute">onclick</span>=<span class="value">"clicked()"</span> <span class="attribute">cx</span>=<span class="value">"50"</span> <span class="attribute">cy</span>=<span class="value">"50"</span> <span class="attribute">r</span>=<span class="value">"50"</span> <span class="attribute">fill</span>=<span class="value">"pink"</span> /&gt;</span><span class="tag">&lt;/<span class="title">svg</span>&gt;</span></div></pre></td></tr></table></figure>


<p>目前该特性已被绝大多数浏览器支持，这里的svg是完成了一个划出圆圈，同时在圆圈中点击会显示提示信息。</p>
<p>对于svg来说，这种格式的图片可以直接放在独立的XML 文档中被访问到，同时也可以放在第三方页面上用&lt; img&gt;引用到，而使用img的话，svg的脚本部分会被完全禁止掉，但是虽然会被禁止，但是还是有危险的，他所在的内置脚本仍然有可能获得图片所在域名的上下文环境权限并且执行，所以如果引入外部来源的svg,就一定要做好非常严谨的语法过滤，上文提到的ImageMagick 漏洞，就是因为在处理图片头的时候，没有做好过滤造成的。</p>
<p>除此之外，还有一些其他类型的文档，比如<strong>数学标记语言</strong>， <strong>XML用户界面语言</strong>， <strong>无线标记语言</strong>，<strong>RSS Atom订阅源</strong> 等等。</p>
<p>另外，还有一些不可显示的文件类型，如插件和扩展的安装清单列表，manifests,自动HTTP代理配置歘繁忙PAC，可安装的外观样式，整数撤销列表CRL，反恶意网站黑名单等等。</p>
<h3 id="安全工程">安全工程</h3>
<p>当需要处理的数据很可能被解析为XHTML 格式，或其他支持脚本的文档类型，不要只去根据Content-Type 响应头和最顶层的xmlns 指令来判断。同时不要再任意位置上允许出现可由用户控制的标记语言。</p>
<p>如果不需要直接访问该文件，可以在响应的响应头加上<strong>Content-Disposition:Attachment</strong>。</p>
<p>对于非HTML 类型文档，正确识别Content-Type响应头，同时正确设置字符集编码，也很重要。</p>
<h1 id="浏览器插件">浏览器插件</h1>
<p>浏览器插件林林总总，形态各异。简单来讲，一个常见的插件，是讲在浏览器中显示一种新型的文件格式，格式类似于HTML，浏览器得到后交给插件进行处理。</p>
<p>很容易可以想到，浏览器插件的安全漏洞，不仅多，而且千奇百怪，可以说针对Web 应用程序的攻击，与插件占有关系占了很大一部分。</p>
<p>对插件的调用通过几个显式的形式调用：</p>
<ul>
<li>标记 &lt; object data=…&gt; 这样的形式，或者是&lt; embed src=…&gt;.</li>
<li>type 参数，将type的参数的MIME 与浏览器里注册的有效插件的MIME类型做一个对比，如果匹配，就把它传给谍影的插件如理，如果没有匹配，理论上会出现窗口，提示用户下载，但某些时候，浏览器会根据Content-Type头域，或者URL 里文件后缀的方式猜测。</li>
<li>插件里的输入信息一般通过&lt; object&gt; 区块里嵌入&lt; param&gt; 标签来进行设置。</li>
</ul>
<p>这里我们要强调的是，在对插件Content-Type 处理时是存在风险的，若干插件实际上有自己完整的代码执行环境，而且这些可执行的应用在于他们所在源站点进行交互时拥有一系列的特权，就很容易出现CSRF 的跨站漏洞。比如已经被启用的&lt; applet&gt;标签，可用于加载java 小程序。GIFAR 漏洞在2008年诞生，就是用一个applet 中加载的java程序，偷偷的隐藏在一个GIF 图片中。</p>
<p><strong>插件的各种应用框架</strong></p>
<p>这其中藏着无数的坑待挖掘，这里只是个小引子~</p>
<ul>
<li>Flash ,不多说，如今越来越不受待见其中存在有严重的脚本注入等问题，如getURL() navigateToURL() 控制浏览器打开访问新窗口等等，他还拥有一些特殊技能，这些特殊技能都有着致命的危险：<ul>
<li>收集字体等系统识别特征</li>
<li>可以全屏，所以可以制作UI 欺诈</li>
<li>能得到麦克风和摄像头的数据</li>
<li>能忽略浏览器的安全和隐私设定，使用自己的安全设置进行数据持久化</li>
<li>默认情况下，可以直接使用浏览器的HTTP 堆栈及其管理的全局身份凭证信息。</li>
<li>可以和其他运行的Flash 交互</li>
<li>访问应用页的DOM 元素</li>
<li>FLash 自带内部简化版HTML 解析器，转义等等问题要注意</li>
<li>插件自身的设计问题等等等等等等等等等等</li>
</ul>
</li>
<li>Microsoft Sliverlight ,不懂，有机会接触的时候再详细理解吧。</li>
<li>Sun java,&lt; applet&gt; 已经因为严重的问题被抛弃了。</li>
<li>XML Browser Applications ，微软家的不怎么懂，同上上。</li>
<li>ActiveX Controls ,一度很火，如今几乎挂了，不过IE8之前，你懂得，黑客的天堂。</li>
</ul>
<h2 id="安全工程-1">安全工程</h2>
<p>提供需要让插件处理的文件时：</p>
<ul>
<li>对于来源信任的数据，还是应当避免处理用户提供的URL，也不要在小程序中产生或者试图修改用户控制的HTML。</li>
<li>对于用户控制的简单的多媒体，记得要验证文件格式，甚至是限制文件格式，使用正确的Content-Type 设置，同时要吸取各种前车之鉴，避免内容检测造成的漏洞。</li>
<li>用户控制的文档格式，虽然本质上是可以绝对安全，但是插件仍然有漏洞的可能，所以对于文档，两个解决办法，专用域名，单词有效的令牌，不要持久cookie.</li>
</ul>
<p>对于需要嵌入由插件处理的文件，无外乎就是确保type 参数明确，如果无法被识别的话，一定要做出各种限制，任何非信任站点来的东西，都不要随便接收，做好对设置的核查。</p>
<p>开发ActiveX 组件？放弃吧！</p>
<hr>
<p>由于对浏览器插件这一块不熟，而且感觉这里边有一些有趣的文章可以做，但作者又讲的很少，而且大多数是一些行将就木的过时插件的东西，所以这里我就简短的写了写。</p>
<p>至此，所有关于Web 的东西基本上结束了，回顾整个过程，我们会发现，在Web 中，存在的漏洞一方面是由于本身在协议阶段就存在不科学的地方，另一方面在浏览器等客户端在实现过程中，又由于各自为战，也存在有不统一和各自的缺陷存在，还有一个原因，就是开发者自己在开发中，并不懂自己写出来的代码会带来什么样的困扰，这大概是最可怕的，同时，由于客户端的真正操作者是对程序对代码一窍不通的人，在安全风险上，完全不能依赖他们去提供一点点的阻挡。</p>
<p>所以，一个真正想要构建安全环境的产品，是需要一个团队在整个流程里，能准确把握所有可能造成安全问题的隐患，用最稳妥的方式处理。渗透不可怕，可怕的是每次只有当渗透发生了之后，仅仅明白哪里出错，而不知道为什么会出错，为什么会被黑客抓住。</p>
<p>所以，真正的安全者，是对自己的产品每一块防护措施都了如指掌的人。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="非HTML类型文档的复仇以及插件">非HTML类型文档的复仇以及插件</h1>
<p>除了HTML文档，浏览器还可以识别其他若干的文件格式，而这些文件格式，在大多数情况风险比较低，但是在某些时候，会冒出致命的危险，接下来会说的一个最近刚刚曝出的漏洞。</p>
<h]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 3) HTML中的野怪 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/06/-level-3-HTML%E4%B8%AD%E7%9A%84%E9%87%8E%E6%80%AA-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/06/-level-3-HTML中的野怪-XSS升级之路/</id>
    <published>2016-05-06T03:25:54.000Z</published>
    <updated>2016-05-06T03:27:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 onXXXX=”在这里” &gt; 或者是放在伪URL 里，比如&lt; a href = “javascript:在这里”&gt; xxxx 。</p>
<p>一般这样地方的参数，很少是直接通过输入就直接放进去的，不过有时候常常是接受了用户的输入，最后输出的时候，会出现在这些位置，但如果对用户的输入没有做详尽的处理和过滤的话，就会出现明显的XSS 漏洞。来个栗子：</p>
<p>比如某网站是这样的：</p>
<p><a href="http://example.com/search.php?word=helloworld" target="_blank" rel="external">http://example.com/search.php?word=helloworld</a></p>
<p>对应在HTML 代码中，他出现在了这样的区域里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>开发者没有对helloworld进行过滤的话，我们直接构造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">word=helloworld<span class="string">" onclick="</span>alert(<span class="regexp">/xss/</span>)</div></pre></td></tr></table></figure>

<p>然后在对引号括号等，使用URL 编码，直接变成如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld%22+onclick%3d%22alert(%2fxss%2f)</div></pre></td></tr></table></figure>

<p>也就完成了xss过程，不过这种漏洞现在已经非常稀少，因为它太容易过滤了，只需要将双引号过滤即可，一般做法就是将双引号过滤成HTML 实体编码，也就是&#quot; 对于HTML 解析器，它能够识别在文本节点和参数值里边的实体编码，并且在内存中创建文档树的表现形式时，透明的对这些编码进行解码。所以，在创建DOM 树结构的时候，&amp;quot(有个分号，但是markdown会直接转了); 还没有被解码成引号，而且创建文档树的内容的时，才会考虑解码，而这时，其XSS 功效已经不能发挥作用了。</p>
<p>于是，对于有过滤规则的情况下，该标签将变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"helloworld&quot; onclick=&quot;alert(1)"</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>但是，仅仅是这样的过滤，显然是不够用的，还有其他的注入点可以进，继续在乌云上来看腾讯的例子，考虑这样一个网址：<br><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=FFFFFF&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>我们查看输出的HTML 源码，发现bg 那里对应的是background-color,我们尝试那里用不同的字符尝试，观察其过滤情况。在这里，我让bg = “\&lt;&gt;() 就是希望观察一下它的过滤情况，基本上所有的字符都被过滤了，但是只有\ 没有被过滤<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625007746187.jpg" alt=""></p>
<p>如何只用 \ 构造利用语句呢，我们可以想到CSS 中的字符编码，CSS 提供了一套转义处理策略，一个反斜杠后边跟1~6位十六进制数字。然后利用CSS 的expression 来调用JavaScript 代码。也就是试图构造出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expression(eval(alert(/xss/))</div></pre></td></tr></table></figure>

<p>这样的代码，完整来说，就是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">style</span>=<span class="value">"... background-color:;width:expression(eval(alert(/xss/)))"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用分号来结束backgroud-color,然后 w: 后边跟上expression,如果expression 要被过滤，那就加上转义，把expression 随意变下形就可以，于是，在下边这样的代码构造下，漏洞又被利用了。</p>
<p><a href="http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx" target="_blank" rel="external">http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\65ssion\28%20eval\28\27\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\64\6f\63\75\6d\65\6e\74\2e\63\6f\6f\6b\69\65\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\7d\27\29\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx</a></p>
<p>不过很遗憾的，expression 当年是微软搞出来的技术，但是一直没被其他浏览器接受，同时，甚至微软自己如今也抛弃了这种特性，它出现在IE6，IE7，和IE8的一些早期版本，因为微软官方也认为该属性不具有通用性，而且它处理的事务，如今已经能够在CSS 中正常的完成，如min-width,max-width， 这些都已经在IE8之后得到很好的支持，所以expression 也只能在这两个古老版本上起效。</p>
<p>那么，继续考虑一些别的情况，考虑下面这个网站：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa</a></p>
<p>其输出的HTML 代码中，我们可以找到它：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-06-14625022573118.jpg" alt=""></p>
<p>对于放在javascript: 中的伪URL，其效果和放在script 代码块中没有区别。在这里 aaaaaa我们可以考虑对其做点什么，很自然的，我们想到用单引号闭合，然后后边加上alert(/xss/) 这样的构造，看起来比较绕，其构造步骤是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location.href=<span class="string">'...&searchvalue=aaaaaa'</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa'</span>+alert(<span class="number">1</span>)+<span class="string">''</span></div><div class="line">location.href=<span class="string">'...&searchvalue=aaaa&#x27;+alert(1)+&#x27;'</span></div></pre></td></tr></table></figure>

<p>如果单引号，被过滤，就要改成HTML 编码，这样，就能在源代码中javascript 伪URL那里添加了alert(1) 这样的XSS。这步骤改造完毕之后，我们将可能被过滤的&amp;-&gt; %26,#-&gt;%23 转换成URL 编码，构造成这样的URL：<br><a href="http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27" target="_blank" rel="external">http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27</a>;</p>
<p>至此，又完成了一次XSS 注入，但到此处，是否有一个疑问呢，还是关于编码解析的问题。在上一个栗子中，我们说，将双引号，改成&amp;quot ; 这样的形式，就不会出现异常的解析了，但是这里，我们主动的将单引号改成了&amp;#27 ; 这样的形式，反而成功的完成了XSS 呢。</p>
<p>其实，这是一个解析顺序的原因，正常的解析顺序是这样的，先对URL解码，那些用URL 编码的字符都变成解码后的参数传出去，然后是HTML 解析，HTML 解析，此时 ，是先构建DOM文档结构，然后才会对每一个文本节点，属性值内容进行解析，这时候，HTML 实体编码的部分，才会还原回来，这个时候已经不会对DOM 结构造成影响了。然后是JS 解析，此时才会执行JS 代码的内容。而此时，HTML 已经完成了解码。</p>
<p>对应上边的栗子，在JS 解析之前，HTML 已经对那些编码完成了解码，对于JS 来说，一切都写的清清楚楚的了。</p>
<p>回到那个栗子，我们利用的代码，原样是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"pagenum"</span>  <span class="attribute">class</span>=<span class="value">"inputstyle0814"</span>  <span class="attribute">onkeydown</span>=<span class="value">"if ((event.keyCode==13) && (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&searchtype_yjbg=yjjg&searchvalue_yjbg=aaaaaaaaaa'"</span>/&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></div></pre></td></tr></table></figure>

<p>当我们构造完成利用代码之后，对于页面上来说，就是要点击按钮，也就是onkeydown。 不仅要将URL 传出去，还需要用户点击按钮，这样造成的威胁小很多，不如img 标签里的onerror ，onload那样可以自动触发。</p>
<p>最后我们再考虑一下如何防守吧，上上栗子的问题，在于漏掉了斜杠的过滤，那么\ 该过滤还是要过滤的。对于上边这个栗子，可以考虑二次过滤，也就是将&amp;都过滤为 &amp;amp ;，这样不仅过滤了无编码的单引号等格式，又可以过滤掉利用实体编码想要逃过的实体编码格式。而如果只是用正则去片段&amp;#xNN..等形式，实际上是不一定搞定所有的HTML 编码形式的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_3_HTML_中的野怪">level 3 HTML 中的野怪</h1>
<p>当然XSS 的漏洞不仅仅只出现在script 代码块中，还可以包含在丰富的HTML 的标签属性中。比如img,input 等一系列标签，基本格式是 &lt; HTML标签 o]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS和JavaScript的烦恼 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/05/CSS%E5%92%8CJavaScript%E7%9A%84%E7%83%A6%E6%81%BC-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/05/CSS和JavaScript的烦恼-《The-Tangled-Web》/</id>
    <published>2016-05-05T14:55:53.000Z</published>
    <updated>2016-05-05T14:56:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不重要，你随便打开一个网页，翻看一下源码，就会发现，满屏幕的div, 只起到了结构的作用，Tim Berners-Lee 的语义网梦想被CSS 阻挡，因为即使全屏的div，css 仍然能通过他五花八门的指令，伪类选择器，伪函数等等实现一个美观的网页。</p>
<p>当然，这里谈CSS， 并不是讲切图的，而是在CSS 里，同样存在着种种漏洞，主要是以XSS 为主的漏洞，所以对CSS 的探讨也在所难免。</p>
<h3 id="基本语法">基本语法</h3>
<p>一般使用方法有直接在&lt; style &gt;中使用，能够全局生效。或者通过&lt; link rel=stylesheet &gt; 引入外部的css 文件。或者是直接为某个标签赋予style参数。</p>
<p>选择器，包括复杂点的伪类选择器这里就不说了，只要稍微用过的人都知道，或者去W3C shcool也能看到详细的介绍。在CSS 的规则里，属性值是其最重要的东西，大约格式有三种：</p>
<ul>
<li><strong>原始文本</strong>：主要是用于设定一些数值型的值，RGB 向量，或者名字代指的原色等，以及一些预定好的关键词，比如 absolute, left, center等等</li>
<li><strong>引号括起来的字符串</strong> ： 当CSS 属性的值不是固定的关键词时，两边用单引号括起来，但是这条规则并不总是如此，比如设置字体，或者某些URL 时候，并不需要引号，而content 属性则需要。</li>
<li><strong>函数表示法</strong>： 有一些设计参数的伪函数，比如讲独立的のRGB 颜色转换成RGB代码的 rgb() , 以及一个大多数人都能用到的url(),同时还有一些比如scale(), rotate(), skew() 等等。<strong>特别的，IE浏览器中有一个函数expression(),可以在css 中嵌入JavaScript语句，这个函数一旦被黑客控制，后果可想而知。</strong></li>
</ul>
<p><strong>@指令和 XBL绑定</strong></p>
<p>除了上边所说的选择器，属性功能，CSS 还支持一种以@ 开头的格式，允许导入独立样式，同时能够改变样式表各种设定，比如指定命名空间，设定不同的显示媒体使用的不同的样式表（如今的跨设备就是如此)。</p>
<p>有两个重要的指令：</p>
<ul>
<li>@charset 用于设置当前CSS 区块的字符集格式</li>
<li>@import 在样式表中插入一个外部文件，@import “foo.css”; @import url(‘foo.css’); @import ‘foo.css’; 这几种表示格式是一样的。</li>
</ul>
<p>关于XBL 绑定，全称叫XML Binding Language，参见<a href="https://zh.wikipedia.org/wiki/XBL" target="_blank" rel="external">XBL维基百科</a>用于描述如何将其他文档中的元素（如XPCOM的功能）绑定到部件（如XUL部件）。可以使用级联样式表（CSS）或文档对象模型（DOM）两种方式绑定，绑定可为部件创建新的行为。绑定可以包含已注册到“被绑定元素”的事件处理程序，实现对“被绑定元素”的新的方法和属性访问，包括“被绑定元素”内的“匿名内容”。</p>
<p>该语言现在算是Mozilla 专有，FireFox 中的一个特性，利用 -moz-binding ，可以从外部源载入外部内容指令，可包括一些JavaScript代码。目前该使用方式并不明朗，当然看起来其中也有着不小的XSS 风险。</p>
<p>值得注意的是，上边提到的@import, url() 都存在有引入伪URL 的安全隐患，大多数浏览器都不接受CSS 的上下文环境使用脚本，但是IE 6 却支持，可以想象，IE6 还存在有大量漏洞，而在中国这片国土，IE 6仍然有不小的占有量。</p>
<p><strong>交互过程</strong></p>
<p>之前说，CSS 和HTML 是各自独立的，也就是说在执行过程中，会先解析HTML，然后解析CSS，但是，如果在CSS 属性里包含了某些HTML 语法，就会造成问题，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="tag">some_descriptor</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(<span class="string">'http://www.example.com/</span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span><span class="tag">&lt;<span class="title">h1</span>&gt;</span>hi!');</div><div class="line">    }</div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如此这般，即使是放在了引号里，html对style 的解析也会提前结束，造成问题。</p>
<h3 id="重新同步的风险">重新同步的风险</h3>
<p>很明显的CSS 的发展之路，深受HTML 的影响，所以在CSS 的解析上，和HTML 一样存在着许多让人摸不清头脑的问题，比如，<strong>解析器碰到错误时，仍会继续工作直到碰到下一对匹配的尖括号或大括号括号恢复正常解析</strong>，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a {</div><div class="line">  fklj@#$%@$@!</div><div class="line">}</div><div class="line">img {</div><div class="line">  border: 1px solid red;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>尽管img 前边的解析的是错误的，仍然会正常解析img。利用这种特性，我们很容器就能想起一些攻击方式，比如对对某些浏览器输入一些有效的输入，对另一些浏览器，却能造成CSS 错误，利用CSS 解析器对出错CSS 的重新同步处理，到能导致一些特别的攻击行为诞生。</p>
<p>举个栗子，比如IE 的浏览器对CSS多行字符串文本支持，所以如果用户提供的CSS 字符串里边包含CR和LF 换行符的话，IE 是OK 的，所以网站开发者，不会对此进行过滤，但是对其他浏览器确实错误的，于是就导致了前边解析错误，只能解析后边恶意植入的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">some_selector {</div><div class="line">   content: 'Attacker-controller text...</div><div class="line">            } evil_rule {margin-left: -1000px;}';</div><div class="line">             }</div></pre></td></tr></table></figure>

<p>对于其他浏览器，由于前边的解析错误，css 会跳到恶意代码那里判定为正常代码执行。最简单的解决办法就是禁止它，不要对IE 姑息。</p>
<p>另外一些存在的问题是，CSS 之间兼容的we附体，比如一些老版本的解析不明白新版本的内容，比如CSS3 里的中括号，不过现在好像CSS3以前的版本已经绝迹，在此就不再赘述了。</p>
<h3 id="又见字符编码">又见字符编码</h3>
<p>字符编码似乎是围绕了整个Web 的问题，毕竟Web 是一个以内容交流为主要功能的平台，各种编码在所难免，问题也在所难免。</p>
<p>在CSS 中，为了在CSS字符串中使用一些保留字符或者有问题的字符，CSS 提僧了不太正统的策略。<strong>它使用反斜杠\ 后边跟1~6位十六进制数字</strong>的方式，再这样的策略下，比如字母e, 可以编辑成\65,\065,\000065, 一般来说，只有最后一种方法才不会产生歧义，比如说teak,编码成 t\65ak，就会转义成\65a。而css 避免这种情况的方法，不过是在每个转义序列后边加上空格。</p>
<p>存在安全问题是，很多CSS 解析器 竟然能够接受<strong>未被引号括起来的字符串里的任意转义序列</strong>，特别的在IE 中，转义的优先级还要高于伪函数语法解析，下边这样的结果是一样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">color</span>: <span class="tag">expression</span>(<span class="tag">alert</span>(1))</div><div class="line"><span class="tag">color</span>: <span class="tag">express</span>\028 <span class="tag">alert</span> \028 1 \029 \029</div></pre></td></tr></table></figure>

<p>甚至在IE 中，url() 中的反斜杠并不会解析成转义符，这仅仅是照顾那些URL 中输错了斜杠的用户的的感情~~~</p>
<h3 id="CSS_安全工程">CSS 安全工程</h3>
<ul>
<li>加载远程样式表时<ul>
<li>如果不做安全处理，就是将自身的安全性和远程样式表的域名绑在一起了，即使在样式表上下文禁止JavaScript，黑客仍然可以使用一些TCL键选择器，或者是引用url()，仍能窃取信息，尽管危险稍小。</li>
<li>如果感受到危险，宁愿去本地保存一份副本。</li>
<li>HTTPS 站点里，引用样式表也要使用HTTPS 协议。</li>
</ul>
</li>
<li>CSS 里包含有攻击者能够控制的信息<ul>
<li><strong>独立区块里的字符串和URL</strong>：请用引号括起来，对控制字符(0x00~0x1f)，以及斜杠尖括号中括号单双引号这些符号，尽量使用数字编码转义。</li>
<li><strong>在style 参数中的字符串。</strong>允许用户设置本身就是高度危险的，尽量不要这么做，即使做，也要按照上一条，做好转义。</li>
<li><strong>非字符串属性</strong>，直接使用白名单，只接受有限的输入。</li>
</ul>
</li>
<li>过滤用户提供的CSS<ul>
<li>不要保存或者产生可以用户控制的注释区，@ 指令等等。</li>
<li>验证选择器语法，不应该出现<strong>数字，字母，下划线，空格以外的字符</strong>；{ 之前的冒号，点号，都好位置要准确，否则就会引起css 解析混乱，黑客趁虚而入。或者是<strong>直接禁止复杂的选择器。</strong></li>
<li>解析和校验{…} 区块内的每个规则，可以的话，设置一个白名单，只允许你认为合法有效的规则进入。</li>
<li>如果不信任用户的输入，那最好只将他们限制在一个单独的框架里。</li>
</ul>
</li>
<li>HTML 标记里允许用户设置Class  值时，应当确保用户的CSS 设置不会和网站用到的Class 重名，或者是可以使用独立的命名空间前缀。</li>
</ul>
<hr>
<p>CSS 可以说完全吸取了 HTML 的混乱风格，在整个CSS 发展之路上，充满了风险。当然，CSS 所能造成的灾难在明面上看起来，相比于HTML 少很多，但是仍然不能小觑，因为配合着社工，黑客仍然能够建立起一次可怕的入侵。</p>
<h2 id="浏览器脚本">浏览器脚本</h2>
<h3 id="JavaScript_基本特点">JavaScript 基本特点</h3>
<p>JavaScript 的发展之路也是充满了崎岖，不再赘述，JavaScript 本身是一门相当简单的运行时解释语言，它的语法受到C 的影响，没有类的概念，有自动垃圾回收，有弱数据类型和动态类型的特点。 </p>
<p><strong>脚本处理模型</strong></p>
<p>前边也说了，对于JavaScript执行环境来说，就像一个沙箱，对每个在浏览器中的HTML 文档，都被赋予了独立的JavaScript 执行环境这些加载脚本的所有全局变量和函数都有一个独立的命名空间。</p>
<p>当然，看起来脚本隔离的规则非常的严格，跨文档的交互也必须非常显式的方式进行，和操作系统的进程隔离非常相似，不过其设计的范围还是远比进程隔离小，所以仍然会存在有一些可以利用的漏洞。</p>
<h4 id="模型的处理流程"><strong>模型的处理流程</strong></h4>
<p><strong>源码处理</strong></p>
<p>主要是检查脚本代码块里的语法，转换成中间层的二进制映像。在完成这一步骤之前，这些二进制代码不会对全局才造成影响，如果该阶段出错，那么整段问题代码都会被抛弃，继续解析下一段代码块。注意代码块之间除非正常解析，才会拼接在一起。</p>
<p><strong>函数解析</strong><br>完成了源代码处理的流程，解析器会对当前代码块里的所有具名的全局函数进行识别并注册。该阶段完成后，函数才会被执行代码调用。</p>
<p>注意每段独立的代码块并不是同时处理的，而是根据JavaScript 引擎读取代码块的先后顺序决定的，所以下边这样的写法是失败的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而下边这个写法是能够成功执行的，因为对hello() 的注册要先于第一行代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然而这样的全局名称解析模型只对函数有效，对变量却并非如此，和其他脚本语言类似，变量是按照执行出现的顺序注册的，所以下面的例子是错误的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">hello();</div><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">   alert(<span class="string">"hello"</span>);</div><div class="line">   }</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><strong>代码执行</strong></p>
<p>由于JavaScript的异步性，在执行过程中，如果碰到错误，那些已经被正确解析的函数仍然能被调用，而且已经执行的代码产生的结果，对上下文仍然有效。</p>
<h4 id="执行顺序的控制">执行顺序的控制</h4>
<p>在同一个执行环境里，JavaScript 是按照时间顺序执行的，外部事件无法中断代码的运行，也不支持线程对任何共享内存的修改。大多数情况下，JavaScript执行时，整个浏览器至少HTML 渲染器部分基本处于不响应状态。</p>
<p>更进一步的说，JavaScript本身没有sleep(),或者pause() 这种暂停功能来释放CPU，如果希望延迟执行，需要注册一个定时器来延迟。而定时器里，也可以写一些内嵌的JavaScript代码。</p>
<p>任何死循环都会被中断退出，等价于一个未处理的异常。循环退出，引擎恢复到闲置状态，引起问题的代码仍然可以被调用，所有的计时器和事件句柄也会保持原样。</p>
<h4 id="代码和对象检视功能">代码和对象检视功能</h4>
<p><strong>检视功能</strong></p>
<p>对代码来说，对于非内置函数，可以通过toString() 和 toSource() 方法可以查看反编译后的源码。</p>
<p>对于程序运行流来说，没有多好的办法能够查看，勉强搜索本页的script代码等，但一般无法知道运行到或者是将执行到哪，在此推荐调试利器Firebug。</p>
<p><strong>eval()</strong></p>
<p>对于eval 中的文本语法错误或执行异常都会传递给调用eval 的函数。也就是说，语法解析无误后，执行过程中产生的未处理异常也会传递到调用 eval 的函数。如果没有问题，最后一行代码的执行结果将是eval 的返回值。</p>
<p><strong>延迟执行</strong></p>
<p>有多种机制可以实现延迟执行，包括定时器：setTimeout, setInterval；事件处理器: onclick, onload；HTML解析器自身的若干接口:innerHTML , document.write等。</p>
<p><strong>自省</strong></p>
<p>JavaScript的自省相对完备，可以使用常见的迭代器方式，也可以通过typeof, instanceof 或者全等符 === 或者length这样的属性获得额外信息。</p>
<h4 id="修改运行环境">修改运行环境</h4>
<p><strong>重写内置函数</strong><br>如果任由流氓脚本发挥，可做的坏事很多，删除，重写，或者屏蔽大部分JavaScript内置函数和所有浏览器的提供的I/O 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> = alert;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>

<p>这样的代码是没有问题的，但是在执行之后，Chrome,Safari，Opera 都会通过delete 操作符，删掉整个eval()函数，因为你已经重写了内置函数。</p>
<p>从此延伸开去，几乎所有的对象，包括内置对象，String，Array，都有一个能被任意修改的原型。这个原型是个master 对象，已产生的全体对象实例甚至包括还未产生的实例，方法和属性都衍生自这个主题。（此处是需要进一步学习的点）</p>
<p><strong>Setter Getter</strong><br>尽管他们不如C++ 里的运算符重载那么强大，但是这两个对象足以使得已有对象或者对象原型的行为变得困惑。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> evil_object = {</div><div class="line">    set foo() { alert(<span class="string">"hi"</span>); },</div><div class="line">    get foo() { <span class="keyword">return</span> <span class="number">2</span>; }</div><div class="line">    };</div><div class="line">    <span class="comment">/* 执行以下代码只会显示 hi.*/</span></div><div class="line">evil_object.foo = <span class="number">1</span>;</div><div class="line"><span class="comment">/* 而此时，foo 并不等于1 */</span></div></pre></td></tr></table></figure>

<p>JavaScript 存在的潜在风险是，在特定的上下文环境里执行脚本，一旦受到了非新人内容的干扰，就没有可靠办法来检查其运行环境是否正确了。比如如果盲目信任了 location 对象，就可能导致一系列的漏洞。</p>
<p><strong>JSON</strong></p>
<p>关于JSON的话题很多,JSON 是对大括号的含义进行了重载，意味着JSON 区块里的内容不能按照独立的代码语句来执行。这样就可以防止&lt; script src=… &gt; 这样的方式进行跨站引用。</p>
<p>但是JSON 还是存在有注入风险，其中一个风险来自于eval, 有些开发者往往直接使用eval 直接来吧json 转换成js 对象，如果此时JSON 数据包中注入了恶意的数据，则直接就获得了执行。所以，正确的做法是应当<strong>分割出JSON 里包含的特殊字符，然后再解析为对象</strong>，比如下面，json2.js里的：</p>
<figure class="highlight javaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We split the second stage into 4 regexp operations in order to work around</span></div><div class="line"><span class="comment">// crippling inefficiencies in IE's and Safari's regexp engines. First we</span></div><div class="line"><span class="comment">// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we</span></div><div class="line"><span class="comment">// replace all simple value tokens with ']' characters. Third, we delete all</span></div><div class="line"><span class="comment">// open brackets that follow a colon or comma or that begin the text. Finally,</span></div><div class="line"><span class="comment">// we look to see that the remaining characters are only whitespace or ']' or</span></div><div class="line"><span class="comment">// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^[\],:{}\s]*$/</span>.</div><div class="line">test(text.replace(<span class="regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g</span>, <span class="string">'@'</span>).</div><div class="line">replace(<span class="regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>, <span class="string">']'</span>).</div><div class="line">replace(<span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>, <span class="string">''</span>))) {</div><div class="line"></div><div class="line"><span class="comment">// In the third stage we use the eval function to compile the text into a</span></div><div class="line"><span class="comment">// JavaScript structure. The '{' operator is subject to a syntactic ambiguity</span></div><div class="line"><span class="comment">// in JavaScript: it can begin a block or an object literal. We wrap the text</span></div><div class="line"><span class="comment">// in parens to eliminate the ambiguity.</span></div><div class="line"></div><div class="line">                j = <span class="built_in">eval</span>(<span class="string">'('</span> + text + <span class="string">')'</span>);</div></pre></td></tr></table></figure>

<p>JSON 得到了最普遍应用，另外预支竞争的有JSONP，JSONP 字面含义是填充式(padding)的JSON，它通过填充额外的内容把JSON 序列化包装起来，变成一段有效的可独立运行的JavaScript于珊珊，常见栗子包括函数调用(如 callback_funcition({…JSON data…})) 或者变量赋值(var return_value = {…json data…})), 但是这些序列化无法兼容JSON。parse()，必须使用不安全的eval.</p>
<p>而JSONP 这种的特点是使用第三方页面以&lt; script src=… &gt;形式加载这些数据时，解析不会出现错误。当然，这种情况实际上还会带来许多风险，《Web 之困》中的说明太过简单，在<a href="http://www.thespanner.co.uk/2011/05/30/json-hijacking/" target="_blank" rel="external">JSON Hijacking</a> 有更为详细的解读，以及这篇<a href="http://blog.csdn.net/hengyunabc/article/details/26305203" target="_blank" rel="external">闲扯Web安全之JSON</a>,对于其中的详细知识，还有一些漏洞，后边会继续扩充。</p>
<p>总的来说，注意这么几点：</p>
<ul>
<li>禁止手动拼接JSON字符串，一律应当用JSON库输出。也不应使用自己实现的ObjectToJson等方法，因为可能有各种没有考虑到的地方。</li>
<li>jsonp请求的callback要严格过滤，只允许”_”，0到9，a-z, A-Z，即合法的javascript函数的命名。</li>
<li>jsonp请求也要判断合法性，比如用户是否登陆（这点很容易被忽略）。</li>
<li>设置好Content-Type（这点对于调试不方便，但是提高了安全性）。</li>
<li>以jsonp方式调用第三方的接口，实际相当于引入了第三方的JS代码，要慎重。</li>
</ul>
<h3 id="标准对象层级">标准对象层级</h3>
<p>JavaScript 的运行环境都是围绕一个隐含的根对象构建起来的，这个根对象也是JavaScript程序里所有全局变量和函数的默认命名空间。</p>
<p>JavaScript 预设了一些层级模式的函数，用来实现浏览器环境里的输入输出功能，包括：对浏览器窗口的操作(open(),close(),moveTo(),resizeTo(),focus(),blur()等), JavaScript 定时器设置(setTimeout(), setInterval()等)，各种提示(alert(),prompt(),print())，以及一些浏览器开发商支持的函数等等。</p>
<p>同时，顶级对象还提供了上下文环境对象的JavaScript引用，比如父框架parent，顶层文档top, 当前窗口的源窗口opener，当前文档的子框架 frames[]，以及window和self。</p>
<p>顶级的对象结构里，除了Document 还有一些子对象，如下：</p>
<ul>
<li>location 对象： 包括读取当前文档URL 信息，或者专项新地址浏览的各种属性和方法。注意使用此对象时，新地址跳转会销毁上下文环境，同时对获取的字符串不要想当然的认为他们已经经过了转义。</li>
<li>history 对象： 不常用，能让每个窗口根据浏览记录前后切换移动，类似于前进后退。比如history.go(-1)</li>
<li>screen 对象： 检查屏幕和浏览器窗口大小等等。</li>
<li>navigator 对象： 查询浏览器版本，操作系统，插件列表等。</li>
<li>document 对象： DOM 不多说。</li>
</ul>
<p><strong>DOM</strong> 东西太多，一言难尽，其中包括转义方面的问题，注入的漏洞。等另开一篇文章讲。</p>
<h3 id="脚本字符编码">脚本字符编码</h3>
<p>JavaScript 支持很多常见的反斜杠方式的字符串编码，用于转义引号，HTML 标记 和内嵌在文本中的有问题的字符。</p>
<ul>
<li>对某些控制祖父使用C风格的表达式： \b 退格符，\t 水平制表符 , \v 垂直制表符， \f 换页符， \r 回车， \n 换行。</li>
<li>3位数字，不足位0填充，按照8位原字节八进制字符编码，无前缀。JSON 中支持此转义。栗子：\145 = e</li>
<li>2位数字，不足位0填充，8位元字节十六进制字符编码，前缀为x。栗子： \x65 = e</li>
<li>4位数字，不足位0填充，16位元字节十六进制Unicode 数值编码，前缀加u。 \u0065 = e</li>
<li>反斜杠后边跟非8进制数字，非第一条所说字符，非u 非x，可以使用反斜杠转义。就是直接的转义符。</li>
</ul>
<p>对于最后一条 值得注意的是，因为JavaScript 解析顺序要晚于HTML 解析，所以，不应该用这种方式来转义尖括号，和其他HTML 语法中的分隔符，这样HTML 解析完毕，再解析JavaScript，转义结束之后就会造成问题。这和CSS 问题一样。</p>
<p>同时以上各种方式，只有Unicode 转义方式可以用在字符串之外的位置，其他转义则不可以，而且在JavaScript里，转义编码只能出现在标示符部分，不能用在对语法有真正影响的符号上，比如括号。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\u006lert(<span class="string">"hello"</span>);</div></pre></td></tr></table></figure>

<p>上边写法是ok的，但是如果用这种方式替换圆括号或者是引号，就会失败。</p>
<h3 id="JavaScript_代码包含在哪里">JavaScript 代码包含在哪里</h3>
<p>JavaScript 代码经常包含在哪里呢？</p>
<ul>
<li>直接嵌入&lt; script&gt; 代码块。</li>
<li>通过&lt; script sr=… &gt; 加载代码。</li>
<li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li>
<li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li>
<li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li>
<li>定时器，Timer(setTimeout, setInterval)</li>
<li>eval(…) 调用。</li>
</ul>
<p>这也是所有可能发生漏洞的地方，比如定时器那里，考虑以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var value = <span class="string">"user_string"</span>;</div><div class="line"><span class="keyword">...</span></div><div class="line">setTimeout(<span class="string">"do_stuff('"</span>+value+<span class="string">"')"</span>, <span class="number">1000</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>

<p>表面上看他没有问题，对 value 只做一次转义就好了，但实际呢，考虑其解析过程，首先是HTML 解析出script 块，然后JavaScript 做第一次解析，检查setTimeout 语法，而等到1秒之后，才会解析do_stuff，如果不多做一次转义，就有可能构造成一次注入，比如user_string 中插入一个JavaScript编码的构造，截断前边函数，然后构造自己的攻击部分。</p>
<p>这种编码模式，看起来比较绕，但实际上也是JavaScript常出现问题的地方。</p>
<h3 id="安全工程">安全工程</h3>
<ul>
<li>加载远程脚本情况，和CSS 一样，这样做等于将自己和远程站点的安全性关联到了一起，所以一定要做好最高的安全措施。</li>
<li>解析从服务器端收到的JSON 数据，一定不要用eval 直接解析，或者是RFC 4627 里提供的基于eval的实现，尽量使用JSON。parse()。 特别是处理第三方返回数据时，这两种方式实际上都并不安全，可以参见前边所说的json2.js 的实现方式。</li>
<li>JavaScript 代码块包含用户输入数据的集中情况<ul>
<li><strong>&lt; script&gt; 代码块中的字符串</strong> ，依照常规，对所有控制字符（0x00~0x1f），\,左右尖括号，引号，用反斜杠加数字的形式转义处理，高位字符也应当转义处理。同时不要直接用用户提供的字符串组成HTML，选择安全的DOM 处理，也不要直接用用户提供的字符串组成参数然后传递给脚本执行功能的函数里，避免使用eval(), setTimeout() 方法。</li>
<li><strong>在独立脚本文件里的独立字符串</strong>：重点防范跨站。</li>
<li><strong>在事件处理器，或者javascript伪URL</strong>：在伪URL 里时，应当在这些位置出现用户提供数据时，做多重转义。而且尽量不要使用这种直接内嵌JavaScript 脚本的方式。如果做，首先进行JavaScript 转义，然后根据情况转义在进行HTML或者URL 参数编码方式编码。不要是用eval(),setTimeout()和 innerHTML .</li>
<li><strong>非字符串类型属性</strong>：白名单形式，并且对数字型数据进行严格验证。</li>
</ul>
</li>
<li>与客户端浏览器对象交互<ul>
<li><strong>客户端产生的HTML内容</strong>：不要使用 innerHTML, document.write() 或者是类似的处理方式，因为这样会造成跨站。构建HTML 文档，请使用 createElement(),appendChild(),安全的属性如：innerText, textContent.</li>
<li><strong>对用户控制数据的处理</strong>： 要先认为从客户端读取的数据都未经过正确转移，特别是如location 属性，以及一些外部URL来源数据，一定要自己做一些转移处理，不能直接传给自己服务器处理。</li>
</ul>
</li>
<li><strong>如果页面能加载其他用户控制的脚本</strong>，实际上，这样是极不安全的，一些可用的框架，或者是沙箱框架，可能会有帮助。</li>
</ul>
<hr>
<p>本来是想着一天写一篇的速度，刚刚好，今天看了CSS 部分，觉得内容很短，而且很多东西配合着 JavaScript看，会有一些收获，于是就把两章放在一起看了，这是个深坑，来自CSS 的问题尚少，都有迹可循，但是来自JavaScript 这个神奇的脚本语言的种种行为模式，思考起来就花费了一些时间，虽然之前JavaScript 有一些基础，但是作者短短几句指出来漏洞，倒是要花费我很多时间去思考这些漏洞到底是怎么构造起来的。</p>
<p>JavaScript 这门语言发展的太快了，而且Web 也发展的太快了，注定这是一个充满了危险的地带，再加上网络这个只用很短时间就从蛮荒时代走向了琳琅满目的东西，总是充满了各种残缺待补的东西，实际上，看如今的网络，似乎没有哪家的服务器没被脱过库了，被爆出来的也都是那些转过几手，拥有的人太多的库了。</p>
<p>由于Web 的漏洞可以来自语言，可以来自浏览器来自客户端，可以来自服务器，来自Web 程序，甚至是程序中一个小小的插件，这两天爆出来的imageTragick 漏洞，不过就是一个图像处理工具，一个小小的漏洞直接让黑客切入到心脏中。</p>
<p>而接下来的部分，也正是将流动在网络上的这些非HTML 文档，以及他们存在的风险，最后还有一个浏览器的插件。书写完成之后，将转入安全特性的探讨上，再次总结书写的过程，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CSS和JavaScript的烦恼">CSS和JavaScript的烦恼</h1>
<h2 id="CSS">CSS</h2>
<p>CSS 是能够做到网页表现和内容分离的样式设计语言，有人爱之深切，有人恨之入骨。由于CSS 的存在，让HTML 在语义学上越来越不]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML的纷争 -- 《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/04/HTML%E7%9A%84%E7%BA%B7%E4%BA%89-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/04/HTML的纷争-《The-Tangled-Web》/</id>
    <published>2016-05-04T03:31:30.000Z</published>
    <updated>2016-05-04T03:32:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 id="HTML_文档的基本概念">HTML 文档的基本概念</h2>
<p><strong>语法</strong></p>
<p>HTML 是标签组成的层级结构，文本穿插其中，而主要是使用无个字符进行约束和限制，<strong>左右尖括号，单引号，双引号，&amp;</strong>，所以说，HTML 里会有一些针对这些字符的规则：</p>
<ul>
<li>HTML 文档的绝大部分区域不应该出现单个「&amp;」符号。</li>
<li>HTML 标签内部不应该出现左右尖括号。</li>
<li>文本节点的左尖括号是危险的。</li>
<li>标签中出现引号字符串可能导致意想不到的效果。</li>
</ul>
<p>以上几条规劝，实际上就是在告诫这样书写的代码，随时会被攻击者抓住，利用代码的缺陷，构造XSS 或者是SQL注入。</p>
<p><strong>文档解析模式</strong></p>
<p>对于传统的HTML，解析器会修复大部分语法上的不合规，同时不区分大小写，参数值不一定要用括号括起来，某些标签可以隐式闭合，而对于XML 来说，标签必须严格匹配，区分大小写，可以整合其他兼容格式内容。</p>
<p>值得一提的是，对于HTML ，碰到某些标签后，会落入特殊模式，直到出现特定的终止字符才会退出状态。如style, script, textarea, xmp 直到出现反斜杠匹配，才会退出。</p>
<p>而对于XML，禁止出现单个「&lt;」和「&amp;」，还有一个特殊的语法，只要一”&lt;![CDATA[“字符串开头，以”]])”结束的，中间短路可以封装含有人以标签的任意原始文本数据。</p>
<p><strong>语义之争</strong>：Tim Berners-Lee 的语义网梦想，这里还是比较遥远，不做进一步探讨。</p>
<h2 id="HTML_解析器的行为"><strong>HTML 解析器的行为</strong></h2>
<p>对于XML 来说，不需要担心，因为解析器的错误几乎零容忍。但是，对于HTML 来说，简直就是灾难，为了最大程度的解析，HTML 会以各种让人摸不着头脑的大胆的方式猜测网页作者的用途。以下边这个标签为例：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-04-14623256480455.jpg" alt=""></p>
<p>先不考虑它没有闭合仍然正常被解析这件事，看各家解析器做出的各种支持：</p>
<ul>
<li>IE 浏览器允许吧空字节NUL（0x00） 插入到1位置</li>
<li>2，4的空白位置可以使用垂直制表符(0x0b)或者进纸换页符(0x0c)替换，令人惊奇的是FireFox 允许在2 用单个普通的正斜杠代替。</li>
<li>3，曾经WebKit 甚至允许此处有正斜杠使用。</li>
<li>位置5，在IE还能接受反引号。</li>
<li>被引号括起来的参数，后边实际上隐式的跟着一个空格符，所以位置6空格可以去掉。</li>
</ul>
<p>一个常见的攻击手段就是xss，此处借助title,我们将 hello world 替换成 hello world” onerror=”alert(1) 于是，对于原标签就变成了：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=image.jpg tile=<span class="string">"hello world"</span>onerror=<span class="string">"alert(1)"</span> <span class="keyword">class</span>=example&gt;</div></pre></td></tr></table></figure>

<p>很自然的一个脚本被我们植入进去了，一个xss 就被触发了。</p>
<p><strong>多重标签的交互</strong></p>
<p>在不正常的HTML 里，还会出现多个HTML 标签堆叠在一起，看起来就让人头疼，而浏览器在解析的时候，也会有区别，比如:</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i &lt;b&gt;</div></pre></td></tr></table></figure>

<p>大多数浏览器会先解析成<strong>‘&lt; i &gt;’</strong> ，而把&lt; b 视为无效的标签参数。</p>
<p>另外，整个文档结束时候标签未闭合的情况也让人摸不清头脑。比如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;i foo=<span class="string">"&lt;b&gt;"</span> [EOF]</div></pre></td></tr></table></figure>

<p>大多数浏览器解析为i 的标签，或者是整个忽略掉，但对于IE 和 Opera 却从后往前处理，把这一串理解成 b 的标签。</p>
<p>所以假如攻击者，可以阶段加载的页面，就可以通过构造手段，让浏览器解析成完全不同的内容。</p>
<h2 id="HTML_实体编码">HTML 实体编码</h2>
<p>（由于MarkDown语言里，自动把这些编码识别出来了，包括尖括号，只好中间加空格或这种方式来书写。）</p>
<p>hTML 的实体编码格式是以&amp;开头，以分号结尾，在HTML 规范里，散步着无数这样的命名实体，比如&amp; lt; 插入左尖括号，&amp; gt;用于插入右尖括号，&amp; amp; 替换 &amp;符号自身。&amp; rarr; 代表一个Unicode箭头等等。</p>
<p>除了命名实体，还可以插入任意十进制ASCII 或者 Unicode 字符编码，样式是 &amp;#数字；<br>例如 &amp;# 60; 被识别成左尖括号，&amp;# 62; 别识别为右尖括号。而十六进制的标记符在这在编码前边加一个x,所以 &amp;# x3c; 仍然是一个左尖括号。</p>
<p>对于HTML 来说，解析器能识别在文本节点和参数值里边的实体编码，在创建文档树的时候，透明的对这些编码进行解码。</p>
<p>但是有一点疑惑的是，在识别和解析HTML 实体任务重，有一些奇怪的解析，比如传统解析中，只要实体名称后边跟着的字符不是字母数字，即使是少了分号，实体名还是被接受了。对于数字型的实体，后边可以跟任意多个0，导致一个超长的数字串，会造成出错。</p>
<h2 id="HTTP/HTML_交互语义">HTTP/HTML 交互语义</h2>
<p>一般来说，我们会在HTTP 的头域指定内容的一些信息，比如Content-Type, Content-Disposition, Transfer-Encoding等等，然而考虑如果我们不适用HTTP 传输HTML，甚至是直接从本地加载HTML，就不能依靠HTTP 的头域来确定编码等信息了。如果缺了像 MIME type 或者字符集这样关键参数，就会破事浏览器随意处置文档的编码解析问题。</p>
<p>解决办法就是文档开头声明&lt; meta http-equiv=…&gt; 指令进行编码设定，一个典型的指定是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></div></pre></td></tr></table></figure>



<p>如果多个http-equiv冲突，或者从服务器端返回HTTP 头域有冲突的话，浏览器表现就会很不一致，一般优先支持hTTP 响应头，然后支持第一个出现的charset。</p>
<h2 id="超链接与内容包含">超链接与内容包含</h2>
<p>这一块是XSS 的重灾区。</p>
<p>一个单纯的HTML 链接写法是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.example.com/"</span>&gt;</span>click me!<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>对于这个超链接，它支持指向浏览器支持的所有协议，包括伪URL，如data: javascript:。</p>
<p>同时，该语法可选的target参数有四种，<strong>_blank</strong>总是打开新窗口；<strong>_parent</strong> 转到包含发出当前链接文档的上一级视图；<strong>_top</strong> 转到浏览器最顶级窗口。<strong>_self</strong> 和没有设置这个值一样。</p>
<p><strong>表单和表单触发的请求</strong></p>
<p>XSS 重灾区。</p>
<p>一个典型的表单写法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">GET</span> <span class="attribute">action</span>=<span class="value">"/process_form.cgi"</span>&gt;</span></div><div class="line">名字：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">given</span>&gt;</span></div><div class="line">姓氏：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">text</span> <span class="attribute">name</span>=<span class="value">family</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">submit</span> <span class="attribute">value</span>=<span class="value">"完成后提交"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></div></pre></td></tr></table></figure>

<p>值得注意的是，form 彼此不能嵌套，如果嵌套了，只有最外层的有效。</p>
<p>如果method 为GET，那么包含的字段名称和他们的值，会以百分号编码机制转义，但其中空格(0x20) 会被以加号代替而非%20,而所有的加号被编码成%2b 。经过编码的「名称=值」数据对用&amp; 连接付分割，组成完整的字符串。</p>
<p>如果method 是POST，分几种情况：</p>
<ul>
<li>默认情况下，application/x-www-form-urlencoded 编码方式，信息组成方式与GET 方式相同，不同的是数据会放在请求头的数据体部分提交，目标URL 查询字符串和其他部分保持不变。<strong>潜在的问题，如果查询字符串和POST 数据体参数相同，冲突，可能会造成HTTP 参数污染</strong></li>
<li>额外的把form 标签中的编码设置为enctype = “text/plain”。而采用这种做法，字段的名称和值不会以百分号编码方式进行编码，某些浏览器可能会把空格替换成加号，而原来用于分割的&amp; 以换行符替换。因此，这样格式的数据，无法明确的对赎金进行解析，因为无法完全区分换行符和等号是表单带进来的，还是浏览器加入的。</li>
<li>entype = “multipart/form-data”，通过表单提交用户选择的文件时候，要用这种模式，会产生一系列较短的MIME 消息，对应于提交的每个字段。然后每个字段会有一个由哭护短选择的特定符号分割。</li>
</ul>
<p><strong>Frame 框架</strong></p>
<p>其作用是使HTML 文档内嵌和显示另一个页面中，有独立的文档视图，甚至独立的JS 环境。对于src 值的限定，与其他链接的规则基本相同， 所以 iframe 也是一个安全隐含。</p>
<p><strong>其他特定的内容</strong></p>
<p>包括图片，层级样式表，客户端脚本，插件内容等等，这些不再赘述，他们都有XSS 的风险。</p>
<h2 id="安全工程">安全工程</h2>
<ul>
<li>良好的规范，良好的规范，良好的规范，毫无疑问要确保输出统一的、有效的、浏览器支持的Content-type 响应头和 charset 字符集信息，以免文档不能按照原有意思解析。</li>
<li>文档包括可被控制的信息时，应当充分考虑到漏洞的可能。<ul>
<li>针对文本部分里用户提供内容：应当以实体编码方式处理左右尖括号和&amp; ， 以及其他的各种ASCII等编码问题。同时，某些Unicode 元字符 U+202E 可能会改变之后文本的显示方向和顺序，<strong>是不是想起了微信</strong>。</li>
<li>针对style 和 on* 标签参数，要做多重编码转义处理，但这种处理往往又有可能出错，所以处处小心。</li>
<li>其他的HTML 参数值，对攻击者能够控制的输入，总是用引号来括起来，对左右尖括号和&amp; 以及任何<strong>单独出现的引号</strong>都要进行实体编码。同时，不要对URL 或其他参数有问题的值做黑名单验证，反而会造成脚本执行漏洞。</li>
<li>特殊的解析模式下，如script, style 区块里的内容，仍然是仔细处理引号字符串，左右尖括号，所有非打印字符都应做好合适的转义处理。</li>
</ul>
</li>
</ul>
<hr>
<p>HTML 部分写完，但是要想完全搞清楚HTML 编码部分的问题，简直是一件不可能完成的任务，曾经有本书叫《Web Application Obfuscation》，它企图创建出能拦截所有已知的危险模式的过滤器，同时又不会影响到其他段落的正常功能，而实际上，这是不可能完成的任务。</p>
<p>一个良好的方法是用一个解析器，把输入的文档翻译成放在内存里的层级文档树，然后去除掉那些无法识别的参数和标签，和所有不需要的标签、参数、参数值。然后在对文档树进行良好的排序和转义，这样看起来要方便和清晰许多。</p>
<p>另外，HTML 中存在问题，造成最大的影响就是XSS 和CSRF 这两个攻击手段，攻击者会绞尽脑汁的绕过开发者设置的层层障碍，他们的最终目的无论如何，都是试图通过各种混淆的代码，让解析器理解成其他意思，达成攻击效果。而XSS 的三种攻击模式，反射型，储存型，DOM 型，都是在这些修修补补的篱笆上找一个足以穿越过去的漏洞。</p>
<p>在配合上HTTP 的问题，可以创造一切可能，对于XSS 的世界，脑洞有多大，可能有多大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTML_的纷争">HTML 的纷争</h1>
<p>HTML 语言的混乱主要源于四种主要解析引擎各自为政，IE 的Trident引擎，Firefox 的Gecko ,Safari 和Chrome 的Webkit,Opera 的Presto. </p>
<h2 i]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 2)把XSS放进脚本 -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-2-%E6%8A%8AXSS%E6%94%BE%E8%BF%9B%E8%84%9A%E6%9C%AC-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-2-把XSS放进脚本-XSS升级之路/</id>
    <published>2016-05-03T13:29:18.000Z</published>
    <updated>2016-05-03T13:29:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还有诸如input, iframe，a href, 主要利用的是href 或者 src 可以使用javascript, 或者是使用onerror，表示当前图片无法显示时候可以调用的脚本。更多的内容，接下来详析。</p>
<p>接下来，我们针对的还是反射型的XSS，仍然是在参数中，作为目标文件中的参数，通过URL 传递给它，但是没有对该参数进行详细的过滤，造成了有机可趁，继续放出腾讯家以前的一个例子，也是乌云上的，网址如下：</p>
<p><a href="http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa" target="_blank" rel="external">http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa</a></p>
<p>此处的callback 参数，如果没有过滤的话，得到的网页源码里，我们就会看出来，如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622798034256.jpg" alt=""></p>
<p>拿出这一块的上下文代码，大约构造是这样的：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;<span class="built_in">document</span>.domain=<span class="string">'soso.com'</span>;_ret={<span class="string">"_res"</span>:<span class="number">2</span>};<span class="keyword">try</span>{parent.aaaaaa(_ret);}<span class="keyword">catch</span>(err){aaaaaa(_ret);}&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>aaaaaa如果我们替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>当然，我们注意到，上边的script 还没有闭合，为了让代码提前跳出前一个script ，我们应该在前边吧sciprt 闭合，这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(/</span>xss/)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>这样，很明显，就会继续发起了XSS 弹窗。但是，如果我们不允许输入破折号呢，上边所说的就没有办法了，但是，这并不代表毫无办法，还有一些具有威胁的函数，比如eval, String.fromCharCode, execute，这些都会造成XSS，也要过滤。如下，我们使用eval() 来构造攻击：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void</span></div></pre></td></tr></table></figure>

<p>callback=eval(‘alert(1)’);void 仍然令我们的源代码语法正确，能够正确执行。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622803866844.jpg" alt=""></p>
<p>但是像这样构造出来的情况，其实非常的少见，因为正常传第一个参数进去，开发者都会将 “ 过滤掉，这样构造就失败了。 </p>
<p>我们知道，XSSer 和 防御者之间的斗争从来就是道高一尺，魔高一丈的过程，防御者绞尽脑汁去过滤所有可能出现的情况，去处理所有可能的奇葩诡异编码情况，而XSSer 又会绞尽脑汁的去挖掘茫茫网络中漏洞，努力用各种奇技淫巧构造出五花八门的形态，看起来诡异无比，然而偏偏又能让javascript 语法正确，正常运行。</p>
<p>然而xss 却又一直是热门，但并不是很受重视的攻击手法，原因大概是这样的：</p>
<ol>
<li>挖洞太麻烦，很耗时间，看上边两个漏洞，其中一个甚至是在某个获取QQ 应用宝上某个app 数据的URL 里发现的，而这种页面甚至很难被发现，所以他的伤害比较低，找到它却又要花费大量时间，而且还有很多构造方法不能成功，需要尝试各种模式。</li>
<li>这种伤害不是很大的反射型攻击，尚且还有机会通过爬虫自动化的挖掘到漏洞存在的可能，有很多复杂的存储型和DOM 型漏洞，更难通过爬虫挖到。</li>
<li>需要有良好的HTML，JS 功底，但是呢，如果功底好的话，直接就跑去做前端了，前端业务现在那么缺高级工程师。更多的，还需要有PHP，JSP 功底。</li>
<li>而Website 设置http-only,crossdomain.xml 时候，很多模式化的xss就失去力量了。</li>
<li>然而为什么热门呢，因为HTTP 世界的混乱，之前在写Web之困读书笔记的时候，作者也是强力吐槽了这个混乱的HTTP 世界，所以造成了XSS 几乎无处不在，而如果一个利用好的XSS，或者CSRF漏洞，会在某些情况下，造成难以弥补的伤害。</li>
<li>本质上将，SQL注入和XSS 都是由于代码上相似的漏洞造成的，而SQL 注入的危害要比XSS 看起来危险很多，很多人在挖SQL 注入漏洞的时候，顺手就挖几个XSS，也是很正常的。</li>
<li>XSS 虽然看起来比较温柔，但是配上社工手段，可造成的影响仍然是不可小觑的，所以XSS 会火下去。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="level_2_包装进script">level 2 包装进script</h1>
<p>上一等级里，我们的xss 构造格式是在img 中,然后直接通过URL 参数提交，通常反射型的XSS 比较广泛，但是伤害一般来说没有太高，而且比较容易防范。除了img 元素，还]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(level 1)无过滤规则的XSS -- XSS升级之路]]></title>
    <link href="http://yoursite.com/2016/05/03/-level-1-%E6%97%A0%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E7%9A%84XSS-XSS%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2016/05/03/-level-1-无过滤规则的XSS-XSS升级之路/</id>
    <published>2016-05-03T13:26:29.000Z</published>
    <updated>2016-05-03T13:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这一块知识聚拢一下，写成一篇文章。想了想，从简单到难，那就是一条打怪升级之路，所以就从最简单的反射型漏洞开始，一点一点提高，直到把大部分XSS 的形式找出来。</p>
<h1 id="level_1_无过滤规则的XSS">level 1 无过滤规则的XSS</h1>
<p>最简单的跨站，也就是我们说的反射型跨站，也叫作非持久型，参数型跨站脚本。这种类型的脚本出现的面非常的广，互联网上这样的漏洞非常多，一般出没在各路小站点，大站点很少出现。乌云的漏洞列表里，海量的XSS 漏洞都来自互联网上访问量不高的小站，被辛苦挖洞的XSSer 们发掘出来的。</p>
<p>站在新手村我们的，需要一个最简单的野怪刷一下，这个野怪上下无任何装备，没有一点防御。也就是说，这个XSS 漏洞对于用户的输入，不做任何过滤行为。</p>
<p>一般来说，XSS 存在的地方，一定是需要有输入和输出概念的，一般的过滤规则，也是出现在输入阶段或者是输出阶段，如果两个都没有过滤，那么很轻松的就造成了漏洞。通常来说，这种洞非常好刷，比较自动化的方式是，建立一个爬虫系统，预设一些URL，爬虫爬取网页，在网页源码中寻找用户可以输入的地方，然后在可以输入的地方，将构造好的XSS 代码以输入形式，构造成请求，然后观察响应，是否对我们的输入做了过滤策略。如果是原本的返回，那么我们就说可能存在有xss漏洞。</p>
<p>同时，有另一种更为简单的漏洞，是直接在URL 中，如果有直接赋值参数的行为，也相当于一个可输入的位置，我们直接在URL 中将XSS 代码构造在URL 中，观察返回是否做了过滤处理，如果没有，那么就是一个最简单的野怪诞生。</p>
<p>在乌云中，有不少这样的漏洞，小站很多，大站很少，因为大站一般都有完备的过滤规则，很难在这些小问题上有任何闪失，再加上如今浏览器基本上都有安全策略对此类型进行防御，所以这种威力相对较小。</p>
<p>之前在HTTP 的文章里，有详细讲过 URL的格式，其基本格式如此：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622667602815.jpg" alt=""></p>
<p>每个结构对应的含义如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<p>通常的注入发生在query 这一块，而一般一个安全的行为，就是对query 中的字符进行过滤，以防止xss。以百度的URL 为例，一个通常的URL 查询之后的造型是下面这样的：</p>
<p><a href="http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969" target="_blank" rel="external">http://www.baidu.com/s?wd=%E6%A0%87%E7%82%B9%E7%AC%A6&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;inputT=2969</a></p>
<p>问号之后有一大堆参数，&amp;用来分割参数，他们对应的是什么意思不是本文关注的重点，可以参见这一篇文章<a href="http://www.biaodianfu.com/baidu-url-secret.html" target="_blank" rel="external">百度搜索URL 参数解析</a>。</p>
<p>其中wd 就是我们所说的搜索关键词，也就是我们的输入，如果我们将此字符改成</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(<span class="regexp">/xss/</span>)&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>

<p>在输出时我们看到，URL 变成了如下，可疑的部分被转义了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.baidu.com/s?wd=%22%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&rsv_spt=1&rsv_iqid=0xb3f5d3380002c15f&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&oq=%26lt%3Bscript%26gt%3Balert(%26%2339%3Bxss%26%2339%3B)%26lt%3B%2Fscript%26gt%3B&rsv_t=455e8xS9GVGwfM%2BTxjkNH6uUohEOPZHQFWlqocmOh9s1caJr5IHzVrPJJKJ1OwdTglc3&inputT=5478&rsv_sug3=27&rsv_sug1=21&rsv_sug7=100&rsv_pq=cce2beda0002a800&rsv_sug2=0&rsv_sug4=6278</span></div></pre></td></tr></table></figure>

<p>在这里举一个大站腾讯的简单的xss，是乌云上某马甲提交的，作为一个最简单的XSS 挖给大家学习。网站的网址是这样的：<br><strong><a href="http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886" target="_blank" rel="external">http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886</a></strong></p>
<p>如果我们在这个URL 里尝试修改参数，将score 参数改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>

<p>而输出的源码并没有发生变化：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673299696.jpg" alt=""></p>
<p>在网易中看到的结果就变成了这样：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622673544485.jpg" alt=""></p>
<p>这很显然，就是一个xss漏洞了，将经典的xss 代码插入进去即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score=<span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">1</span> <span class="attribute">onerror</span>=<span class="value">alert(1);</span>&gt;</span></span></div></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14622674130351.jpg" alt=""></p>
<p>这就是一个最无防御的XSS 存在，很明显的，它简单，暴力，当然也是极容易防御的，所以在一个较高级的攻防对抗，或者是大站漏洞中，基本上不会出现这样的漏洞（然而腾讯还是有这样的问题~~）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="XSSer_升级之路">XSSer 升级之路</h1>
<p>之前积累了XSS 有一段时间，因为目前开始了一件有趣的工程，需要整合非常多的知识，其中Web 安全这一块出现最多的，应该就是XSS，SQL注入了，再加上乌云泡着看别人的文章，看各家大网站的漏洞，决定把这]]>
    </summary>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP许多事-《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/05/03/HTTP%E8%AE%B8%E5%A4%9A%E4%BA%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/05/03/HTTP许多事-《The-Tangled-Web》/</id>
    <published>2016-05-03T01:26:05.000Z</published>
    <updated>2016-05-03T01:26:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提供任何额外的元数据交换空间</strong>，其过程非常的简单，只有一行，客户端的请求只有一行，比如以GET 开头，后跟URL 路径和查询字符串，CRLF结束，服务器端接到后立刻返回HTML 数据。</p>
<p>所以，这个版本上，有很明显的缺陷，比如无法根据浏览器用户的首选语言或者文档类型进行交互处理，找不到请求文件或返回内容不是HTML的话，无法通知客户端，比如不能做到在一个服务器用一个IP 支持多个不同主机名的网站。</p>
<p><strong>HTTP/1.0 &amp; HTTP/1.1</strong></p>
<p>下面这两个版本，修正了这些问题和缺陷，其格式在之前的HTTP 详解里，已经介绍过了，请求头里包括了具体版本信息，和许多以键值对形式存在的数据，同时一个单独的空行代表结束。响应头则包含了包含协议版本，响应码，状态信息，和一些其他的键值对形式存在的响应信息，同时以一个空行结束，随后才是要返回的具体资源。</p>
<p>很显然，这一版本就成熟了许多，但是协议里有一个要求，HTTP/1.0 的客户端必须能够理解HTTP/0.9 ，这看起来是一种向下兼容的表现，但实际上会带来许多恶果，如果攻击者想要攻击某个HTTP 客户端，攻击者会试图令客户端HTTP 降级，采用0.9的模式，而这种模式下，十分危险，返回给客户端的文件，然而在0.9中，返回的内容只有请求的文件本身，无法从这些回应的内容里，表明响应方确实可以理解HTTP 协议，以及返回内容是否是真的HTML 文件。</p>
<p>这让我想起了SSL 里的安全问题，也是由于SSL 3.0 需要向下支持SSL 2.0 ,而SSL 2.0 中存在有严重的漏洞，所以攻击者会故意引起降级到SSL 2.0，寻找漏洞。到后来，进步到TLS后，SSL 3.0也不被信任了。</p>
<p><strong>换行处理</strong></p>
<p>这是一个小细节，HTTP/1.1 要求客户端不仅要接受CRLF 和LF 换行模式，还要接受CR，然而不同的浏览器和服务器却又有不一样的支持情况，比如Apache 就不接受RFC 这条建议，而FireFox以外的客户端都能接受。</p>
<p>所以，开发人员在处理HTTP 头域的时候，不仅要考虑LF，CRLF，还要考虑CR 字符。不然就有可能产生漏洞利用，也就是在头域中注入CR ，响应拆分。</p>
<p>另外一个不安全的小细节是，HTTP/1.1 要求支持多行请求头，也就是以一个空格开头的行，认为是接上一行的内容。但是这一规定，有些浏览器和服务器支持，有些却并不支持，比如IE ，Opera 等等都不支持。这种混乱，就会造成漏洞，不过这种攻击可能性比较低一些，我也没想到它能造成什么严重的影响。</p>
<p><strong>经过代理的HTTP 请求</strong></p>
<p>这一块在HTTP 详解那里，只对代理这一部分做了基础的了解。使用代理的原因有很多，比如为了提高性能（缓存），强制某些网络的访问策略（禁止）或需要以代理方式接入某些独立的网络环境等等。</p>
<p>相比于普通语法格式，有一些不同：<strong>第一行URL 是一个完整的URL</strong>，而在Host 中也要标识出主机名，这看起来是重复的，但实际上两者是两套机制独立发展起来的，<strong>当Host 与 URL 不匹配时，代理服务器以URL为准，或用特定的URL-Host 数据对和缓存内容关联</strong></p>
<p>同时，代理服务器还允许浏览器获取非HTTP 类型的资源，比如FTP 文件或者目录。这种情况下，数据返回给用户之前，代理服务器会把HTTP 响应里返回的内容先封装整理，转换成HTML格式。而如果服务器不便于查看数据，就另做处理了。也就是Connect 方式，这样代理服务器就会进行盲转发。当时，盲转发中间存在一个疏忽，不过已经解决，处理代理服务器返回的非加密错误响应信息时，浏览器会认为是目的服务器返回的。</p>
<p>另外有一些代理服务器并不适用HTTP 方式和浏览器打交道，这些代理为了缓存内容或者强制执行某些规则，会需要检查HTTP 过程中的信息交换。比如一个透明代理，它拦截TCP/IP 层流量，但是它能看到连接的目标端IP，和主机头Host信息，但是它并不能确认，要连接的目标端IP 是否真的和Host 设定的服务器名称匹配，除非去做一次查询，确定两者是否相关，否则客户端和服务器串通好久回对代理服务器造成影响。比如，如果不检查，攻击者可以向代理服务器要求连接自己的服务器，但发送的是一个故意误导的代理的Host头，www.google.com ，这样，那些想要访问www.google.com 获得的可能是错误缓存的响应内容。</p>
<p><strong>重复或者有冲突的头域的解析</strong></p>
<p>一句话，不同的浏览器和服务端都有不同的处理，而且在协议中，对此的描述也有很多小的疏漏，比如同时有用HTTP/1.0 和1.1 相同功能但是不同名称的头域，应当如何处理，比如EXPires 和 Cache-Control。</p>
<p>另外，比如第一行的URL 和 Host 冲突时候，应当怎么处理，文档要求是不要理会Host, 但是Host 必须存在。</p>
<p><strong>以分号作分隔符的头域值</strong></p>
<p>有一些HTTP 头域，比如Cache-Control 或者Content-Disposition ，可以使用分号来分隔在同一行里的几对独立的’名称=值’数据组，允许使用这种嵌套语法，可以更加有效率和直观。</p>
<p>同时RFC 里规定了某些使用场景，这种数据组里等号右边的参数可以使用Quoted-String(双引号括起来的任意可打印字符组成的字符串，支持分号和空格)。</p>
<p>但遗憾的是有些浏览器对该语法的支持并不好，比如IE，他不能支持分号，如果””中存在分号，有分号的地方就会被截断，造成安全漏洞。</p>
<p>还有一个问题并有做统一规定，就是多次出现的名称=值，名称如果相同，应该如何处理，不同的浏览器和服务器做了不同的处理。一般以第一次出现的值为准。</p>
<p><strong>头域里的字符集和编码策略</strong></p>
<p>这又是一个令人头疼的地方，因为规则混乱，处理方式混乱，甚至可以说，没有任何一套编码方式能同时为所有的浏览器所支持。书里只是简单的举例说明了这个编码有多混乱，记录如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-03-14620909259094.jpg" alt=""></p>
<p><strong>Referer头域的表现</strong></p>
<p>Referer 头域里包含的是，哪个URL 地址触发了对当前网页的访问，Referer头域都纠错处理有一定的帮助，但是这个头域也会泄露一定的信息，还会暴露引用页面的查询字符串参数等。</p>
<p>一般情况下，在HTTP 头域都会出现，但除了一下集中情况：</p>
<ul>
<li>地址栏直接输出新的URL</li>
<li>浏览器动作是由data: 或者javascript: 伪协议触发的</li>
<li>当前请求来自Refresh 响应头</li>
<li>从加密站点到非加密站点，<strong>注意虽然有此措施，但是还会有信息泄露（未明）</strong></li>
<li>用户可以通过调整浏览器设置或者安装隐私保护插件，选择不发送或者干脆伪造一个来源。</li>
</ul>
<h2 id="HTTP_请求类型">HTTP 请求类型</h2>
<p>这一块比较清楚，但是其中包含的各种问题有一些之前没有想到过。在此简单列举：</p>
<ul>
<li>GET 本来RFC 只要求GET 只用于索取信息，但现在浏览器和服务器基本上都依靠GET 来更多的操作。同时，Range 请求头域代表非连续请求字段，也叫断点续传。</li>
<li><strong>POST</strong>，将客户端提交的信息传递给服务端，由于POST 的动作，可能带来持久性的副作用，所以浏览器在重载包含POST 方式的数据时，浏览器都会健身的向用户确认。但POST方法，有很多服务器是默认拒绝的。</li>
<li><strong>HEAD</strong> 和GET 方向类似，但只返回头域，一般是用来自动化测试等。</li>
<li><strong>PUT</strong> 向服务器特定URL 上传文件，但是大部分浏览器都不支持该方法，一般使用POST 完成。同时，某些服务器在配置上的错误，可能导致支持PUT 请求，这也会产生安全问题。</li>
<li><strong>OPTIONS</strong> 元数据请求，返回其所支持的所有方法列表。在提议阶段的跨域请求授权协议的基础。</li>
<li><strong>DELETE</strong> 与PUT 类似。</li>
<li><strong>TRACE</strong> 主要用于在安全测试中，揭示远程网络的内部架构的。所以，这一般用户用不到，一般被禁止了。</li>
<li>CONNECT 通过HTTP 代理服务器建立非HTTP 类型连接时使用。该指令不能直接发送给目标服务器<br>，如果特定服务器上不小心设置了支持CONNECT，可能会造成安全问题，攻击者可以通过他进一步攻击。</li>
</ul>
<h2 id="HTTP_响应码">HTTP 响应码</h2>
<p>同上，此处也做过详细解释，RFC 文档里列出了几十种状态码，但是常用的大约15种，而其他的一般是为未来准备的。这些有用的，列举如下：</p>
<ul>
<li>200 OK。没什么说的</li>
<li>204 No Content。无内容，说明请求已经执行成功，但是不做任何响应。</li>
<li>206 Partial Content。部分内容，根据Range 设置返回部分请求内容。</li>
<li>301 Moved Permanently。永久移动。</li>
<li>302 Found。 找到</li>
<li>303 See Other。 参见其他。以上三个响应码都意味着，重定向同时给出新地址，一般会在Location 响应头指出。如果是POST 请求，一般会替换成GET 方法，去除POST 数据体部分，并重新发送一次。</li>
<li>304 Not Modified.无变化，告诉请求者现在请求的文档和之前请求的没有变化，该响应信息会根据If-Modified-Since 头域的设定，对最后修改时间进行条件判断。</li>
<li>307 Temporary Redirect 。 临时重定向，与302类型，但是307 方法下，浏览器不会吧POST 重置为GET 方法。</li>
<li>400 Bad Request.不合规范的请求，服务器不愿或者不能做出回应，更详细的有 411 Length Required。405 Method Not Allowed.414 Request-URL Too LOng.</li>
<li>401 Unauthorized 未授权。</li>
<li>403 FOrbidden.禁止访问。文件存在但是不允许访问。</li>
<li>404 Not Found. 文件找不到</li>
<li>500 Internal Server Error 内部服务器错误，503 Service Unavailable 服务不可用。 </li>
</ul>
<h2 id="持续会话和分段数据传输">持续会话和分段数据传输</h2>
<p>持续会话应当注意，使用KeepAlive 会话时，响应端要包含一个Content-Length 头域，用于判断还有多少数据，有可能遇上拆分漏洞，也是前边所提到的[CR][CRLF]等等的处理品混乱。</p>
<p>对于分段数据传输，RFC 提供了 Transfer-Encoding:chunked 功能，协议里讲，只要可能，产生的数据立刻作为部分内容先发送出去，单独传输的每部分长度，都以16进制整数标识放在一个单独的行里，但是整个文件的长度是不确定的，知道出现下一个0字节标志整段结束。</p>
<h2 id="缓存机制">缓存机制</h2>
<p>RFC 里说，如果没有其他服务器端指令，客户端可以默认装若干的GET请求的HTTP响应码进行缓存，只要请求方法和URL 一致。</p>
<p>当响应被缓存后，客户端都会在重用之前判断是否需要验证和重载内容。通过Data/If-Modified-Since 和 ETag/If-None-Match 判断是否重用。这些是隐式的缓存机制，存在一些问题，比如我们通过以上两组的搭配，在结合Cache-Control: private ，能方便的获得浏览器在一段时间内的访问规律和习惯。甚至，如果讲一个字符串标记嵌入和缓存的JavaScript 文件中，然后在访问该文件时候，如果请求头里包含了缓存条件，一律答复 304 Not Modified 。</p>
<p>为此，服务器更倾向于使用显示的HTTP 缓存指令。但是HTTP/1.0 和 1.1之间的处理方式有不同。</p>
<p>1.0中提供的是Expires响应头，判断Expires He  Date 之间的联系，文档没有详细的说明，不同的浏览器处理不同，FireFox，Opera 根据两者的差值，其他浏览器则是Expires和缓存服务器的系统时间进行相比。</p>
<p>同时，1.0中还提供一个Pragma: no-cache ，代理服务器如果收到该请求头，就会重新抓取。</p>
<p>1.1 中，则是在Cache-Control 中承载缓存指令，有四种区域：<strong>public</strong> 可以被公开缓存的文档。<strong>private</strong> 代理服务器不得缓存文档。<strong>no-cache</strong> 可以被缓存，不能被重用（仅能用于后退前进）。<strong>no-store</strong>, 不缓存。</p>
<p>1.0 和 1.1 处理方式的不同，造成了服务器和客户端在处理上，必须两者都兼容。</p>
<p><strong>HTTP 缓存带来的安全问题</strong></p>
<p>攻击者可以通过拦截对某些URL 的请求，想受害者返回被篡改，并且长期缓存的请求内容，这样收到污染的浏览器缓存如何在受信任的网络上被重用，被注入的内容可能就出人意料的重新浮现。甚至，攻击者可以精心选择一些敏感域，然后在其他上下文环境中再引用这些域的内容。</p>
<h2 id="HTTP_cookie">HTTP cookie</h2>
<p>cookie 是四种全局授权方式之一，其他三种是HTTP 认证，IP检查， 客户端认证。</p>
<p>cookie 是通过Set-Cookie 响应头进行设置的,其基本参数之前列举过，现在简单陈列：</p>
<ul>
<li>Expires Cookie过期时间</li>
<li>Max-age  另一种建议的过期时间</li>
<li>Domain  Cookie 的有效范围，与安全会有关联。</li>
<li>Path ，允许Cookie 在特定的请求路径内有效</li>
<li>Secure 禁止以非加密形式传输Cookie.</li>
<li>HttpOnly 禁止JavaScript的doccument.cookie API 的方式读取Cookie.</li>
</ul>
<h2 id="HTTP_认证_和_SSL">HTTP 认证 和 SSL</h2>
<p>HTTP 认证现在很少有人用了，而且会有401钓鱼的风险。</p>
<p>SSL 部分参见另一篇博文。</p>
<p>值得注意的是，出于方便和降低成本的考虑，某些机构现在只需要一张信用卡，在目标服务器放一个用于完成验证的文件就能够获得证书。这种做法导致了证书中除了cn 和 subjectAltName 两个字段，信息都不再可信了。</p>
<h2 id="安全工程">安全工程</h2>
<p>处理Content-Disposition 头域中用户提供的文件名，如果不需要非拉丁语系的文件名，通常只保留字母数字和<strong>. \ - _</strong>  ，其他字符一概移除。为了保证用户免遭有害或者欺骗文件，至少保证文件名的首字符是字母或者数字，并把所有最后一个句号外的其他句号一律用其他字符代替。</p>
<p>如果而需要用到非拉丁语系的文件名，按照RFC 文档昨说，根据浏览器的情况使用百分号编码的URL 形式作为文件名，确保过滤控制字符(0xxx~0x1f) 和对任何分号，反斜杠和引号进行转义。</p>
<p>在处理<strong>HTTP cookie 里的用户出入信息</strong>，应当对字母和数字以外的所有字符进行百分号编码，或者干脆使用base64, 因为那些引号，控制字符(0x00~0x1f)，高位字符（0x80~0xff），逗号，分号，反斜杠都可能导致Cookie注入，或是当前Cookie 含义发生变化。</p>
<p>在发送<strong>用户提供的Location 头域</strong>，应对提供的URL 进行解析和规范化处理，确保URL 对应协议的允许的白名单上，以及重定向到的指定主机是安全的。同时确保任何控制字符和高位字符得到了恰当的转义。</p>
<p>在发送<strong>用户提供的Redirect 头域</strong>，遵从与Location 主机头一样的建议，注意在这里，分号也是不安全的，而且没办法的进行可靠的转义，而分号在某些特定的URL 里又有特殊的含义，应当干脆杜绝这样的URL 或者对分号进行百分号编码。</p>
<p>构建其他类别的用户输入请求或者是响应时，一定要<strong>进行语法检查，排除头域可能导致的副作用</strong>，重点注意控制字符，高位字符，逗号，引号，反斜杠，分号。<strong>创建新HTTP客户端，服务器或代理时</strong>，一定要注意上述那些问题。</p>
<hr>
<p>HTTP 这一部分，算是吧基础的知识又一次串了一遍，很明显的，所谓Web 安全问题，都是围绕 HTTP展开的，因为任何web的交互，基本上都需要使用HTTP 协议。本篇提到的，我觉得迷惑点最多的还是混乱的编码模式，由于很难搞清楚各种编码的真谛，何处支持何种编码，拒绝何种编码，才能真正的解决那些通过各种构造形式的攻击，所以，关于编码，后边我还会再做讨论，当然，我感觉这是一个漫长的工作量，因为在任何一个犄角旮旯里，都会藏着对Web 致命威胁的点。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="许许多多小细节">许许多多小细节</h2>
<p><strong>HTTP/0.9</strong></p>
<p>0.9的版本虽然看起来和1.0 1.1只差了一点点，但实际上，0.9只能算是HTTP 一个非常原始的版本。<strong>完全没有为客户端和服务器提]]>
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从URL 开始 --《The Tangled Web》]]></title>
    <link href="http://yoursite.com/2016/04/29/%E4%BB%8EURL-%E5%BC%80%E5%A7%8B-%E3%80%8AThe-Tangled-Web%E3%80%8B/"/>
    <id>http://yoursite.com/2016/04/29/从URL-开始-《The-Tangled-Web》/</id>
    <published>2016-04-29T03:19:19.000Z</published>
    <updated>2016-04-29T03:20:59.000Z</updated>
    <content type="html"><![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br><a id="more"></a><br>这也是一本疯狂的吐槽书，在作者的眼里，整个Web 应用界，混乱不堪，看似繁荣却处处都是破绽，而且确实如此，因为作者随随便便便发现了数百个安全漏洞。</p>
<p>所以我以逐章节的形式，写自己的读书笔记，希望在阅读和反刍的过程中，收获到更多的信息，构建起更完善的知识体系。</p>
<h1 id="这里放一个前言">这里放一个前言</h1>
<p>Web安全为什么存在，是因为它沉寂的太久，而又崛起的太快，崛起的过程中，各方势力互相角力，争议不断，浏览器的厂家拥有强势的决定权，W3C 理事会又缺乏足够的控制能力，组织内部又常常意见不统一，造成了Web 一路发展过来，有许多千奇百怪的新东西出现又消失。再加上天然的Web 的强交互本质，其在安全上存在的风险是巨大的。</p>
<p>首先，用户是Web 应用的使用者，而大部分缺乏安全素养的个人用户，在使用Web应用的时候，怎么可能会去关注那些林林总总的安全风险问题，所以，首先web应用不应当寄希望于将安全的决策权交给用户，然而这一点上浏览器上做的并不好，虽然在逐渐改进，但是有很多忽然跳出来的选项，跳出来的专业词汇，对于小白用户来说就是一个灾难，大多数情况，小白一般就会忽略这些安全风险提示，直接操作到最后。</p>
<p>其次，Web 运行环境难以隔离，各类相关数据杂糅在一起难解难分，在其他领域，数据对象，用户层应用，操作系统内核之间界限清晰，每个应用程序的进程各自独立，相互通信，输入输出都要靠系统内核进行调配。然而在浏览器中，却不存在这样的隔离，<strong>文档和代码交融在一起，无关的应用之间无法完全隔离，因为他们常常使用了相同的全局JavaScript运行环境</strong> ，这也就造成了诸如跨站，CSRF等等的攻击。</p>
<p>同时还有一些不言而明的缺陷，比如缺乏一个统一的安全体系，在浏览器领域，<strong>同源策略</strong>算是他的一个核心安全范式了，但是这种同源策略仍然是问题多多的，比如复杂的使用场景（JavaScript DOM访问， XML HttpRequest API，HTTP Cookie, 本地存储API， FLash,java插件等等等）。比如跨浏览器交互的问题，比如客户端和服务端的区别逐渐模糊，会在如今安全仍然非常脆弱的情况下，增加复杂度，也使得设计层面更加混乱，进一步增加了风险。</p>
<h1 id="URL_开始">URL 开始</h1>
<p>我们都知道一条URL 对应的是Web 服务器上某个独一无二的资源，在简短的一行长度里，我们希望浏览器和服务器能够获取足够的信息量，RFC 文档为URL 制定了一系列规则，好让一个URL 里可以携带更多信息，所以五花八门的功能和内容也会爬上URL， 而此时由于繁多的URL 花样加上各种浏览器的不同解读方式，也让其漏洞百出，有无数安全的隐患。</p>
<p>为了让URL 拥有更多功能，于是有了伪URL ，它不是资源，而是包括了一些功能，诸如脚本引擎，集中特别的文档渲染模式等功能。但是由于URL 本身机制上的疏漏和浏览器对协议的解析机制的不同，带来了诸多安全问题。具体RFC 文档可参见，<strong>RFC3986</strong>，以及RFC 1738，2616等次要文档。</p>
<h2 id="URL_结构">URL 结构</h2>
<p>在之前的笔记里，已经整理HTTP 里的大部分内容，其中就包括URL 部分，所以一个典型的结构是：<br><strong><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></strong></p>
<h3 id="协议名称">协议名称</h3>
<p>这是第一个会出问题的地方，IANA 维护了官方认可的有效URL 地址，如http,https, ftp, 等几十项，而实际上浏览器会支持一些额外的协议，如data: , javascript:  这些都会带来安全问题。</p>
<p><strong>（此处应插入更详细解释）</strong></p>
<p>在RFC 1738 定义中，要求绝对URL 在冒号之前只能出现字母，数字，「+」 ，「-」 , 「.」。但是在实际上各个浏览器都有一些奇怪的支持和不支持方式，在书中列举的例子，我偷懒复制一下别人写的思维导图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618519826666.jpg" alt=""></p>
<p>实际测试下，我手动构造一个HTTP 请求，在协议头这个部分，他也会忽略掉空格0x00这样的字段，比如ht%20tps://www.baidu.com/index.html 仍然是能够正常解析的，我想这应该是服务器方面解析的原因了，目前不知道这上边编码的混乱如何利用制造安全问题。</p>
<h3 id="层级URL_标记符号">层级URL 标记符号</h3>
<p>仍然是我们的RFC 1738 要求我们的绝对URL 应当包含’//‘，如果没有这个东西，后边的URL 就无法正常解析了，只能把他们看成一个含糊的与某个协议有关的内容了。</p>
<p>然而文档里包含了很多含混不清的东西，比如如果一个费层级结构的URL 带有了// ，如何处理，同时如果一个协议没有带//该如何解析，这些在1738 文档里都没有讲清楚。最常见的就是http:www.google.com这样的结构，或者是javascript://www.google.com/%0Aalert(1)。不同的浏览器都有各种各样的解释方式。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618533600523.jpg" alt=""></p>
<h3 id="访问资源的身份验证">访问资源的身份验证</h3>
<p>这一块貌似是没什么重点内容了，直接挂别人的思维导图，略过：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618534589822.jpg" alt=""></p>
<h3 id="服务器地址">服务器地址</h3>
<p>这里就是放域名或者IP地址的地方，IP还有IPv4 的，或者是放在方括号里的IPv6。RFC 要求规范的IP地址写法，然而大多数应用都支持八进制，十进制，十六进制的写法，甚至还可以把其中几个或者全部8位元数据拼在一起转成单个整数的写法。所以实际上一下几个地址是一样的：</p>
<ul>
<li><a href="http://127.0.0.1/" target="_blank" rel="external">http://127.0.0.1/</a></li>
<li><a href="http://0x7f.1/" target="_blank" rel="external">http://0x7f.1/</a>  先以16进制表示标准写法的第一个八位元，剩下三个按照16进制然后拼在一起，然后再整体转换成一个十进制的数字，好绕。</li>
<li><a href="http://017700000001/" target="_blank" rel="external">http://017700000001/</a>  以0为前缀，后面是把全部4个8位元数据的十六进制拼在一起，同意转换成单个八进制整数。</li>
</ul>
<p>大部分浏览器都会忽略出现在URL 内且数值范围在 0x0a~0x0d 和 0xa0~0xad之间的控制字符。因为这些是换行符等等特殊字符。</p>
<h3 id="服务器端口">服务器端口</h3>
<p>这里可以指定端口号，作者说这里会造成一个安全问题，就是我们可以用浏览器向人以网络服务发送攻击者提供的数据，尽管浏览器并不支持这些服务的协议。作者举得例子虽然知道是什么，但实在是不知道这怎样引发安全问题，作者说后边会详细说，然而宝宝粗略的翻阅后边，没发现哪里有讲，等我找到了，我再回来补上。</p>
<h3 id="层级的文件路径">层级的文件路径</h3>
<p>这一块不用做过多解释，他是直接从UNIX 目录语义拿过来的，所以也会出现/../这种路径，作者没有提其中的安全问题，但这一块大约是安全问题比较多的，通过/../可以向上搜索文件，如果服务器没有适当的设置权限，或者是对此类的请求进行过滤的话，就有可能引起文件泄露。</p>
<h3 id="查询字符串">查询字符串</h3>
<p>用于把一串非层级格式的任意参数传递给由前边路径对应的资源。关于这一块的格式，RFC 文档里都没有任何强制性的规定，所以作为浏览器，或者是服务器，它可以以任意喜欢的方式去处理和解析。这也是在URL 上存在注入的原因之一，通过在URL 里嵌入脚本，企图注入路径上的文件，达到攻入的效果。</p>
<h2 id="保留字符，百分号编码">保留字符，百分号编码</h2>
<p>为了不破坏URL 语法，一些符号需要保留：<strong>: / ? # [] @</strong><br>同时RFC 也规定了若干底层分隔符，这些符号留给上层协议或者具体的应用去实现：<strong>! $ &amp; ‘ () * + , ; =</strong></p>
<p>以上这些都是原则性的，但是仍然允许应用有合适的使用方法，那就是对这些字符进行编码，也就是我们常说的百分号编码或URL编码，以一个百分号加上字符的ASCII编码对应的2位16进制数字替换这些字符。比如/ 编码成%2F，百分号本身也会被编码成%25,查阅wiki， 列表如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618914319078.jpg" alt=""></p>
<p>值得注意的是，中间程序在处理URL 的时候，不应当对这些URL 保留字符进行编码，以免传递下去的时候改变了URL 的含义。</p>
<p>另外，虽然禁止，但如果接收到这样的字符，浏览器方为了保证高容错率，一般都会有一套处理方式，但是RFC文档中没有明确说明，所以各家浏览器处理起来完全自由发挥。</p>
<p>同时，RFC 还规定了一批非保留字符（这个听起来有点莫名其妙了），包括字母，数字，- . _ ~ ，意思大概是说，只有这里边的字符，以及出现在正确位置的保留字符，才能够使规范的URL。但是规定里并没有说不可以对非保留字符编码，出现在URL。所以对这些保留字符进行编码，其表示的效果仍然是一样的，例子如下：</p>
<ul>
<li><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></li>
<li><a href="http://%65ample.%63om/" target="_blank" rel="external">http://%65ample.%63om/</a></li>
<li><a href="http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/" target="_blank" rel="external">http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/</a></li>
</ul>
<p>对此可以在浏览器中进行尝试，完全一样的效果。当然这种编码也是因为攻击的一种方式。而一般的，浏览器会在地址栏直接进行强制解码，让这些非必要的编码字符以规范化形式展现。</p>
<p>同时，还有一些，既不在保留字符，又不在非保留字符，RFC 文档的描述有一定的缺失，此时的处理就要看浏览器了，这里直接上图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618924205141.jpg" alt=""></p>
<p>另外，在非正常的US-ASCII 编码问题上，浏览器的解决之道各种混乱，在家这各种编码规范鱼龙混杂，这里我还没有完全搞清楚，此处留坑。</p>
<h2 id="常见_URL_协议及其功能">常见 URL 协议及其功能</h2>
<p>这里讲讲协议的两三事：</p>
<h3 id="浏览器本身支持的，与获取文档有关的协议">浏览器本身支持的，与获取文档有关的协议</h3>
<p>这就是最基本的浏览器内部直接处理，通过特定的传输协议，获取指定文档内容，通过常规的内核解析引擎的逻辑处理。最常规的协议，http,https,ftp等。</p>
<h3 id="第三方应用和插件支持的协议">第三方应用和插件支持的协议</h3>
<p>当浏览器匹配到这个协议的时候，会将处理转交给相应的第三方应用或者插件上，比如arobat:,callto: ,等一票调用第三方应用的协议，大多数情况来说，这些协议对于发起他们的Web 应用本身没有安全性的影响，但是那些第三方协议的处理程序往往是漏洞百出，并有可能导致操作系统被入侵。</p>
<h3 id="未封装的伪协议">未封装的伪协议</h3>
<p>这些伪协议，是为了访问浏览器脚本解析引擎和某些内部功能的，不需要从远程获取数据，同时一般也无法通过互联网访问到。如最常见的 javascript：，data:(不需要额外的网络请求，创建一个短小的内置式文档),这两个都是高危险的协议。</p>
<h3 id="封装过的伪协议">封装过的伪协议</h3>
<p>这类特别的伪协议，可以放在任何的URL 前面，只是将取回的内容强制进行特殊的解码或者渲染显示。比如最常见的查看源码，view-source： 同时其他浏览器还有一些各自支持的伪协议：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-29-14618948022474.jpg" alt=""></p>
<p>在这种伪协议的方式下，会隐藏最后实际有浏览器处理的真是URL ，比如 view-source:javacript: 后边跟恶意代码，就会达到攻击的目的。或者说，微软的mhtml 协议，会护绿服务器返回的HTTP 内容设置指令。</p>
<p>最后要说的是，这些协议里暗藏各种杀机，而简单的设置黑名单又很难完全杜绝，因为攻击者可以对其进行各种各样的变形，如加上制表符，将JavaScript 编程 VBScript等等，都同样会触发安全问题。</p>
<h2 id="相对URL_解析">相对URL 解析</h2>
<p>RFC里定义了，URL 字符串不是以有效协议名开始，后边没有跟冒号，或没有// ，都是相对URL。按道理讲，这讲的很明确了吧，如果有上下文环境，那就放在上下文环境里构造成安全的相对链接，如果没有正确的上下文环境，那就拒绝访问。</p>
<p>然而，事实上并没有看起来那么轻巧，各种浏览器的具体实现千差万别，有效协议名称的字符集又各不相同，以及各种替代// 的做法出现，这时候，在处理上就应当小心翼翼，因为随时可能会有黑客构造出一个URL 的变形，对你的文件资源进行攻击。</p>
<p>下面有一些情况：</p>
<p><strong>有协议名称，没有授权信息</strong></p>
<p>如： http:foo.txt 这是RFC 文档早期的疏漏，规范认为这种URL是一个无效的绝对地址，但是，提供的解析算法又会对这种地址有一些含混的解释。在现在的地址解析算法中,这种形式的URL ，协议，路径，查询字符串或者片段ID以URL 为准，授权信息以引用页面为准。这个可以在HTTP 构造包时候进行尝试。</p>
<p><strong>没有协议名，但有授权信息</strong></p>
<p>如： //example.com 这也是个奇怪的写法。此时的处理方式一般是，保留当前页面的协议，字符串作为新的授权信息字段。这个好理解。</p>
<p><strong>没有协议名，没有授权信息，有路径</strong></p>
<p>如： ../notes.txt 这里要用到一些常见的处理方式了，如果开头没有/ ，要添加到引用URL 最右边的的/ 后边，而如果初始路径形如 <a href="http://example.com/files/index.html" target="_blank" rel="external">http://example.com/files/index.html</a> ，则需要将其部分砍掉，拼接路径。</p>
<p><strong>只有片段ID</strong></p>
<p>如 ：#bunnies 这种情况，除ID 外，全部信息原封不动引用，然后替换片段ID 部分。通常这样的 构造，不会让页面重新加载。</p>
<h2 id="安全工程指导">安全工程指导</h2>
<p>如果要构建用户用户输入的全新的URL 时候，一定要慎重：</p>
<p>如果允许用户构造URL 的路径、查询或者片段ID 部分，应当注意，如果其中一部分不能正确的的转移，就有可能会产生意外的结果。所以，最好的做法是，如果要插入攻击者能控制的字段值，应当对除了字母和数字，都进行百分号编码的转义。当然，这种方法也只是部分的解决了问题，还有一些二次转义等绕过的问题。</p>
<p>如果允许用户提供协议名称或者是授权信息部分数据：这里会造成严重的代码注入问题，这时候就应当设置合理的URL 过滤器了。</p>
<p>一些常见的URL 过滤方式：</p>
<ul>
<li>相对URL ，直接禁用相对URL ，避免不必要的麻烦。 </li>
<li>协议名称，建议直接使用白名单模式，因为使用黑名单不知道会漏掉那些漏网之鱼。</li>
<li>授权信息部分，主机名部分应当只包含数字，字母，-和. 在他的后边只能跟<strong>/ ? #</strong> 或者字符串结束符号。允许其他的任何数据都会带来风险。<strong>如果需要检查主机名，确保合理的使用从右往左的截取匹配模式</strong></li>
</ul>
<p>而如果需要从接受的URL 那里进行参数解码，注意，任何从URL 里获取到的值，准备放入数据库查询前，或者是拼接成新的URL前，一定要做好过滤，这些值不一定是安全的，随时可能造成安全问题。</p>
<hr>
<p>至此，URL 部分写完了，但是中间还是留存有许多坑，后边还需要在这些坑上做修补，对细节更加理解。URL 存在的安全问题，应该是较为显眼的攻击了，几年前也许这些攻击有如家常便饭，现在在安全编码的规范下，很多人都会更加关注URL 上的问题，所以在URL 上做文章的几率也在逐渐变低。</p>
<p>所以，联系到我之前做数据挖掘方向上的网络安全分析，如果单纯的拿到服务器的日志，（对于服务器的日志格式，《HTTP权威指南》中有一定介绍，各家服务器也支持自定义）拿到默认的数据格式的数据的话，可以构造的特征值，除了时间分析，频率分析，大概也只有URL 了。虽然URL 藏有非常多的玄机，但在处理上千变万化以及莫名其妙，直接处理都有难度的情况下，还试图通过挖掘的形式直接找到玄机，可能还是不够的。所以，为了能够抓取到最够有用的信息，我们还需要在服务器上获取更多的信息，如对系统调用的日志，如每次发包的的协议头部分内容，甚至还有可能要分析实体部分。当然，目前有一个清晰地轮廓，但是内里确是模糊的，在继续看下去的过程中，应该会有更多的收获。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>—《The Tangled Web: A Guide to Securing Modern Web Applications》</p>
<p>这本书看了之后觉得似乎只是晃过一眼，虽然里边讲的林林总总的东西，之前都有接触和学习过，但是作者总是会点到一些这些东西的核心问题。这是一本很牛X的书，二百多页，能读出来八百页的感觉。作者也显示出了超级深的功底，web安全方向，涉及的内容非常宽泛，而作者反而还能够处处设计，且没什么废话，处处点到核心。所以，细读这本书，我是想找到作者每一个提到的部分的微言大义，将其收获扩展到最大。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次简单的缓冲区溢出实验]]></title>
    <link href="http://yoursite.com/2016/04/27/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2016/04/27/一次简单的缓冲区溢出实验/</id>
    <published>2016-04-27T02:11:14.000Z</published>
    <updated>2016-04-27T02:11:14.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP再详解]]></title>
    <link href="http://yoursite.com/2016/04/27/HTTP%E5%86%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/27/HTTP再详解/</id>
    <published>2016-04-27T02:05:51.000Z</published>
    <updated>2016-04-27T02:07:29.000Z</updated>
    <content type="html"><![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br><a id="more"></a></p>
<h1 id="概述">概述</h1>
<p>本部分内容较为笼统，直接快速跳过，只简述极少内容。</p>
<h2 id="版本协议">版本协议</h2>
<ul>
<li>HTTP/1.0: 使得包含图片的web页面和交互表格可以实现。</li>
<li>HTTP/1.0+: 包括持久keep-alive，虚拟机支持，代理连接被加入。</li>
<li>HTTP/1.1 校正HTTP设计中的结构缺陷，明确语义，性能优化。</li>
<li>HTTP/2.0: 关注性能的提升，更强大的服务逻辑远程执行框架。</li>
</ul>
<h2 id="Web_结构组件">Web 结构组件</h2>
<p>Web 上比较重要的应用：</p>
<ul>
<li>代理，中间实体</li>
<li>缓存，HTTP仓库，常用页面的副本保存在离客户端较近的地方，CDN。</li>
<li>网关，帮助连接到特殊的Web服务器,HTTP/FTP 网关。</li>
<li>隧道，HTTP报文进行盲转发的特殊处理，SSL。</li>
<li>Agent代理，发起自动HTTP请求的半智能Web 客户端，爬虫。</li>
</ul>
<h1 id="URL">URL</h1>
<p>这是在研究WEB 安全中的重要的内容，在我们抓取到的包内容中，包含非常多的信息。</p>
<h2 id="URL_结构">URL 结构</h2>
<ul>
<li>第一部分是URL 方案，scheme，方案可以告知Web 客户端怎样访问资源。常见例子中，URL 说明要使用HTTP 协议。</li>
<li>URL 第二部分,host 主机 ，www.google.com ，指服务器的位置，也就是资源位于何处，此处通过DNS 解析可以解析到其IP 地址。</li>
<li>URL 第三部分，比如/seasonal/index.html ，是资源路径，说明了请求服务器上哪个资源。</li>
</ul>
<p>其重点在于第三部分，第三部分可以承载URL 的语法，很多的入侵行为也出现在第三部分。</p>
<h3 id="URL_语法">URL 语法</h3>
<p><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
<p>以上是一个URL 的通用格式，包含9部分内容。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609000091165.jpg" alt=""></p>
<h2 id="编码机制">编码机制</h2>
<p>为了避开安全字符集（US-ASCII）表示法带来的限制，为URL 设计了一种新的编码机制，通过一种『转义』表示法来表示不安全字符，包含一个百分号和两个表示字符ASCII 码的十六进制。</p>
<p>同时，保留了一些有特殊含义的字符，这些字符与某些协议或网关会产生混淆，所以应当注意，在将其用于保留用途之外的场合时，应当对其进行编码。其中有：<strong>% / . .. # ? ; : $,+ @,&amp;,= {}|\^~[]’ &lt;&gt;”</strong></p>
<p><strong>URL 包含的内容丰富多样，但是这些字段更多的信息，在后边才会介绍到，在这里，了解了URL 的基本格式和编码机制已经基本足够，而其中包含的字段和意义，再后边会有更详细的介绍。</strong></p>
<h1 id="HTTP_报文流">HTTP 报文流</h1>
<h2 id="报文流">报文流</h2>
<p>报文的流动方向和基本的格式在此不再过多介绍，因为这一部分属于基础内容，在所有的内容中都会接触，无需记录也不会忘记，这里简要记录一下：</p>
<ol>
<li>method 方法： 如GET，HEAD，POST 等。</li>
<li>request-URL : 命名请求的资源。</li>
<li>version: HTTP 版本。</li>
<li>status-code: 状态码，描述请求过程中发生的情况，后边会有详述。</li>
<li>reason-phrase: 原因短语，仅用于人阅读，机器忽视，属于状态码的可读版本。</li>
<li>header： 有多个键值对，以一个空行结束CRLF。</li>
<li>entity-body： 实体部分，以一个空行结束。</li>
</ol>
<h2 id="起始行">起始行</h2>
<p>起始行可以分为请求行和响应行，其起始行的内容不同。对于起始行，其起始行包含有method, request-URL,version。一些常见的方法有：</p>
<ol>
<li>GET， 获取一份文档</li>
<li>HEAD，获取首部</li>
<li>POST，向服务器发送需要处理的数据</li>
<li>TRACE，对可能经过的代理服务器传送到服务器上的报文进行追踪</li>
<li>OPTIONS，决定可以在服务器上执行哪些方法</li>
<li>DELETE，从服务器上删除一份文档</li>
</ol>
<p>GET，HEAD 方法被认为是安全的，是因为这些方法不会再服务器上产生什么结果，而像POST 方法，会提交信息在服务器上，就会执行一系列动作。而安全方法并非说不会执行服务器动作，而是当出现可能不安全行为的时候，会发出警告，这些由用户决议。</p>
<p><strong>HEAD</strong>：响应中只返回头部，不返回实体，使用HEAD，可以在不获取资源的情况下了解资源的情况，判断类型等；通过查看响应状态码，确定某对象是否存在；通过查看首部，测试资源是否被修改。</p>
<p><strong>PUT</strong>： 该方法是向服务器写入文档，其语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的文档，如果已存在，就替换之。执行PUT 请求，需要先登录。</p>
<p><strong>POST</strong>： 用来向服务器输入数据，一般用来支撑HTML 表单数据，发送给服务器。</p>
<p><strong>TRACE</strong>: 该请求可能会要求穿过防火墙、代理、网关等，都会修改HTTP 内容。而其目的一般用于诊断，一般用于验证请求是否如愿穿过了请求，或者响应链。但是，目前仍然有一些缺点，比如TRACE ，不会区分不同的方法机制。TRACE 请求中不带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<p><strong>OPTION</strong>: 请求web 服务器告知其支持的各种功能，包括通常支持的方法，或者对某些特殊资源支持哪些方法。</p>
<p><strong>DELETE</strong>: 请求服务器删除URL 所指定的资源。</p>
<p><strong>扩展方法</strong>： 其他还有一些扩展的方法，LOCK 锁定资源, MKCOL 允许用户创建资源, COPY 复制资源, MOVE 服务器上移动资源。</p>
<p>对于响应行，则一般会返回状态码，和reason-phrase，状态码是人们规定的一系列表示状态的code.</p>
<ul>
<li>1开头，表示信息提示，目前定义了100，101</li>
<li>2开头的，表示成功，200~206 最常见的还是200</li>
<li>3开头，表示重定向，300~305</li>
<li>4开头，客户端错误，400~415</li>
<li>5开头，服务器错误，500~505</li>
</ul>
<p><strong>100 Continue</strong>:<br>100状态码是HTTP/1.1 之后引入的信息性状态码， 其复杂性和感知价值存在一些争论。他实际上是客户端要向服务器发送一个实体，同时愿意在发送实体前等待100 Continue 响应，所以会发送一个值为100 Continue 的Except 请求首部。但中间会有很多问题，比如服务器如果没有回复响应，客户端一定要一直等着么，所以一般客户端会设置一个超时时间，超过后客户端会直接发送实体。而服务器需要处理几种情况，一种是还没有响应就收到了实体，一种是由于错误等服务器决定结束响应。对于代理，同样应当有处理逻辑，比如兼容问题，比如错误响应等。</p>
<p><strong>200 成功状态码</strong>：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609658165005.jpg" alt=""></p>
<p>成功状态码存在的问题是，hack 可能会伪装成服务器，向客户端发送虚假的成功码，就会劫持客户，所以此处的响应码就可能包含更多的信息。</p>
<p><strong>重定向状态码</strong>：<br>对于重定向状态码来说，也是极有可能对客户端发生劫持的内容，有可能将用户导向错误的地址，以下是更为详细的内容：</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609660727847.jpg" alt=""><br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609661357874.jpg" alt=""><br>从图中可以看出，不同的状态码其实非常相近，其实内部各有区别，对于不同版本的HTTP 都有其处理上的差别，在此不再详述，有需要时再详细识别。</p>
<p><strong>客户端错误码</strong></p>
<p>4开头的状态码大概是用户最讨厌碰见的状态码，这一部分也包含了非常多的内容，同样的，在此不详述，具体见下表。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664853726.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14609664914763.jpg" alt=""></p>
<p><strong>服务器错误状态码</strong></p>
<p>当服务器自身出现错误的时候，就会返回这样的状态码，同样的，不同的状态码也代表了服务器不同的状态。</p>
<ul>
<li>500 Internal server error： 服务器遇到一个妨碍它为请求提供服务的错误。</li>
<li>501 not implemented ： 客户端发起的请求超过服务器能力范围。</li>
<li>502 bad gateway: 作为代理或者网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应。</li>
<li>503 service unavailable： 目前无法提供服务，如果知道什么时候可以提供服务，会在首部包含一个retry-after，告知。</li>
<li>504 gateway timeout: 等待另一个服务器对其请求进行响应超时了。</li>
<li>505 http version not supported： 使用了它不支持的协议版本。</li>
</ul>
<h2 id="首部">首部</h2>
<p>首部其所包含的内容和属性更多，一般来说，可以分为以下几类：</p>
<ol>
<li>通用首部：可以出现在请求报文和响应报文</li>
<li>请求首部：有关请求的信息</li>
<li>响应首部：如题</li>
<li>实体首部：描述主体长度，内容，或资源自身。</li>
<li>扩展首部：规范未定义的新首部。</li>
</ol>
<p>另外，如果想让某行分出多行提高可读性，记得要在多出来的行前加入空格或者tab。</p>
<p><strong>通用首部：</strong></p>
<ul>
<li>Connection 允许客户端和服务器指定与请求/响应连接有关的选项</li>
<li>Date 提供日期和时间的标志</li>
<li>MIME-Version MIME 版本号。</li>
<li>Trailer 如果报文采用了分块传输编码，使用这个首部列出报文拖挂（trailer）部分的首部集合。</li>
<li>Transfer-Encoding 采用的编码方式。</li>
<li>Update 更新的协议和版本。</li>
<li>Via 显示经过的中间节点。</li>
</ul>
<p>强调一点，<strong>Connection</strong>首部是一个逐跳首部，只适用于单挑传输链路，他不会沿着传输链路向下传输，也就是只在两个最近连接中产生作用。<br>同时，还有两个通用的缓存首部，就是允许http应用程序缓存对象本地副本的首部。</p>
<ul>
<li>Cache-Control 用于随报文传送缓存指示</li>
<li>Pragma 另一种随报文传送指示的方式，并不专用于缓存</li>
</ul>
<p><strong>请求首部</strong></p>
<ul>
<li>Client-IP 客户端机器的IP 地址。</li>
<li>From 客户端用户的E-mail 地址。</li>
<li>Host 接受请求的服务器的主机名和端口号。</li>
<li>Referer UA-Color UA-CPU UA-Disp UA-OS UA-Pixels User-Agent</li>
</ul>
<p>后边这些，基本上很少会出现，也很难去寄希望挖掘到有用的信息。</p>
<ul>
<li>Accept 首部为客户端提供了一种将其倾向告知服务器的方式。包括了媒体类型，字符集，编码方式，语言等内容。</li>
<li>条件请求首部，则是为请求加入一些限制。</li>
<li>安全请求首部，对请求进行质询/响应认证，其中Authorization ,cookie, cookie2 首部就是这一类。</li>
<li>代理请求首部。</li>
</ul>
<p><strong>响应首部</strong></p>
<ul>
<li>Age  响应持续时间，从最初创建开始</li>
<li>Public 服务器为其资源支持的请求方法列表</li>
<li>Retry-After 资源不可用时，可响应的重试时间</li>
<li>Server 服务器应用程序软件的名称和版本</li>
<li>Title html文档标题</li>
<li>Warning 警告报文</li>
<li>协商首部，具有一定协商能力，内容包括对某资源可接受的范围和向阳发生变化的时候可选择。</li>
<li>安全响应首部，对应于前边的authenticate,cookie</li>
</ul>
<p><strong>实体首部</strong><br>此处可能会发生安全问题，比如劫持服务器，像客户发送错误的 location ，让客户链接向错误的地址。</p>
<ul>
<li>Allow 可以对实体执行的请求方法</li>
<li>Location 告知客户端实体实际上位于何处，用于接收端定向到资源的位置上去。</li>
<li>内容首部，包括Content-Base（解析主体相对URL 时使用的基础URL），对主体执行的编码方式，自然语言，主体长度，资源位置，MD5，字节范围，对象类型等。</li>
<li>实体缓存首部，对被缓存的实体添加的一些信息，如验证已缓存的副本是否仍然有效等等。其中包括了标记，不再有效的日期，最后一次被修改的时间等。</li>
</ul>
<h1 id="连接管理">连接管理</h1>
<p>本部分，介绍的是HTTP 以及其之下的TCP 的原理和内容，实际上，这也是报文流的过程结构，其中会有许多安全上的危险发生。</p>
<h2 id="TCP">TCP</h2>
<p>先列一下TCP 套接字的常用接口函数，很常用，这是在分析代码时候必要的寻找流程的几个关键节点。</p>
<ul>
<li>s = socket() 创建套接字。</li>
<li>bind(s, <ip:port>) 绑定地址和端口</ip:port></li>
<li>connect(s, <remote ip:port="">) 创建本地套接字和远程主机和端口的链接</remote></li>
<li>listen(s, …) 坚挺</li>
<li>s2 = accept(s) 等待某人建立一条道本地端口的连接。</li>
<li>n = read(s, buffer, n) 从套接字到缓冲区读取n 个字节。</li>
<li>n = write(s, buffer, n) 从缓冲区向套接字写入n 个字节。</li>
<li>close(s) 关闭</li>
<li>shutdown(s,<side>) 关闭TCP 连接的输入或输出端</side></li>
<li>getsockopt(s, ..) 读取某内部套接字配置选项的值</li>
<li>setsockopt(s, ..) 修改某内部套接字配置选项的值</li>
</ul>
<p>以下就是一个正常的HTTP 服务器和客户端交互的过程。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14610508715798.jpg" alt=""></p>
<h2 id="HTTP_TCP_性能考量">HTTP TCP 性能考量</h2>
<p><strong>HTTP 事务的时延</strong></p>
<p>在日常上网过程中，我们时常被龟一样的网速折磨，其中有很多原因，有一部分是HTTP 的事务上的，一部分是TCP 之上的。HTTP上的事务延迟可能的原因有：</p>
<ol>
<li>通过DNS 解析将主机名换成一个IP 可能会花费不小的时间。</li>
<li>TCP 连接的建立时间延迟。</li>
<li>对TCP 报文的解析和处理依靠服务器性能，有一定的时间延迟。</li>
<li>Web 响应时间延迟。</li>
</ol>
<p><strong>TCP相关的时间延迟</strong></p>
<p>此处就进入较为深入的部分了，本来在研究上不需要达到这一地步，但是出于兴趣，做以简要挖掘。</p>
<ul>
<li>TCP 建立握手。</li>
<li>TCP 慢启动拥塞控制。</li>
<li>数据聚集的Nagle 算法。</li>
<li>用于捎带确认的TCP 延迟确认算法</li>
<li>TIME_WAIT 时间延迟和端口耗尽。</li>
</ul>
<p>对于第一点，HTTP 通过保持重用现存连接来解决每次握手花费时间的问题。</p>
<p>低于第二点，不需过多解释，HTTP 为了解决在初始调谐时速度慢的问题，采用长连接，也就是持久连接的方式解决。</p>
<p>对于第三点，Nagle 算法解决的问题，是说TCP 的数据流接口，允许任意尺寸的数据放入栈中，一次一个字节也可以，但是当大量的一字节内容发送，而实际上TCP 为这一字节的内容要装在40字节的标记和首部，造成了性能的严重下降。Nagle 算法就是试图将大量TCP 数据绑在一起，提高网络效率。Nagle 算法的主旨是鼓励网络发送全尺寸段（1500字节），只有在目前所有挂起的分组都被确认了，才可以立即发送非全尺寸段。而其他时间，则是将他们缓存起来，积累到一个全尺寸分组才发出去。</p>
<p>Nagle 算法在优化网络的同时，可能会对HTTP 性能造成一定影响，因为一个小的报文，必须要等到之前所有段都确认了，才可以发送，而这段时间，会有延迟，一般来说，HTTP 会设置参数TCP_NODELAY ,来禁用。当然这里还有很多文章可以做。</p>
<p>对于第四点，在我们TCP 连接的时候，每一个发出去的报文，都期望收到一个很小的确认包，但是因为报文非常小，不值得每次都单独发送，所以有时候延迟确认算法会在一个特定的窗口内将确认包放在缓冲区，等待一个时间窗口内，看能够有输出数据分组发出，将这个确认报文捎带上，如果这段时间里没有，就单独发包。这一点上，本来是为了解决TCP 连接中频繁发小包引起的性能问题而采用的算法，但是HTTP 确实具有明显的双峰特征，就是一端会频繁输出，而另一端只是频繁接收，如果还是使用这种延迟算法，则可能会带来性能上的下降，此时就应当调整和禁止延迟确认算法，来提高性能。</p>
<p>对于第五点，TIME_WAIT 的出现时机应当都很清楚，这个状态一般需要保持一小段时间，通常使用的是<strong>最大分段使用期的两倍，2MSL，通常两分钟</strong>，来确保这个时间段不会创建具有相同地址和端口号的连接。而如果一个服务器是短连接属性的，如果一段时间有较高的访问，就会出现大量的TIME_WAIT 状态，导致端口耗尽，性能急剧下降。一般的解决办法是剪短TIME_WAIT 时间，或者是用虚拟地址，增加更多的连接组合。</p>
<p><strong>提高HTTP 性能的技术</strong></p>
<ul>
<li>并行连接，多条TCP 连接发起并发的HTTP请求。</li>
<li>持久连接，重用TCP 连接，消除连接和关闭的时间延迟。</li>
<li>管道化连接，通过共享的TCP 连接发起并发的HTTP 请求。</li>
<li>复用的连接，交替传送请求和响应报文。</li>
</ul>
<p>对于并行连接，无需过多解释，目前考虑到性能等方面，浏览器一般支持的并行连接数量是4个。</p>
<p>对于持久连接，也就是保持TCP 连接状态，HTTP/1.0+ 上采用的是keep-alive 连接，HTTP/1.1 上采用的是 persistent 连接。关于keep-alive 中有很多信息，但是没有过于复杂的知识点，都是可以理解的内容，不再赘述。</p>
<p>对于管道化连接，他是keep-alive的进一步优化。在响应到达之前，可以将多条请求放入队列，如此连续的以管道化的形式进行传输，可以降低网络上的环回时间，提高性能。<br>注意，为了实现这种高性能，实际上是有一些限制：</p>
<ul>
<li>客户端应确认连接是持久的</li>
<li>HTTP 响应不能失序，否则无法与请求匹配。</li>
<li>客户端要做好随时可能会关闭的准备，以及要重发所有未完成请求的准备。</li>
<li>不应发送产生副作用的请求，如POST。（非幂等请求）<strong>HTTP 的幂等性待搞明白，简单来说就是一次和多次请求带来的副作用应当是一样的</strong><a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html" target="_blank" rel="external">参考文章</a></li>
</ul>
<p>另外，关闭连接也包含了大量的内容，这里我不想深究了，因为在保持连接部分里边的坑就目测很深，关闭连接里边也很深，因为要涉及到冲连接，安全性，数据完整，幂等性这些东西，都会有很多需要处理的内容，待到以后需要用到，再深究吧。简单的说，关闭连接，包括内容有『任意』接触连接，content-length 和截尾操作，连接关闭容限，重试等。</p>
<h1 id="HTTP_结构">HTTP 结构</h1>
<p>这一部分，略过了一些内容，只选择有价值的一部分，另外一些可能会有更深层的信息待挖。</p>
<h2 id="响应实体">响应实体</h2>
<p>响应实体的报文通常包括：</p>
<ul>
<li>描述响应主体MIME类型的Content-Type 首部。</li>
<li>描述响应主体长度的 Content-Length 首部。</li>
<li>报文主体。</li>
</ul>
<p>其中MIME类型负责指示资源的类型，一般服务器会提供魔法分类，或者是自定义分类。</p>
<p><strong>重定向：</strong></p>
<p>一个3xx 的重定向响应一般有如下情况</p>
<ul>
<li>永久删除资源：301</li>
<li>临时删除资源：303 307</li>
<li>URL 增强，一般是重写URL用于嵌入上下文，客户端会根据这个重定向信息重新发起请求。303 307</li>
<li>负载均衡 303 307</li>
<li>服务器关联，Web 服务器可能会有某些用户的本地信息，服务器可以将客户端重定向到包含那个客户信息的服务器上去。 303 307</li>
<li>规范目录名称：也就是规范URL 名。</li>
</ul>
<h2 id="代理">代理</h2>
<p>这是一个和其他部分没有太大联系的门类，其中包含的信息非常的大，在这里，我先留个坑，不花费时间去处理这个内容，留待单开补充。</p>
<h2 id="缓存">缓存</h2>
<p>缓存是解决带宽瓶颈的一个重要的方法，以CDN 为代表的技术仍然是主流。主要解决了网络时延，带宽瓶颈，瞬间拥塞，冗余数据的问题。</p>
<p>缓存包含的技术术语有：命中与未命中（这个很常见），再验证（新鲜度检测）。</p>
<p><strong>命中与未命中</strong><br><strong>再验证</strong>，缓存对缓存的副本再验证时，会向原始服务器发送一个小的再验证请求，如果内容没有变化，服务器会响应304，这个被称作再验证命中。这种方式要与原始服务器进行核对，所以比单纯的缓存命中要慢。</p>
<p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，最常用的是 If-Modified-Since 首部。首部添加到GET 请求中，告诉服务器，只有在缓存了对象的副本，又对其进行了修改的情况下，才发送此对象。对于再验证命中，则返回304，表示仍然新鲜。如果未命中，则像正常响应200.如果已删除，返回404，缓存的副本也将删除。</p>
<p><strong>命中率</strong>，这是一个重要的考量目标，缓存提供服务所占的比率，他与缓存大小，缓存用户兴趣点的相似性，缓存数据的变化或者个性化频率，以及缓存的配置，都影响到命中率。</p>
<p><strong>字节命中率</strong>，由于有些大型对象被访问的次数可能较少，但是由于尺寸的原因，对整个数据流量的贡献却很大。所以，有时候使用字节命中率更加准确。字节命中率表示缓存提供的字节在传输的所有字节中所占的比率。</p>
<p>客户端判断命中和未命中的方法是使用Date 首部，将响应的Date首部值与当前时间比较，如果响应日期比较早，可能认为这是一条缓存的响应，也可以使用Age 首部进行判断。</p>
<p><strong>代理缓存的层次结构</strong></p>
<p>实际上，缓存还存在有层次化的结构，一级缓存二级缓存等，这是为了逐步采用更大，功能更强的缓存来装在更多的用户共享文档。</p>
<p>而更加复杂的，还有网状缓存，内容路由以及对等缓存。可以考虑现在的P2P技术与之类似。</p>
<h3 id="缓存处理的基本步骤">缓存处理的基本步骤</h3>
<ul>
<li>接收，缓存读取请求报文。</li>
<li>解析，提取URL 和首部。</li>
<li>查询，查看是否有本地副本可用，没有就获取一份副本，将其保存本地。</li>
<li>新鲜度检测，如果已有，就验证是否新鲜，如果不新鲜，则请求服务器是否有更新。</li>
<li>创建响应，缓存构建响应报文。</li>
<li>发送</li>
<li>日志</li>
</ul>
<p>下图是一个新鲜的缓存命中<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200094685.jpg" alt=""></p>
<p>以一个更为一般化的流程图做以描述：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14611200650513.jpg" alt=""></p>
<p>服务器可以通过HTT 定义集中方式来控制缓存：Cache-Control ，Expires 首部等等，里边的内容包括max-age，详细的不再纠结。</p>
<p>后边关于缓存还有更多的知识点，甚至还有一些算法，比如使用期的算法，新鲜生存期算法，新鲜度算法等等。</p>
<h1 id="集成点：_网关，隧道，中继">集成点： 网关，隧道，中继</h1>
<h2 id="网关">网关</h2>
<p>网关的概念可以作为某种翻译器理解，抽象出了一种能够到达资源的方法。更形象的讲，网关就是一个门，用用程序可以通过接口请求网关来处理请求，网关提供响应。同时网关可以向数据库发送查询语句，生成动态内容等。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613152822853.jpg" alt=""></p>
<p>Web 网关在一侧使用HTTP 协议，在另一侧则使用另一种协议。例如当网关收到了一个对FTP 资源的请求，客户端实际上发送的是HTTP 请求，而网关则会打开一条到原始服务器的FTP 端口，通过FTP 协议去获取对象。完成之后，将对象放在HTTP 响应中返回给客户端。</p>
<p>再比如，客户端以普通的HTTP 形式浏览Web 内容，而网关可以自动加密用户对话，这是常见的HTTP/HTTPS 安全网关。而另外一种客户端安全加速网关则是反过来的HTTPS/HTTP 网关，这是为了确保在客户端和网关连接中途发生安全问题。</p>
<p>而最常见的网关，则是为了在客户端通过HTTP 通信的时候，能够与服务器端的应用程序相连，这时候就是需要调用服务器上应用程序的API ，来实现应用程序的调用。<strong>最早期的应用程序网关API 是CGI</strong>，而纯CGI 来写的人已经很少了，因为注入ASP，PHP 已经将CGI 包装好，实现了其特性，本质上CGI 就像一个非常简单的协议，人们更习惯使用更加简单易读的PHP 等语言。</p>
<p>在CGI 初始，由于CGI 是分离的，服务器要为每条CGI 请求引发一个新进程，这会极大的限制服务器的性能，为解决这个问题，人们开发的新语言FastCGI ，这个接口模拟CGI，作为持久守护进程运行的，消除了每个请求简历和拆除进程带来的性能损耗。当然实际上，现在还是PHP 这些语言的天下。</p>
<p>时至今天，应用程序和Web服务的接口越来越多，甚至我们也看到了Chrome Book 甚至可以仅仅将一个浏览器就可以作为一个操作系统的入口。这时候，HTTP 其实可以作为一种连接应用程序的基础软件来看待，而此时，将HTTP 协议与其他应用程序的协议之间的协商和接口，都成为了重要的内容。</p>
<h2 id="隧道">隧道</h2>
<p>接上一个话题，刚才说的是通过HTTP 协议，与应用程序之间建立接口，而HTTP 还有另一个用法，就是为应用程序之间建立通信，这就是隧道（Web tunnel）。通过隧道，非HTTP 协议可以在HTTP 协议包装下，穿过只允许Web 流量的防火墙了。</p>
<p>常见的隧道建立方式是通过<strong>Connect</strong> 建立的，CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的TCP 连接，并对客户端和服务器之间后继数据进行盲转发。下图就是以建立SSL 隧道为例，注意看其中的请求，则是以CONNECT 为首，主机号和端口号取代了URI，响应短语经常为Connection Established。</p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613168465645.jpg" alt=""></p>
<p>为什么我们要实现SSL 的隧道呢，因为对于传统的代理服务器，SSL 的信息是加密的，防火墙无法识别，就会被HTTP 防火墙拦截。而实现了隧道化的SSL ，加密数据放入正常的HTTP 报文中，就能通过防火墙了。在隧道的起点用HTTP 封装SSL ，然后以普通HTTP 报文的形式通过防火墙，然后在对报文解封，继续进行普通的SSL 连接。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613176934946.jpg" alt=""></p>
<p>SSL 隧道与我们刚才所讲的网关实现HTTP/HTTPS 有一定的差别。相比于隧道，网关实现方式有几个缺点：</p>
<ol>
<li>客户端到网关之间的连接是普通的HTTP，因为只有普通的http 才可以通过防火墙。</li>
<li>尽管代理是已认证的主体，但客户端无法对远端的服务器执行SSL 客户端认证 X509证书。</li>
<li>网关要支持完整的SSL 实现。</li>
</ol>
<p>同时，隧道为了安全考虑，也需要将代理的认证支持与隧道配合使用，对客户端使用隧道权利进行认证，过程如图。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613179676011.jpg" alt=""></p>
<p>出于对隧道安全的考虑，因为我们在传输过程中，不知道其内容是什么，所以有些人就可能通过诸如SSL 隧道，越过防火墙传递其他流量，包含一些恶意信息等，所以一般情况下，网关只对特定的端口和特定的内容开发端口，如443.</p>
<h2 id="中继">中继</h2>
<p>中继的内容不多，理解为一个没有完全遵循HTTP 规范的HTTP 代理。中继在两个连接之间，只进行盲转发。当然，我们也可以在中继上部署一些简单的过滤，诊断和内容转换的功能。</p>
<p>但是，中继上存在一个严重的问题，它无法正确处理Connection 首部，所以有潜在挂起 keep-alive 连接的可能。因为Connection 它是逐跳首部，只适用于单条传输链路，中继仅仅是盲转发，无法理解，也无法让他沿着链路一直传送下去，但是对于服务器和客户端，双方都以为建立了keep-alive 长连接，但实际上并非如此。所以，就陷入了麻烦。当然，现代的方法，采用了更加智能的判断方式，来消除这一个风险。</p>
<h1 id="Web_robot">Web robot</h1>
<h2 id="爬虫">爬虫</h2>
<p>爬虫是一个有趣的门类，他看起来很简单，似乎也有很多现成的解决方案，但是在实际的场景中，却又会有很多新的问题要解决，爬虫和反爬虫之间的斗争也一直在延续。本质上，在网络上活跃的自动化脚本，都可以叫做爬虫，他们日夜不停的执行着任务，为自己的老板收集大量的有用的内容。</p>
<p>下面是围绕到爬虫的一些必要的内容，当然，这是与HTTP 相关的内容：</p>
<h3 id="连接提取和相对链接标准化"><strong>连接提取和相对链接标准化</strong></h3>
<p>很简单，我们爬去的URL ，有些可能是相对链接，所以我们要根据其父亲结点，将相对链接标准化，处理成能够规范整理的信息。</p>
<h3 id="环路避免"><strong>环路避免</strong></h3>
<p>为了避免出现循环和重复，对那些访问过的URL ，我们要用特殊的结构保存起来，以确保在爬取的是新的URL，一般采用下面这些技术：</p>
<ul>
<li><strong>树和散列表</strong>，使用树形结构和散列表的结构，去寻找已访问的URL，提高了一定的速度，但在空间上仍然是巨大的。</li>
<li><strong>有损的存在位图</strong>，这里用的就是位图的概念，建立一个存在位数组，对每个URL 都转换为一个定长的数字，这个数字对应在数组的位置就是存在位，爬行过之后，该位置就置位。由于URL 潜在数量是近乎无限的，但是给予的空间总是有限的，所以很可能有两个不同的URL 对应于一个存在位，所以就可能会有部分URL 被忽略，所以是有损的。</li>
<li><strong>本地化列表</strong>，URL 列表应保存一份在本地硬盘，防止机器人崩溃，前功尽弃。</li>
<li><strong>分类</strong>，实际上就是采用了爬虫集群，分工的形式对某URL 片进行爬取，个体之间可能还需要相互通信，实现更复杂的功能。</li>
</ul>
<p>注意，不仅在URL 上可能会有环路问题，在文件系统连接上也会存在环路，在目录层次上可能会进入深度无限的假象。比如一个subdir 的链接链接到上层文件夹，就会让层级无限深入下去。</p>
<p>而在爬虫和反爬虫的斗争中，网管甚至还会创造一些虚假信息，他们会发布一个看起来是普通的文件，实际上却是网关应用程序，这是很容易的，当爬虫去请求了这个URL，服务器就会捏造一个新的HTML页面和一个新的虚构的URL ，以此让爬虫在这个看似都不同的URL 陷阱里越陷越深。如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613267668464.jpg" alt=""></p>
<p>在斗智斗勇的路上，爬虫也会进化：</p>
<ul>
<li>规范化URL，以此来避免别名带来的URL 重复</li>
<li><strong>广度优先</strong>，采用此策略，可以降低环路带来的影响，因为不像深度优先一样爬进一个坑里出不来。</li>
<li><strong>节流</strong>， 为防止在一个URL 站点里越陷越深，适当的限制重复的页面总数和对服务器访问总数来截至该操作。</li>
<li>限制URL 大小，某些情况，可能会让URL 无限增长，最简单的办法就是限制一个URL 的长度。一般1kb</li>
<li>URL 黑名单，建立一个列表，维护那些曾经让机器人陷入回路和陷阱的站点列表，所爬取的时候，就绕过他们。</li>
<li><strong>模式检测</strong>，造成环路陷阱的一般都会有一定的模式，比如固定模式循环出现，某组件重复出现超过三次等等。</li>
<li><strong>内容指纹</strong>，这是更加复杂的方法，爬虫爬取某页面，会通过提取部分字节建立指纹，指纹压缩存储起来，爬取新页面的时候，提取其校验和，与指纹库比较，如果以前见过，就不再爬取，这样就避免了仅依靠URL 做判断的方法。</li>
<li><strong>人工审计</strong>，这是最无奈的方法。</li>
</ul>
<h3 id="别名的判断"><strong>别名的判断</strong></h3>
<p>有些时候，同一地址的URL 可能会不同，叫做别名，比如URL 上添加不添加端口号，比如URL 编码，比如使用标签，服务器文件大小写，默认页面写不写，ip地址和域名地址等。</p>
<p>所以在别名的判断时候，有时就会对URL 进行规范，比如加上指定端口，把所有的转义字符用等价字符表示，删除#标签。</p>
<h2 id="爬虫与HTTP">爬虫与HTTP</h2>
<p>一个良好的爬虫，是受网站欢迎的，比如搜索引擎的爬虫爬取网站的基本信息，提供给人们搜索，可以提高网站访问，所以遵循道德准则的爬虫往往是放行的。而一个爬虫在爬取网页时，它也需要像正常请求一个，使用HTTP 请求，请求页面内容，只是在爬取的阶段中，可以在http 的首部告知自己的身份，也可以在Accept 里写明自己想要爬取什么样的内容，图片，文本等。</p>
<p>在使用HTTP 发出请求的时候，应当注意一些细节：</p>
<ul>
<li>一定要携带Host,如果遇到一个服务器提供两个站点，而发送请求没有携带Host， 服务器可能只会返回默认的那个站点。</li>
<li>爬虫辛苦爬到的站点，可能随时会改变内容，爬虫应当对时间戳或者是实体标签进行比较，来确认获取的版本是否升级，这方法类似于缓存查看机制。</li>
<li>对响应做处理，比如状态码，常见状态码，和一些特别的状态码。</li>
<li>实体部分，有些响应的实体中，可能会包含一些重定向等信息，包含在元标签如 http-equiv 等，<meta></li>
</ul>
<p>不良爬虫的特点：</p>
<ul>
<li>失控，访问速度太快，造成站点服务器过载，会被当做ddos攻击的爬虫。</li>
<li>失效URL ，没有更新URL，总是使用失效的URL 向服务器进行访问，也会对服务器的开销造成影响。</li>
<li>很长又错误的URL，同样造成web服务器性能下降。而且这两个都会让审计日志变得杂乱。</li>
<li>不小心访问了私有的URL地址。</li>
<li>保留了一些已经被删除的信息。</li>
</ul>
<p>由于有不良爬虫的存在，但是良好的爬虫仍然是有益的，所以人们约定在服务器文档根目录上提供一个可选的文件，robots.txt ，里边包含了对机器人的一些约束，也提供给良好的爬虫，让其更加方便的爬取信息。所以，一个良好的爬虫，首先要做的就是试图去获取站点的robots.txt 资源，并根据响应码做出下一步的反应，比如200，则拿到robots.txt， 就必须进行解析，依照规则爬取；如果404，说明不受限；如果401或403，表示该站完全不欢迎爬虫；如果503，则应稍后重试；如果3xx，则重定向方向去爬取。</p>
<p>至于robots.txt 的格式，很简单，不再赘述，因为我还没有想做一个站长，而且现在很多成熟的爬虫，会有自动化工具给予采用。而且，现在的站点，为了优化自己让搜索引擎更快的更新站点信息，会提供一个sitemap.txt 的文件，让爬虫直接顺着内容爬取即可，这样双方受益，效率可观。</p>
<h2 id="搜索引擎">搜索引擎</h2>
<p>爬虫有很多终极目的，而搜索引擎可以说是最重要的应用之一。搜索引擎相比于爬虫，还要多提供全文索引，本地内容存储的功能。因为为了给用户提供关键词的搜索，搜索引擎必须对它所搜索到的页面建立一个『全文索引』的复杂本地数据库，用户发送查询请求的时候，他应当在自己的数据库中找到所有的包含该关键词的文档。</p>
<p>更复杂的，搜索引擎还应当对匹配的结果进行排名，这一部分就包含了更多的东西，在这里不是重点了，有机会更深一步的时候，再进行理解。</p>
<h1 id="HTTP，识别、认证、安全">HTTP，识别、认证、安全</h1>
<h2 id="cookie_机制">cookie 机制</h2>
<p>在cookie机制之前，我们还会介绍另外一些识别机制，各有优劣，先列如下：</p>
<ul>
<li>HTTP 首部承载用户信息</li>
<li>客户端 IP地址跟踪，通过IP 进行识别。</li>
<li>用户登录，根据用户认证识别用户。</li>
<li>胖URL， 一种在URL 中嵌入识别信息的技术。</li>
<li>cookie</li>
</ul>
<p><strong>HTTP 首部承载信息</strong></p>
<p>在HTTP 首部中有七个常见可承载信息的首部：</p>
<ul>
<li>From 用户Email.</li>
<li>User-Agent 用户浏览器软件</li>
<li>Referer 用户是从这个页面上依链接条转过来的。</li>
<li>Authorization 用户名和密码</li>
<li>Client-IP 客户端IP。</li>
<li>X-Forwarded-For 客户端IP地址。</li>
<li>Cookie 服务器产生的ID 标签。</li>
</ul>
<p>实际上其中可用的信息实际上是后三个：</p>
<p><strong>客户端IP</strong></p>
<p>首先应说，Client-IP 首部并不一定是存在的，但是我们仍然可以调用诸如 UNIX 下 getpeername 的函数来返回客户端IP ,但是实际上，客户端IP 很难作为识别用户的方式。</p>
<ul>
<li>客户端IP描述的是机器，不是用户。</li>
<li>很多服务商是动态分配IP，每次登陆会得到不同的地址，所以现在利用IP 识别的，也一般仅仅是识别一个IP段，去做某种操作。</li>
<li>有些防火墙会通过NAT 网络地址转换方式，转换成一个防火墙共享IP 来访问。</li>
<li>有些会从HTTP 代理或网关出重新发出TCP 连接。</li>
</ul>
<p><strong>用户登录</strong><br>如果服务器希望在用户提供对站点访问之前，先行登陆，就会响应一个401 状态码，Login Required，然后显示一个登陆对话框，在随后的请求中会添加Authorization 首部。</p>
<p>其实这种方法已经不怎么用了，因为安全性太低了，现在也会出现有401钓鱼的行为，用户的登录信息虽然会加密，但是加密信息实在是太好破了，而且如果劫持了用户的信息，还可以放在自己的首部伪装成用户登录。</p>
<p><strong>胖URL</strong></p>
<p>有些站点利用对URL 添加特定的URL 版本，来追踪用户身份，比如一些商务网站，通过针对每个用户在URL 后边生成特定的标示符，可以实现对用户浏览的追踪。通过胖URL 可以将Web服务器上的若干个HTTP 事务绑定在一个会话和访问上，用户首次访问某站点，生成一个ID ，服务器通过识别ID 的方式，添加到URL 中去，然后将客户端导向到那个胖URL 上去。不论什么时候，只要服务器收到了胖URL 请求，都可以查找那个用户ID 相关的操作，增量状态等，然后重写输出超链接，让其成为胖URL，维护用户ID。</p>
<p>但是，这样的操作，我们也很明显看出了其中的问题：</p>
<ul>
<li>URL 丑陋，不说了</li>
<li>URL 无法共享，因为它包含了特定用户的一些信息。仅在部分情况下可以，就比如邀请人链接，刚好是需要这样的识别。</li>
<li>破坏缓存，每个用户的URL 都生成特定的版本，那么意味着没有公共可访问的URL 需要缓存了。</li>
<li>服务器负荷，重写HTML 和 生成胖URL。</li>
<li>逃逸，如果用户逃离了严格修改的URL 链接，就会失去了他所有的进展。</li>
<li>会话期间非持久，除非用户收藏了特定的URL， 否则用户删除之后，再也找不回来了。</li>
</ul>
<p>当然，胖URL 技术还是有很多应用的，这就要应对许多新的场景，展开更丰富的联想，也可以通过加入其它手段来克服其中的缺点，总之，不要放弃任何一种方法，有时候都是会起死回生。</p>
<p><strong>cookie</strong></p>
<p>cookie 可以分为两类： <strong>会话cookie 和 持久cookie</strong></p>
<p>对于会话cookie， 它是一种临时的cookie， 记录了用户访问站点时候的设置和偏好，用户退出浏览器，会话cookie 就会删除掉。而持久cookie 显然是生存周期更久的一种。常见的，如果cookie 设置了Discard 参数，没有设置Expires 或者 Max-Age 参数来说明扩展过期时间，那么一般就是一个会话cookie.</p>
<p>cookie 包含了一个由名字和值 组成的信息构成，通过Set-Cookie,Set-Cookie2 HTTP响应首部来给用户。下边这只是一个例子，cookie 的格式又服务器决定：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613325046800.jpg" alt=""></p>
<p>cookie 罐的概念，就是浏览器在本地管理cookie 信息的形式，浏览器要负责储存这些信息，一般统称为<strong>客户端侧状态</strong>，这种规范叫HTTP状态管理机制。不同的浏览器，会有不同的cookie 的储存机制。储存起来的cookie 包含了一些名称变量过期安全等考量，具体可查看每种浏览器的cookie格式。</p>
<p>虽然我们说，cookie 只会发给那些之前对应的服务器，但是某些无量的广告商，他们会发送持久cookie ，一些站点会委托同一个广告公司提供服务（比如百度），那么浏览器会将持久的cookie 发过来，广告公司通过将此技术和referer 结合，暗地里构建了一个用户档案和浏览习惯的详尽数据集。</p>
<p>cookie 将包含一些必要的信息，有些信息是可选的，其中具体的内容，这里不再赘述，具体可参见RFC 2965：</p>
<ul>
<li>cookie 域属性，Domain 属性将控制哪些站点可以得到那个cookie.</li>
<li>cookie 路径属性，cookie 规范允许用户将cookie 与部分 Web站点关联起来。Path 属性来实现功能，在这个属性下列出的URL 前缀下所有的cookie 都是有效的。</li>
<li>安全属性，可选</li>
<li>日期属性，可选</li>
</ul>
<p>而在cookie 的扩展版本中，引入了Set-Cookie2首部 和Cookie2 首部，做出了一些新的改进，它能够与cookie 互操作。</p>
<p>而 Set-Cookie2 属性包括有：</p>
<ul>
<li>NAME=VALUE 强制</li>
<li>Version 强制，规范版本。</li>
<li>Comment 可选，说明服务器如何使用cookie.</li>
<li>CommentURL  可选，策略文档。</li>
<li>Discard 可选，客户端程序终止时，指示客户端放弃cookie.</li>
<li>Domain 可选，域。</li>
<li>Max-Age 可选，生存期，秒为单位。</li>
<li>Path 可选，路径。</li>
<li>Port 可选，可以应用cookie 的端口列表。</li>
<li>Secure 可选，使用SSL才可以发送的指示。</li>
</ul>
<h3 id="cookie_与会话跟踪">cookie 与会话跟踪</h3>
<p>一张图，讲所有：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14613368816595.jpg" alt=""></p>
<p>Web 通过一系列的重定向，URL 重写，和cookie 设置来附加标识信息。</p>
<h3 id="cookie_与缓存">cookie 与缓存</h3>
<p>目前还不需要用到相关业务，暂且不表。</p>
<h2 id="认证">认证</h2>
<p>HTTP 通过一组可定制的控制首部，为不同的认证协议提供一个可扩展的框架。主要分<strong>基本认证和摘要认证</strong></p>
<ul>
<li>质询 WWW-Authentiacate，服务器以401状态码拒绝请求，说明需要提供用户名和密码。</li>
<li>授权 Authorization 客户端重新发送请求，但这一次会负责为一个Authorization 首部，用来说明认证算法，用户名和密码。 属于GET</li>
<li>成功 Authentication-Info 如果授权书正确，服务器会将文档返回，授权算法在该首部返回一些与授权会话相关的信息。 200 OK。</li>
</ul>
<p>下面是相关的流程示意图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614015756784.jpg" alt=""></p>
<p><strong>安全域</strong></p>
<p>在上边的质询里有一个realm 他就是安全域，也就是你试图访问的安全域，需要哪个授权。</p>
<h3 id="基本认证">基本认证</h3>
<p>基本认证就是我们刚刚讲的质询响应，用户请求的资源位于某个安全域中，服务器会返回一个401，质询，并提供安全域。用户只有将用户名密码（base64 处理）后返回，才可以获得正确响应。</p>
<h3 id="代理认证">代理认证</h3>
<p>中间的代理服务器也可以实现认证功能，这样我们就可以在代理服务器上对访问策略进行集中管理。代理认证的首部有所不同，对应的返回码也是不同的。</p>
<ul>
<li>代理服务器返回 407</li>
<li>Proxy-Authenticate 对应 WWW-Authenticate</li>
<li>Proxy-Authorization 对应 Authorization</li>
<li>Proxy-Authentication-Info 对应 Authentication-Info</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<p>基本认证的缺陷很明显，所以现代的服务器基本不是这样处理了，缺陷有这么几点：</p>
<ol>
<li>基本认证通过网络发送用户名和密码，bash-64 没有安全可言。</li>
<li>即使密码是更难解码的方式加密，第三方用户仍然可以捕获修改过的用户名和密码，重放攻击。</li>
<li>即使将基本认证用于一些不重要的应用程序，如内部网络访问控制和个性化的访问，但捕获这些密码，可以构建撞库的可能。</li>
<li>基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，如果他们不修改认证首部，但是修改了报文的其他部分，仍然是严重的。</li>
<li>假冒服务器容易骗过基本认证，这也就是401钓鱼。</li>
</ol>
<h2 id="摘要认证">摘要认证</h2>
<p>摘要认证是另一种HTTP 认证协议，修复了一些严重的缺陷，一般有如下改进：</p>
<ul>
<li>永远不会以明文方式在网络上发送密码</li>
<li>可以防止恶意用户捕获并重放认证的握手过程</li>
<li>可以有选择的防止对报文内容的篡改</li>
<li>防范集中常见的攻击方式，如重放攻击等。</li>
</ul>
<p>单向摘要，实际上就是我们常用的MD5 ，SHA-1 了。<br>而为了防止重放攻击，服务器和客户端使用随机数这样的特殊令牌，客户端在计算摘要前将随机数附加上去，这样每次发送的信息，都会有一个随时间变化的随机数。</p>
<p>摘要算法的核心是对公共信息，保密信息，和有时限的随机值的摘要。核心是三个组件：</p>
<ul>
<li>单向散列函数H(d) 摘要KD(s, d)组成的一对函数。s表示密码，d表示数据。</li>
<li>包含安全信息的の数据块A1，包括密码。</li>
<li>包含请求报文中非保密属性的数据块，A2。</li>
</ul>
<p>其中A1 的数据块是密码，和受保护信息的产物，包含有用户名，密码，保护域，随机数的内容。一般是MD5.<br>A2 表示的是与报文自身有关的信息，比如URL，请求方法和报文实体部分。A2主要是防止方法，资源，报文被篡改。当qop = 「auth」 只包含HTTP 请求方法和URL。qop=’auth-int’ ，添加了报文的实体主题部分，提供一定程度的报文完整性检测。<br>摘要认证的过程及其内容看起来像是一个弱化版的SSL，所以在这里不再赘述，一个图大约够了。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-04-27-14614149936666.jpg" alt=""></p>
<p>稍微补充几个概念：</p>
<ul>
<li>预授权，正常来说，如果按照上边的说法，每次的请求，都要做一次质询，但如果我们采用授权模式，如果一次请求授权成功之后，每次服务器会返回一个随机数，客户利用随机数再发出下一次的请求，和授权，这样就节省了很多交互。</li>
<li>随机数的产生，是一个只有服务器知道的数据。</li>
<li>不仅可以有单向的认证，还可以采用对称形式的认证。</li>
</ul>
<p>下面则是讨论一下这个认证一些重要的实际问题和安全性问题：</p>
<ol>
<li>多重质询，因为服务器不知道客户端可以做到哪种能力的认证，所以可以又提供基本认证质询，又提供摘要认证质询。</li>
<li>差错处理，如果某个指定其值不正确或缺少必要指令，应当返回400 bad request。而且某些时候，连续的差错可能代表了某种攻击行为。</li>
<li>保护空间，也就是提供授权访问的区域。对于基本认证，考虑URL 之下的所有子路径都是同一保护空间。对于摘要认证，服务器会提供一个URI 的列表。</li>
<li>缓存，Cache-Control 指令为must-revalidate 和 public 会有不一样的处理。</li>
</ol>
<p>安全性的考量：</p>
<ol>
<li>首部篡改，这里的认证机制，实际上只是一个首部防篡改系统，对数据并起不到多少的保护作用。</li>
<li>重放攻击，也是前边一直力图解决的问题，防止中间人利用截获的认证证书用于其他事务。最重要的实际上应当是防止POST 请求和PUT 请求，可能会篡改服务器的内容。上边内容的缺陷在于面对代理集群传输的时候，会遇上麻烦，而且攻击者伪造IP 也是有可能的。而一种完全可以避免重放共及的方式就是为每个事务提供唯一的随机数，发布的随机只对指定的事务有效，而且只在超时区间内有效，这样中间人即使是篡改了报文，但随机数只对某事务有效，它仍然无法成功，当然这会造成服务器的负担。</li>
<li>多重认证机制，因为服务器支持多重认证，攻击者可能会采用某些方法，让服务器采用最弱的基本认证机制，而基本认证机制会有一些安全上的脆弱，所以，解决办法也只能是不允许降级。其实主动降级攻击这在攻击表里很常见，例如对SSL 的攻击了，就是试图去让SSL 退化到早先的版本，然后利用其中的漏洞进行攻击。</li>
<li>词典攻击，大部分是针对弱密码，采用复杂密码或者是密码过期策略之外，没有更好的办法。</li>
<li>中间人，恶意代理。客户端和服务器之间的代理，在处理客户端的报文时，故意降级，采用较弱的认证方式，实现前边所说的攻击。</li>
<li>选择明文攻击，这里是一个恶意的服务器，伪装成服务器，预先使用一个随机数和一个常见密码变化形式形成一组响应，创建一个词典。一旦有了规模可观的词典，攻击服务器或代理就可以完成对流量的封锁，向客户发送预先确定的随机数。攻击者从客户端得到一个响应时，会搜索生成的字典，寻找匹配项。找到对应的匹配项，就能获取密码了。另外，暴力枚举现在能力也很强大，他不使用预设的字典去匹配了，直接在指定空间内枚举全部可能，直接暴力破解。</li>
<li>服务器保存了密码文件，用来与用户响应的内容比较，如果密码文件被侵入，那该域中文件就不再安全了。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前对HTTP 的内容做过梳理，如今看来显得太过粗略，很多值得关注的细节都直接被省略，也只是对整个结构感受较为清晰罢了。现在结合《HTTP 权威指南》这本将近七百页的大部头，我对HTTP 重新做了梳理和理解，当然在阅读的过程中，我感觉即使是权威指南，在讲解的时候，仍然是粗略的，有很多内容明显的看起来其中有很多文章。所以，这大约是我第一遍的HTTP 再详解，再后边，我会对HTTP 的更多内容，做已更细节的理解。如HTTP 版本差异，method 的在现实应用场景到底会有哪些安全问题，HTTP头域里隐藏着哪些玄机，编码种种，代理、缓存。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
</feed>
