<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[临风|刀背藏身]]></title>
  <subtitle><![CDATA[代码是一棱刀背，幸好，有此藏身。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-12T11:14:26.428Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[临风]]></name>
    <email><![CDATA[xuelinf@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[The different means of Stack]]></title>
    <link href="http://yoursite.com/2016/03/10/The-different-means-of-Stack/"/>
    <id>http://yoursite.com/2016/03/10/The-different-means-of-Stack/</id>
    <published>2016-03-10T05:40:05.000Z</published>
    <updated>2016-03-10T05:45:02.000Z</updated>
    <content type="html"><![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。<a id="more"></a>

</li>
</ul>
<h3 id="代码存放的区域">代码存放的区域</h3>
<p>stack 的另一种含义是存放数据的一种内存区域，参考<a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" target="_blank" rel="external">维基百科</a> ，我们知道，程序包含几个区域，静态区，堆区，栈区。</p>
<ul>
<li><strong>栈区（stack）</strong>— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li>
<li><strong>堆区（heap）</strong> — 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)。 - 程序结束后由系统释放</li>
<li><strong>文字常量区</strong> — 常量字符串就是放在这里的。 程序结束后由系统释放</li>
<li><strong>程序代码区</strong>— 存放函数体的二进制代码。</li>
</ul>
<p>下面这是个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">main.cpp </div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>; 全局初始化区 </div><div class="line"><span class="keyword">char</span> *p1; 全局未初始化区 </div><div class="line">main() </div><div class="line">{ </div><div class="line"><span class="keyword">int</span> b; 栈 </div><div class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>; 栈 </div><div class="line"><span class="keyword">char</span> *p2; 栈 </div><div class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="number">123456</span>在常量区，p3在栈上。 </div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； 全局（静态）初始化区 </div><div class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </div><div class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </div><div class="line">分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。 </div><div class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="number">123456</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">"123456"</span>优化成一个地方。 </div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于stack 来说，stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；但是heap 是没有结构的，数据可以任意的存放，因此，stack 的寻址速度要快于heap。</p>
<p>而且，一般来说，对每个线程会分配一个stack ,每个进程分配一个heap 。那么stack 就是线程独占的，而heap 则是线程共用的。stack 在创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap 的大小是不确定的，需要的话，可以不断的增加。</p>
<p>所以，只要是局部的，占用空间确定的数据，都会存放在stack 里边，其他的不确定的，动态生成的，就存放在heap 里去。</p>
<p>比如我们的创建新的对象，就会存放在heap中，因为stack 在使用完后会又编译器自动释放，但是heap 如果不去有效的清理，等待系统的垃圾清理机制去将这块内存清理，就很容易发生内存溢出。</p>
<p>更多详细的解释，可以参考<a href="http://blog.csdn.net/chenke1988/article/details/7273375" target="_blank" rel="external">这篇文章</a></p>
<h3 id="代码运行的方式-_调用栈">代码运行的方式- 调用栈</h3>
<p>第三种含义可以是调用栈，call stack 。它用的就是栈的思路，表示函数或者子例程像堆积木一样存放，以实现层层调用。</p>
<p>对于调用栈的方式，我们举个例子，该例子来自<a href="http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/" target="_blank" rel="external">java 8 stack and heap</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Student{</div><div class="line">    <span class="keyword">int</span> age;              </div><div class="line">    String name;      </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Student</span>(<span class="keyword">int</span> Age, String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.age = Age;</div><div class="line">        setName(Name);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String Name)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.name = Name;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">            Student s;           </div><div class="line">            s = <span class="keyword">new</span> Student(<span class="number">23</span>,<span class="string">"Jonh"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其调用main 方法时候，需要生成一个student实例，于是调用student 构造函数，在构造函数中又调用了setName方法。如图（来自阮一峰）：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575871473636.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们通常理解的Stack 里，存在有不同的含义。简单的解释一下。</p>
<h3 id="最常见的栈数据结构">最常见的栈数据结构</h3>
<p>最常见的含义就是栈，一种数组形式的储存形式，后进先出的特点，针对这样的数据结构，配套的函数应当：</p>
<ul>
<li>push 顶层加入元素</li>
<li>pop 返回顶层元素，并弹出</li>
<li>top 返回顶层元素，不弹出</li>
<li>isempty 返回当前栈是否为空。]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSL 图解]]></title>
    <link href="http://yoursite.com/2016/03/10/SSL-%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/10/SSL-图解/</id>
    <published>2016-03-10T03:22:20.000Z</published>
    <updated>2016-03-10T03:23:36.000Z</updated>
    <content type="html"><![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br><a id="more"></a><br>SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。SSL 包括的工作原理有，<strong>握手协议，记录协议，报警协议。</strong></li>
</ul>
<h3 id="握手协议">握手协议</h3>
<p>握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。</p>
<p>每个握手协议包含以下3个字段</p>
<ul>
<li>Type：表示10种消息类型之一</li>
<li>Length：表示消息长度字节数</li>
<li>Content：与消息相关的参数<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575301594684.jpg" alt=""></li>
</ul>
<p>比如我们在发送已加密的 HTTP 报文之前,客户端和服务器要进行一次 SSL 握手,在这个握手过程中,它们要完成以下工作:</p>
<ul>
<li>交换协议版本号;</li>
<li>选择一个两端都了解的密码;</li>
<li>对两端的身份进行认证;</li>
<li>生成临时的会话密钥,以便加密信道。</li>
</ul>
<p>我这里引述阮一峰在博客中举得alice and Bob 的例子。</p>
<ol>
<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>
<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ol>
<p>下面再进一步详解每一部分：</p>
<p><strong>第一和第二步，建立安全能力</strong></p>
<p>SSL握手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。<br>Client hello消息包括Version，Random，Session id，Cipher suite，Compression method等信息。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575307943892.jpg" alt=""></p>
<p>ClientHello 客户发送CilentHello信息，包含如下内容：</p>
<ul>
<li>客户端可以支持的SSL最高版本号</li>
<li>一个用于生成主秘密的32字节的随机数。</li>
<li>一个确定会话的会话ID。</li>
<li>一个客户端可以支持的密码套件列表。</li>
<li>一个客户端可以支持的压缩算法列表。</li>
</ul>
<p>密码套件格式：每个套件都以“SSL”开头，紧跟着的是密钥交换算法。用“With”这个词把密钥交换算法、加密算法、散列算法分开，例如：SSL_DHE_RSA_WITH_DES_CBC_SHA, 表示把DHE_RSA(带有RSA数字签名的暂时Diffie-HellMan)定义为密钥交换算法；把DES_CBC定义为加密算法；把SHA定义为散列算法。</p>
<p>而ServerHello服务器用ServerHello信息应答客户，包括下列内容</p>
<ul>
<li>一个SSL版本号。取客户端支持的最高版本号和服务端支持的最高版本号中的较低者。</li>
<li>一个用于生成主秘密的32字节的随机数。（客户端一个、服务端一个）</li>
<li>会话ID</li>
<li>从客户端的密码套件列表中选择的一个密码套件</li>
<li>从客户端的压缩方法的列表中选择的压缩方法</li>
</ul>
<p>这个阶段之后，客户端服务端知道了下列内容：</p>
<ul>
<li>SSL版本</li>
<li>密钥交换、信息验证和加密算法</li>
<li>压缩方法</li>
<li>有关密钥生成的两个随机数。</li>
</ul>
<p><strong>第二阶段，服务器鉴别与密钥的交换</strong></p>
<p>服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：</p>
<ul>
<li>证书：服务器将数字证书和到根CA(Certification Authority)整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。</li>
<li>服务器密钥交换（可选）：这里视密钥交换算法而定</li>
<li>证书请求：服务端可能会要求客户自身进行验证。</li>
<li>服务器握手完成：第二阶段的结束，第三阶段开始的信号</li>
</ul>
<p>这一步在刚才的例子中被合并在第二步里。其重点在于服务端的验证和密钥的交换。在SSL 中密钥交换算法有6种：无效（没有密钥交换）、RSA、匿名Diffie-Hellman、暂时Diffie-Hellman、固定Diffie-Hellman、Fortezza。</p>
<p>在阶段一那里，双方已经协商确定使用哪种算法。而且CA 证书里包含了公钥。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575744280354.jpg" alt=""></p>
<p>比如我们协商使用了RSA 交换密钥，那么过程是这样的：<br>这个方法中，服务器在它的第一个信息中，发送了RSA加密/解密公钥证书。不过，因为预备主秘密是由客户端在下一个阶段生成并发送的，所以第二个信息是空的。注意，公钥证书会进行从服务器到客户端的验证。当服务器收到预备主秘密时，它使用私钥进行解密。服务端拥有私钥是一个证据，可以证明服务器是一个它在第一个信息发送的公钥证书中要求的实体。</p>
<p><strong>第三阶段，客户机鉴别与密钥交换</strong></p>
<p>在这一阶段，主要是我们的客户机启动，发送消息，服务器是唯一的接收方。分为三个阶段：</p>
<ul>
<li>证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。</li>
<li>客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。</li>
<li>证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。</li>
</ul>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575746918586.jpg" alt=""></p>
<p>这里的重点就是，我们的客户端把自己的公钥发给服务端，方便服务端用公钥加密，然后通过服务端之间发过来的证书里的公钥，加密自己的随机数和预备秘密，又保证了秘密的私密性，又证明了它拥有证书的公钥。</p>
<p><strong>第四阶段</strong></p>
<p>刚才服务端收到了用公钥加密的第三个随机数，这时服务端和客户端就可以使用三个随机数生成本次的会话密钥，双方通过计算得到本次使用的会话密钥。然后互相发送：</p>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>握手结束通知，表示握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供互相校验。</li>
</ul>
<p>而这三个随机数要获得总共六个加密秘密：四个密钥（客户公钥私钥 和服务器公钥私钥），两个IV（initialization vector 初始向量，与区块加密模式有关）。加密过程如下图：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575782242346.jpg" alt=""></p>
<p>首先利用之前发送的预备主秘密，双方发送的随机数等组合散列并获得MD5值，得到一个主秘密。再对主秘密进行处理，得到一串散列值，这个散列值可以拆分成四个密钥和两个IV。<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791281572.jpg" alt=""></p>
<p><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575791478878.jpg" alt=""></p>
<h3 id="记录协议">记录协议</h3>
<p>刚才讲的只是在完成了握手协议，下面在握手成功后，双方如何互传信息呢。就需要使用记录协议。记录协议提供了两个服务：</p>
<ul>
<li>保密性，使用握手协议定义的秘密密钥实现</li>
<li>完整性，握手协议定义了MAC， 用于保证信息完整性</li>
</ul>
<p>整个记录协议的过程如下：<br><img src="http://7s1s1q.com1.z0.glb.clouddn.com/2016-03-10-14575792771159.jpg" alt=""></p>
<h3 id="警报协议">警报协议</h3>
<p>当客户和服务器发现出现错误的时候，就需要处理这个错误。于是，就向对方发送一个警报信息。如果是致命错误，那么就会立即关闭SSL 连接，而且双方还会删除相关的会话号，秘密和密钥。这就是警报协议，每个警报的信息共有两个字节，第一个字节表示错误类型，如果是警报，置1，如果是致命错误，置2.第二个字节指定实际的错误类型。</p>
<p>相关扩展：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">DH加密方法</a></p>
<p><a href="http://www.openssl.org/" target="_blank" rel="external">OpenSSL</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSL 协议详解<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。<br>　　<br>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p><strong>SSL协议的三个特性</strong></p>
<ul>
<li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</li>
<li>鉴别：可选的客户端认证，和强制的服务器端认证。</li>
<li>完整性：传送的消息包括消息完整性检查（使用MAC）。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP/IP 完全解读之传输层协议]]></title>
    <link href="http://yoursite.com/2016/03/09/TCP-IP-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB1/"/>
    <id>http://yoursite.com/2016/03/09/TCP-IP-完全解读1/</id>
    <published>2016-03-09T09:29:23.000Z</published>
    <updated>2016-03-09T09:36:38.000Z</updated>
    <content type="html"><![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br><a id="more"></a></p>
<h3 id="1-1_多路复用/分解">1.1 多路复用/分解</h3>
<p>在阐述这个问题之前，我们先来简单谈一下不同主机应用程序<strong>进程间通信</strong>的问题。我们知道不同应用程序之间的交互实际上是进程间的交互，在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。在这个过程中，通信间进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送和接收报文，套接字是同一台主机内应用层与传输层之间的接口（因此套接字也称为应用程序和网络之间的API）。在网络中，主机地址由IP地址标识，一个发送进程要将报文送往另一台主机的接收进程，除了要知道主机IP地址外，还要知道接收进程的接收套接字，这个接收套接字对应一个目的地<strong>端口号（port number）</strong>。</p>
<p>对于传输层传输的每个报文，其中都有一些字段，传输层检查这个字段，进而把报文定向到正确的接收套接字。将运输层报文段中的数据交付到正确的套接字的工作就称为<code>多路分解</code>。与之对应，源主机从不同套接字收集数据块，并为每个数据块封装上首部信息（用于以后分解）从而生成报文段，并将报文段传递到网络层的工作称为<code>多路复用</code>。</p>
<p>实际中，这些特殊的字段是<strong>源端口号</strong>字段和<strong>目的端口号</strong>字段，端口号是一个16bit的数，大小在0—65535之间，其中0—1023范围称为<strong>周知端口号（well-known port number）</strong>，保留给诸如HTTP（80端口）、FTP（控制：21端口，数据：20端口）、telnet（23端口），SMTP（25端口），POP3（110端口），NNTP（119端口）等周知的应用层协议使用。查看周知端口号可前往：<a href="www.iana.org">www.iana.org</a></p>
<p>下这张图给出了一个多路复用和分解的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-1.png" alt="1"></p>
<h4 id="1-1-1_无连接的多路复用/分解">1.1.1 无连接的多路复用/分解</h4>
<p>UDP采用无连接的多路复用与分解，一个UDP套接字是由一个二元组（源端口号，目的端口号）来标识的，该二元组包含一个目的IP地址和目的端口号，两个UDP报文只要有相同的IP地址和目的端口号，那么这两个报文就将通过相同的目的套接字被定向到相同的目的进程。在下面的例子中，主机A中的一个进程具有UDP端口号19157，它要发送一个应用程序数据块给位于主机B的另一进程，该进程具有UDP端口号46428。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-2.png" alt="2"></p>
<h4 id="1-1-2_有连接的多路复用/分解">1.1.2 有连接的多路复用/分解</h4>
<p>TCP采用有连接的多路复用与分解，一个TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，与UDP不同，即使两个TCP报文有相同的目的IP地址和目的端口号，如果它们源IP地址或源端口号不同，就会被定向到两个不同的套接字。例子如下：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-3.png" alt="3"></p>
<h2 id="2_UDP">2 UDP</h2>
<p>UDP（User Datagram Protocol）指用户数据报协议，简单来讲，UDP无非就是对网络层协议增加了多路复用/分解功能而已（还有少量差错检测）。</p>
<p>使用UDP时，在发送报文之前，发送方和接收方的运输层实体间没有握手，因此UDP被称为<strong>无连接的</strong>。UDP无法提供可靠的数据传输，它有以下特点：</p>
<blockquote>
<ul>
<li>只要应用程序将数据传递给UDP，UDP就会将此数据打包进UDP报文并立即将其传递给网络层（相比之下TCP有拥塞控制机制）。由于实时应用通常要求最小发送速率，不希望过分延迟报文段的传送，且能容忍一些数据丢失，因此这些应用可以采用UDP实现。</li>
<li>无需建立连接，TCP在开始数据传输之前要经过三次握手，而UDP不需要任何准备即可传输数据，因此UDP不会引入建立连接的时延（正是由于这个原因，DNS使用UDP而不是TCP）。</li>
<li>无需维护连接状态，TCP要在端系统间维护连接状态（接收/发送缓存，拥塞控制参数，序号，确认号），而UDP不维护连接状态，因此也不需要这些参数。对于一些应用而言，相比TCP，UDP能支持更多的活跃用户。</li>
<li>分组首部开销小，每个TCP报文有20字节的首部开销，而UDP仅有8字节，更节约流量带宽。</li>
<li>由于UDP缺乏拥塞控制机制，因此发生拥塞时可能导致发送方和接收方的高丢包率，并会挤垮TCP会话。</li>
</ul>
</blockquote>
<h3 id="2-1_UDP报文段结构">2.1 UDP报文段结构</h3>
<p>UDP定义在RFC 768中，如下图所示，UDP首部只有四个字段（源端口号，目的端口号，长度，检验和），每个字段由两个字节组成。长度字段指示了UDP报文段中的字节数（首部+数据），检验和提供了差错检验功能。</p>
<p><em>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。</em><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-4.png" alt="4"><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-32.png" alt="32"></p>
<blockquote>
<ol>
<li>源端口：16bits，该数据报的发出端口。发送进程将在此端口发送数据包。</li>
<li>目标端口：16bits，该数据报的接收端口。接收进程将在此端口处进行接收。</li>
<li>总长度：整个UDP报文的长度，即UDP头部和数据的长度。</li>
<li>校验和：一个16位补码，是由伪IP头，UDP头（由于校验和字段本身就在UDP头部中，因此使用UDP头计算时先假设校验和为0），UDP数据形成的。其中，伪IP头的协议号为17。如果要求接收方忽略校验和，发送方不计算校验和，直接把校验和设置为0。对伪IP头的说明见下一小节。</li>
</ol>
</blockquote>
<h3 id="2-2_UDP检验和">2.2 UDP检验和</h3>
<p>根据RFC 768，<strong>检验和的计算方法如下：</strong><br>图中给出了伪IP头的格式，注意，<code>TCP与UDP计算检验和的方式是一样的。</code><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-0.png" alt="0"></p>
<blockquote>
<p>发送方<code>对伪IP头，UDP头（校验和为0），UDP数据的所有16bits字的和进行反码运算，求和时遇到的所有溢出都被回卷</code>（即忽略最高位的进位溢出），得到的结果放在检验和字段。在接收方，将全部字段之和与检验和字段相加，如果没有引入差错，则这个结果应当是全1的，如果有任何&gt;一位为0，则说明传输出现了差错。（参见下图）<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-5.png" alt="5"></p>
</blockquote>
<p>这里还有一个问题要说明，<strong>虽然UDP提供差错检测，但它对差错的恢复无能为力</strong>，对于出错的报文段，UDP的接收方有两种选择：</p>
<blockquote>
<ol>
<li>丢弃受损的报文段。</li>
<li>将受损的报文段交给应用程序并给出警告。</li>
</ol>
</blockquote>
<h2 id="3_可靠数据传输原理">3 可靠数据传输原理</h2>
<h3 id="3-1_可靠数据传输">3.1 可靠数据传输</h3>
<p>借助于可靠信道，传输数据比特不会受到损坏或丢失，而且所有数据都是按其顺序进行交付，我们将实现这种服务的抽象称为可靠数据传输协议（reliable data transfer protocol）（注意：可靠数据传输协议的下层协议也许是不可靠的），下面两图给出了一个可靠数据传输协议所提供的服务及其概要实现，其中rdt表示可靠数据传输协议，理解这两张图是理解TCP的基础。</p>
<p><strong>可靠数据传输协议提供的服务和实现：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片1.png" alt="图片1"></p>
<p><strong>详细说明：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-图片2.png" alt="图片2"></p>
<p>接下来我们逐步讨论实现可靠数据传输协议的几个要点，在讨论过程中，我们会用到<strong>FSM</strong>（有限状态机，finite-state machine），其中初始状态用虚线指出，箭头代表从一个状态变化到另一个状态，每个箭头旁会附有引起变迁的事件（横线上方）及事件发生时所采取的行动（横线下方），符号\^表示空集（横线上方表示条件为空/横线下方表示所采取的行动为空）。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-11.png" alt="11"></p>
<p>为了能更深入的理解TCP，我们先在研究TCP之前改概略的研究以下协议：<strong>rdt1.0-&gt;rdt2.0-&gt;rdt3.0</strong>，它们从最理想的网络情况切入，一步步拓展到真实网络环境，其中rdt1.0假设传输信道完全可靠，rdt2.0假设传输信道会有比特差错但不会丢包，rdt3.0假设传输信道不仅会有比特差错，还会丢包（和真实网络情况一致）。</p>
<blockquote>
<p><strong>rdt1.0:假设发送双方经完全可靠信道传输</strong>，这种情况下我们不必担心任何差错，因为我们假定信道是完全可靠的，且假定接收方接收速率和发送方发送速率一样快。</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-12.png" alt="12"></p>
<blockquote>
<p><strong>rdt2.0:假设经有比特差错但不会丢包的信道传输</strong>，一个分组在传输、传播、缓存的过程中都可能出现差错，这种情况下，我们需要在rdt1.0的基础上引入以下三种功能来解决。</p>
<ol>
<li>差错检验：利用<code>检验和</code>使接收方能够检测到数据分组是否出错。</li>
<li>接收方反馈：如果没有出错，则返回肯定确认（ACK）给发送方，如果检测到出错，则返回否定确认（NAK），即引入<code>肯定和否定</code>分组。</li>
<li>重传：如果发送方收到NAK，则重传该分组。</li>
</ol>
</blockquote>
<p><strong>由此我们得到rdt2.0如下：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-13.png" alt="13"></p>
<p>在上图中，只有发送方收到来自接收方的ACK，才会发送下一个分组，如果收到NAK，则重发当前分组。这之中用到了停等协议（stop-and-wait）的思想。但rdt2.0存在以下问题：<strong>没有考虑到ACK或NAK在发送过程中受损的问题</strong>。如果ACK或NAK受损，rdt2.0的发送方就无法判断该进入哪个状态。解决这一问题的思路是：作为发送方如果不确定收到的是ACK还是NAK，只需重传当前分组（注意：这种方法在信道中引入了<strong>冗余分组</strong>），但是新的问题来了，如果采取这种方法，作为接收方如何判断自己收到的分组是新的还是一次重传？为了解决这一问题，我们引入<code>序号</code>字段。即在数据分组中增加一个序号字段，让发送方对其发送的数据进行编号，对于停等协议，这个序号1比特就足够了（使用0、1两个状态轮流标记发送分组），由此我们得到了改进版的rdt2.5，可以看到，此时接收方可以根据序号识别这个一个新的分组还是一次重传。!</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-14.png" alt="14"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-15.png" alt="15"></p>
<blockquote>
<p><strong>rdt3.0:假设经有比特差错且会丢包的信道传输</strong>，这是真实网络的情况，为了能处理丢包，我们必须解决以下两个问题：如何检测丢包及发生丢包后该做些什么。第二个问题的答案是显然的，因为其实在引入<code>检验和</code>、<code>序号</code>、<code>肯定和否定分组</code>及<code>重传</code>机制后，只要能检测到丢包，我们就可以通过通过重传解决这个问题。<br>解决第一个问题的办法是引入一个定时器，即选定一个合适的时间值，以判定可能发生了丢包（虽然不能确保是丢包），如果在这个时间内没有收到ACK，则重传该分组。（注意：如果一个分组经历了一个特别大的时延，即使该数据分组及其ACK都没有丢失，发送方也会重传该分组，这在信道中引入了<strong>冗余数据分组</strong>，但正如rdt2.0中讨论的那样，我们已有的机制可以处理这种冗余，即：可以判断收到的分组是新的还是一次重传。）</p>
</blockquote>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-16.png" alt="16"></p>
<h3 id="3-2_ARQ">3.2 ARQ</h3>
<p>如果在协议中，发送方在准备下一个数据项目之前先等待一个肯定的确认，则这样的协议称为ARQ（Automatic Repeat Request，自动重传请求协议）。自动重传请求（Automatic Repeat Request），通过接收方请求发送方重传出错的数据报文来恢复出错的报文，是通信中用于处理信道所带来差错的方法之一，传统自动重传请求分成为三种，即<strong>停等协议</strong>(stop-and-wait），<strong>回退n帧</strong>（go-back-n），以及<strong>选择性重传</strong>（selective repeat）。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为流水线ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。接下来停等协议我们已经在之前粗略的提到过，接下来我们分别对这三个协议进行讨论。</p>
<h4 id="3-2-1_停等协议（stop-and-wait）">3.2.1 停等协议（stop-and-wait）</h4>
<p>我们在上述讨论中提到的rdt3.0也被称为比特交替协议（alternating-bit protocol），尽管它是一个功能正确的协议，但其性能并不令人满意，其性能问题的核心在于它是一个停等协议，下面两张图分别给出了停等协议在<strong>无丢包</strong>、<strong>分组丢失</strong>、<strong>ACK丢失</strong>和<strong>过早超时</strong>4种情况的过程：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-17.png" alt="17"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-18.png" alt="18"></p>
<p>停等协议的性能不佳主要集中表现在它对信道的利用率很低，假设两个距离很远的端系统间的RTT大约为30ms，分组长度为1000字节（8000bits）的数据通过发送速率为1Gbps的信道传输，根据下图的说明和给出的公式计算可知信道利用率只有万分之2.7，停等协议极大的限制了底层网络硬件所能提供的能力，事实上，如果再考虑上发送方与接收方之间路由器的处理时间和排队时延，性能将更加糟糕。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-19.png" alt="19"></p>
<p>停等协议的性能问题的根源在于每次只能发送一个分组，为了解决其存在的性能问题，我们可以采用流水线技术，即允许发送方一次发送多个分组而无需等待确认，但这也引入一些新的问题：</p>
<blockquote>
<ol>
<li>由于每个传输中的分组必须有一个唯一的序号，因此必须<code>增加序号的范围</code>。</li>
<li>发送方和接收方两端必须能<code>缓存多个分组</code>，具体而言，发送方最低限度应当能缓存那些已经发送但还没有确认的分组，接收方，而接收方可能需要缓存那些已正确接收的分组（具体取决于采用GBN还是SR）。</li>
<li>解决流水线下的差错恢复。</li>
</ol>
</blockquote>
<p><strong>解决流水线差错恢复的两种基本方法分别是：GBN和SR</strong>。</p>
<h4 id="3-2-2_GBN（go-back-n）">3.2.2 GBN（go-back-n）</h4>
<p>在GBN中，允许发送方发送多个分组而不需要等待确认，但这里有一个限制，即在流水线中未确认的分组数不能超过某个最大允许数N（N即为窗口长度），下图中，我们定义base为最早的未确认分组号，定义nextseqnum为最小的未使用序号（也即下一个待发分组的序号），则[0，base-1]对应已经发送并被确认的分组，[base,nextseqnum-1]对应已经发送但未被确认的分组，[nextseqnum,base+N-1]内的序号能用于那些要被立即发送的分组，而大于等于base+N的序号是不能使用的。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-21.png" alt="21"></p>
<p>在未被确认的分组被确认后，窗口向前滑动，因此GBN也被称为滑动窗口协议，分组序号承载在分组首部一个固定长度的字段中（如果分组序号的比特数是k,则序号范围是$[0，2^k-1]$），关于GBN需要理解以下几点：</p>
<blockquote>
<ol>
<li>当上层要发送数据时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组，如果窗口未满，则产生一个分组并将其发送，并相应的更新变量，如果窗口已满，发送方缓存这些数据或使用同步机制让上层在仅当窗口不满时才能调用rdt_send()请求发送。</li>
<li>在GBN中，对序号为n的分组采取累积确认的方式，接收方丢弃所有收到的失序分组，知道收到期待接收的分组n，然后为分组n返回一个ACK，作为发送方，一旦收到分组n的ACK，就表明n及n之前的所有分组都已被正确接收。</li>
<li>发送方仅使用一个定时器，这个定时器是最早的已发送但未被确认的分组适用的定时器。出现超时时，发送方重传所有已发送但还未被确认的分组，即回退n步，并重启计时器。</li>
</ol>
</blockquote>
<p>一个GBN的例子：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-24.png" alt="24"></p>
<p>GBN的优点是接收缓存简单，缺点是单个分组的差错就可能引起大量本没有必要重传的分组重传。</p>
<p><strong>实现了GBN的rdt4.0：</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-22.png" alt="22"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-23.png" alt="23"></p>
<h4 id="3-2-3_SR（selective_repeat）">3.2.3 SR（selective repeat）</h4>
<p> 在GBN中，随着信道差错率的增加，信道可能会被不必要重传的分组所充斥，而SR则可以避免这一问题，选择重传协议通过让发送方重传那些它怀疑在接收方出错的分组而避免不必要的重传，关于SR需要理解以下几点：</p>
<blockquote>
<ol>
<li>接收方确认一个正确接收的分组而不管其是否按序，失序的分组将被缓存直到所有序号更小的分组都被收到为止。</li>
<li>具体而言有三种情况：如果一个分组的序号落在接收方的窗口内时，如果该分组以前没有收到过，则缓存该分组，回发ACK；如果该分组序号等于接收窗口的基序号（rcv_base），则该分组及其之后缓存的序号连续的分组被交付给上层，而后接收方窗口向后滑动；如果该分组已经被缓存，则也必须回发一个ACK（否则如果上一次回发的该分组的ACK丢失，则发送方将永远无法向后移动窗口）。</li>
</ol>
</blockquote>
<p> 一个SR的例子：<br> <img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-25.png" alt="25"></p>
<p>SR协议看起来比BNG优秀很多，但它也引入了新的问题，即：由于发送方和接收方窗口间缺乏同步，如果SR接受窗口太大，会带来下图中的问题：接收方在最后收到具有序号0的分组时，无法区分它是第1个分组的重传还是第5个分组的首次传输。<br><strong>这里要首先补充一点：</strong>由于序号空间是一个长度为$2^k$的环（即序号$2^k-1$之后的序号为0）。</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-26.png" alt="26"></p>
<p>为了避免上述问题，通常我们规定窗口长度必须小于序号空间大小的一半。</p>
<h2 id="4_TCP">4 TCP</h2>
<h3 id="4-1_TCP概述">4.1 TCP概述</h3>
<p>与UDP不同，TCP是面向连接的，两个端系统的进程在通信前首先要经过三次握手建立连接。TCP提供全双工服务，是点对点的（如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向A的同时，也从A流向B）。在发送方，当应用层有数据要发送时，客户进程通过套接字传递数据流，TCP将这些数据流引导到发送缓存中（发送缓存在三次握手初期设置），之后TCP会从发送缓存中取出一块数据，加上40字节的首部形成TCP报文段（TCP segment）下传给网络层。当TCP在另一端收到一个报文后，将其存入接收缓存，而后接收方应用程序从此缓存中读取数据流。</p>
<p>这里我们谈到“TCP会从发送缓存中取出一块数据”，所谓一块究竟是多大呢？TCP可从缓存中取出并放入报文段中的数据量受限于<strong>最大报文段长度（maximum segment size，MSS）</strong>，而MSS通常根据最大链路层帧长度，即最大传输单元（maximum transmission unit，MTU）来设置。以太网和PPP链路层协议都具有1500字节的MTU，除去TCP40字节的首部，因此MSS的典型值为1460字节。</p>
<h3 id="4-2_TCP报文段结构">4.2 TCP报文段结构</h3>
<p>TCP定义在RFC 793中，下图显示了TCP报文段的结构：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-31.png" alt="31"></p>
<p><strong>下面我们逐个分析这些字段：</strong></p>
<blockquote>
<ol>
<li>源端口号/目的端口号：各长16bits，分别标识了源端口号和目的端口号。</li>
<li>序号：32bits，是该报文段首字节的字节流编号。</li>
<li>确认号：32bits，主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</li>
<li>首部长度：4bits，该字段指示了以32bits的字为单位的TCP首部的长度，由于选项字段的原因，TCP首部长度是可变的，通常选项字段为空，因此TCP首部典型长度为20字节。</li>
<li>保留未用：6bits，必须全0。</li>
<li>标志（flag）：6bits，其中ACK用于确认号字段中的值是有效的，即该报文包括一个对已被成功接收报文段的确认；RST，SYN，FIN比特用于连接的建立和拆除（这一点我们在之后对三次握手的讨论中会详细阐述）；PSH比特被置位时，指示接收方应立即将数据交给上层；URG比特用来指示报文段中有被发送端上层实体置位紧急的数据（紧急数据的最后一个字节由16比特的紧急数据指针字段指出，当紧急数据存在且给出紧急数据尾的指针时，TCP必须通知上层实体）。注意，在实际中PSH，URG和紧急数据指针并没有被使用。</li>
<li>窗口大小：通告接收缓冲区空闲块大小（确认字节之后还可以发送多少字节）。</li>
<li>检验和：一个16位补码，是由伪IP头，TCP头，TCP数据形成的。伪IP头与UDP类似，其中的协议号为6。</li>
<li>紧急数据指针：与标志URG一起用来取出紧急数据或指出记录边界。</li>
<li>选项：最大数据段长度(Maximum Segment Size，MSS)：为TCP有效载荷的最大长度；窗口比例(Scale): 乘以通知窗口大小；允许选择性确认(SACK-Permitted；选择性确认(SeletiveACK,SACK): 已收到数据段的序号集合；时间戳等等。Unix系统的默认值：MSS为536，SACK-Permitted为False。Windows 的默认值MSS为1460，SACK-Permitted为True。</li>
</ol>
</blockquote>
<p><strong>详细说明：</strong></p>
<blockquote>
<ul>
<li>URG: Urgent Pointer field significant（紧急(Urgent)指针标志，表示本数据段包含紧急数据，位于数据段前部，直到紧急指针指向的位置（从0开始）。可以用来在字节流中指明记录的边界。）</li>
<li>ACK: Acknowledgment field significant（确认号有效标志。）</li>
<li>PSH: Push Function（告知接收方发送方执行了推送(Push)操作，接收方需要尽快将这些数据交给接收进程，不要将其放在缓冲区。另外，PSH还实现了段的立即传输，不用等待构建一个大的数据段再发送。当缓冲区中出现回车后，系统会自动设置PSH。因此，PSH在发送端和接收端均起作用。）</li>
<li>RST: Reset the connection（重置(Reset)连接。因为出现了错误，通知对方立即中止连接并释放与连接有关的资源。）</li>
<li>SYN: Synchronize sequence numbers（同步(Synchronous)序号标志，用来发起一个TCP连接。）</li>
<li>FIN: No more data from sender（结束(Finish)标志，表示发送方完成了所有发送任务，要求释放连接。）<br><code>（* 所有标志为1有效。）</code></li>
</ul>
</blockquote>
<h3 id="4-3_往返时间（RTT）的估计与超时">4.3 往返时间（RTT）的估计与超时</h3>
<h4 id="4-3-1_RTT的估计">4.3.1 RTT的估计</h4>
<p>TCP通过如下方式估计发送方与接收方的往返时间：<br>我们定义SampleRTT为某报文段被发出到对报文段的确认被收到之间所用的时间，同时TCP维持一个SampleRTT的均值EstimatedRTT。TCP每隔一段时间测量一次SampleRTT，并根据以下公式更新EstimatedRTT。<br>$$EstimatedRTT = (1- α)<em>EstimatedRTT + α</em>SampleRTT$$<br><strong>RFC 6298给出α的参考值为0.125</strong></p>
<p>EstimatedRTT是一个加权平均值，这个加权平均值对最近的样本赋予的权值要大于对老样本赋予的权值，因为越近的样本越能反应当前网络的拥塞情况。除了估算RTT外，测量RTT的变化也是有价值的，RFC 6298定义RTT偏差：DevRTT，用于估算SampleRTT偏离EstimatedRTT的程度：<br>$$DevRTT = (1-β)<em>DevRTT + β</em>|SampleRTT-EstimatedRTT|$$<br><strong>RFC 6298给出α的参考值为0.25</strong><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-41.png" alt="41"></p>
<h4 id="4-3-2_超时">4.3.2 超时</h4>
<p>给出SampleRTT和EstimatedRTT的定义后，我们不妨考虑，TCP超时间隔应该选取什么值呢？我们定义这个值为TimeoutInterval为超时时间间隔。（显然，TimeoutInterval应当大于EstimatedRTT，否则会造成不必要的重传，但也不能比EstimatedRTT大太多，否则报文丢失时将无法很快的重传丢失报文）根据下面公式计算TimeoutInterval：<br>$$TimeoutInterval = EstimatedRTT + 4*DevRTT$$<br>RFC 6298推荐的TimeoutInterval初始值为1秒，并在超时后将TimeoutInterval加倍，直到报文收到确认后就使用上面的公式计算TimeoutInterval。</p>
<h3 id="4-4_可靠数据传输">4.4 可靠数据传输</h3>
<p>TCP在IP不可靠的尽力而为的服务之上提供了可靠的数据传输服务，确保了一个进程从其接收缓存读取的数据是<strong>无损坏，无间隔，非冗余和按序</strong>的数据流。接下来我们将具体讨论TCP是如何做到这一点的，我们将会看到，它与我们之前讨论的rdt3.0再很多细节上有所不同。</p>
<p>在之前rdt3.0的讨论中，为了解决丢包的问题，我们实际上为每个分组都引入了一个计时器，一旦计时器超时，就重传该分组，但这样做我们要为计时器的管理付出巨大开销，因此，TCP实际上只采用单一的重传计时器（即使有多个已发送但还未被确认的报文段），这个计时器具体的工作方式我们会在下面逐步给出。</p>
<h4 id="4-4-1_超时间隔加倍">4.4.1 超时间隔加倍</h4>
<p>在大多数TCP的实现中，对TimeoutInterval的取值并不总是按照4.3.2中的公式进行计算，而是这样一个过程：<br>每当超时时间发生时，TCP重传具有最小序号的还未被确认的报文段，并将TimeoutInterval的值设为之前的两倍，而不是使用4.3.2中的公式计算，因此，TimeoutInterval会成指数增长，但是，如果遇到<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>事件时，定时器会重新启动，此时启动的定时器将按照4.3.2中的公式计算TimeoutInterval。</p>
<p>之所以这么做是出于以下考虑：如果发生超时，则很可能是由于网络拥塞造成的，而频繁的重传分组会使得拥塞更加严重，因此在没有<strong>上层应用的数据发送请求</strong>或<strong>收到来自接收方的ACK</strong>时，TCP使用加倍TimeoutInterval的方式，让重传经过越来越长的时间间隔进行。</p>
<h4 id="4-4-2_快速重传">4.4.2 快速重传</h4>
<p>如果我们仅依赖是否超时来判断是否丢包，则对于这个真正丢失的分组，发送方必须在超时之后才会重传它，如果超时周期较长，重传会被延迟。为了优化这个问题，TCP引入了<strong>快速重传</strong>机制。</p>
<p>假设接收方期待接收序号为n的报文段但却收到了序号大于n的报文段，我们就说此时它检测到了数据流的一个间隔，造成间隔的原因可能是报文段丢失或报文段被重新排序，由于TCP不使用否定确认，它会对已经收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK），作为发送方如果收到对同一个数据的<strong>3个冗余ACK</strong>（即第4次收到这个数据的ACK），即使当前计时器还没有超时，TCP也立即重传这个分组，这就是快速重传机制。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-43.png" alt="43"></p>
<h4 id="4-4-3_累积确认">4.4.3 累积确认</h4>
<p>TCP返回的ACK实际上是它期待（从发送方）接收的下一个分组号，TCP的确认是累积式的，正确接收但失序的报文会被缓存但不会被逐个确认（确认号都是其期待接收的下一个分组号，即前面提到的冗余ACK）。发送方只需要维护已发送但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum），对于发送方的一组报文1,2，…，N，假设报文段n丢失（n&lt;N），但它之前的全部报文和它之后的全部报文在超时前到达了接收方，则超时后TCP只会重传至多一个报文段（而GBN则会重发n及n之后的分组）。如果对报文段n+1的确认在n超时前到达，即使对n的确认还没有到达，发送方也可以知道接收方已经正确接收报文n了，这是因为TCP采取累积确认，收到对n+1的确认就意味着n+1之前的分组接收方都收到了。</p>
<p>附：RFC 5681对产生TCP ACK的建议：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-44.png" alt="44"></p>
<h3 id="4-5_流量控制">4.5 流量控制</h3>
<h4 id="4-5-1_流量控制的实现">4.5.1 流量控制的实现</h4>
<p>一条TCP连接每一侧主机都为该连接设置了接收缓存，如果应用程序读取数据相对缓慢，而发送方发送的太多太快，发送的数据就会时接收缓存溢出。TCP为应用程序提供<strong>流量控制服务（flow-control service）</strong>以消除发送方使接收方缓存溢出的可能性，因此流量控制是一个速度匹配服务。</p>
<p>TCP通过让发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量来提供流量控制（接收窗口告诉发送方该接收方还有多少缓存空间）。因为TCP是全双工通信，因此在连接两端的发送方都各自维护一个接收窗口。<br>定义：LastByteRead为主机B上应用程序从缓存读出的数据流的最后一字节的编号，LastByteRcvd为从网络中到达主机B并且已经放入主机B接收缓存中的数据流的最后一个字节的编号。则为了不使缓存溢出，下面式子必须成立：<br>$$LastByteRcvd - LastByteRead≤RcvBuffer$$<br>用rwnd表示接收窗口大小，则：<br>$$rwnd=RcvBuffer-（LastByteRcvd - LastByteRead）$$<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-45.png" alt="45"></p>
<p>为了不使主机B接收缓存溢出，主机A只需轮流跟踪2个变量：LastByteSent和LastByteAcked，注意到LastByteSent - LastByteAcked就是主机A发送到连接中但未被确认的数据量，通过将未被确认的数据量控制在rwnd以内，就可以保证主机B的缓存不会溢出。</p>
<h4 id="4-5-2_死锁处理">4.5.2 死锁处理</h4>
<p>在上面的讨论中，如果主机B接收缓存已满，即rwnd=0，在将这一信息告诉主机A后，如果B没有任何数据要发送给A，就会发生死锁，因为此时即使B将缓存中的数据取走，A也无法得知这一事实。为了解决这一问题，我们采用“聪明的发送方/笨拙的接收方”，即发送方定期(Persist Timer)发送一个字节数据，以使接收方响应以获得通知窗口的大小。接收方响应采用下一个期待接收的字节。</p>
<h3 id="4-6_连接管理">4.6 连接管理</h3>
<h4 id="4-6-1_三次握手">4.6.1 三次握手</h4>
<p>建立连接的过程需要三步，称为<strong>三次握手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个SYN报文段，不含应用层数据，SYN=1，客户端会随机选择一个初始序号x。</li>
<li>服务器收到客户端的SYN报文段后，为TCP连接分配缓存和变量，返回一个SYNACK报文段，SYN=1，ACK=1，ACKNum=x+1，同时服务器选择自己的初始序号y。</li>
<li>在收到SYNACK报文段后，客户端也分配缓存和变量，并回发一个报文段进行确认，SYN=0，ACK=1，ACKNum=y+1，可以在负载中携带数据。</li>
</ol>
</blockquote>
<p><strong>超时重发：</strong>每一步均采用超时重发，多次重发后将放弃。重发次数与间隔时间依系统而不同。<br><strong>数据字节序号：</strong>客户和服务器发送的第一个数据字节的序号分别为x+1和y+1。<br><strong>选项：</strong>头两个数据段给出选项：SACK-Permited，Scale，MSS。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-46.png" alt="46"><br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-47.png" alt="47"></p>
<h4 id="4-6-2_四次挥手">4.6.2 四次挥手</h4>
<p>中断连接的过程需要四步，称为<strong>四次挥手</strong>：</p>
<blockquote>
<ol>
<li>客户端TCP向服务器端TCP发送一个FIN报文段，FIN=1，seq=x，客户端进入FIN_WAIT_1状态。</li>
<li>服务器收到客户端的FIN报文段后，返回一个ACK报文段，ACK=1，ACKNum=x+1，客户端收到后进入FIN_WAIT_2状态。</li>
<li>服务器TCP向客户端TCP发送一个FIN报文段，FIN=1，seq=y。</li>
<li>客户端收到服务器的FIN报文段后向服务器发送一个确认，ACK=1，ACKNum=y+1，并进入TIME_WAIT状态，假设ACK丢失，TIME_WAIT状态会使客户端重传最后的报文。</li>
</ol>
</blockquote>
<p><strong>释放连接：</strong>先发FIN一方在ACK发送完毕后需要等待2MSL(Maximum Segment Lifetime)的时间才完全关闭。TCP标准中MSL采用60秒，Unix采用30秒。<br><strong>超时重发：</strong>超时未收到确认，则超时自动重发，在若干次重发后依然没有收到确认，则发送RST后强行释放连接。不同的系统重发方法不同。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-48.png" alt="48"></p>
<h4 id="4-6-3_SYN洪泛攻击">4.6.3 SYN洪泛攻击</h4>
<p>在三次握手的过程中，如果客户端不发送ACK完成第三步，则服务器将在一段时间内出于半开连接的状态，并在这一时间之后才断开连接并收回资源，如果攻击方发送大量TCP SYN连接但又不完成第三步，就会导致服务器的连接资源最终被耗尽。这种攻击方式被称为SYN Flood Attack，是一种经典的DOS攻击方式，我们可以采用SYN cookie（RFC 4987）来避免它。</p>
<h3 id="4-7_拥塞控制">4.7 拥塞控制</h3>
<p>TCP发送方法可能因为IP网络的拥塞而被遏制，这种对发送方的控制称为拥塞控制。由于IP层不向端系统提供显式的网络拥塞反馈，因此TCP必须使用端到端的拥塞控制。TCP拥塞控制的方法大致可描述为根据发送方所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果TCP发送方感知到路径上没有拥塞，则增加发送速率，反之则降低发送速率。<br>运行在发送方的拥塞控制机制需要跟踪一个额外的变量，即拥塞窗口（congestion window），不妨定义它为cwnd，发送方中未被确认的数据量不能超过cwnd和rwnd中的较小值，即：<br>$$LastByteRcvd - LastByteRead≤min{cwnd , rwnd}$$<br><strong>TCP拥塞控制算法主要包括三个部分：慢启动，拥塞避免，快速恢复。</strong>其中慢启动和拥塞避免是TCP的强制部分，快速恢复是可选部分。</p>
<h4 id="4-7-1_慢启动">4.7.1 慢启动</h4>
<p>当一条TCP连接开始时，在慢启动（slow-start）状态，cwnd的值以1个MSS开始，并且每当传输的报文段被首次确认就增加一个MSS，这样每经过一个RTT发送速率就会翻倍，因此，采用慢启动算法，TCP发送速率起始慢，但在慢启动阶段以指数增长。<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-51.png" alt="51"></p>
<p>我们记ssthresh为“慢启动阈值”，在以下三种情况发生时，结束慢启动过程：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，TCP发送方将ssthresh设置为cwnd/2（即当检测到拥塞时将ssthresh值置位拥塞窗口的一半），将cwdn设置为1，并重启慢启动算法。</li>
<li>当cwnd等于ssthresh时，结束慢启动算法，转移到<strong>拥塞避免</strong>模式。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，此时TCP执行快速重传并转入<strong>快速恢复</strong>状态。</li>
</ol>
</blockquote>
<h4 id="4-7-2_拥塞避免">4.7.2 拥塞避免</h4>
<p>进入拥塞避免状态时，cnwd的值大约是上次遇到拥塞时值的一半，此时TCP采取一种较为保守的方法，每到达一个新的确认，就将cwnd增加一个<strong>MSS*(MSS/cwnd)</strong>字节，即每个RTT只将cwnd的值增加一个MSS（线性增长）。<br>在以下两种情况发生时，结束拥塞避免的线性增长：</p>
<blockquote>
<ol>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
<li>如果检测到一个由于3个冗余ACK指示的丢包事件，TCP发送方将cwnd的值减半，将ssthresh设置为cwnd/2，进入<strong>快速恢复</strong>状态。<h4 id="4-7-3_快速恢复">4.7.3 快速恢复</h4>
<strong>注意：</strong>快速恢复只是TCP推荐但非必须的构件。<br>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK（最少为3个，但可能不止3个），cwnd的值都增加一个MSS（最少增加3个MSS），不妨设因为冗余ACK而增加的MSS数为k。<br>在以下两种情况发生时，结束快速恢复：</li>
<li>当丢失报文段的一个ACK到达时，TCP将cnwd减去k后进入拥塞避免状态。</li>
<li>如果检测到一个由于超时指示的丢包事件，将ssthresh更新为cwnd/2，cwnd的值被置位1个MSS，转移到<strong>慢启动</strong>状态。</li>
</ol>
</blockquote>
<p>一个可能的TCP拥塞窗口变化图如下（图中画出了Reno版TCP与Tahoe版TCP拥塞窗口的变化情况，其中Reno使用了快速恢复而Tahoe没有使用快速恢复）：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-52.png" alt="52"></p>
<p>TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，每出现3个冗余ACK时cwnd减半，因此TCP拥塞控制也被称为加性增，乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）拥塞控制方式。如下图所示：<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-03-09-53.png" alt="53"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>BY 凯寓</p>
<h1 id="传输层协议">传输层协议</h1>
<p>[TOC]</p>
<h2 id="1_传输层概述">1 传输层概述</h2>
<p>传输层位于应用层和网络层之间，其关键功能是将网络层在<strong>两个端系统之间</strong>的交付拓展到运行在两个不同端系统上的<strong>应用层进程之间</strong>的交付服务。相比网络层协议为主机之间提供<code>逻辑通信</code>，传输层协议为运行在不同主机上的应用进程之间提供<code>逻辑通信</code>，传输层协议是在端系统中实现，而不是在路由器中实现，传输层传送的是<strong>报文段（segment）</strong>。</p>
<p><strong>一方面</strong>，传输层协议提供的服务受制于网络层协议的服务模型：即如果网络层协议无法为主机之间发送的传输层报文段提供时延或带宽的保证，则传输层协议也就无法为进程之间发送的应用层报文提供时延或带宽保证。<strong>另一方面</strong>，传输层又可提供网络层协议无法提供的服务，如保密性，可靠性。</p>
<p>传输层协议将主机间交付扩展到进程间交付的行为称为<strong>传输层多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>，最有名的传输层协议是TCP和UDP。他们的行为有着鲜明的`两极化``，<strong>在一个极端</strong>，UDP仅向通信进程提供多路复用/分解的服务，而不提供其他任何服务（因此它非常简单），<strong>在另一个极端</strong>，TCP向通信进程提供可靠交付、时延保证、带宽保证等一些列服务。具体而言，TCP通过使用流量控制、序号、确认和定时器确保数据正确、按序的从发送进程交付给接受进程，即提供<strong>可靠数据传输（reliable data transfer）</strong>，同时TCP还提供<strong>拥塞控制（congestion control）</strong>。<br>]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[薛定谔的2016]]></title>
    <link href="http://yoursite.com/2016/01/11/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%842016/"/>
    <id>http://yoursite.com/2016/01/11/薛定谔的2016/</id>
    <published>2016-01-11T12:37:27.000Z</published>
    <updated>2016-01-11T12:40:08.000Z</updated>
    <content type="html"><![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的转变，因为我认识到自己性格里的不成熟和缺陷，认识到大约二十年的无知以及自以为是。这算是一份特别的工作带给我的最大收获。</p>
<hr>
<p>回头将自己2015年的日记回看了一遍，就像又走了一遍2015年，看着自己一点一点的变化。看自己从迷茫到坚定，到焦虑，到淡定，到迟疑，到沉默…</p>
<p>年初的时候，我给自己定下了许多规划，试图去重建自己的生活习惯，比如坚持写日记，硬规定阅读量，坚持为记录时间，完善GTD。我试着去打破过去二十年懒惰的自己，重构出一个不一样的自己，这个过程，艰难，但显得自然而然。</p>
<p>而到了八月份，回到这个久违的荒岛（当然，现在已经商业开发的不再是荒岛了），度过最初的适应之后，那种期盼中的生活慢慢的展开，时间就真变成了离弦的箭，因为所有想要做的事情都展开了，在这个过程中，过去半年所规划的生活也被我重新调整。当然，在这个过程里，各种好的坏的习惯被改变，有很多过去无法完成的事情成了自然而然的一件小事。</p>
<p>在这接下来的半年里，从纠结的选择到淡定，从焦虑到从容。每天沉浸在实验室，感觉时间的每个节点，都被放大成了一个波澜不惊的平面，在这些平面上，我可以做许多事情。而且，我更珍惜每一个时间的断面，想要做更多的事情。</p>
<p>回到15年年初给自己定下的规划：</p>
<ul>
<li>关于阅读：一百本书的量基本完成，后半段大量的技术文档和文章可以填补本来的规划。</li>
<li>关于日记：止步于开学后不久，因为将精力投入到做事中，无暇记录。</li>
<li>关于知识结构：基本满意。</li>
<li>关于自控力：提高明显。</li>
<li>关于时间管理：不满意，使用了数种GTD 方法，均弃。</li>
<li>关于性格：有进步，但缺点明显，仍未改变。</li>
<li>关于健身：基本满意，身体素质提高，需坚持。</li>
<li>关于未来：有了更多的期许。</li>
</ul>
<p>所以，实际上，我的2015年看似是我变动最大的一年，也是环境变化最剧烈的一年，但似乎又是理所当然和波澜不惊的，我预想了一整年的状态，也预料到了这些波澜不惊。</p>
<p>实际上，2015年带给我的最大最大的收获，是我认识到，未来，哪怕是短短的一年两年，都应当是不可预测的。而如果未来是可测的，那人生一定是可悲的，因为那是一条毫无意义的路，你看不到不一样的风景，看不到未知，看不到未知里所藏匿着的壮美。去年，我一篇日志里写，追赶时间最佳的方式只有阅读，因为每本书实际上都是一段时间线的扩展，它可以将二维的时间提升到三维，四维…在更高的维度下，理解世界的方式在变化，认识人生轨迹的方式也在变化。</p>
<p>对于2016年，我所要面对的生活，将会有更大的变化，我甚至无法预测在未来的某个时间节点，我会在哪里出现，我在做什么。所以，我把我的二零一六称为薛定谔的二零一六，因为所有的可能都存在，在我没有打开盒子的时候，我不会知道我将为自己创造一个怎样的2016。所以，关于规划，我只写期望。</p>
<ul>
<li>关于阅读： 因为阅读量代表的是时间的量，我希望时间越长越好，所以仍然会给自己留下一百本的要求，按照2015年经验，平均每月8+本阅读，每本10w+字数，一个月的阅读量100w+ 难度不高。但鉴于书籍的选择我会尽量筛去口水化严重的书，那就需要花费更多的时间反思和内化，所以最后的实际期望在80~100本之间。2015的后半程没有坚持把每一本书都记录和总结出来，在2016年，一定要坚持将每一本书记录下来。</li>
<li>关于日记：我希望整合进时间管理中去，2015年有一大部分日记是用来思考和反省的，花费了较多时间。而2016年我希望，日记能作为一种行为习惯，与时间规划一起，用来整理人生。所以，选择一个优秀的APP或者自己开发一个应用，回顾事件和时间。日记的另一部分，用极简的话，记录收获。</li>
<li>关于自控力：自控力就像肌肉，只有锻炼，才能保持，否则只会越来越差。只要记住这句就好了。</li>
<li>关于时间管理：是2015年的最大遗憾，也是因为糟糕的时间管理能力，让一整年很多事情做起来毫无头绪，并行多线程互抢资源的情况经常发生。所以，新的一年，结合日记和一个合适的GTD方法，管理自己的时间，将是重点关注的事情。</li>
<li>关于健身：两天一次。</li>
<li>关于性格：藏拙，克己，平心，助人。</li>
<li>关于知识结构：结合时间管理，有计划的补充知识点。就技术而言，两向发展，技术内核学习一个方向，实践coding另一个方向。就知识面而言，依兴趣点规划，比如心理学方面把荣格的作品看完。</li>
<li>关于写作：2015年，其实总结了不少文章，但是因为懒惰，也因为感觉没有时间去整理，就没有挂在博客上。2016年，我还是应当学会用清晰的文字表达自己的学习内容，研究问题，学会表达。</li>
</ul>
<p>整个2015年，我认识到的另一件重要事，也是非常浅显的道理：所有的预想和规划，都无法代替真正的经历和体会，只有实践才能给出答案。所有对2016年的规划，都不过是一种期许，在新的一年，也许自己会面对新的挑战，不期而遇的变化，所有的计划都追赶不上变化，而我唯一要做的，就是努力将时光铺陈在所有美好的事物上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>镇定一下，我要开始总结了。</p>
<p>2014年的末尾，我没有为自己预想未来的一年我会有怎样的生活，因为每一个转折点，都会扩散出许多种可能，这些可能的叠加，最终会超出我所有预想的结果。</p>
<p>在2014年年中，有一个大转折点，我将它称之为1.0生活到2.0生活的]]>
    </summary>
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Python写一个虚拟解释器]]></title>
    <link href="http://yoursite.com/2015/11/09/%E7%94%A8Python%E5%86%99%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://yoursite.com/2015/11/09/用Python写一个虚拟解释器/</id>
    <published>2015-11-09T13:18:08.000Z</published>
    <updated>2015-11-09T13:20:14.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br><a id="more"></a></p>
<h2 id="0-_解释器到底是什么">0. 解释器到底是什么</h2>
<p>前边解释了一些，但解释的并不清楚，在<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a>中，做一个比较不错的解释。</p>
<blockquote>
<p>首先我们来谈一下解释器是什么。说白了解释器跟计算器差不多。它们都接受一个“表达式”，输出一个 “结果”。比如，得到 ‘(+ 1 2) 之后就输出 3。不过解释器的表达式要比计算器的表达式复杂一些。解释器接受的表达式叫做“程序”，而不只是简单的算术表达式。从本质上讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p>
<p>需要注意的是，我们的解释器接受的参数是一个表达式的“数据结构”，而不是一个字符串。这里我们用一种叫“S-expression”的数据结构来表示表达式。比如表达式 ‘(+ 1 2) 里面的内容是三个符号：’+, ‘1 和 ‘2，而不是字符串“(+ 1 2)”。从结构化的数据里面提取信息很方便，而从字符串里提取信息很麻烦，而且容易出错。</p>
<p>从广义上讲，解释器是一个通用的概念。计算器实际上是解释器的一种形式，只不过它处理的语言比程序的解释器简单很多。也许你会发现，CPU 和人脑，从本质上来讲也是解释器，因为解释器的本质实际上是“任何用于处理语言的机器”。</p>
</blockquote>
<h2 id="1-_学习写一个解释器的另一个原因">1. 学习写一个解释器的另一个原因</h2>
<p>在《编程珠玑》的第十章，提到代码空间技术，如何节省足够的空间，讲到了解释程序。他说，远古时代，有时候空间的瓶颈不在于数据，而在于程序本身的规模。比如一开始一个图形程序，有如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">17</span>, <span class="number">43</span>]</span> set(<span class="built_in">i</span>, <span class="number">68</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="matrix">[<span class="number">18</span>, <span class="number">42</span>]</span> set(<span class="built_in">i</span>, <span class="number">69</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">81</span>, <span class="number">91</span>]</span> set(<span class="number">30</span>, <span class="built_in">j</span>)</div><div class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="matrix">[<span class="number">82</span>, <span class="number">92</span>]</span> set(<span class="number">31</span>, <span class="built_in">j</span>)</div></pre></td></tr></table></figure>

<p>其中，set(i,j)表示点亮屏幕（i, j）处的像素，也就是说这实际上是一个绘制直线的程序。而当我们使用了适当的函数，比如用于绘制水平线的hor函数和垂直线的ver函数，就可以替代上述代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">hor</span><span class="params">(<span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span>)</span></span></div><div class="line"><span class="title">hor</span><span class="params">(<span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span>)</span></div><div class="line"><span class="title">ver</span><span class="params">(<span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span>)</span></div></pre></td></tr></table></figure>

<p>而上述代码又可以利用一个解释器来替换，这个解释程序可以从下面的数组中读取命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">h</span> <span class="number">17</span>, <span class="number">43</span>, <span class="number">68</span></div><div class="line">h <span class="number">18</span>, <span class="number">42</span>, <span class="number">69</span></div><div class="line">v <span class="number">81</span>, <span class="number">91</span>, <span class="number">30</span></div><div class="line">v <span class="number">82</span>, <span class="number">92</span>, <span class="number">31</span></div></pre></td></tr></table></figure>

<p>至此，我们已经将空间减小了很多了，但如果你还想减少，那么就可以为命令h 或 v分配两个位，为后边的三个数字，每个数字，分配10个位置，这样一个32位的数字，表示一行命令了。这就是代码空间技术的运用。</p>
<p>当然，今天我们谈起节省空间，好像已经成了笑话，但是，当我们面对巨量数据，也就是我们今天所说的大数据的时候，空间，时间，效率的话题又一次被提起来。当我们面对着像混乱电流一样的数据时，尝试将自己的头脑想象成计算机，学会用更加底层的方式去思考，对对理解数据处理将有更深刻的认识。</p>
<p>为什么我们时常提起像机器一样思考呢？那是因为机器远比我们人类严谨，也是所有检验逻辑最严格的关卡，他不容许一点点错误，一个毫不起眼的bug，都会让程序完全崩溃。而程序是写给计算机的语言，所以，程序的严谨性就应当像计算机一样严谨。所以我们时常劝告自己要像计算机一样思考。</p>
<p>正如『正义的花生』在<a href="http://www.jianshu.com/p/f0863846b7e8" target="_blank" rel="external">数学与编程</a>中提到的一样：</p>
<blockquote>
<p>普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言好很多。用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。如果你的代码有问题，它迟早会导致出问题。</p>
</blockquote>
<p>诚然，大牛作者在思想上有很多偏执的地方，但是往往他的观点我都有着不小的认同感。前边那篇『怎样写一个解释器』也是他的文章。</p>
<p>所以，学习写一个解释器，可以带给我更多的思考，从效率，空间，机器等等方面进一步认识程序运行的本质，将这种认识正反馈到实际编程中，将潜移默化的带来影响。当然，这篇文章试着依葫芦画瓢的写完一个解释器，显然仅仅算是摸了摸门道，想要继续探索，还有更多的事情可以做。做更多的事情，可以参考上边提到的开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。</p>
<h2 id="1-_构建堆栈机">1. 构建堆栈机</h2>
<p>堆栈机的执行原理很简单，将需要处理的值放进堆栈中，然后执行。Python， Java这些高级语言将它作为自己的虚拟机。</p>
<p>所以我们利用了堆栈的方式存放指令。首先，我们需要一个指令指针栈，它能够储存返回地址。这个返回地址就是当我们执行一个子程序（如函数）的时候，需要用它跳回到开始调用该函数的地方。</p>
<p>我们将这个复杂的问题简洁化。比如有一个数学表达式：<code>（2+3）*4</code> ，这个表达式的意思就是依次推入<code>2 3 + 4 *</code>, 将2 和3 依次推入栈中，接下来要推入的指令是 <code>+</code>， 将两个数字弹出，令他们执行加法运算，然后将结果入栈。然后继续进行下去，直到计算出结果。</p>
<p>依靠这个原理，我们开始建立一个栈，我们使用python 中的一个类 collections.deque。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(deque)</span>:</span> <span class="comment"># 定义一个栈</span></div><div class="line">    push = deque.append  <span class="comment"># 添加元素</span></div><div class="line">    <span class="comment"># 返回最后一个元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self[-<span class="number">1</span>]</div></pre></td></tr></table></figure>

<p>deque 中自带pop 方法，所以我们就不用再定义 pop .</p>
<p>接下来我们继续构建一个虚拟机的类 Machine。 我们需要两个栈和一段储存代码的内存空间。一个栈储存数据，一个栈储存地址。得益于Python 动态类型，因此我们可以往列表里面存储任何东西，但是我们不能区分列表里面的内置函数和字符串，正确的做法是将Python 内置函数单独存放在一个列表。这里我们使用字典方法，键值分别对应字符串和函数。另外，我们需要一个指令指针，用来指向代码中下一个需要被执行的模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Machine</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, code)</span>:</span> <span class="comment"># 预先定义一个初始化函数</span></div><div class="line">       self.data_stack = Stack()</div><div class="line">       self.return_addr_stack = Stack()</div><div class="line">       self.code = code</div><div class="line">       self.instruction_pointer = <span class="number">0</span> </div><div class="line">    <span class="comment"># 再创建一些栈结构中必备的函数</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.pop()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.data_stack.push(value)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data_stack.top()</div></pre></td></tr></table></figure>

<p>为了执行操作码，而这个操作码并非实际意义上的操作码，它只是一种动态类型，所以我们建立一个dispatch 函数，在这之前，我们创建一个解释器的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>   <span class="comment"># 代码运行的条件</span></div><div class="line">    <span class="keyword">while</span> self.instruction_pointer &lt; len(self.code):</div><div class="line">         opcode = self.code[self.instruction_pointer]</div><div class="line">         self.instruction_pointer += <span class="number">1</span></div><div class="line">         self.dispatch(opcode)</div></pre></td></tr></table></figure>

<p>它的原理很简单： 获取下一个指令，指令指针自增1 然后基于操作码执行dispatch 函数，下面就是dispatch函数的定义。而对解释器的扩展增强基本在这个函数中实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, op)</span>:</span></div><div class="line">    dispatch_map = {</div><div class="line">        <span class="string">"%"</span>:        self.mod,</div><div class="line">        <span class="string">"*"</span>:        self.mul,</div><div class="line">        <span class="string">"+"</span>:        self.plus,</div><div class="line">        <span class="string">"-"</span>:        self.minus,</div><div class="line">        <span class="string">"/"</span>:        self.div,</div><div class="line">        <span class="string">"=="</span>:       self.eq,</div><div class="line">        <span class="string">"cast_int"</span>: self.cast_int,</div><div class="line">        <span class="string">"cast_str"</span>: self.cast_str,</div><div class="line">        <span class="string">"drop"</span>:     self.drop,</div><div class="line">        <span class="string">"dup"</span>:      self.dup,</div><div class="line">        <span class="string">"if"</span>:       self.if_stmt,</div><div class="line">        <span class="string">"jmp"</span>:      self.jmp,</div><div class="line">        <span class="string">"over"</span>:     self.over,</div><div class="line">        <span class="string">"print"</span>:    self.print_,</div><div class="line">        <span class="string">"println"</span>:  self.println,</div><div class="line">        <span class="string">"read"</span>:     self.read,</div><div class="line">        <span class="string">"stack"</span>:    self.dump_stack,</div><div class="line">        <span class="string">"swap"</span>:     self.swap,</div><div class="line">        }</div><div class="line">    <span class="keyword">if</span> op <span class="keyword">in</span> dispatch_map:</div><div class="line">        dispatch_map[op]()</div><div class="line">    <span class="keyword">elif</span> isinstance(op, int):  <span class="comment"># 如果指令是整形数据，就将数据存放到数据栈中</span></div><div class="line">        self.push(op)</div><div class="line">    <span class="keyword">elif</span> isinstance(op, str) <span class="keyword">and</span> op[<span class="number">0</span>]==op[-<span class="number">1</span>]==<span class="string">'"'</span>:</div><div class="line">        <span class="comment"># 如果是字符串类型，就将字符串内容存放到数据栈中</span></div><div class="line">        self.push(op[<span class="number">1</span>:-<span class="number">1</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError( <span class="string">"Unknown opcode: '%s'"</span> % op)</div></pre></td></tr></table></figure>

<p>上边的指令的意思是，当输入一段指令后，该函数就会根据这段指令在字典中找到对应的方法。比如符号<code>*</code>对应的是self.mul 。而这个self.mul 也是我们定义的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self)</span>:</span></div><div class="line">    self.push(self.pop() * self.pop())</div></pre></td></tr></table></figure>

<p>其他的函数定义也如此。</p>
<p>搭建好环境之后，下面继续进行。一个语言解释器包括两个部分：</p>
<ol>
<li>解析：解析部分接受一个由字符序列表示的输入指令，然后将输入字符分解成一系列的词法单元</li>
<li>执行： 程序内部的解释器根据语义规则进一步处理词法单元，进而执行原指令的实际运算。</li>
</ol>
<p>这是流程图：</p>
<figure class="highlight flow"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 指令</div><div class="line">op1=&gt;operation: 解析器</div><div class="line">op2=&gt;operation: 词法单元</div><div class="line">op3=&gt;operation: 执行运算</div><div class="line">e=&gt;end: 结果</div><div class="line"></div><div class="line">st<span class="variable">-&gt;op1</span><span class="variable">-&gt;op2</span><span class="variable">-&gt;op3</span><span class="variable">-&gt;e</span></div></pre></td></tr></table></figure>

<h2 id="2-_下面我们创建一个简单的解析器">2. 下面我们创建一个简单的解析器</h2>
<p>使用<a href="https://docs.python.org/3/library/tokenize.html" target="_blank" rel="external">tokenize</a>模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tokenize</div><div class="line"><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="comment"># 将text以StringIO的形式读入内存</span></div><div class="line">    <span class="comment"># 以字符串形式返回刀generate_tokens()函数中。</span></div><div class="line">    tokens = tokenize.generate_tokens(StringIO(text).readline)</div><div class="line">    <span class="comment"># generate_tokens 生成器生成一个5元组：标记类型、标记字符串、标记开始位置二元组、标记结束位置二元组以及标记所在的行号</span></div><div class="line">    <span class="comment"># 下面大写的单词都属于token模块的常量</span></div><div class="line">    <span class="keyword">for</span> toknum, tokval, _, _, _ <span class="keyword">in</span> tokens:</div><div class="line">        <span class="keyword">if</span> toknum == tokenize.NUMBER:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> toknum <span class="keyword">in</span> [tokenize.OP, tokenize.STRING, tokenize.NAME]:</div><div class="line">            <span class="keyword">yield</span> int(tokval)</div><div class="line">        <span class="keyword">elif</span> tokun == tokenize.ENDMARKER:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"Unknown token %s: '%s'"</span> % (tokenize.tok_name[toknum], tokval))</div></pre></td></tr></table></figure>

<p>关于token常量，查看<a href="https://docs.python.org/3/library/token.html#module-token" target="_blank" rel="external">官方文档</a>。</p>
<p>其中还有一个关键字 <code>yield</code>，它是用来定义生成器(Generator)，具体功能是可以当return 使用，从函数理返回一个值，不同之处是用yield 返回之后，可以让函数从上回yield 返回的地点继续执行。也就是说，yield 返回函数，交给调用者一个返回值，然后再移动回去，让函数继续运行下去，知道下一个yield语句再返回一个新的值。举个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def test_yield():</div><div class="line">...     yield 1</div><div class="line">...     yield 2</div><div class="line">...     yield (1,2)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; a = test_yield()</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">1</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">2</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">(1, 2)</div><div class="line">&gt;&gt;&gt; a.next()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">StopIteration</div></pre></td></tr></table></figure>

<p>我们用生成器产生一个Fibonacci数列的函数就会更加直观：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></div><div class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></div><div class="line">    <span class="keyword">while</span> a &lt; max:</div><div class="line">        <span class="keyword">yield</span> a</div><div class="line">        a, b = b, a+b</div><div class="line"> </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> fab(<span class="number">20</span>):</div><div class="line"><span class="prompt">... </span>    <span class="keyword">print</span> i,<span class="string">","</span>,</div><div class="line">...</div><div class="line"><span class="number">0</span> , <span class="number">1</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">5</span> , <span class="number">8</span> , <span class="number">13</span> ,</div></pre></td></tr></table></figure>

<h2 id="3-_简单优化：_常量折叠">3. 简单优化： 常量折叠</h2>
<blockquote>
<p>常量折叠是其中一种被很多现代编译器使用的编译器最优化技术。常量折叠是在编译时间简单化常量表达的一个过程。简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表。可以算作一种编译优化。</p>
</blockquote>
<p>也就是我们最早举例子的时候说的，将2，3放入栈中，+ 进来的时候，2 3取出来进行运算，然后将运算结果放入栈中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_fold</span><span class="params">(code)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="comment"># 指令中找到两个连续的数字以及一个运算符</span></div><div class="line">        <span class="keyword">for</span> i, (a, b, op) <span class="keyword">in</span> enumerate(zip(code, code[<span class="number">1</span>:], code[<span class="number">2</span>:])):</div><div class="line">            <span class="keyword">if</span> isinstance(a, int) <span class="keyword">and</span> isinstance(b, int) <span class="keyword">and</span> op <span class="keyword">in</span> {<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>}:</div><div class="line">                m = Machine((a, b, op))</div><div class="line">                m.run()</div><div class="line">                code[i:i+<span class="number">3</span>] = [m.top()]</div><div class="line">                print(<span class="string">"Constant-folded %s%s%s to %s"</span> % (a, op, b, m.top()))</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> code</div></pre></td></tr></table></figure>

<h2 id="读取-求值-输出循环">读取-求值-输出循环</h2>
<blockquote>
<p>“读取-求值-输出”循环（英语：Read-Eval-Print Loop，简称REPL）是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境，但也能指代命令行的模式和例如APL、BASIC、Clojure、F#、Haskell、J、Julia、Perl、PHP、Prolog、Python、R、Ruby、Scala、Smalltalk、Standard ML、Tcl、Javascript这样的编程语言所拥有的类似的编程环境。这也被称做交互式顶层构件（interactive toplevel）。</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" target="_blank" rel="external">read-eval-print loop</a><br>这个名字来自于以下几个Lisp用来实现这种机制的内置函数：</p>
<ul>
<li>读入函数接收一个来自于用户的表达式，将其解析成数据结构并存入内存。例如，用户可能会输入一个s-表达式　(+ 1 2 3)，这句话会被解析成一个包含四个元素的链表。</li>
<li>求值函数　负责处理内部的数据结构并对其求值。在Lisp中，求一个以函数名开头的ｓ－表达式意味着对接下来的参数调用那个函数。所以函数”+”被在参数1 2 3上调用，产生结果6。</li>
<li>输出函数接受求值结果，并呈现将其给用户。尽管当前的结果“6”并不具有复杂的格式，但如果是一个较为复杂的表达式，那么它将会被精心处理，以便于更方便地被理解。</li>
</ul>
<p>代码应当这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Hit CTRL+D or type "exit" to quit.'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            source = raw_input(<span class="string">"&gt; "</span>)</div><div class="line">            code = list(parse(source))</div><div class="line">            code = constant_fold(code)</div><div class="line">            Machine(code).run()</div><div class="line">        <span class="keyword">except</span> (RuntimeError, IndexError) <span class="keyword">as</span> e:</div><div class="line">            print(<span class="string">"IndexError: %s"</span> % e)</div><div class="line">        <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">            print(<span class="string">"\nKeyboardInterrupt"</span>)</div></pre></td></tr></table></figure>

<h2 id="再思考">再思考</h2>
<p>这样，基本上的我们就完成了一个简单的解释器，实际上它的能力很弱小，但是作为一个锻炼思考的方式，是一个不错的实践。接下来，可以给这个解释器添加更多的功能。</p>
<p>另外，推荐几个其他的文章：<br><a href="http://python.jobbole.com/82206/" target="_blank" rel="external">用 Python 从零开始写一个简单的解释器</a><br><a href="http://blog.jobbole.com/88152/" target="_blank" rel="external">一起来写个简单的解释器</a><br><a href="http://blog.jobbole.com/47659/" target="_blank" rel="external">如何使用Python编写一个Lisp解释器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.jianshu.com/p/28c029de8fb3" target="_blank" rel="external">刀背藏身|简书</a><br>先来看看这篇文章 <a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter/" target="_blank" rel="external">怎样写一个解释器</a></p>
<p>所谓虚拟机器，就是一定意义上的堆栈机。<br>解释器能够执行其他计算机语言编写的程序的系统软件，他是一个翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般比较低。解释器的实现比较简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。<br>可参考<a href="https://csl.name/post/vm/" target="_blank" rel="external">本链接</a>，开源项目<a href="https://github.com/cslarsen/crianza" target="_blank" rel="external">Crianza</a>。<br>当然，解释器要从最基础的最简单的语言开始，然后逐步增加语言的复杂度，才能构造出正确的解释器。而最基础的一个解释器，其实就是一个高级的计算器，下面我们一起来创建一个解释器吧。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python高效编程小技巧]]></title>
    <link href="http://yoursite.com/2015/10/28/Python%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/10/28/Python高效编程小技巧/</id>
    <published>2015-10-28T13:34:59.000Z</published>
    <updated>2015-10-28T13:37:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Python_高效编程小技巧">Python 高效编程小技巧</h1>
<p>Python 一直被我拿来写算法题，小程序，因为他使用起来太方便了，各种niubi闪闪的技能点也在写算法的过程中逐渐被挖掘到，感谢万能的谷哥度娘SOF以及各大博客网站，在这里整理一二。<br><a id="more"></a><br><strong>几句废话：</strong></p>
<blockquote>
<p>因为我是懒癌晚期，最不喜欢在文章里发图片，因为Mweb写作或者是马克飞象写作，可以直接拖图进来，但是上传博客的话，就需要考虑是使用服务器上的媒体库，还是放七牛，放七牛上还得用它的命令行工具，或者是Web端操作，想想都好麻烦。所以，本地一直存放着几篇写完的文章楞是没有上传（一篇探索红黑树，一篇是设计模式C++版半完全指南，一篇是Linux的小文章），就是因为往里边塞了太多图片的原因。所以以后写文，尽量控制图片 &lt;= 3。</p>
</blockquote>
<p>下面进入密集式正题，过于炫技的部分被我去掉了，因为我看过之后只是碎了膝盖，然而并不常用。因为自己很少做整理，现在知道整理的强大之处了，所以以后也会注意相关知识的整理。以下方法的适用场景我也就不用多说了，因为都是最最常见的场景：</p>
<h2 id="1-_拆箱（这个方法比较常见，非常高效）">1. 拆箱（这个方法比较常见，非常高效）</h2>
<p>变量声明利用拆箱这种方式，非常高效，这也算是Python 里最常用的技巧了，也是我最开始使用 Python 时感觉非常惊奇的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c = (<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c</div><div class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, (b, c), d = [<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b, c, d</div><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></div></pre></td></tr></table></figure>

<p>拆箱也可用于变量交换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>, <span class="number">2</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b = b, a</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a, b</div><div class="line">(<span class="number">2</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>

<h2 id="2-_指定步长的切割">2. 指定步长的切割</h2>
<p>刚开始接触Python 的时候，被Python 深拷贝的方式逗乐了，写Python 你可以利用想象力写代码。深拷贝利用的就是这个指定步长的切割。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line"><span class="comment"># 下边这个实现深拷贝</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> a[::<span class="number">1</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line"><span class="comment"># 逆序拷贝</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> a[::-<span class="number">1</span>]</div><div class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</div><div class="line"><span class="comment"># 你还可以给切割的部分赋值，也可以借此插入数组</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">0</span>, <span class="number">0</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="comment"># 还有命名列表切割方式</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>last_three = slice(-<span class="number">3</span>, <span class="keyword">None</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>last_three</div><div class="line">slice(-<span class="number">3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a[last_three]</div><div class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>

<h2 id="3-_压缩器zip">3. 压缩器zip</h2>
<p>zip 这个也是靠想象力实现各种各样的功能。</p>
<ol>
<li>列表 or 迭代器的压缩与解压缩</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>z = zip(a, b)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>z</div><div class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(*z)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)]</div></pre></td></tr></table></figure>

<ol>
<li>列表相邻元素压缩器</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(*([iter(a)] * <span class="number">2</span>))</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*([iter(a)] * k))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</div><div class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(a[::<span class="number">2</span>], a[<span class="number">1</span>::<span class="number">2</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(a[::<span class="number">3</span>], a[<span class="number">1</span>::<span class="number">3</span>], a[<span class="number">2</span>::<span class="number">3</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: zip(*(a[i::k] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</div><div class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</div></pre></td></tr></table></figure>


<ol>
<li>用压缩器翻转字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m.items()</div><div class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(m.values(), m.keys())</div><div class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'d'</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>mi = dict(zip(m.values(), m.keys()))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>mi</div><div class="line">{<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>}</div></pre></td></tr></table></figure>

<h2 id="4-_列表展开">4. 列表展开</h2>
<p>列表展开的方式五花八门，动用大脑可以创造各种各样的方法，最便于理解的是以下两种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(a, [])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>

<h2 id="5-_生成器表达式">5. 生成器表达式</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>g = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</div><div class="line"><span class="number">2025</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>sum(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">1</span>)</div><div class="line"><span class="number">408</span></div></pre></td></tr></table></figure>

<h2 id="6-_字典推导和集合推导">6. 字典推导和集合推导</h2>
<p>一上来我打成了推倒是什么心理，相信在平时推导过列表，他还有更多的应用方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这个是最常见的推导</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list2 = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> list1]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list2</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="comment"># 我们可以用语法来创建集合和字典表，开开脑洞</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = { x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> }</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</div><div class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</div><div class="line"><span class="comment"># 其实，我们有更简单的方式创建一个集合：</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>setlist = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>setlist</div><div class="line">set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"><span class="comment"># 创建字典表</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>d = { x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) }</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>d</div><div class="line">{<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>}</div><div class="line"><span class="comment"># 利用这个脑洞，你还可以用字典推导翻转字典</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m</div><div class="line">{<span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>{v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items()}</div><div class="line">{<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>}</div></pre></td></tr></table></figure>

<p>另外，刚刚提到了，直接省略set 方式的创建集合，它还有一些在这基础之上更犀利的应用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B</div><div class="line">set([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A | B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A & B</div><div class="line">set([<span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A - B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>B - A</div><div class="line">set([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>A ^ B</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>(A ^ B) == ((A - B) | (B - A))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>

<h2 id="7-_Counter_计数器">7. Counter 计数器</h2>
<p>对于我们来说，数一个东西，是非常常用的，然而这件事又不是程序员喜欢做的事情，我们用 counter 来完成这个操作。他在我们python 内置的库里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c = Counter(<span class="string">'hello world'</span>)</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c</div><div class="line">Counter({<span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>})</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>c.most_common(<span class="number">2</span>)</div><div class="line">[(<span class="string">'l'</span>, <span class="number">3</span>), (<span class="string">'o'</span>, <span class="number">2</span>)]</div></pre></td></tr></table></figure>

<h2 id="8-_双端队列">8. 双端队列</h2>
<p>我们都知道，队列和栈实际上就是对在双端队列的基础上实现的，python可以直接操作双端队列。当然也在内置的库 collections 里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q = collections.deque()</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.append(<span class="number">1</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.appendleft(<span class="number">2</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.extend([<span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.extendleft([<span class="number">5</span>, <span class="number">6</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.pop()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.popleft()</div><div class="line"><span class="number">6</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.rotate(<span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q.rotate(-<span class="number">3</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>Q</div><div class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure>

<p>同时，我们还可以在括号里添加 maxlen 来限制双端队列的最大长度。<code>last_three = collections.deque(maxlen=3)</code></p>
<h2 id="9-_默认词典">9. 默认词典</h2>
<p>一般情况下，空词典它就是空的，但是我们利用 collections 里的函数，可以实现默认的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = dict()</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">KeyError: <span class="string">'a'</span></div><div class="line"><span class="comment"># 你可以在括号里添加各种条件</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(int)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(str)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="string">''</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>] += <span class="string">'a'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="keyword">lambda</span>: <span class="string">'[default value]'</span>)</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'a'</span>]</div><div class="line"><span class="string">'[default value]'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>m[<span class="string">'b'</span>]</div><div class="line"><span class="string">'[default value]'</span></div></pre></td></tr></table></figure>

<h2 id="10-_利用json库打印出漂亮的JSON串">10. 利用json库打印出漂亮的JSON串</h2>
<p>这个方法就是为了让让人面对眼花缭乱的JSON串，能够打印出一个漂亮的可读的格式，对于在控制台交互编程，或者是做日志是，还是非常有用的。另外，也可以注意一下pprint 这个模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">data = {<span class="string">"status"</span>: <span class="string">"OK"</span>, <span class="string">"count"</span>: <span class="number">2</span>, <span class="string">"results"</span>: [{<span class="string">"age"</span>: <span class="number">27</span>, <span class="string">"name"</span>: <span class="string">"Oz"</span>, <span class="string">"lactose_intolerant"</span>: true}, {<span class="string">"age"</span>: <span class="number">29</span>, <span class="string">"name"</span>: <span class="string">"Joe"</span>, <span class="string">"lactose_intolerant"</span>: false}]}</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>print(json.dumps(data))  <span class="comment"># No indention</span></div><div class="line">{<span class="string">"status"</span>: <span class="string">"OK"</span>, <span class="string">"count"</span>: <span class="number">2</span>, <span class="string">"results"</span>: [{<span class="string">"age"</span>: <span class="number">27</span>, <span class="string">"name"</span>: <span class="string">"Oz"</span>, <span class="string">"lactose_intolerant"</span>: true}, {<span class="string">"age"</span>: <span class="number">29</span>, <span class="string">"name"</span>: <span class="string">"Joe"</span>, <span class="string">"lactose_intolerant"</span>: false}]}</div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">2</span>)) {</div><div class="line">  <span class="string">"status"</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="string">"count"</span>: <span class="number">2</span>,</div><div class="line">  <span class="string">"results"</span>: [</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="string">"age"</span>: <span class="number">27</span>,</div><div class="line">      <span class="string">"name"</span>: <span class="string">"Oz"</span>,</div><div class="line"></div><div class="line">      <span class="string">"lactose_intolerant"</span>: true</div><div class="line">    },</div><div class="line">    {</div><div class="line">      <span class="string">"age"</span>: <span class="number">29</span>,</div><div class="line"></div><div class="line">      <span class="string">"name"</span>: <span class="string">"Joe"</span>,</div><div class="line">      <span class="string">"lactose_intolerant"</span>: false</div><div class="line">    }</div><div class="line">  ]</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="11-_最大和最小的几个列表元素">11. 最大和最小的几个列表元素</h2>
<p>这个经常用到啊，少年们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random, heapq</div><div class="line">a = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">100</span>)]</div><div class="line">b = heapq.nsmallest(<span class="number">5</span>, a)</div><div class="line">c = heapq.nlargest(<span class="number">5</span>, a)</div><div class="line"><span class="keyword">print</span> b,c</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>]</div></pre></td></tr></table></figure>

<h2 id="12-_一些更贴近大脑的写法，和一些掉了下巴的代码段">12. 一些更贴近大脑的写法，和一些掉了下巴的代码段</h2>
<p>有一些语句，写出来你就能读懂，就像读一篇文章一样。有时候，其他语言用了超长的代码写出来的程序，python只需要几行，甚至是，1行。</p>
<ol>
<li>数值比较</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">2</span></div><div class="line"><span class="keyword">if</span> <span class="number">3</span> &gt; x &gt; <span class="number">1</span>:</div><div class="line">   <span class="keyword">print</span> x</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span></div><div class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; x &gt; <span class="number">0</span>:</div><div class="line">   <span class="keyword">print</span> x</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span></div></pre></td></tr></table></figure>

<ol>
<li>有这么一个算法题，打印数字1到100，3的倍数打印“Fizz”来替换这个数，5的倍数打印“Buzz”，对于既是3的倍数又是5的倍数的数字打印“FizzBuzz”。对此，我们只使用一行代码，搞定它.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):<span class="keyword">print</span><span class="string">"fizz"</span>[x % <span class="number">3</span>*<span class="number">4</span>::]+<span class="string">"buzz"</span>[x % <span class="number">5</span>*<span class="number">4</span>::]<span class="keyword">or</span> x</div></pre></td></tr></table></figure>

<h2 id="13-_一个超小型的Web服务">13. 一个超小型的Web服务</h2>
<p>我们在两台机器或者服务器之间做一些简单的基础的RPC之类的交互，我们就可以用到python 这个神奇的模块。<br>服务器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_reader</span><span class="params">(file_name)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">return</span> f.read()</div><div class="line"></div><div class="line">server = SimpleXMLRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>))</div><div class="line">server.register_introspection_functions()</div><div class="line"></div><div class="line">server.register_function(file_reader)</div><div class="line"></div><div class="line">server.serve_forever()</div></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xmlrpclib</div><div class="line">proxy = xmlrpclib.ServerProxy(<span class="string">'http://localhost:8000/'</span>)</div><div class="line"></div><div class="line">proxy.file_reader(<span class="string">'/tmp/secret.txt'</span>)</div></pre></td></tr></table></figure>

<p>这样就得到了一个远程文件读取工具，超小型，没有外部依赖，当然没有任何安全可言，仅作家里使用，当然我现在还没用过这个。</p>
<hr>
<p>人生苦短，我用Python。</p>
<p>ps. 似乎不说一句这个名言，就不像是在写Python一样。当然了，我还是要滚回去好好地学C++。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Python_高效编程小技巧">Python 高效编程小技巧</h1>
<p>Python 一直被我拿来写算法题，小程序，因为他使用起来太方便了，各种niubi闪闪的技能点也在写算法的过程中逐渐被挖掘到，感谢万能的谷哥度娘SOF以及各大博客网站，在这里整理一二。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里云上CentOS的图形访问]]></title>
    <link href="http://yoursite.com/2015/10/11/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8ACentOS%E7%9A%84%E5%9B%BE%E5%BD%A2%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2015/10/11/阿里云上CentOS的图形访问/</id>
    <published>2015-10-11T08:14:49.000Z</published>
    <updated>2015-10-11T08:33:47.000Z</updated>
    <content type="html"><![CDATA[<p>因为阿里云给学生白菜价格购买ECS，那我就买来玩玩，顺便用来学习Linux/UNIX。买回来之后，发现闲着也是闲着，就现在上边搭了个博客，用 WordPress。因为WordPress这个建站很厉害，但是以前在自己的电脑上，不想为了玩一下wordpress 配置一堆东西，把电脑搞乱了，所以一直用的 Hexo这个用node.js写的轻量博客系统，挂在Github上。<br><a id="more"></a><br>这个新的博客先放在二级域名上 new.xuelinf.cc ，不过阿里云上建站要备案，目前还在备案中（备案是一个坑坑的过程），想要访问还是用IP访问吧 ：）。目前想法是吧这个网站做成一个小小的圈子，放一些干货，文章之类的东西上去。<a href="http://115.28.190.231" target="_blank" rel="external">地址在这里</a></p>
<p>WordPress 现在这个系统真的是太大了，传说全球百分之二十多的网站都是使用WordPress搭建的，也就是每进入四个网站，就有一个是用WP做的，当然了，不同水平有不同的效果，有闲功夫我也会做几个WP的小插件或者主题玩玩。</p>
<p>回到正题，搭完WordPress之后，无聊之余，我就想建立图形访问，像远程登陆一样登陆CentOS，这样有时候学习Linux的话，更直观一些了。在阿里云文档的帮助下，解决了问题。下面是步骤：</p>
<hr>
<p>首先查看一下自己的centos的版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> /etc/redhat-release</div></pre></td></tr></table></figure>

<p>检查版本之后，导入CentOS 6 的证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">#rpm</span> <span class="subst">--</span><span class="keyword">import</span> http:<span class="comment">//mirrors.163.com/centos/RPM-GPG-KEY-CentOS-6</span></div></pre></td></tr></table></figure>

<p>为了让下载速度快一些，所以选用网易的源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#cd /etc/yum.repos.d/</span></div><div class="line"><span class="preprocessor">#wget http://mirrors.163.com/.help/CentOS-Base-163.repo</span></div></pre></td></tr></table></figure>

<p>所有mirrorlist前面加上#，把所有$releasever替换成6，保存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="array">#sed </span>-i <span class="string">'/mirrorlist/d'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'/\[addons\]/,/^$/d'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'s/\$releasever/6/'</span> CentOS-Base-<span class="number">163.</span>repo</div><div class="line"><span class="array">#sed </span>-i <span class="string">'s/RPM-GPG-KEY-CentOS-5/RPM-GPG-KEY-CentOS-6/'</span> CentOS-Base-<span class="number">163.</span>repo</div></pre></td></tr></table></figure>

<p>完成后，清理并重新生成yum缓存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#yum clean metadata</span></div><div class="line"><span class="preprocessor">#yum makecache</span></div></pre></td></tr></table></figure>

<p>因为想要远程图形访问，那么就首先要让CentOS有一个图形界面，下面就是安装 gnome 的图形界面了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"X Window System"</span></div><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"Desktop"</span></div><div class="line"><span class="array">#yum groupinstall </span>-y <span class="string">"Chinese Support"</span></div></pre></td></tr></table></figure>

<p>系统有了图形界面之后，就是安装和配置VNCserver了<br>首先看一下你有没有已经安装了vncserver</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -<span class="keyword">qa</span> |<span class="keyword">grep</span> vnc</div></pre></td></tr></table></figure>

<p>如果显示了<code>tigervnc-server-1.0.90-0.17.20110314svn4359.el6.x86_64</code>类似的一条，那么久已经安装过了，就不需要再安装了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#yum <span class="operator"><span class="keyword">install</span> -y tigervnc-<span class="keyword">server</span></span></div></pre></td></tr></table></figure>

<p>如果想设置为开机启动，那么可以<code>#chkconfig --level 345 vncserver on</code></p>
<p>配置vnc密码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#vncserver</span></div><div class="line">You will <span class="built_in">require</span> <span class="operator">a</span> password <span class="built_in">to</span> access your desktop.</div><div class="line">Password:</div><div class="line">Verify:</div></pre></td></tr></table></figure>

<p>将桌面配置为使用gnome桌面，修改 /root/.vnc/xstartup文件，把最后的 twm &amp; 删掉 加上 gnome-session &amp;。<br>配置VNCserver 启动监听端口和环境参数<br>修改/etc/sysconfig/vncservers 文件添加以下内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">VNCSERVERS</span>=<span class="string">"1:root"</span></div><div class="line"># 桌面号:用户    监听 <span class="number">590</span>* 端口</div><div class="line"><span class="constant">VNCSERVERARGS[1]</span>=<span class="string">"-geometry 1200x800"</span></div></pre></td></tr></table></figure>

<p>配置完成后，就是需要允许我们的root用户访问图形界面了，同时生成一个新的machine-id</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#sed -i 's/.*!= root.*/#&/' /etc/pam.d/gdm </span></div><div class="line"><span class="preprocessor">#dbus-uuidgen &gt;/var/lib/dbus/machine-id</span></div></pre></td></tr></table></figure>

<p>同时，一不做二不休，我把防火墙都关掉了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># service iptables stop </span></div><div class="line"><span class="preprocessor"># chkconfig iptables off</span></div></pre></td></tr></table></figure>

<p>然后在你的主机上下载<a href="http://www.realvnc.com/download/viewer/" target="_blank" rel="external">VNC Viewer</a>，这个软件支持我所能想到的所有设备了，连手机端也有。下载之后运行，host填入<code>address:1</code>，输入密码就可以远程访问了。</p>
<p><img src="http://i2.wp.com/upload-images.jianshu.io/upload_images/30117-4a0ebd4f135228eb.png?w=690" alt="pc_vncview"></p>
<p><img src="http://i0.wp.com/upload-images.jianshu.io/upload_images/30117-e3429711db2fc233.jpg?w=690" alt="ios_vncview"><br>当然，平时我也不能老开着这个VNCserver , 虽说阿里云上不开白不开。输入<code>vncserver -kill :2</code> 就行了。</p>
<p>感谢<a href="http://help.aliyun.com/knowledge_detail.htm?knowledgeId=5974462" target="_blank" rel="external">阿里云的帮助</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为阿里云给学生白菜价格购买ECS，那我就买来玩玩，顺便用来学习Linux/UNIX。买回来之后，发现闲着也是闲着，就现在上边搭了个博客，用 WordPress。因为WordPress这个建站很厉害，但是以前在自己的电脑上，不想为了玩一下wordpress 配置一堆东西，把电脑搞乱了，所以一直用的 Hexo这个用node.js写的轻量博客系统，挂在Github上。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《C陷阱与缺陷》笔记]]></title>
    <link href="http://yoursite.com/2015/10/08/%E3%80%8AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/10/08/《C陷阱与缺陷》笔记/</id>
    <published>2015-10-08T14:27:37.000Z</published>
    <updated>2015-10-08T14:45:50.000Z</updated>
    <content type="html"><![CDATA[<p>这本书超薄，但含金量很高，里边一些常见的陷阱也是面试的时留的坑，适合没事翻一翻，指不定什么时候还有意外惊喜。<br><a id="more"></a></p>
<h2 id="词法陷阱">词法陷阱</h2>
<p><strong>词法分析中的『贪心法』</strong>：<br>编译器将程序分解成符号的方法是,从左到右一个字符一个字符地读入,如果该字符可能组成一个符号,那么再读入下一个字符,判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分;如果可能,继续读入下一个字符,重复上述判断,直到读入的字符组成的字符串已不再可能组成一个有意义的符号。<br>比如：<code>y = x/*p</code>与<code>y = x / *p</code>一个将<code>/*</code> 理解为注释的开始，一个理解为指针。</p>
<p><strong>双引号与单引号</strong>：<br>也就是字符与字符串的区别，在C语言里，单引号引起的一个字符实际上代表的是一个张数，与ASCII严格对应。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针，该数组被双引号之间的字符以及一个额外的二进制值为0的字符<code>\0</code> 初始化。</p>
<h2 id="语法陷阱">语法陷阱</h2>
<p><strong><code>（*(void(*)())0）()</code>所代表的含义</strong><br>实际上一层一层看即可，<code>void(*)()</code>是一个函数指针,该函数返回<code>void</code>型数据<br><em>`(void(</em>)())0<code>*就是将常数0转换为指向返回值为</code>void<code>的函数的指针
而</code>(<em>(void(</em>)())0)();<code>就是一个表达式,调用</code>0`地址的函数</p>
<p>而它的等价表达式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef void (<span class="keyword">*</span>funcptr)();</div><div class="line">(<span class="keyword">*</span>(funcptr)0)();</div></pre></td></tr></table></figure>

<p><strong>运算符优先级问题</strong>：<br>这类问题例子很多，比如 <code>if (A &amp; B != 0)</code> 其中的<code>&amp;</code>优先级更低，所以先执行 非等判断，再进行与操作。所以解决这类问题的方式，就是在不知道优先级的情况下，加上括号就好了。记住几点：</p>
<ul>
<li>任何一个逻辑运算符的优先级低于任何一个关系运算符</li>
<li>移位运算符的优先级比算术运算符要低，但是比关系运算符要高</li>
<li>所有的赋值运算符的优先级是一样的，他们的结合方式是从右到左，所以<code>home = visitor = 0</code> 是从右往左赋值的。</li>
</ul>
<p><strong>几个小陷阱注意</strong></p>
<ul>
<li>分号，有时候不会引起编译错误，但是结果千差万别。</li>
<li><code>switch</code> 语句中每一个case 不要忘记<code>break</code>， 否则顺序执行。</li>
<li><code>else</code> 始终与同一对括号内最近的未匹配的if结合。</li>
</ul>
<h2 id="语义陷阱">语义陷阱</h2>
<p><strong>非数组的指针</strong>：<br>下面这个方法想要合并s， t两个字符串，变成一个单字符串r，但是这种方法是行不通的，因为不能确定r指向了何处。不仅要让<code>r</code> 指向一个地址，还应该有内存空间可供容纳字符串。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="value">char</span> *r;</div><div class="line"><span class="function">strcpy</span>(r, s);</div><div class="line"><span class="function">strcat</span>(r, t);</div></pre></td></tr></table></figure>

<p>在这里引入一个库函数<code>malloc</code> 实现这个操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *r, *<span class="built_in">malloc</span>();</div><div class="line">r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t));</div><div class="line"><span class="built_in">strcpy</span>(r, s);</div><div class="line"><span class="built_in">strcat</span>(r, t);</div></pre></td></tr></table></figure>

<p>但是这样仍然是不对的，原因有三个。</p>
<ul>
<li>malloc 函数可能无法提供请求的内存，这种情况下malloc 函数会返回一个空指针作为内存分配失败的信号。</li>
<li>r 分配的内存在使用结束后，应当立即释放。</li>
<li>长度是不够的，因为字符串最后一位空字符没有算在内，需要 +1。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *r, *<span class="built_in">malloc</span>();</div><div class="line">r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t) + <span class="number">1</span>)；</div><div class="line"><span class="keyword">if</span>(!r){</div><div class="line">	complain();</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">}</div><div class="line"><span class="built_in">strcpy</span>(r, s);</div><div class="line"><span class="built_in">strcat</span>(r, t);</div><div class="line"><span class="comment">//一段时间以后</span></div><div class="line"><span class="built_in">free</span>(r);</div></pre></td></tr></table></figure>

<p>（所以说，c简直就是个坑，入大Python教）</p>
<p><strong>空指针</strong><br>编译器保证由<code>0</code> 转化而来的指针不等于任何有效的指针，通常被<code>null</code> 这个值代替，所以任何企图使用该指针所指向的内存中存储的内容的行为都是非法的。</p>
<p><strong>求值顺序</strong>：<br>C语言中只有四个运算符<code>(&amp;&amp; ,  || ,  ?: , ,)</code>存在规定的求值顺序.运算符<code>&amp;&amp;</code>和运算符<code>||</code>首先对左侧操作数求值,只在需要时才对右侧操作数求值.运算符<code>?:</code>有3个操作数:在<code>a?b:c</code>中,操作数a首先被求值,根据<code>a</code>的值再求操作数<code>b</code>或<code>c</code>的值.而逗号运算符<code>,</code>首先对左侧操作数求值,然后该值被”丢弃”,再对右侧操作数求值.其他所有运算符对其操作数求值的顺序都是未定义的.特别的,赋值运算符并不保证任何求值顺序.</p>
<h2 id="连接">连接</h2>
<p>这部分是C语言的特性，所以就直接粗略的看了一下跳过去。<br><strong>static 修饰符与命名冲突</strong>：他是一个能有效减少命名冲突的方式，<code>static int a;</code> 之后，a 的作用域限制在了一个源文件里，其他文件是不可见的。<code>static</code> 同样适用于函数。</p>
<h2 id="库函数">库函数</h2>
<p>作者刁刁的，写这本书的时候，ANSI C 标准还没有最后定案。所以书中考虑了很多现在不需要考虑的问题，比如兼容各种风格，兼容K&amp;R 风格的函数定义形式。<br><strong><code>getchar（）</code>函数</strong>：<br>getchar()函数读取的字符，如何直接赋值给一个<code>char</code>型的 <code>c</code> ，就会出现问题。因为c无法容下所有可能的字符，特别是，可能无法容下读文件结束时候的<code>EOF</code>，这样就会出现问题，如果getchar()读入的字符无法存入<code>char c</code>中去，那么就会『截断』，结果可能正确，但是这样做是不对的。</p>
<p><strong>更新文件顺序</strong>：<br>一个输入操作不能随后直接紧跟一个输出操作，输入fread和输出fwrite同时操作，需在其中插入fseek函数的调用，之后文件就可以正常的读取或写入了。</p>
<p><strong>缓冲输出</strong>：<code>setbuf(stdout, buf)</code>  将写入刀stdout 的输出都使用buf 作为输出缓冲区，知道buf 缓冲区已满，或者是直接调用 <code>fflush</code> buf 缓冲区的内容才会实际写入stdout中去。</p>
<p><strong>errno 检测错误</strong>： 在库函数调用没有失败的情况下，并没有强制要求库函数一定要设置<code>errno</code> 为0，也可能是上一个执行失败的库函数设置的值。甚至在函数看似正确执行的情况下，也会将<code>errno</code> 设置一个值，所以用 <code>if(errno)</code> 来处理这个错误的方式是不可以的，我们可以用 <code>if (返回错误的值) 检查 errno</code> 这种方式，也就是我们检测作为错误指示的返回值，确定程序执行已经失败，再检查errno，来搞清楚错误原因。</p>
<p><strong> signal </strong>：信号这个函数非常的复杂，因为在其他的库函数中，可能已经有信号在执行过程中，我们再使用signal处理函数，极有可能导致数据完全崩溃。所以，信号非常的复杂和棘手，具有一些从本质上不可移植的特性，所以要让<code>signal</code>处理函数尽可能的简单。</p>
<h2 id="预处理器">预处理器</h2>
<p>C语言里的宏，和C++中的泛型模板，在精神上有相仿之处，也有人用C 的宏实现通用容器。众多C++书籍都告诉我们，宏是万恶之首，所以没达到得心应手的时候，所以这一块，当做了解来看。</p>
<p><strong>不要忽视宏定义中的空格</strong>：注意这里说的是<strong>宏定义</strong>。一个宏如果不带参数，则只需要调用宏名即可，括号无关紧要，所以宏定义后边的空格可能就会引起下面的麻烦。<br><code>#define f (x) ((x)-1)</code><br>f代表(x) ((x)-1),而不是f(x)代表((x)-1),后者应写为<br><code>#define f(x) ((x)-1)</code><br>这一规则不适用于宏调用,只对宏定义适用.因此上面完成宏定义后,f(3)与f (3)求值后都等于2.</p>
<p><strong>宏不是函数</strong>：最好在宏定义中把每个参数都用括号括起来，整个结果表达式也用括号括起来，防止当宏用于一个更大一些的表达式中可能出现的问题。<br><strong>宏不是语句</strong>：assert(e)的正确定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define <span class="keyword">assert</span>(e) /</div><div class="line">             ((<span class="keyword">void</span>)((e) || _assert_error(<span class="keyword">__FILE__</span>,<span class="keyword">__LINE__</span>)))</div></pre></td></tr></table></figure>

<p>这个定义实际上利用了||运算符对两侧的操作数依次顺序求值的性质.<br><strong>宏不是类型定义</strong>：<br>宏的一个常见用途是，让多个不同变量的类型可以在一个地方说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define FOOTYPE struct foo</span></div><div class="line"><span class="title">FOOTYPE</span> a;</div><div class="line"><span class="title">FOOTYPE</span> b,c;</div></pre></td></tr></table></figure>

<p>这样，我们只需要在程序中改动一行代码，就可以改变a, b, c 的类型了，而与a, b, c 在程序中的什么地方声明无关。这与<code>typedef</code> 的方式相同，但是后者更通用一些。而宏的方式某些时候，可能存在一些问题。</p>
<h2 id="可移植性缺陷">可移植性缺陷</h2>
<p>作者大牛在这里超前讨论了C语言在移植的时候小心的一些坑和缺陷。</p>
<ul>
<li><strong>标示符名称的限制</strong></li>
<li><strong>整数的大小</strong>：因为无法保证short型，int型，long型在不同语言中的长度，所以考虑到可移植性，也许最好的方式是使用long型，也可以自己定义一个新的类型。</li>
<li><strong>字符是有符号整数还是无符号整数</strong>：在char 类型转化刀较大的整数int类型时，做有符号处理还是无符号处理，影响是巨大的。而如果使用<code>（unsigned）c</code> 同样会带来问题，因为将字符转换为无符号的整数时，首先会被转换为int型整数，同样达不到预期效果，较好的解决方法是使用语句<code>（unsigned char）c</code> ，一个<code>unsigned char</code>类型的字符在转换为无符号整数类型的时候，无需首先转换为int型。</li>
<li><strong>移位运算符</strong>：<ul>
<li>向右移位时,空出的位是由0填充,还是由符号位的副本填充?<br>  如果被移位的对象是无符号数,那么空出的位将被0填充.如果被移位的是有符号数,那么C语言实现既可以用0填充空出的位,也可以用符号位的副本填充空出的位.</li>
<li>移位计数(即移位操作的位数)允许的取值范围是什么?<br>  如果被移位的对象长度是n位,那么移位计数必须大于或等于0,而严格小于n.</li>
<li>另外，不要用除法代替有符号的整数的移位运算，例如<code>（-1）&gt;&gt;1</code></li>
</ul>
</li>
<li>null 指针不知现任和对象，除非用于赋值和比较运算，其他用法都是非法的。</li>
<li><strong>除法运算</strong>：大多数编译器要求余数与被除数的正负号相同.</li>
<li><strong>随机数的大小</strong></li>
<li><strong>大小写的转换</strong>： C语言有两种处理大小写转换的方式，一种是直接利用ASCII码转换，但是当输入的字母大小写不对的时候，就会返回一些奇异的值，另一种则进行了一个判断操作，但是这样增加了开销，所以根据效率自行选择，在移植的时候，应当注意这个问题。</li>
<li><code>malloc</code>, <code>realloc</code> , <code>free</code> </li>
</ul>
<h2 id="建议">建议</h2>
<p>最后作者提出了几个建议，说的挺有意思。比如作者推荐我们在编程的时候，一定要尽可能的清晰表达意图，该用括号的时候，都尽量用括号，以防不该有的错误出现。同时要考察一些最简单的特例，测试程序的工作情况。一定要注意一些边界问题，比如数组的下标。以及一些潜伏在暗处的Bug。</p>
<p>最后作者提出了防御性编程，其实就是在说，啊，C语言有很多很多的坑，我们不知道什么时候就会踩到了坑，所以再变成的时候，一定要采用最稳妥的方式编程，意思就是一定要走那些被证明是康庄大道的平坦的道路呀，少年，不然你就要被坑惨了~~</p>
<p>以上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书超薄，但含金量很高，里边一些常见的陷阱也是面试的时留的坑，适合没事翻一翻，指不定什么时候还有意外惊喜。<br>]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web开发规范]]></title>
    <link href="http://yoursite.com/2015/10/06/Web%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2015/10/06/Web开发规范/</id>
    <published>2015-10-06T12:12:43.000Z</published>
    <updated>2015-10-06T12:17:30.000Z</updated>
    <content type="html"><![CDATA[<p>from: <a href="">Github</a></p>
<h2 id="通用规范">通用规范</h2>
<ul>
<li>使用空格代替TAB，windows和Linux的Tab占位不同。</li>
<li>CSS样式属性和 JavaScript代码后边添加分号<code>;</code> ，方便断句，利于压缩。</li>
<li>文件内容编码均统一为UTF-8。</li>
<li>CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。</li>
</ul>
<h2 id="文件规范">文件规范</h2>
<ul>
<li>文件名用英文单词，多个单词用驼峰命名法。</li>
<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。<code>ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao</code><br><a id="more"></a><h2 id="HTML书写规范">HTML书写规范</h2>
</li>
<li>为每个HTML页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>文档类型声明统一为HTML5声明类型，编码统一为UTF-8。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li><code>&lt;HEAD&gt;</code>中添加信息。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"author"</span> <span class="variable">content=</span><span class="string">"smile@kang.cool"</span>&gt;//作者</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"description"</span> <span class="variable">content=</span><span class="string">"hello"</span>&gt;//网页描述</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"keywords"</span> <span class="variable">content=</span><span class="string">"a,b,c"</span>&gt;//关键字,“，”分隔</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"expires"</span> <span class="variable">content=</span><span class="string">"Wed, 26 Feb 1997 08：21：57 GMT"</span>&gt;//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Pragma"</span> <span class="variable">content=</span><span class="string">"no-cache"</span>&gt;//禁止浏览器从本地机的缓存中调阅页面内容</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Window-target"</span> <span class="variable">content=</span><span class="string">"_top"</span>&gt;//用来防止别人在框架里调用你的页面</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Refresh"</span> <span class="variable">content=</span><span class="string">"5;URL=http://kahn1990.com/"</span>&gt;//跳转页面，<span class="number">5</span>指时间停留<span class="number">5</span>秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引</div><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"robots"</span> <span class="variable">content=</span><span class="string">"none"</span>&gt;//content的参数有all,none,index,noindex,follow,nofollow，默认是all</div><div class="line">&lt;link <span class="variable">rel=</span><span class="string">"Shortcut Icon"</span> <span class="variable">href=</span><span class="string">"favicon.ico"</span>&gt;//收藏图标</div><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Cache-Control"</span> <span class="variable">content=</span><span class="string">"no-cache, must-revalidate"</span>&gt;//网页不会被缓存</div></pre></td></tr></table></figure>

<ul>
<li>IE支持通过特定<meta>标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为edge mode ，从而通知IE采用其所支持的最新的模式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta <span class="variable">http-equiv=</span><span class="string">"X-UA-Compatible"</span> <span class="variable">content=</span><span class="string">"IE=Edge"</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li><p>非特殊情况下CSS样式文件外链至HEAD之间，JAVASCRIPT文件外链至页面底部。引入JAVASCRIPT库文件，文件名须包含库名称及版本号及是否为压缩版。引入JAVASCRIPT插件, 文件名格式为库名称+.+插件名称。<code>jQuery.cookie.js</code></p>
</li>
<li><p>HTML属性应当按照以下给出的顺序依次排列，来确保代码的易读性。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span></div><div class="line">id 、 name</div><div class="line">data-*</div><div class="line">src、<span class="keyword">for</span>、 <span class="class"><span class="keyword">type</span>、 <span class="title">href</span></span></div><div class="line">title、alt</div><div class="line">aria-*、 role</div></pre></td></tr></table></figure>

<ul>
<li>编码均遵循XHTML标准，标签、属性、属性命名由小写英文、数字和_组成，且所有标签必须闭合，属性值必须用双引号””，避免使用中文拼音尽量简易并要求语义化。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CLASS <span class="comment">--&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）</span></div><div class="line">ID <span class="comment">--&gt; n_head_title --&gt; ID遵循名称+_</span></div><div class="line">NAME <span class="comment">--&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_</span></div><div class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"nHeadTitle"</span> <span class="property">id</span>=<span class="string">"n_head_title"</span> <span class="property">name</span>=<span class="string">"N_Head_Title"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li>当JAVASCRIPT获取单个元素时，通常使用<code>document.getElementById</code>来获取dom元素，<code>document.getElementById</code>兼容所有浏览器，<strong>但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"test"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"alert(document.getElementById('test').tagName)"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- ie6下为INPUT --&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>特殊符号应使用转意符。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;    <span class="literal">-</span><span class="literal">-</span>&gt;    <span class="comment">&lt;</span></div><div class="line">&gt;    <span class="literal">-</span><span class="literal">-</span>&gt;    <span class="comment">&gt;</span></div><div class="line"><span class="comment">空格</span>  <span class="literal">-</span><span class="literal">-</span>&gt;</div></pre></td></tr></table></figure>

<ul>
<li>含有描述性表单元素（INPUT，TEXTAREA）添加LABEL。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"test"</span>&gt;</span>测试<span class="tag">&lt;/<span class="title">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"test"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>多用无兼容性问题的HTML内置标签，比如SPAN、EM、STRONG、OPTGROUP、LABEL等,需要自定义HTML标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有，可使用须以“data-”为前缀来添加自定义属性，避免使用其他命名方式。</li>
<li>语义化HTML。</li>
<li>尽可能减少<code>&lt;DIV&gt;</code>嵌套。</li>
<li>书写链接地址时避免重定向。<br><code>href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/”</code></li>
</ul>
<h1 id="Web开发规范（二）">Web开发规范（二）</h1>
<p>@(总结)</p>
<h2 id="CSS书写规范">CSS书写规范</h2>
<p>-为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合<code>W3C</code>的代码写到一个文件中,而一些IE中必须而又不能通过<code>W3C</code>验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 放置所有浏览器样式--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">href</span>=<span class="value">""</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if IE]</span></div><div class="line">    &lt;link rel="stylesheet" href=""&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>

<ul>
<li><p>CSS样式新建或修改尽量遵循以下原则。</p>
<ul>
<li>根据新建样式的适用范围分为三级：全站级、产品级、页面级。</li>
<li>尽量通过继承和层叠重用已有样式。</li>
<li>不要轻易改动全站级CSS。改动后，要经过全面测试。</li>
</ul>
</li>
<li><p>CSS属性显示顺序。</p>
<ul>
<li>显示属性</li>
<li>元素位置</li>
<li>元素属性</li>
<li><p>元素内容属性</p>
</li>
<li><p>CSS书写顺序。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> .header {</div><div class="line"><span class="comment">/* 显示属性 */</span></div><div class="line">    display || visibility</div><div class="line">    list-style</div><div class="line">    position top || right || bottom || left</div><div class="line">    z-index</div><div class="line">    <span class="keyword">clear</span></div><div class="line">    <span class="keyword">float</span></div><div class="line"><span class="comment">/* 自身属性 */</span></div><div class="line">    width <span class="keyword">max</span>-width || <span class="keyword">min</span>-width</div><div class="line">    height <span class="keyword">max</span>-height || <span class="keyword">min</span>-height</div><div class="line">    overflow || <span class="keyword">clip</span></div><div class="line">    margin</div><div class="line">    padding</div><div class="line">    outline</div><div class="line">    border</div><div class="line">    background</div><div class="line"><span class="comment">/* 文本属性 */</span></div><div class="line">    <span class="keyword">color</span></div><div class="line">    font</div><div class="line">    <span class="keyword">text</span>-overflow</div><div class="line">    <span class="keyword">text</span>-<span class="keyword">align</span></div><div class="line">    <span class="keyword">text</span>-indent</div><div class="line">    line-height</div><div class="line">    white-space</div><div class="line">    vertical-<span class="keyword">align</span></div><div class="line">    cursor</div><div class="line">    content</div><div class="line">    };</div></pre></td></tr></table></figure>

<ul>
<li>兼容多个浏览器时，将标准属性写在底部。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">moz-border-<span class="symbol">radius:</span> <span class="number">15</span>px; <span class="regexp">/* Firefox */</span></span></div><div class="line">-<span class="ruby">webkit-border-<span class="symbol">radius:</span> <span class="number">15</span>px; <span class="regexp">/* Safari和Chrome */</span></span></div><div class="line">border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性</div></pre></td></tr></table></figure>

<ul>
<li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.hd,.bd,.td{};<span class="comment">//如这些命名</span></div></pre></td></tr></table></figure>

<p>可用上级节点进行限定。<code>.recommend-mod .hd</code></p>
<ul>
<li>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.btn,</div><div class="line">input.btn,</div><div class="line">input[<span class="keyword">type</span>=<span class="string">"button"</span>] {…};</div></pre></td></tr></table></figure>

<ul>
<li>优化CSS选择器。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="id">#header</span> <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#444</span></span></span>; <span class="rule">}</span></span>;<span class="comment">/*CSS选择器是从右边到左边进行匹配*/</span></div></pre></td></tr></table></figure>

<ul>
<li>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器</div><div class="line">不要限定id选择符，如<span class="operator">div</span><span class="comment">#header（提权的除外）</span></div><div class="line">不要限定类选择器，如ul.recommend（提权的除外）</div><div class="line">不要使用 ul li <span class="operator">a</span> 这样长的选择符</div><div class="line">避免使用标签子选择符，如<span class="comment">#header &gt; li &gt; a</span></div></pre></td></tr></table></figure>

<ul>
<li><p>使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。</p>
</li>
<li><p>尽量避免使用CSS Hack。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* 所有浏览器 */</span></div><div class="line">+<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE7 */</span></div><div class="line">_<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE6 */</span></div><div class="line">*<span class="tag">property</span><span class="pseudo">:value</span>; <span class="comment">/* IE6/7 */</span></div><div class="line"><span class="tag">property</span><span class="pseudo">:value</span>\9; <span class="comment">/* IE6/7/8/9，即所有IE浏览器 */</span></div><div class="line"></div><div class="line">\* <span class="tag">html</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* IE6 */</span></div><div class="line">\*<span class="pseudo">:first-child+html</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* IE7 */</span></div><div class="line"><span class="tag">html</span>&gt;<span class="tag">body</span> <span class="tag">selector</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* 非IE6 */</span></div><div class="line"><span class="at_rule">@<span class="keyword">-moz-document</span> <span class="function">url-prefix</span>() </span>{ … }; <span class="comment">/* firefox */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio:<span class="number">0</span>) </span>{ … }; <span class="comment">/* saf3+/chrome1+ */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio:<span class="number">10000</span>),not all and (-webkit-min-device-pixel-ratio:<span class="number">0</span>) </span>{ … }; <span class="comment">/* opera */</span></div><div class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (max-device-width: <span class="number">480px</span>) </span>{ … }; <span class="comment">/* iPhone/mobile webkit */</span></div></pre></td></tr></table></figure>

<ul>
<li>避免使用低效的选择器。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">body</span> &gt; * <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="tag">ul</span> &gt; <span class="tag">li</span> &gt; <span class="tag">a</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="id">#footer</span> &gt; <span class="tag">h3</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="tag">ul</span><span class="id">#top_blue_nav</span> <span class="rules">{<span class="rule">…}</span></span>;</div><div class="line"><span class="id">#searbar</span> <span class="tag">span</span><span class="class">.submit</span> <span class="tag">a</span> <span class="rules">{ <span class="rule">… }</span></span>; <span class="comment">/* 反面示例 */</span></div></pre></td></tr></table></figure>

<ul>
<li><p>六个不要三个避免一个使用。</p>
<ul>
<li>不要在标签上直接写样式</li>
<li>不要在CSS中使用<code>expression</code></li>
<li>不要在CSS中使用<code>@import</code></li>
<li>不要在CSS中使用<code>!important</code></li>
<li>不要在CSS中使用<code>“*”</code>选择符</li>
<li>不要将CSS样式写为单行</li>
<li>避免使用filter</li>
<li>避免使用行内<code>（inline）</code>样式</li>
<li>避免使用<code>“*”</code>设置<code>{margin: 0; padding: 0;}</code></li>
<li>使用<code>after</code>或<code>overflow</code>的方式清浮动</li>
</ul>
</li>
<li><p>减少使用影响性能的属性。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">position</span><span class="value">:absolute;</span></div><div class="line"><span class="attribute">float</span><span class="pseudo">:left</span>;<span class="comment">//如这些定位或浮动属性</span></div></pre></td></tr></table></figure>

<ul>
<li><strong>减少在CSS中使用滤镜表达式和图片repeat</strong>,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px。</li>
</ul>
<h2 id="JavaScript书写规范">JavaScript书写规范</h2>
<ul>
<li>命名规范。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">常量名</div><div class="line">    全部大写并单词间用下划线分隔</div><div class="line">    如：CSS_BTN_CLOSE、TXT_LOADING</div><div class="line">对象的属性或方法名</div><div class="line">    小驼峰式（little camel-case）</div><div class="line">    如：init、bindEvent、updatePosition</div><div class="line">    示例：Dialog.prototype = {</div><div class="line">                init: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {},</div><div class="line">                bindEvent: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {},</div><div class="line">                updatePosition: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {}</div><div class="line">                …</div><div class="line">                };</div><div class="line">类名（构造器）</div><div class="line">    <span class="comment">--&gt;小驼峰式但首字母大写</span></div><div class="line">    <span class="comment">--&gt;如：Current、DefaultConfig</span></div><div class="line">函数名</div><div class="line">    <span class="comment">--&gt;小驼峰式</span></div><div class="line">    <span class="comment">--&gt;如：current()、defaultConfig()</span></div><div class="line">变量名</div><div class="line">    <span class="comment">--&gt;小驼峰式</span></div><div class="line">    <span class="comment">--&gt;如：current、defaultConfig</span></div><div class="line">私有变量名</div><div class="line">    <span class="comment">--&gt;小驼峰式但需要用_开头</span></div><div class="line">    <span class="comment">--&gt;如：_current、_defaultConfig</span></div><div class="line">变量名的前缀</div><div class="line">    <span class="comment">--&gt;续</span></div></pre></td></tr></table></figure>

<ul>
<li>代码格式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">"()"</span>前后需要跟空格</div><div class="line"><span class="string">"="</span>前后需要跟空格</div><div class="line"><span class="string">","</span>后面需要跟空格</div><div class="line"><span class="built_in">JSON</span>对象需格式化对象参数</div><div class="line"><span class="keyword">if</span>、<span class="keyword">while</span>、<span class="keyword">for</span>、<span class="keyword">do</span>语句的执行体用<span class="string">"{}"</span>括起来</div><div class="line"><span class="keyword">if</span> (a==<span class="number">1</span>) {</div><div class="line">    <span class="comment">//代码</span></div><div class="line">};</div></pre></td></tr></table></figure>

<ul>
<li>避免额外的逗号。<code>var arr = [1,2,3,];</code></li>
<li><p><strong>for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。</strong></p>
</li>
<li><p>长语句可考虑断行。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TEMPL_SONGLIST.replace(<span class="string">'{TABLE}'</span>, da[<span class="string">'results'</span>])</div><div class="line">    .replace(<span class="string">'{PREV_NUM}'</span>, <span class="keyword">prev</span>)</div><div class="line">    .replace(<span class="string">'{NEXT_NUM}'</span>, <span class="keyword">next</span>)</div><div class="line">    .replace(<span class="string">'{CURRENT_NUM}'</span>, current)</div><div class="line">    .replace(<span class="string">'{TOTAL_NUM}'</span>, da.page_total);</div></pre></td></tr></table></figure>

<p> -为了避免和<code>JSLint</code>的检验机制冲突，“.”或“+”这类操作符放在行尾。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TEMPL_SONGLIST.replace('{TABLE}', da['results']).</div><div class="line">    <span class="operator"><span class="keyword">replace</span>(<span class="string">'{PREV_NUM}'</span>, prev).</span></div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{NEXT_NUM}'</span>, <span class="keyword">next</span>).</div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{CURRENT_NUM}'</span>, <span class="keyword">current</span>).</div><div class="line">    <span class="keyword">replace</span>(<span class="string">'{TOTAL_NUM}'</span>, da.page_total);</div></pre></td></tr></table></figure>

<p>如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/<em>global</em>/声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/*global alert: <span class="literal">true</span>, console: <span class="literal">true</span>, top: <span class="literal">true</span>, <span class="keyword">set</span>Timeout: <span class="literal">true</span> */</div></pre></td></tr></table></figure>

<ul>
<li>使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="literal">null</span></div><div class="line"><span class="literal">undefined</span>与<span class="literal">null</span>相等</div><div class="line">字符串<span class="string">''</span></div><div class="line">数字<span class="number">0</span></div><div class="line"><span class="literal">NaN</span></div></pre></td></tr></table></figure>

<p>在==时，则会有一些让人难以理解的陷阱，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> <span class="literal">undefined</span>;</div><div class="line">    <span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></div><div class="line">    <span class="number">1</span> == <span class="literal">true</span>; <span class="comment">//true</span></div><div class="line">    <span class="number">2</span> == <span class="literal">true</span>; <span class="comment">// false</span></div><div class="line">    <span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></div><div class="line">    <span class="number">0</span> == <span class="string">''</span>; <span class="comment">// true</span></div><div class="line">    <span class="literal">NaN</span> == <span class="literal">NaN</span>;<span class="comment">// false</span></div><div class="line">    [] == <span class="literal">false</span>; <span class="comment">// true</span></div><div class="line">    [] == ![]; <span class="comment">// true</span></div><div class="line">})();</div></pre></td></tr></table></figure>

<p>对于不同类型的 == 判断，有这样一些规则，顺序自上而下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span>与<span class="literal">null</span>相等</div><div class="line">一个是<span class="built_in">number</span>一个是<span class="built_in">string</span>时，会尝试将<span class="built_in">string</span>转换为<span class="built_in">number</span></div><div class="line">尝试将<span class="built_in">boolean</span>转换为<span class="built_in">number</span></div><div class="line"><span class="number">0</span>或<span class="number">1</span></div><div class="line">尝试将<span class="built_in">Object</span>转换成<span class="built_in">number</span>或<span class="built_in">string</span></div></pre></td></tr></table></figure>

<p>而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用===。===会先判断两边的值类型，类型不匹配时为false。</p>
<ul>
<li>下面类型的对象不建议用new构造。引用对象成员用<code>obj.prop</code>代替<code>obj[“prop”]</code>，除非属性名是变量。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Object</span> <span class="comment">//用{}代替</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span> <span class="comment">//用[]代替</span></div></pre></td></tr></table></figure>

<ul>
<li>从number到string的转换。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">typeof(a); <span class="comment">//"number"</span></div><div class="line">console.log(a); <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> aa=a+'';</div><div class="line">typeof(aa); <span class="comment">//"string"</span></div><div class="line">console.log(aa); <span class="comment">//'1'</span></div><div class="line"><span class="javadoc">/** 不推荐写法*/</span></div><div class="line"><span class="keyword">new</span> String(a)或a.toString()</div></pre></td></tr></table></figure>

<p>从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line"><span class="keyword">var</span> a = '<span class="number">1</span>';</div><div class="line"><span class="keyword">var</span> aa = parseInt(a,<span class="number">10</span>);</div><div class="line">typeof(a); <span class="comment">//"string"</span></div><div class="line">console.log(a); <span class="comment">//'1'</span></div><div class="line">typeof(aa); <span class="comment">//"number"</span></div><div class="line">console.log(aa); <span class="comment">//1</span></div></pre></td></tr></table></figure>

<p>从float到integer的转换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 推荐写法*/</span></div><div class="line">Math.floor/Math.round/Math.ceil</div><div class="line"><span class="javadoc">/** 不推荐写法*/</span></div><div class="line">parseInt</div></pre></td></tr></table></figure>

<ul>
<li>字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**推荐的拼接方式array的push、join*/</span></div><div class="line">var str=[],</div><div class="line">    list=[<span class="string">'测试A'</span>,<span class="string">'测试B'</span>];</div><div class="line"><span class="keyword">for</span> (var i=<span class="number">0</span> , len=list.length; i &lt; len; i++) {</div><div class="line">    str.push( <span class="string">'&lt;div&gt;'</span>+ list[i] + <span class="string">'&lt;/div&gt;'</span>);</div><div class="line">};</div><div class="line">console.log(str.join(<span class="string">''</span>)); <span class="comment">//&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;</span></div><div class="line"><span class="javadoc">/** 不推荐的拼接方式+=*/</span></div><div class="line">var str = <span class="string">''</span>,</div><div class="line">    list=[<span class="string">'测试A'</span>,<span class="string">'测试B'</span>];</div><div class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>, len = list.length; i&lt; len; i++) {</div><div class="line">    str+=<span class="string">'&lt;div&gt;'</span> + list[i] + <span class="string">'&lt;/div&gt;'</span>;</div><div class="line">};</div><div class="line">console.log(str); <span class="comment">//&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>尽量避免使用存在兼容性及消耗资源的方法或属性。不要使用with，void，evil，eval_r，innerText。</li>
<li>注重HTML分离, 减小reflow, 注重性能。</li>
</ul>
<h2 id="图片规范">图片规范</h2>
<ul>
<li>命名应用小写英文、数字、_组合，便于团队其他成员理解。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header_btn.gif</div><div class="line"> header_btn2.gif</div></pre></td></tr></table></figure>

<ul>
<li>页面元素类图片均放入img文件夹，测试用图片放于<code>img/testimg</code>文件夹，psd源图放入img/psdimg文件夹。</li>
<li>图片格式仅限于gif、png、jpg等。</li>
<li>用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。</li>
<li>背景图片请尽可能使用<code>sprite</code>（将一个页面涉及到的所有零星图片都包含到一张大图中去）技术, 减小http请求。</li>
</ul>
<h2 id="注释规范">注释规范</h2>
<ul>
<li>JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。中间可添加如下信息：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@file</span> 文件名</div><div class="line"><span class="variable">@addon</span> 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中</div><div class="line"><span class="variable">@argument</span> 用大括号中的自变量类型描述一个自变量</div><div class="line"><span class="variable">@author</span> 函数/类作者的姓名</div><div class="line"><span class="variable">@base</span> 如果类是继承得来，定义提供的类名称</div><div class="line"><span class="variable">@class</span> 用来给一个类提供描述，不能用于构造器的文档中</div><div class="line"><span class="variable">@constructor</span> 描述一个类的构造器</div><div class="line"><span class="variable">@deprecated</span> 表示函数/类已被忽略</div><div class="line"><span class="variable">@exception</span> 描述函数/类产生的一个错误</div><div class="line"><span class="variable">@exec</span> <span class="variable">@extends</span> 表示派生出当前类的另一个类</div><div class="line"><span class="variable">@fileoverview</span> 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前</div><div class="line"><span class="variable">@final</span> 指出函数/类</div><div class="line"><span class="variable">@ignore</span> 让jsdoc忽视随后的代码</div><div class="line"><span class="variable">@link</span> 类似于<span class="variable">@link</span>标签，用于连接许多其它页面</div><div class="line"><span class="variable">@member</span> 定义随后的函数为提供的类名称的一个成员</div><div class="line"><span class="variable">@param</span> 用大括号中的参数类型描述一个参数</div><div class="line"><span class="variable">@private</span> 表示函数/类为私有，不应包含在生成的文档中</div><div class="line"><span class="variable">@requires</span> 表示需要另一个函数/类</div><div class="line"><span class="variable">@return</span> 描述一个函数的返回值</div><div class="line"><span class="variable">@see</span> 连接到另一个函数/类</div><div class="line"><span class="variable">@throws</span> 描述函数/类可能产生的错误</div><div class="line"><span class="variable">@type</span> 指定函数/成员的返回类型</div><div class="line"><span class="variable">@version</span> 函数/类的版本号</div></pre></td></tr></table></figure>

<h2 id="开发和测试工具约定">开发和测试工具约定</h2>
<ul>
<li>编码格式化，三码统一。</li>
<li>测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>from: <a href="">Github</a></p>
<h2 id="通用规范">通用规范</h2>
<ul>
<li>使用空格代替TAB，windows和Linux的Tab占位不同。</li>
<li>CSS样式属性和 JavaScript代码后边添加分号<code>;</code> ，方便断句，利于压缩。</li>
<li>文件内容编码均统一为UTF-8。</li>
<li>CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。</li>
</ul>
<h2 id="文件规范">文件规范</h2>
<ul>
<li>文件名用英文单词，多个单词用驼峰命名法。</li>
<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。<code>ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao</code><br>]]>
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《增长黑客》读书笔记]]></title>
    <link href="http://yoursite.com/2015/10/05/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/10/05/《增长黑客》读书笔记/</id>
    <published>2015-10-05T12:20:30.000Z</published>
    <updated>2015-10-05T12:39:27.000Z</updated>
    <content type="html"><![CDATA[<p>通过简书阅读：<a href="http://www.jianshu.com/p/ced81ced4b0d" target="_blank" rel="external">《增长黑客》读书笔记</a></p>
<p>国庆期间，利用两天里的空闲时间，把这本最近颇受好评的书读了一遍，感觉很有意思之余，又把把书里的干货整理了一遍。</p>
<p>书里的干货很多，案例很多，纯理论的东西不多，如果想要成为一个牛逼的 Leader , 就应当把自己培养成为T型的人才，跨界知识能力超强，某方面技术超硬，这个某方面，更多的指技术能力超硬。</p>
<p>同时，书中所提到的一些案例，某些地方是游走在规矩的边界上，还有一部分虽然很有效但是也增加了用户的恶感（如捆绑下载，插件广告等），当然这本书并不是要教你学坏。</p>
<p>在写这个读书笔记之前，我也看了一些人做的思维导图，内容很全，但是思维导图的缺点在于看的人更容易整体的浏览，一瞬接接触巨大的信息量，而无法深入的思考每一个信息点，所以我直接以正常笔记的形式进行了整理。</p>
<h2 id="第一章：概念">第一章：概念</h2>
<h4 id="定义（P6）">定义（P6）</h4>
<p>以数据驱动营销，以市场指导产品，通过技术化手段贯彻增长目标的人。</p>
<h4 id="增长目标：（P7）">增长目标：（P7）</h4>
<p><strong>『AARRR』转化漏斗模型：</strong></p>
<ul>
<li>Acquisition 获取用户</li>
<li>Activation 激发活跃</li>
<li>Retention 提高留存</li>
<li>Revenue 增加收入</li>
<li>Referral 传播推荐</li>
</ul>
<h4 id="能力特质：（P16）">能力特质：（P16）</h4>
<ul>
<li><strong>数据为王：</strong>具有数据思维，一切工作建立在数据分析之上</li>
<li><strong>专注目标：</strong>时刻围绕增长目标展开，不断的测试、改进，学习、再测试</li>
<li><strong>关注细节：</strong>对细小改动做出评估</li>
<li><strong>富于创意：</strong>缜密分析+天马行空的增长方案</li>
<li><strong>信息通透：</strong>深入理解产品用户的活跃渠道，关注新生渠道和业界趋势</li>
</ul>
<p>（Andy Johns的增长黑客生涯）：facebook小挂件，向潜在用户发邮件广告推广，Twitter的着陆页改进（关注注册登录），新用户注册推荐用户，开发内部群发邮件系统，Quora捉摸用户行为模式，归纳为标准流程，引导其他用户执行流程<br><a id="more"></a></p>
<h4 id="一切以数据说话：（P17）">一切以数据说话：（P17）</h4>
<ul>
<li><strong>明确分析目的</strong></li>
<li><strong>了解数据来源的相关信息</strong>：<ul>
<li><strong>强调核心指标</strong>：建立在品类特性和自身提供服务的核心价值之上</li>
<li><strong>确定上报机制</strong>：时机、内容、技术实践形式</li>
</ul>
</li>
<li><strong>数据分析方法</strong><ul>
<li><strong>定性分析</strong>：对事物性质进行判断</li>
<li><strong>定量分析</strong>： 对事物数量做统计</li>
</ul>
</li>
</ul>
<h4 id="团队定位（P20）">团队定位（P20）</h4>
<p>游走在产品、运营、研发、设计、用户研究之间的多面手，比产品更关注能带来数据增长的功能特性，比运营更倾向于数据中探索新的增长机会，比设计师更少关注感观层面的艺术性，长于用户研究</p>
<h4 id="招聘经验以及发展要素（P23）">招聘经验以及发展要素（P23）</h4>
<p><strong>要求</strong>：具备技术、产品、营销思维、传播和分享的精神（案例为Teambition , WIFI万能钥匙的招聘经验）<br><strong>如何培养</strong>：熟悉产品和技术的市场影响，有产品干和市场思维，培养横向跨界知识，纵向某一领域专攻。<strong>软实力</strong>为：热情、聪明、好奇、收集资源、影响力、心态开放、内心强大、轻微强迫症<br><strong>常用的工具箱：</strong>Google Analytics , Mixpanel , KissMeteics , UserCycle , Customer.io , Optimize.ly , Basscamp , 友盟 </p>
<h2 id="第二章：产品">第二章：产品</h2>
<h4 id="PMF（P40）">PMF（P40）</h4>
<p>也就是产品与市场的完美切合度，Product / market fit。从早期用户得到反馈，利用最小的成本持续改进产品。</p>
<p><strong>成功案例</strong>： instagram的转型，砍掉冗余功能，吧用户喜欢的照片分享功能拿出来做<br><strong>失败案例</strong>： 叮咚小区，前期粗暴的线下广告投放，但是产品的基础功能不完善，用户体验极差。</p>
<p>所以，应当先做好产品的验证，达到了PMF状态再全力推广。</p>
<h4 id="需求（P45）">需求（P45）</h4>
<ul>
<li><strong>需求是真实存在的还是伪需求</strong>（QQ邮箱将邮件附件单列出来，但几乎没人用）</li>
<li><strong>需求是否属于刚需</strong></li>
<li><strong>需求是否足够大</strong>：估计目标用户的基数、消费能力、意愿预算；评估进入市场的原有规模和新的规模、借助排行榜和搜索热度了解需求（YY 向视频直播平台转变）</li>
<li><strong>需求的变现能力如何</strong></li>
</ul>
<h4 id="MVP（P49）">MVP（P49）</h4>
<p>也就是最小化的可行产品来验证需求。</p>
<ul>
<li><strong>基本功能</strong>： 在最短时间内完成，如Dropbox通过仅完成宣传视频，Groupon 通过WordPress建站，排版软件制作礼券等，大众点评3天做出网页，数据来源于旅游手册，微信游戏近似于图片拼凑视觉稿。这几种常见的方式：<strong>伪造网站，不提供实际的功能；用户点击按钮后告知正在开发，留下电子邮箱；调研用户呼声最高的功能，然后成为种子用户；基于微信做MVP的开发（无需适配，分发方便，便于收集反馈，数据可以沉淀，开发成本低）</strong></li>
<li><strong>反馈渠道</strong>：内部反馈机制等</li>
<li><strong>官方公告</strong>： 群体公告 + 单用户通知</li>
<li><strong>自动升级</strong>： 启动时提示更新</li>
<li><strong>使用行为统计</strong></li>
</ul>
<p>同时应当注意，在产品早期应当尽快适配新环境，案例：多拉口袋的iOS8崩溃问题。</p>
<h2 id="第三章：获取用户">第三章：获取用户</h2>
<h4 id="种子用户（P64）">种子用户（P64）</h4>
<p>通过<strong>冷启动</strong>来获取第一批用户和制作过程，早期的种子用户的质量将决定产品初期的氛围、运营走向、以及日后的发展策略，案例如：知乎的早期邀请制度，哔哩哔哩的答题机制，小米的种子用户反馈。</p>
<p>但是一定要警惕『产品蝗虫』，也就是目标客户之外的围观群众，他们将占用原有的目标用户名额，伤害到社区的生态，抠一些没用的『细节』，行为会对产品的决策产生误导。</p>
<h4 id="从最笨的事情做起（P68）">从最笨的事情做起（P68）</h4>
<p>几个案例：</p>
<ul>
<li>聚美优品，写BB霜的软文，提供化妆品的高质量美图</li>
<li>Strikinfly，寻找超级粉丝，线上线下聊天</li>
<li>云笔记，邀请内测用户成立反馈协助群</li>
<li>Airbnb , 挨家挨户的上门拍照</li>
</ul>
<h4 id="社交红利（P72）与数据抓取（P77）">社交红利（P72）与数据抓取（P77）</h4>
<ul>
<li>与社交网络整合，获取用户量、关系链和行为数据（Spotify用facebook 登陆，Zynga用Facebook的开放平台制作社交游戏）</li>
<li>第三方社交网络的账号登陆，达成移动应用的分享和回流（啪啪，使用微博QQ登陆，挖掘关系链潜力）</li>
<li>数据抓取，可以保证产品初期启动的数据量，以及抢占先机，或者争取资源（微软关闭空间主页服务的时候，网易迅速提供『一键搬家』，追TA抓取唱吧的用户头像）</li>
</ul>
<h4 id="内容营销（P81）">内容营销（P81）</h4>
<p>其作用是<strong>吸引流量，培养潜在用户，劝诱转化</strong>，所以应当讲用户爱听的故事，如官方微博输出用户喜欢的图文（知乎）。<br><strong>注意事项</strong>：明确目标受众，持续稳定输出高质量内容，标题的撰写技巧，保证文章长度（2400），数据分享与互动（有让人讨论的空间，如知乎刊发有争议的文章），选择合适的发布渠道。</p>
<h4 id="搜索的优化（P89）">搜索的优化（P89）</h4>
<p>分为搜索引擎的优化和应用商店的优化。</p>
<p>搜索引擎的优化案例，Facebook 针对用户资料的页面优化，twitter自动提交热门标签给搜索引擎，TochCrunch通过wiki百科建立反向链接。<br>应用商店的优化案例，如大姨吗，通过副标题的修改推关键词，大众点评『更新跑得快』活动。</p>
<h4 id="文案的撰写">文案的撰写</h4>
<ul>
<li>简要概述（100字内）</li>
<li>话题事件</li>
<li>核心特色</li>
<li>主要功能</li>
<li>团队访谈</li>
<li>未来计划</li>
<li>推广活动</li>
<li>转化引导</li>
</ul>
<h4 id="更多的技巧">更多的技巧</h4>
<ul>
<li>捆绑下载：如豌豆荚捆绑下载其APP</li>
<li>排队机制，饥饿营销： Mailbox显示排队人数，Trak.io付费插队，邀请好友插队。</li>
<li>嵌入式代码和小挂件： Youtube分享</li>
<li>线上到线下</li>
<li>海外的扩张： 猎豹，Facebook等</li>
</ul>
<h2 id="第四章：激发活跃">第四章：激发活跃</h2>
<h4 id="A/B测试（P121）">A/B测试（P121）</h4>
<ul>
<li>提供两个方案并行测试，</li>
<li>变量唯一排除其他干扰因素，</li>
<li>有判定结果优劣的标准，</li>
<li>移动应用也可以借助HTML5快速验证需求。</li>
</ul>
<p>几个典型案例如37Signals 『注册高额回报账户』vs 『所有账户享受30天免费使用』，ZAGG 商品的静态图片 vs 360度图片 ， OkDork 先注册后进网站的测试，根据行为热点图去掉导航栏的测试。移动端如百姓网利用HTML5容器实现A/B测试。</p>
<p>但注意，不要过度依赖AB测试。</p>
<h4 id="独辟蹊径的技术（P133）">独辟蹊径的技术（P133）</h4>
<p>在技术瓶颈下通过巧妙的手段破除用户使用功能的障碍，降低用户活跃的门槛。几个例子都很有趣：</p>
<ul>
<li>SKype『伪立体声』，提高清晰度，击败了其他同类服务</li>
<li>QQ音乐利用专辑图片实现了IOS的『锁屏歌词』</li>
<li>WIFI万能钥匙通过截图加上OCR技术识别WIFI热点，同时利用GPS+云服务获取附近的热点</li>
</ul>
<h4 id="补贴（P137）">补贴（P137）</h4>
<p>有直接的现金补贴，快速获取用户，激发活跃度，也就是如返利和嘀嘀快的的补贴大战。<br>也有新玩法的红包补贴，通过社交关系链的传播，比如嘀嘀打车的补贴新玩法，打车红包。</p>
<h3 id="游戏化（P139）与脚本自动化运营（P146）">游戏化（P139）与脚本自动化运营（P146）</h3>
<p><strong>《游戏改变世界》提到的游戏四大特征</strong>： 目标、规则、反馈系统、自愿参与。<br>比如星巴克的线下会员成长体系，同时还开发了app把线下的游戏化搬到了线上。移动签到应用Foursquare 通过积分排名，徽章挑战和抢夺地主的游戏设计抓取用户忠诚度。滴滴打车提供的『滴米』系统等等。</p>
<p>而产品在早期社区通过团队自己来运营启动，后期就可以通过写脚本来实现自动化运营，一个有趣的运营案例是豌豆荚打造的贴吧神兽，其实就是一个自动聊天的机器人，获得了几十万的关注度。</p>
<h2 id="第五章：提高留存">第五章：提高留存</h2>
<h4 id="用户留存率">用户留存率</h4>
<p><strong>留住已有的用户胜过拓展新用户</strong><br>用户流逝的原因：</p>
<ul>
<li><strong>程序漏洞，性能瓶颈</strong>：Color基本流程都跑不通</li>
<li><strong>用户频繁被骚扰</strong>： 新浪微博的各种通知、广告、推送、话题等</li>
<li><strong>产品热度消减</strong>： 『你画我猜』的日活锐减</li>
<li><strong>更好的替代产品</strong> ： eBay被淘宝击败</li>
<li><strong>其他原因</strong></li>
</ul>
<p><strong>留存率的衡量标准</strong>：</p>
<ul>
<li>次日留存（40%）</li>
<li>7日留存（20%）</li>
<li>30日留存（10%）</li>
</ul>
<h4 id="产品性能优化">产品性能优化</h4>
<p>优化内容包括：用户终端性能、网络性能、流量压缩、安装包空间、界面设计与布局、其他。</p>
<p>如Facebook为非洲用户的优化，减少了启动速度，提供了预加载，压缩图片，优先家在适合当前分辨率的照片，优化安装包大小，其实就是前边所说的优化内容。</p>
<p>再如 Instagram 的安卓版优化，扁平化设计，重新布局精简架构专注内容，延迟加载不必要的模块（方法追踪method tracing 和时点声明 Timing Statements 技术）。</p>
<h4 id="有损服务——放下不必要的坚持">有损服务——放下不必要的坚持</h4>
<p>定义：<strong>刻意输出在品质上存在某些损失的服务，换取其他方面的优化。</strong><br>原则：</p>
<ul>
<li><strong>优先保证核心功能的运转</strong></li>
<li><strong>牺牲的特性越少越好，在条件允许的情况下</strong><br>几个经典的案例如：QQ农场在高峰期提供的静态默认列表，微信的高峰期不强求信息发送顺序的一致，小米在抢购的时候不提供剩余手机的精确统计（也有可能是饥饿营销），刀塔传奇的大版本升级采用『低清晰度版本』保证用户尽早升级。</li>
</ul>
<h4 id="引导用户上手_社交维系与社交解绑">引导用户上手 社交维系与社交解绑</h4>
<p>Twitter注册完成后的推荐用户，知乎的推荐订阅，都是引导用户快速上手的例子。</p>
<p>社交维系与社交解绑是对立的概念，前者如全民飞机大战，『啪啪』提示新加入的微博好友，Facebook在注销账号页面显示亲密好友的照片，通过社交手段维系用户留存。而same则通过解绑社交的方式，提高留存。</p>
<h4 id="唤醒机制">唤醒机制</h4>
<p>互联网产品中专为召回流失用户而设计的产品机制。</p>
<ul>
<li><strong>电子邮件召回EDM</strong><ul>
<li><strong>提供奖励</strong>，Pocket 用高级付费账户试用来吸引你</li>
<li><strong>告知进展</strong>，IFTTT增加Nest支持，Evernote推出商业版等方式</li>
<li><strong>个性化推荐</strong>，如知乎的每周精选，淘宝的同类商品。</li>
<li><strong>社交互动提示</strong>，如Twitter定期发送未处理消息，Facebook中通知用户『有一张照片中圈了你』。</li>
<li>优秀的第三方服务商包括 TinyLetter,MailChimp等，EDM要注意内容，和取消订阅方式。</li>
</ul>
</li>
<li><strong>消息推送通知</strong><ul>
<li><strong>推送授权</strong>，推荐试用简单的浮层或者弹窗提示用户获取权限后的使用目的。</li>
<li><strong>徽章通知</strong>，也就是角标，利用用户的强迫症。</li>
<li><strong>本地通知</strong>，在预设的时间点通知，如刀塔传奇每天的三个时间点推送通知。</li>
<li><strong>地理围栏通知</strong></li>
<li><strong>图片推送通知</strong></li>
<li><strong>表情文字通知</strong></li>
</ul>
</li>
<li><strong>网页内唤醒移动应用</strong>，iOS有直接的URL Scheme技术来实现，安卓上有四种方式，分别是：拦截http跳转、自定义scheme、Crome Internet ，内嵌http服务。如知乎，哔哩哔哩等。</li>
</ul>
<h2 id="第六章：增加收入">第六章：增加收入</h2>
<h4 id="免费的世界">免费的世界</h4>
<ul>
<li><strong>互联网与免费的午餐</strong><br> 互联网可以降低信息传播的承办本，海量用户摊薄了边际成本，人的本性对免费产品更感兴趣以及更喜欢『免费』的国人。</li>
<li><strong>免费又赚钱的策略</strong><ul>
<li>基本功能免费，高级功能收费的Freemium策略，比如Evernote，QQ，Flickr等等。</li>
<li>交叉补贴，《征途》的游戏免费，道具收费。</li>
<li>三方市场的流量变现，例子就是搜狗的『三级火箭』策略，通过输入法来带动搜狗浏览器下载，利用浏览器下载带动搜狗搜索的使用量（虽然我巨恶心搜狗的这个行为，但是这种变现的方式确实是最佳方式）</li>
<li>开源代码的盈利可能，如厂商定制开发收费，比如卖技术说明文档，或者接受用户捐赠（其实这个就不算是运营了，纯粹是情怀）</li>
<li>公司上市或者是被收购</li>
</ul>
</li>
<li><strong>免费午餐的终结</strong>，在产品足够好的情况下，可以试着完全掐断免费。</li>
</ul>
<h4 id="重定向广告">重定向广告</h4>
<p>也就是cookie和url分析，业界对此存在两种声音，一种认为增加了收入，另一种则担心用户隐私的泄露。</p>
<h4 id="几个营销案例">几个营销案例</h4>
<p><strong>Wet Seal </strong>：『和友人一起逛街』的社交购物，虚拟的DIY服务，Etsy根据社交资料精准推荐礼物。</p>
<p><strong>罗辑思维的微信月饼</strong>：这也是一次粉丝经济的催生，分别尝试了找人代付，多人代付，随机送礼，加入游戏思维的方式完成了一次精彩的营销。</p>
<p><strong>面对盗版的营销方式</strong>：腾讯给『非法』的QQ会员提供了八折开通会员的服务，而CleanmyMac 给盗版用户提供半价的优惠。面对盗版的变惩为奖的几个原则是：<strong>绝不责备用户，给予合理补偿，提供转化便利</strong></p>
<p><strong>建立商业智能系统</strong>：用数据可视化的方式辅助企业管理，如百姓网建立内部的数据化营销系统，提高了业务增长。</p>
<h2 id="第七章：病毒营销">第七章：病毒营销</h2>
<p><strong>凯文凯利《新经济，新规则》中说道，传真机效应，单独一台传真机没有什么价值，只有它处于一个网络中才能被赋予价值。对于拥有一台传真机的人来说，网络中的传真机越多，你的传真机价值也就越大，用户买下传真机，实则买下了整个网络。</strong></p>
<p>核心指标：</p>
<ul>
<li><strong>K因子</strong>：评判病毒传播的覆盖面，等于感染率*转化率。</li>
<li><strong>病毒传播周期</strong>： 用户发出病毒邀请，到新用户完成转化所花费的时间。（引爆点提到的个别人物法则，附着力法则和环境威力法则）。</li>
</ul>
<h4 id="几个案例">几个案例</h4>
<ul>
<li><strong>坏事传千里</strong>，百度的Bug营销，利用一个假装的bug，百度云获得了大量的新注册用户和铁杆粉丝，以及完整的流程体验，大量的用户个人文件。</li>
<li><strong>借势营销，利用时机</strong>，比如各种旅游产品借助阿里的去啊做热点营销，猎豹移动专门推出的春节抢票版。segmentFault的光棍节程序员闯关秀。（如今打开segmentfault.com/game会有一个新的闯关游戏，不过也是很难的）</li>
<li><strong>构建产品体系外的病毒循环</strong>，追TA的整蛊朋友圈游戏。三大考验：<ul>
<li><strong>创意来源</strong></li>
<li><strong>生命周期</strong></li>
<li><strong>产品契合度</strong>：知乎的财务包子铺与知乎的《金钱有术》。</li>
</ul>
</li>
<li><strong>产品内置的传播因子</strong>。外置的传播因子有几个缺陷，渠道特性与产品特性不匹配，获得的用户参差不齐；渠道传播与下载转化之间可能存在断链（朋友圈可能屏蔽一些下载）；渠道传播的策划固然成功，但是用户可能对产品本身缺乏兴趣。所以借用内置的传播因子可能更好，如AirDrop的推荐产品解锁高级功能，美图秀秀内建的可分享到朋友圈的小功能。</li>
<li><strong>邮件提醒增强传播效率</strong>： SpringSled 好友邀请提高排队名次，通过有效的邮件跟踪提高用户数量。</li>
</ul>
<h4 id="病毒传播中的用户心理把握">病毒传播中的用户心理把握</h4>
<ul>
<li><strong>喜爱</strong>：游戏，文学等大ip的作品，转化率比较高。</li>
<li><strong>逐利</strong>：如Groupon的邀请好友奖励10美元等。</li>
<li><strong>互惠</strong>： 是追逐利益的一种变体，基于理性经济人假说的传统经济学认为，经济行为主体是单纯追求个人利益最大化的，人们的复杂性为和社会参与，都基于成本收益的计算。如dropbox的推广获得额外空间。</li>
<li><strong>求助</strong>：手机游戏，免费游戏，续命或者是买体力要钱。</li>
<li><strong>炫耀</strong>： 支付宝每年一度的晒单</li>
<li><strong>稀缺</strong>： 稀缺资源会引起争抢，如Gmail，Dribbble初期仅允许被邀请者发表作品。</li>
<li><strong>害怕失去或错过</strong>： EverMemo 的互相扫描二维码解锁高级功能。</li>
<li><strong>懒惰</strong>： 严肃的商业内容，大多数用户倾向于复制部分文字和链接再发送，偏重知识性娱乐性的网站，人们优先使用分享按钮分享他们看到的东西。</li>
</ul>
<h2 id="第八章：案例集">第八章：案例集</h2>
<p>最后，作者复盘了几个完整的案例集，Airbnb ，Tinder ，Github，美丽说，外卖库，每一个都值得看几遍，了解一个成功的增长是如何做到的。</p>
<hr>
<p>整本书写的很赞，不像一些外国书，通篇的核心观点极少，统统以过分详实的案例填充那种情况。书中的干货还是非常多的，复盘的案例非常契合，分析到位。总之这是一本不错的书，至少应当读两遍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过简书阅读：<a href="http://www.jianshu.com/p/ced81ced4b0d" target="_blank" rel="external">《增长黑客》读书笔记</a></p>
<p>国庆期间，利用两天里的空闲时间，把这本最近颇受好评的书读了一遍，感觉很有意思之余，又把把书里的干货整理了一遍。</p>
<p>书里的干货很多，案例很多，纯理论的东西不多，如果想要成为一个牛逼的 Leader , 就应当把自己培养成为T型的人才，跨界知识能力超强，某方面技术超硬，这个某方面，更多的指技术能力超硬。</p>
<p>同时，书中所提到的一些案例，某些地方是游走在规矩的边界上，还有一部分虽然很有效但是也增加了用户的恶感（如捆绑下载，插件广告等），当然这本书并不是要教你学坏。</p>
<p>在写这个读书笔记之前，我也看了一些人做的思维导图，内容很全，但是思维导图的缺点在于看的人更容易整体的浏览，一瞬接接触巨大的信息量，而无法深入的思考每一个信息点，所以我直接以正常笔记的形式进行了整理。</p>
<h2 id="第一章：概念">第一章：概念</h2>
<h4 id="定义（P6）">定义（P6）</h4>
<p>以数据驱动营销，以市场指导产品，通过技术化手段贯彻增长目标的人。</p>
<h4 id="增长目标：（P7）">增长目标：（P7）</h4>
<p><strong>『AARRR』转化漏斗模型：</strong></p>
<ul>
<li>Acquisition 获取用户</li>
<li>Activation 激发活跃</li>
<li>Retention 提高留存</li>
<li>Revenue 增加收入</li>
<li>Referral 传播推荐</li>
</ul>
<h4 id="能力特质：（P16）">能力特质：（P16）</h4>
<ul>
<li><strong>数据为王：</strong>具有数据思维，一切工作建立在数据分析之上</li>
<li><strong>专注目标：</strong>时刻围绕增长目标展开，不断的测试、改进，学习、再测试</li>
<li><strong>关注细节：</strong>对细小改动做出评估</li>
<li><strong>富于创意：</strong>缜密分析+天马行空的增长方案</li>
<li><strong>信息通透：</strong>深入理解产品用户的活跃渠道，关注新生渠道和业界趋势</li>
</ul>
<p>（Andy Johns的增长黑客生涯）：facebook小挂件，向潜在用户发邮件广告推广，Twitter的着陆页改进（关注注册登录），新用户注册推荐用户，开发内部群发邮件系统，Quora捉摸用户行为模式，归纳为标准流程，引导其他用户执行流程<br>]]>
    
    </summary>
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[平淡日子里的刺]]></title>
    <link href="http://yoursite.com/2015/09/27/%E5%B9%B3%E6%B7%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E5%88%BA/"/>
    <id>http://yoursite.com/2015/09/27/平淡日子里的刺/</id>
    <published>2015-09-27T13:54:20.000Z</published>
    <updated>2015-09-27T13:58:59.000Z</updated>
    <content type="html"><![CDATA[<p><strong>很多人二十五岁已经死了，七十五岁才埋葬。    ——叔本华</strong></p>
<hr>
<p>八月十五，中秋，一个人。</p>
<p>之前的两年时间，都在期待着新生活，而转眼间也在这里过去了一个月，生活平淡，美好。终于开始思考眼前的生活，思考无论有意义还是无意义都不会烦躁的问题。</p>
<p>一句不恰当的比喻，自己就像从一段漫长的噩梦里苏醒，发现阳光亘古未变的打在脸上，痒痒的，真实的感觉。叔本华说，很多人二十五岁已经死了，七十五岁才埋葬，而我感觉自己好像刚刚复活，扑一扑身上的尘土，重新走入生活。课堂，健身，实验室，聚餐，电影，当下，以及梦想。</p>
<p>生活以痛吻我，后又赐我以希望。所以，面对那些浮动的喧嚣，又有一种新的心境去审视和面对。前后的时光重叠在眼前的生活里，但对我来说，一切都是新的，都是从头来过。简桢常说的一句话，不为浮华所惑，在认定的道路上努力追求单纯的梦想，随之而来的将是丰厚的人生。所以，这些年生活带给我的痛和希望，都是于我的恩赐，给了我更多的自省和淡定。</p>
<p>好了，回到正题。中秋结束，九月份基本宣告结束，2015年也就完成了三分之二，审视自己在年初定下的目标，有些惭愧，因为发现有很多习惯仍然没有养成。关于读书，没有做详细的统计，在三月份时候做的统计是二十本，而后到七月份的时候大约有五十本，稍慢于节奏。而后入学一个月的时间里，阅读量下降，主要精力放在了课程，刷题，和填坑。</p>
<p>虽说我可以通过填充一些小篇幅的书籍来补回阅读量，但是这样无意义的阅读反而是有害的，有一些编写的并不好的书读起来的价值反而不如重看几遍经典书籍，所以今年的百本计划可能完不成了，不过因为开学之后又给自己设定了其他新的目标，所以通过完成几个目标，也算是可以填补这个目标的遗憾吧。</p>
<p>这个博客的上一篇日志发于三月份，而后的六个月是长长的空白，这说明在一个孤独的、而且操作不便的环境里学习，很快就会遇到瓶颈，天花板让我满怀斗志的原地踏步，毫无寸进。日志依然保持持续更新（从八月份到现在，因为入学相关事宜，日记时断时续），文章依然在写，却感觉没有太多新的思考可供我写，大多数的阅读又都与我过去的思考重复，许多阅读收获我放在里简书的账号里。</p>
<p>现在入学一个月有余，度过了适应阶段，我又有新的东西可以思考了，也有了新的目标可以期待，所以，这个博客我可以继续下去了，年初的时候我写文章说，自己在两年里完成了一次从 1.0 到 2.0 的成长，那么，现在就是刺激自己从 2.0 向 3.0 成长的过程吧。</p>
<p>宋冬野有首歌叫《平淡日子里的刺》，韩寒写的词，其实是讲平淡生活里那些猝不及防的无奈，随时会刺痛你，会瞬间刺破幻境，所以他说，生活是这样子，不如诗。</p>
<p>可是，我需要一把刺，我觉得更像一把锥，时刻让我认真感知生活，努力追逐。我需要这根刺，让我时刻保持清醒。张爱玲说，对于三十岁的人来说，十年八年不过是指缝间的事。她说的是爱情，但在我看来，生活也是如此，如果没有一把刺，三五年转瞬老去，大约要真的像叔本华所说的那样，我们都已死去，却等到七十五岁才埋葬。</p>
<p>最后，再用《倾城之恋》里的一段话刺痛一下自己（为什么我总把爱情的思考看成人生的思索，我好想忽然明白了什么人生道理）。</p>
<p><strong>你年轻么？不要紧，过两年就老了。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>很多人二十五岁已经死了，七十五岁才埋葬。    ——叔本华</strong></p>
<hr>
<p>八月十五，中秋，一个人。</p>
<p>之前的两年时间，都在期待着新生活，而转眼间也在这里过去了一个月，生活平淡，美好。终于开始思考眼前的生活，思考无论有意]]>
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/tags/Diary/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习笔记(一)]]></title>
    <link href="http://yoursite.com/2015/09/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://yoursite.com/2015/09/25/Docker学习笔记-一/</id>
    <published>2015-09-25T07:27:44.000Z</published>
    <updated>2015-09-25T07:41:44.000Z</updated>
    <content type="html"><![CDATA[<p>来自：<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker 从入门到实战 Gitbook</a></p>
<h2 id="什么是Docker">什么是Docker</h2>
<hr>
<p>Docker 是一个开源的项目，于2013年诞生，基于Go语言实现，代码在<a href="https://github.com/docker/docker" target="_blank" rel="external">Github</a>上维护。</p>
<p><strong>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</strong>，Docker 的基础是Linux 容器等技术。</p>
<p>在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/30117-b2fb8aee9f40c436.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Alt text"></p>
<p>与传统虚拟机相比，Docker 容器是在操作系统层面实现了虚拟化，直接复用本地主机的操作系统，传统的方式仅在硬件层面上实现。</p>
<h2 id="Docker优点">Docker优点</h2>
<hr>
<p>秒级实现，资源利用率高，除运行应用外，基本不消耗额外系统资源，使应用性能很高，开销更小。</p>
<h3 id="更快的交付和部署">更快的交付和部署</h3>
<p>开发者使用标准镜像构建一套开发容器，完成后，运维可以直接使用容器来部署代码。Docker可以快速创建，快速迭代，全程可见。</p>
<h3 id="更高效的虚拟化">更高效的虚拟化</h3>
<p>内核级的虚拟化，不需要额外的hypervisor支持。</p>
<h3 id="更轻松的迁移和扩展">更轻松的迁移和扩展</h3>
<p>可在任意平台运行，更好的实现迁移。</p>
<h3 id="更简单的管理">更简单的管理</h3>
<p>简单修改，以增量的方式分发和更新，实现自动化和高效管理。</p>
<h2 id="基本概念">基本概念</h2>
<hr>
<h3 id="镜像（Image）">镜像（Image）</h3>
<p>Docker镜像就是一个只读模板。<strong>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</strong></p>
<p>用户通过简单的机制创建或者更新现有的镜像。</p>
<h3 id="容器（Container）">容器（Container）</h3>
<p>Docker利用容器运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。<strong>每个容器都是相互隔离的、保证安全的平台</strong>。</p>
<h3 id="仓库（Repository）">仓库（Repository）</h3>
<p>仓库是集中存放镜像文件的场所。概念与Git相似，注册服务器可以理解为Github这样的托管服务。所以Docker也有仓库和仓库注册服务器的概念。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 <a href="http://dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等，可以提供大陆用户更稳定快速的访问。</p>
<p>用户也可以自己创建一个私有仓库，通过<code>push</code>命令上传，通过<code>pull</code>命令下载。</p>
<h2 id="安装">安装</h2>
<hr>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/installation/#installation" target="_blank" rel="external">安装指南</a> ， 不再赘述。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来自：<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker 从入门到实战 Gitbook</a></p>
<h2 ]]>
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阶段读书总结]]></title>
    <link href="http://yoursite.com/2015/03/15/%E9%98%B6%E6%AE%B5%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/03/15/阶段读书总结/</id>
    <published>2015-03-15T15:19:30.000Z</published>
    <updated>2015-09-25T07:37:21.000Z</updated>
    <content type="html"><![CDATA[<p>很长时间没有更新这个博客了，其实常常责备自己难道又要三分钟热度的放弃了这个博客了么。</p>
<p>不过虽然博客没有更新文章，但是文章一直在写，每天千字，如今已经积累了一百多篇，不过一直觉得自己思考的东西，没必要总是更新在博客里。博客里更新的应该是比较成熟的而且更加思想密集的文章，所以就一直搁置下来，包括阅读笔记也没有更新。</p>
<p>大概在今年年中的时候，环境发生变化后，我可能会改变很多学习方式，这个博客就会继续更新，并且确保自己处在高效思考的状态。</p>
<p>下面是2015年截至现在的阶段读书统计，算是一个归档。</p>
<p>———<br>已读书目（包含部分阅读过半，觉得没算太好但会抽时间看完的书）：</p>
<blockquote>
<p>由于之前没有看完记录的习惯，于是归档的书籍没办法统计时间及先后顺序，而且对一月一号这个分界线前后阅读的书区分有些忘记，所以只能按照自己模糊记忆中的整理。</p>
</blockquote>
<ul>
<li>《参与感》小米公司的营销方法书，黎万强写的，写的还不错，记住了那句，台风口上，猪都会飞起来。</li>
<li>《意志力》 如书名，讲解了意志力这东西，意志力的特点和如何锻炼意志力。书不错，意志力就像肌肉，过度使用就会疲劳，长期锻炼就会增强。</li>
<li>《演讲之禅》 介绍演讲的前前后后和真谛，看的有点早，很多内容现在接触不到，有一定意见性，对以后如果做演讲会有好处。</li>
<li>《风起陇西》 马伯庸的小说，三国背景的谍战题材，脑洞大开，文笔顶棒，马亲王一生粉。</li>
<li>《习惯的力量》 讲述习惯存在的意义和具有的能量，以及如何养成良好的习惯。不过事例太多，口水太多，读一半准备弃掉，再看一部分，看还有希望没。</li>
<li>《激荡三十年》上  可以归在在读的行列，不过打算按照速读的方式进行，因为有很多内容可能对我来说意义不大，讲述七八年改革之后国家经济的起起落落，本意是想要了解一下这三十年来经济资产的发展之路。</li>
<li>《超级时间整理术》 个人时间管理方面的知识，有一定用处，不过和之前一些看过的东西，以及自己的认知重合，算是强化认识吧。</li>
<li>《来到地球的第一天》 大象公会的第一本书，算是热知识冷知识的合集，挺有意思，适合我这种好奇心比较浓厚的人。</li>
<li>《暗时间》 刘未鹏的博客合集，前半部分对我触动比较大原因是发现自己思考的东西，原来别人也已经思考过，而且也总结的很棒了。更加激励我坚定的走下去。</li>
<li>《把时间当做朋友》 李笑来的书，是知道了刘未鹏之后知道了李笑来，也是一个个人时间管理方面的书，比较有实战意义，不过很多事情还是因人而异，只有懂了原理和真谛，具体的方法还是要看自己了。</li>
<li>《阮一峰博客文集：如何变得有思想》 比较失望的一本书，本来以为是比较有深度思考的书，结果发现其实就是一些特别简单的阅读笔记和思考总结，难不成我的日记整理整理也能出本书？虽然阮一峰比我牛逼太多，不过还是觉得书没那么好。</li>
<li>《野蛮生长》 一开始喜欢这书名买来看的，发现冯仑这人确实非常有才华，看待事物非常清楚，分析的很透彻，书没看完，是因为觉得虽然分析的很好，可是总觉得和自己关系不大，有些伤感。</li>
<li>《古董局中局3》 马亲王的书，不解释，第三部，依然好。</li>
<li>《新经济，新规则》 KK的书，考虑到写这十大未来特点的年代，KK果然是牛人。</li>
<li>《苗疆蛊事》 近年来唯一看完的一本快餐小说，马亲王以前推荐的，有点意思</li>
<li>《故事：材质，结构，风格和银幕创作的原理》  应该是编剧的宝书，买来看看纯属求知欲，指不定什么时候想写个剧本什么的。</li>
<li>《罗辑思维》  是罗辑节目的一个合集，罗辑也是思维挺独特一个人，而且见识挺广，所以读来也有意思，这样看合集的方式要好过一集一集的看节目。</li>
<li>《穿布鞋的马云》  看这本书也是源于当时马云成为首富，我对这个人的风云故事比较感兴趣，觉得这个人看起来很闷，但内在一定很丰富，所以拿来看看。</li>
<li>《三十六大》 冯唐的书，冯唐的文字风格有北京人那种痞气，读起来酣畅淋漓但是总觉得有点过了，可能是他这个人确实才华出众所以才睥睨万物吧，我想起了和菜头。</li>
<li>《亵渎》 网文，开头烂得读不下去，但是总是很多人推荐，正好那段时间心情不好，压着读了前边，后边写的好了一些，不过其实感觉也好不到哪去，不知道自己有没有闲工夫把它看完。</li>
</ul>
<hr>
<p>共计20本，考虑到一年阅读一百本书的计划，平均每月需要阅读八本，到今天刚好符合进度。</p>
<p>特点：</p>
<ul>
<li>阅读难度不高，整体没有什么难度的书要啃，没有什么专业类书籍，一方面是因为环境的原因，专业类的书籍有看，但是进度很缓慢，缺少大块的消化时间。</li>
<li>归档整理不及时，一来没有登记，二来没有整理读书笔记。</li>
<li>没有计划，选择看的书，基本没有什么计划，就是看完一本，挑选挑选就开始看下一本。</li>
<li>阅读心得没有继续下去，去年说的要写阅读笔记来着，结果没有坚持下去，可能环境原因占一部分。</li>
</ul>
<hr>
<p>在读：</p>
<ul>
<li>《算法心得》</li>
<li>《编程珠玑》 &amp; 《编程珠玑续》  三本算法类的书，装逼利器，可是看起来挺折磨的，第一天看了几页，花费了半个上午的时间，需要慢慢消化。</li>
<li>《IOS开发指南》，虽然还没有彻底开始打算做IOS的开发，但先作为入门知识了解一下也是好的，毕竟自己这么多语言都想好好学学，不得都先入个门。</li>
<li>《梁文道：我读1》，属于是不想细看的书可以在这了解，想看的书可以在这看下介绍，看过的书在这看看他怎么看。</li>
<li>《上帝掷筛子么？量子史话》 很早以前其实就看了一部分，貌似当时是因为看的盗版的epub，不完整，影响阅读体验，就搁置了，在多看买回来之后，想着把它补完。</li>
<li>《结网》 PM的书，目前离这个职位比较远，直接想当PM的人，其实很大部分都自以为能力足够了，看了本《人人都是产品经理》等几本书，觉得就可以胜任了。想要往这发展，预计自己还有大约五十本相关类的书要看完并有相应五十篇以上的思考。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>很长时间没有更新这个博客了，其实常常责备自己难道又要三分钟热度的放弃了这个博客了么。</p>
<p>不过虽然博客没有更新文章，但是文章一直在写，每天千字，如今已经积累了一百多篇，不过一直觉得自己思考的东西，没必要总是更新在博客里。博客里更新的应该是比较成熟的而且更加思想密集]]>
    </summary>
    
      <category term="阶段总结" scheme="http://yoursite.com/tags/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一周阅读笔记（2015年第三周）]]></title>
    <link href="http://yoursite.com/2015/01/19/%E4%B8%80%E5%91%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882015%E5%B9%B4%E7%AC%AC%E4%B8%89%E5%91%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2015/01/19/一周阅读笔记（2015年第三周）/</id>
    <published>2015-01-18T16:06:14.000Z</published>
    <updated>2015-01-18T16:07:08.000Z</updated>
    <content type="html"><![CDATA[<p>上周给忘记写读书笔记了，其实最近书看的不少，却没有哪本让我发自内心的想好好写篇读书笔记，结果就晃悠晃悠的过了一周又一周，眼看这第三周又要结束了，于是就把最近读的书感兴趣的一些东西汇总一下，写篇读书笔记吧。</p>
<h2 id="1">1</h2>
<blockquote>
<p>整体性学习的顺序： （1）获取 （2）理解 （3）拓展 （4）纠错 （5）应用 还有一个测试步骤是伴随上述每一步的。</p>
<ol>
<li><strong>获取</strong>　获取就是信息进入你的眼睛和耳朵，阅读、课堂上记笔记以及个人的种种经历都是获取。获取阶段的目标是获取的信息要准确，信息量要尽量压缩。</li>
<li><strong>理解</strong>　理解就是了解信息的基本意思，并放在上下文中联系，这是学习的最基本联系。</li>
<li><strong>拓展</strong>　拓展阶段是整体性学习中最花力气的地方，这一步将形成模型、高速公路和广泛的联系，从而获得良好的结构。<br>4.<strong>纠错</strong>　纠错阶段是在模型和高速公路中寻找错误，这个阶段要删除那些无效的联系。</li>
<li><strong>应用</strong>　应用把纠错带入最后的水平，通过比较（知识）信息是如何在现实中运行的来进行调整，如果理解不符合现实世界，那么再多也无用。在这一步中失败的典型例子就是书呆子，即那些读书读得很好但是出了学校大门却茫然不知所措的家伙。</li>
<li><strong>测试</strong>　上述阶段的每一步都需要测试，测试有助于你迅速找到学习中的问题所在，帮助你改进学习技术，克服缺点。</li>
</ol>
<p>—from 《如何高效的学习》</p>
</blockquote>
<p>这本书只用了半天读完的，感觉干货不多，也就是提供了一套学习的方法，至于是否高效，还真的需要在实践中去找寻方法。以上引得是这本书对学习过程的一个总体的顺序，针对这六步骤，作者也算是简单的讲述了一下，我觉得还是要自己去发现适合自己的高效学习法。</p>
<ul>
<li>获取阶段，要探索如何简化知识，也就是如何快速剔除无用的知识。要探索如何扩容自己的知识体系，探索如何保证高速的阅读。</li>
<li>理解阶段，是要建立起一个高效的逻辑思维，高效的吸收知识。</li>
<li>拓展阶段，本阶段是要在个人的知识体系之间建立良好的联系，确保让自己的知识不是孤立在自己的学习体系中。</li>
<li>纠错阶段，本阶段用于复查所获取的知识有没有逻辑上的错误，有没有错误的知识。</li>
<li>应用阶段，对一部分重实践型的知识来说，应用是重中之重。</li>
<li>测试阶段，相当于每个阶段的调试，作者是这么说的：<strong>获取阶段的测试——我以前看过或听过这个知识吗？ ·理解阶段的测试——我理解知识的含义吗？（至少是字面上的意思。） ·拓展阶段的测试——我知道知识从何而来，与哪些知识有关系吗？ ·纠错阶段的测试——我删除了那些不恰当的联系吗？我删除了那些错误结论吗？ ·应用阶段的测试——我将知识用到实际生活中了吗？</strong></li>
</ul>
<p>所以下一步，自己要花时间总结出一套适合自己的学习法。</p>
<h2 id="2">2</h2>
<blockquote>
<p>年轻人在城市获得的更多东西，远不仅仅是肉身之间非延时的沟通，更重要的是见识。其实见识跟经济地位和聪明程度没多少关系，和是否在大城市生活有关。北京随便一个四五岁的小孩站在街边上，也许什么名车都认识，他们家的车库可能跟国贸的车展也没什么区别。而一个外地的农村大学生，可能学问很高但缺乏见识。这就是城市生活给人类灵魂世界带来的最丰厚的一笔财富。<br>—from 《罗辑思维》</p>
</blockquote>
<p>这后边的比喻有点偏颇了，但是观点还是比较赞同的，赞同的原因是因为来到这个小城市工作之后发现的，虽然这个小城市在经济上并不落后，但总是发现在世界观和价值观上，有着许多让我难以理解的地方。这也是为什么最近那么多人嚷嚷着逃回北上广，其实只是因为他们从大城市逃离回到自己小时候成长的家乡时，才发现他们在城市里已经习以为常的观念或者事物，无处可寻，发现自己的价值观和周围人不在一个维度。</p>
<p>虽然自己不是大城市出来的孩子，但是也能体会到罗辑讲的有关大城市的聚集效应的逻辑。</p>
<h2 id="3">3</h2>
<blockquote>
<p>刘慈欣得出的结论非常特别，他说在地球这样一个星体上搞环保完全没有必要。他给我们看了一幅图，是发射到外太空的一个小型探测器回望地球时拍下的照片。从多远的地方回望的呢？64亿公里，也就是从地球到太阳距离的40倍之远回看地球，然后拍下了这张照片。在这张照片中你还找得着地球吗？找得着，不过得用显微镜去找。就是一个小小的灰点而已，看上去地 球就是宇宙中的一粒尘埃。<br>—from 《罗辑思维》</p>
</blockquote>
<p>这里罗辑讲了个很有趣的话题，就是环保真的有必要么。按照大刘的说法，从宇宙的尺度上来看，地球就是一粒尘埃，我们人类真的有必要在一粒尘埃上去拂拭尘埃么。我们提保护资源，保护地球环境，每年在环保上投入的钱有近万亿，可是投入在外太空探索上的资金不过百亿。为什么不花更多的钱去研究和探索外太空呢，宇宙广袤，外边是无边无际的资源和空间，为什么只把目光定格在宇宙的这一尘埃上呢。</p>
<p>当然，这个观点漏洞很多，比如说人类环保是因为要保证当下人类生活环境的健康，保证人类的正常繁衍，比如保护资源是为了确保人类的发展不会出现资源断层，引起全球资源荒。</p>
<h2 id="4">4</h2>
<blockquote>
<p>耶鲁大学的经济学家Nancy Qian以及哈佛大学的经济学家Nathan Nunn做过一个调查，他们从1972年一直跟踪到2006年，发现一个国家得到的粮食援助每增加10%，这个国家的暴力动乱程度就会增加1.14%。道理很好理解，因为一个底层的贫民，是没有办法直接拿到援助粮的。一部分援助粮被政府官员贪污走，另一部分就是权力大的是哥哥，枪杆子里出政权。那些反政府武装、游击队，这些有组织的暴力会劫持这些粮食，从而变得更加强大。 最典型的就是索马里，大量的捐助粮都在半途被武装组织，比如海盗、游击队、反政府武装劫持。底层老百姓的境况几乎没有改善，这就是慈善的一大难处。</p>
</blockquote>
<p>慈善，是一个非常有争议的话题，中国的红十字会过去几年经常处在风口浪尖，颇多非议。罗辑讲的坏慈善，是指的引文中所讲的这种援助粮被侵吞的情况。其实，以国家层面做的这种慈善事业，并非普罗大众想象中的那么简单，它是放在国际政治的背景下进行的，中国近几年大力气援助非洲国家，更大的原因并非来自所谓的国际人道主义精神，而是为了与非洲各个国家建立良好的关系，在这种良好的关系之上，可以有更多的计划和发展项目可以继续进行，而至于真正饥荒的难民，其实仅仅是最后要考虑的问题。</p>
<p>在中国古代，朝代更迭或者是朝代衰亡的最大导火线，就是饥荒，朝廷一般情况下也都会发赈灾粮救济灾民，但一般来说，这种行为基本上对饥荒没有多大的缓解作用，因为腐朽的封建王朝，是一坛酱缸，基层的官员基本上是以腐败为主，劣币驱逐良币，大部分的赈灾粮基本上都被当地官员和巨贾瓜分殆尽。</p>
<p>所以，慈善是一件看起来很美好，做起来很复杂的事业。</p>
<h2 id="5">5</h2>
<blockquote>
<p>你不知道，古董行当里，有三劝之说。哪怕是拿赝品骗人，对方临要买前，骗子得劝上三回，以示不负良心。劝了三回，对方还不醒悟，那就是自己作死，命中注定要被我骗了。”<br>—from 《古董局中局》3</p>
</blockquote>
<p>马伯庸的博学在我看过的小说里比较少见，以前被惊艳到的是张大春的《城邦暴力团》，掉书袋子让我佩服的五体投地。</p>
<p>这里也就是引一段觉得有意思的话，中国古人讲盗亦有道，所以中国的各行各业似乎都明着暗着有些行规，这种行规，似乎是行业里的人不约而同为自己设立的一个道德底限，文中说这个三劝之说，便是这样一个意思。所以说，在西方依靠宗教建立起群体的心理依赖时，中国完全依靠这种“道”，建立起了群体的道德规范。</p>
<p>当然，到今天这种所谓的底限意识已经一次次被打破，江湖和道上规矩，也零零碎碎荡然无存。</p>
<h2 id="6">6</h2>
<p>《新经济，新规则》</p>
<ol>
<li><strong>Embrace the Swarm拥抱集群</strong> 当力量逐渐远离中心，竞争优势属于那些懂得接受去中心化控制点的人。</li>
<li><strong>Increasing Returns回报递增</strong> 随着人与物之间连线增加，这些连线的效果快速地倍增，你取得的初步成功将不再是自我限制的，而是自我供给的。</li>
<li><strong>Plentitude, Not Scarcity普及，而非稀有</strong> 制造工艺趋于完美，使大批量复制越来越容易。因此，价值产生于普及，而非稀缺性，这颠覆了传统的商业定律。</li>
<li><strong>Follow the Free追随免费之道</strong> 随着资源匮乏性将让位于资源充足性，慷慨将带来财富。坚持免费印证了价格下滑的必然性。学会利用真正匮乏的资源，那就是人的注意力。</li>
<li><strong>Feed the Web First优先发展网络</strong> 网络使各种商贸业务纠缠在一起，公司的关注重心从最大化公司价值转移到最大化网络价值。除非你适应网络效应并使其运作，公司才不至于灭亡。</li>
<li><strong>Let Go at the Top不要在巅峰逗留</strong> 创新不断加速，抛弃那些目前极为成功，但是最终会因为守旧而被淘汰的公司将是最困难但最根本的任务。</li>
<li><strong>From Places to Spaces. 从地点到空间</strong> 物理层面的临近（地点）将被大量的互动所代替，这些互动存在于任何事物、时间与地点之间（空间）。中介、中间人以及中型利基市场将大幅扩大。</li>
<li><strong>No Harmony, All Flux和谐不再，乱流涌现</strong> 商业世界中，动荡与失衡成为常态，因此最高效的生存状态是持续的选择性破坏，我们称之“创新”。</li>
<li><strong>Relationship Tech关系技术</strong> 软性技术胜过硬性技术，最强大的技术是能够提高、放大、延伸、增进、提取、召回、扩展或者建立各种软性关系的技术。</li>
<li><strong>Opportunities Before Eciencies机会优于效率</strong> 人类不断完善机器，使其变得越来越高效，并以此创造财富。但是还有巨大的财富等待人类发掘，它可能意味着低效的发现，也可能是新机会的创造。</li>
</ol>
<p>——互联网时代的十条规则</p>
<h2 id="7">7</h2>
<blockquote>
<p>新达尔文主义把蝴蝶翅膀的每一次扇动，叶片上的每一条曲线，鱼的每一个种类都归于适应性选择来解释。似乎没有什么不能归结为适应的结果。可是，正如理查德·莱旺顿这位著名的新达尔文主义者所言，“正是因为自然选择什么都能解释，所以它其实什么也没有解释”。<br>———from 《失控》</p>
</blockquote>
<p>如今，达尔文的进化论，仍然是被定为假说，因为它仍然存在争议的地方，那些争议的地方，包括达尔文进化论的研究者至今也无法解释的内容。比如人得眼睛，设计精巧且相互作用的晶状体、虹膜、视网膜等结构，看起来确实挑战了达尔文那种“轻微、累进的”随机改进机制的可信度。<strong>正如达尔文在给他的美国朋友阿萨·格雷的信中所写的：“你说的弱点我同意。直到今天，眼睛还是会让我不寒而栗。”</strong></p>
<p>格雷所遇到的困难，是他想不出在一个没有进化完全的眼睛中，某些部分会有什么用处，也就是说，他想不出一个没有晶状体与之配套的视网膜，或者反过来，没有视网膜与之配套的晶状体能对它的拥有者有什么用处。而既然生物不会囤积它的发明（“哈，等熬到白垩纪这东西就有用了！”），那每个阶段的物种进步就都得是马上就能用上、能产生效果的。每次突破，都必须首演即获成功。即使是聪明的人类也无法为这么久远以后的挑剔需求而矢志不渝地谋划。</p>
<h2 id="8">8</h2>
<blockquote>
<p>有一个高度灵活的基因官僚机构管理着其他基因的生活。最令人惊讶的是，所有生命，从果蝇到鲸鱼，都授权同一个基因管理局实行管理。比如说，在每一种脊椎动物体内，都能发现几乎完全相同的同源异形盒自控序列（这是一段主开关基因，可以打开大段的其他基因）。<br>——from《失控》</p>
</blockquote>
<p>前些天看的《I型起源》这个电影，其中也是用了这样一个线索，反达尔文的研究者在研究这些非随机突变的时候，有许多非常有意义的发现和推论，上边就是一个。I型起源这个电影里讲的是，主角认为所有动物的基因中应该存在一个控制眼睛的开关基因，可以控制眼睛的产生。</p>
<p>其实这样的理论有一定的颠覆性，因为它几乎是在背着达尔文进化论的研究方向进行的，文中又说：</p>
<blockquote>
<p>变异可以通过某种有意的、精心准备的方式来选择。与其说基因管理局仅仅对随机变异进行编辑，不如说它按一些计划表自己产生出变异。基因组为特定目的会创造出突变。定向突变可以刺激自然选择的盲目进程，把后者带出泥潭，将其推向越来越复杂的状态。在某种意义上，有机体会自编自导出突变以响应环境因素。多少有点讽刺的是，这种定向突变的强势看法在实验室里获得的证据，比弱化的非随机看法更多更过硬。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>翻看这几天记录的书摘，发现好内容很多，而且有些内容竟然已经开始在遗忘了，前边讲了高效学习的方法，其实知识体系的建立，必然要考虑到知识的记忆。所以，保持整理读书笔记的习惯，分类读书笔记，也算是一种高效学习的手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上周给忘记写读书笔记了，其实最近书看的不少，却没有哪本让我发自内心的想好好写篇读书笔记，结果就晃悠晃悠的过了一周又一周，眼看这第三周又要结束了，于是就把最近读的书感兴趣的一些东西汇总一下，写篇读书笔记吧。</p>
<h2 id="1">1</h2>
<blockquote>]]>
    </summary>
    
      <category term="weekly note" scheme="http://yoursite.com/tags/weekly-note/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏设计迷思]]></title>
    <link href="http://yoursite.com/2015/01/14/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E8%BF%B7%E6%80%9D/"/>
    <id>http://yoursite.com/2015/01/14/游戏设计迷思/</id>
    <published>2015-01-14T14:43:50.000Z</published>
    <updated>2015-01-14T14:48:54.000Z</updated>
    <content type="html"><![CDATA[<p>因为之前写的那篇「读书是追赶时间的方式」，里边讲到了游戏的终极设计原理都一样。写这句话也是因为之前看过一篇相关的文章，现在已经踪迹难寻，另外我也确实同意这个观点，因为游戏的终极设计之路是从心理学上开始的。后来，赵飞问了句，游戏的终极设计原理是什么？我觉得应该试着去分析一下游戏的存在意义和设计原理，当然我自己并没有钻研过这方面的知识，又不是相关行业的人员，也只能是查查资料，以自己的想法为主。以简练为主，更多的思考内容，可以留在以后添加。</p>
<h2 id="始于心理学">始于心理学</h2>
<p>记得之前一个心理学和经济学双修的作者在谈经济中的消费心理学时，说他学心理学的同学里，最优秀的去制作游戏了，然后是去经商了，最后剩下的才留在了心理学的岗位上。固然说的有点夸张，但基本可以看出来，游戏的设计，最重要的就是如何把握玩家心理。<br>那么游戏的目的是什么呢，从远古还穿着草裙狩猎的原始人就已经有了游戏，到古代的射覆，蹴鞠，一直到今天的体育对抗。这些都是人类生存中的游戏，它们共有着对抗的特征，这是源于原始人的强者生存，族群之间的战斗是用生命搏杀的，要想保存族群长生不灭，只有保持最强大的战斗力和时刻旺盛的求胜欲（或者说是求生欲），所以，游戏的对抗性是它存在的意义。</p>
<p>这一意义一直保留到了今天的电子游戏中。今天所玩到的所有游戏，对抗性都是设计的必须先考虑的，人与人对抗，人与游戏中设置的环境对抗，分别对应了原始部落中部落间的对抗和人类与自然的对抗。</p>
<p>所以，从游戏的起源上看，所谓电子游戏，也是和其他游戏同源的，并没有谁比谁更玩物丧志的道理。体育竞技，棋牌对抗，甚至于抠麻将轮盘赌，本质上和电子游戏是相同的。所以今天电子游戏所面临的舆论，其实是不健康的一种舆论状态。当然了，大概是两三年前开始，中国的社会舆论已经开始逐渐接纳电子游戏作为竞技游戏的地位，游戏产业也得到了国家经济部门的肯定。其实，这只是因为爱玩游戏的八零后们已经开始掌握话语权，并且逐渐从电子竞技中建立了早期的发展模式。而老一辈们扼腕长叹着“游戏不死，下一代必将垮掉”，继续痛恨电子游戏，但已经于事无补了。</p>
<h2 id="游戏的奖励机制">游戏的奖励机制</h2>
<p>前边说了那么多，好像都没有说到重点。因为我自己强调了玩游戏会让自己变得空虚，日子变得无意义，这就聊一聊游戏的设计。</p>
<p>游戏设计的最核心就是<strong>奖励机制</strong>，这种奖励机制就像是实验室里，测试大猩猩行为训练的香蕉一样，如果你完成了规定的任务，就会收获想要的香蕉。在所有类型游戏中，判定胜负和游戏模式千差万别，但都逃不过奖励机制，缺乏奖励机制的游戏就不能称之为游戏了。</p>
<ul>
<li>比如网络游戏中刷完副本会奖励装备和金币，RPG游戏在阶段剧情完成后，会奖励人物的升级，以及后续剧情（没错，后续剧情就是RPG游戏的奖励之一）；</li>
<li>比如类Dota的MOBA游戏的奖励是胜利，是杀戮的快感，而跳出的红字以及震撼的背景音都强化了这种奖励；</li>
<li>策略类游戏的奖励，就是给予你作为领袖的支配感和攻城略地的快感，通过逼真的音效，胜利的欢呼，甚至是敌军的求饶强化奖励。</li>
<li>文明等养成类的游戏的奖励，是获得上帝视角的奖励，通过全景的观感和完全的服从意识来给予奖励。</li>
<li>虚拟现实的游戏，比如体育竞技类，棋牌类就不用说了，他们是根植于现实中的游戏的。</li>
</ul>
<p>还有更多的游戏分类，不用一一讲明，我们就可以很清楚地看到，游戏的核心在于<strong>奖励机制</strong>，只有将奖励悬置于游戏的后面，才能让玩家这群大猩猩去完成任务。</p>
<h2 id="游戏的基本元素">游戏的基本元素</h2>
<p>刚才说的<strong>奖励机制</strong>，我想应该算是游戏为什么能存在，我为什么说游戏都是雷同的原因，当然可能会遭到很多反驳，比如有人会觉得，那按照这么说，人在生活中的一切事物，都可以理解为是雷同的，因为完成任务不都是为了获得最终的奖励嘛。这么理解也对，那我们就继续对电子游戏再探究探究，进一步抓取游戏的本质雷同属性。</p>
<p>游戏的四个基本要素是什么。</p>
<ul>
<li>游戏机制</li>
<li>故事设定</li>
<li>美学表现</li>
<li>实现技术</li>
</ul>
<p>那么这四个要素里，前两个是核，后两个是皮，所以后两个可以不作为分析的对象。</p>
<p>先看游戏机制，游戏机制是整个游戏的中心地位，刚才我所说奖励机制是游戏核心，是从心理学的角度说的，而游戏机制作为核心，是从游戏设计的角度上是核心，它大致有六个机制：</p>
<ul>
<li>空间</li>
<li>对象，属性</li>
<li>行为</li>
<li>规则</li>
<li>技能</li>
<li>偶然性</li>
</ul>
<p>（篇幅有限，就不一一讲述，感兴趣的人可以买《全景探秘游戏设计》这本书，是本非常干货的好书，六个机制也就是从书中引出来的。）</p>
<p>六个机制可以看出来，游戏的设计之路，完全是遵循着这么一套的流程出现的。游戏始于灵感，然后进入这样一个流水线进行加工，形成一个游戏模型，然后再进行美学表现和实现技术的加工，形成一个成品。</p>
<p>那么这个流水线都包含哪些东西呢，换句话说，就是游戏机制在设计中，遵循了哪些原则，要考虑哪些因素？其实玩游戏多的人，想一想也就知道了，无外乎以下几点：</p>
<ul>
<li>公平性：这是为了保持玩家之间公平竞争的健康发展</li>
<li>挑战与成功</li>
<li>有意义的选择：增加选择性，是为了创造游戏所谓的多样性~</li>
<li>技能与几率：网络游戏，RPG之类的首要考虑</li>
<li>动脑与动手：</li>
<li>对抗与协作：</li>
<li>奖励与惩罚：上一章节探讨过</li>
<li>简单和复杂：</li>
<li>自然与人工平衡：</li>
<li>细节和想象力：</li>
</ul>
<p>从上边这套流水线生产下来之后，游戏就成为了一个半成品，只需要在加上皮，就可以正式的投入社会，面向玩家了。</p>
<p>从这套流水线你看到了什么呢，其实应该看到的是，游戏设计的所有核心，都是为了刺激玩家的感官和心理，让玩家收获来自游戏给予的满足感，而其中包含的奖励机制又刺激玩家持续的跟进，为了获得更多的奖励和更大的满足。</p>
<h2 id="游戏设计的更多探讨">游戏设计的更多探讨</h2>
<p>经过前边的探究之后，我确实是要修正一下我的观点。游戏的终极设计原理，从心理学上是相同的，但是整个游戏的设计过程，其实是和艺术创作的过程是相似的，是拥有着非常大的创造性在里边的。这两天正在看剧本创造的宝书<strong>《故事：材质、结构、风格和银幕剧作的原理》</strong>，感觉剧本的创作和游戏的设计拥有着相似之处，所以这也激起了我更多的兴趣，对游戏创作的原理进一步探究。</p>
<p>继续沿着心理学的路，分析游戏设计，以下是在《全景探秘游戏设计艺术》中提到的相关内容：</p>
<blockquote>
<p>男人喜欢在游戏中见到的5样东西：征服、竞争、破坏、空间谜题、尝试与失败。</p>
<p>女人喜欢在游戏中见到的5样东西：情感、真实世界、照料、对话和字谜、照实例学习。</p>
<p>巴特尔的玩家类型分类：成功者、探险家、社交者和杀手。</p>
<p>马克勒布朗的游戏乐趣分类法：感受、幻想、叙述、挑战、伙伴关系、探索、表达和服从。</p>
</blockquote>
<p>这和剧本的创作具有非常大的相似性，男人热衷于战争、强对抗、暴力、宏大，而女人更喜欢温柔、情感、关爱、解答。正如兄弟连是男人的电影一样，使命召唤属于男人，而养成类的模拟人生则吸引更多的女性玩家。</p>
<p>所以说，游戏在设计之后，和影像作品一样，拥有着丰富无穷的发挥空间，而且有着比影像作品更强的参与性。</p>
<h2 id="电子游戏的空虚感和罪恶">电子游戏的空虚感和罪恶</h2>
<p>那为什么游戏会带来巨大的空虚呢，于是我从新审视这个问题，又有了不同的想法。<br>首先，因为电子游戏带来了前所未有的代入感，让玩家体验了更加真实的虚拟世界，虚拟世界带来的巨大的梦幻的场景，刺激玩家产生大量的多巴胺和肾上腺素，带来愉悦。一旦在游戏结束后，随着场景的消失，多巴胺和肾上腺素的消退，玩家就会感觉到失落，于是是巨大的空虚感。</p>
<p>想象一下自己在平时看喜欢的小说，当小说完结的那一刻，是不是同样也有着一种特别的失落感，因为小说在你内心构建起来的虚幻空间坍塌了。</p>
<p>另外，游戏最大的罪恶在哪里呢？原因就在于，游戏的产生和制作本身，是完全以盈利为目的的。它的创作过程，完全是以心理学为基础，最大限度地去刺激玩家产生更多的多巴胺，获得更多的愉悦感，以期在该游戏上投入更多。而网络游戏更是为了能够利用重复循环的游戏模式长期的吸引玩家，心理学上的知识无所不用其极，造成了部分玩家沉迷其中无法自拔。</p>
<p>正是因为这种从盈利为本质出发点制作出来的作品，自然带着罪恶，所以才会遭受更多人唾弃。而如书籍，则是首先来自作者自身的创作冲动，电影则是一群人的艺术追求方式，体育竞技则是人类的天生战斗的基因。</p>
<p>电子游戏，如同好莱坞的爆米花电影，起点中文的打怪升级小说一样，构建起虚幻又无用的想象空间，让玩家享受完带来的快感后，又什么都不留下的消失，这对人生是完全无正相关意义的，完全是在虚耗生命，浪费时间。</p>
<p>然而我们所说游戏是不带有正收益的事物，并非绝对，比如文明系列，对古文明历史的还原，有着超越书籍和电影的代入感；军事类游戏，更是早已进入美军高级指挥所，在美军巨量信息库的支持下，用来模拟战争的细节，短时预测战争走向。</p>
<h2 id="结语">结语</h2>
<p>其实写着写着发现自己已经脑袋有些混乱了，所以还是早点总结吧。毕竟游戏作为新崛起的文化产业，它所带来的话题和辩论，一时两刻是无法讨论清楚地，我自己在这里梳理想法，也只能是简单地讲清楚部分问题。</p>
<p>总的来说，通过这篇文章，扭转了之前用二元论直接否定电子游戏的作法。当然，作为玩家自身，人都有自由支配自己生命的权利，即使是将整个生命投身到游戏中去，只要自己认为是有意义的，那旁人就无权干涉。</p>
<p>我写这篇文章也只是为了提醒自己，任何事物都不可怕，可怕的是自己无法看清楚。电子游戏作为紧密联系着信息时代，互联网时代的娱乐产业，去了解它和接触它，对于了解社会，也有着一定的帮助，所以自己平时可以适当的接触部分游戏，能获得不少的灵感。</p>
<p>最后，一句老话送给自己。</p>
<blockquote>
<p>上帝,请赐予我平静, 去接受我无法改变的。 给予我勇气, 去改变我能改变的, 赐我智慧, 分辨这两者的区别。</p>
</blockquote>
<p>——</p>
<p>发现语言组织能力，还是不足，中间自己思路不清晰的时候，很难组织起明晰的逻辑语言。希望以后能够学习如何用更加简洁和直白的语言讲清楚问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为之前写的那篇「读书是追赶时间的方式」，里边讲到了游戏的终极设计原理都一样。写这句话也是因为之前看过一篇相关的文章，现在已经踪迹难寻，另外我也确实同意这个观点，因为游戏的终极设计之路是从心理学上开始的。后来，赵飞问了句，游戏的终极设计原理是什么？我觉得应该试着去分析一下游]]>
    </summary>
    
      <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="Study" scheme="http://yoursite.com/categories/Study/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书是追赶时间的方式]]></title>
    <link href="http://yoursite.com/2015/01/09/%E8%AF%BB%E4%B9%A6%E6%98%AF%E8%BF%BD%E8%B5%B6%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/01/09/读书是追赶时间的方式/</id>
    <published>2015-01-09T15:56:37.000Z</published>
    <updated>2015-01-09T15:58:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="写在前边的闲话：">写在前边的闲话：</h4>
<blockquote>
<p>本文纯粹是一篇闲来的随笔，又好像恢复了以前晦涩的感觉，偏意识流一些了。其实大多数时间自己在这种时候，思考的方式更纯粹一些。本周终于看完了《失控》，后小部分理解起来越来越费劲，所以常常读完一大块会停下来思考一下，KK在资料的丰富度上是此类书籍里比较少见的，见解也有很多独到或者是在今天社会有些离经叛道的。</p>
<p>本周看完的另外几本书是《易中天中华史》中国根系列的的后两本，越来越口水，不过有那么几个观点还挺有趣。把node.js的一本开发入门又看了一遍，发现比django更轻量一些，或者说是我了解的还不够？</p>
</blockquote>
<h2 id="正文">正文</h2>
<p>这世界上，有无数东西是不可逆的（或者严谨一些说，目前看来是不可逆的），比如熵，比如时间，比如容颜和青春。</p>
<p>作为三维动物，我们永远只能在时间线的上匀速前进，无论你是感慨万千伤春悲秋，还是唐突岁月碌碌一生，时间总是不疾不徐的流逝，无法放大，无法缩小。几乎所有的人，都曾后悔过浪费了时间，后悔没有珍惜某段时光，更会因为时间马不停蹄的流逝而彷徨失措。</p>
<p>而阅读大概是我能想到的唯一追赶时间的方式，因为在阅读的时候，文字所承载的时间的重量传递到了读者的时间里，个体在短暂的时间里变得强大，变得丰富。所以每次感觉自己在浪费时间的时候，我就会迅速拿起一本书去读，一本好书，能让我在时间上穿越千万年，空间上直抵亿万光年，于是，自己就好像在这段时间里，获得了足够强大的力量，可以扯住时间的步伐。</p>
<p>当然，在过去的1.0生活里，自己常常热爱虚耗时间，热衷于平静的生命体验，崇尚所谓无用的灵魂，惧怕自己分秒必争，惧怕劳累。那时候，读书对我来说，更像是一种陶冶情操，洞见灵魂的方式，喜欢就看下去，不喜欢就放下，作者和读者，像在围炉夜话，促膝长谈，有趣的可以剪烛畅谈，无趣的可以一拍两散，读书不过是给生命另一种体验的方式而已。</p>
<p>然而现在，我却认为读书，是追赶时间的唯一方式，因为你可以用一天时间，收获作者辛勤耕耘数月的收获，可以用一周的时间，收获作者许多年，甚至毕生的时间精华，在和作者交流的过程，时间的有效收益被成倍的放大。这也是为什么，人在读一本书的时候，会有一种奇特的充实感。</p>
<p>本来玩游戏，看电视，和读书，都是个体对外界的信息获取，然而为什么玩完一天游戏和看完一天电视后，人会有一种特别空虚的感觉，而读书却感觉特别的充实呢。</p>
<p>知乎上有相关问题的讨论，我闲时也去看过，回答的比较丰富，且用的是心理学上的分析方法。就我自己觉得，大部分游戏和大部分电视节目都不过是生活里的噪声，是有趣的噪声，大多数人会被这种喧哗的噪声吸引，于是认真倾听，并渴望从这些噪声中听出些什么，然后事实却是最终发现一无所获，这也是空虚感的来源，因为他们对于你的人生，起不到一点点的正相关作用，甚至于负相关作用都起不到，你接下来的生活，不会因为他们而兴起一丝丝波澜。</p>
<p>诚然，游戏已经被称为了第九艺术，一个好的游戏设计和制作，更趋近于一种令人享受的艺术，比如文明系列，比如全面战争系列，其中包含的控制论，人工智能，分布式等等理论也都创造了令人着迷的未来景观。然而，游戏却无法摆脱它固有的噪声本质，它的创造总是遵循着较为固定的套路，所以你所玩过的千千万万款游戏，其实都是同一款游戏，他们的终极设计原理相同，目的也相同。从生物学上讲，游戏的感官体验刺激了多巴胺、肾上腺素和后叶加压素的分泌，而在游戏结束后，这些因素的消退造成了巨大的空虚感。</p>
<p>然而读书却不一样，这里，首先排除掉网络上流行的小白文读物，因为这些读物的设计原理，其实和游戏的设计原理非常相近，也同样不过是一堆噪声而已。一本好书，其中汇聚着的是真正的信号，是真正有意义的信息，他们承载了作者人生体验中提炼出的思想之花，无论读者同意与否，都可以让读者收获有意义的信息量。</p>
<p>推荐《信号与噪声》这本书，可以花一天的时间，速读一番，更高效的提炼出作者思考所得，也对生活中无处不在的信号与噪声有一些自己的想法。</p>
<p>在抱着这种对读书新的理解下，我加快了自己的阅读速度，因为我变得异常渴望留住时间，大约半年的时间，阅读了大约五十多本书，绝大多数的书保证了80%以上的完成度。而这半年时间里，自己也获得了非同一般的体验，这是以前的阅读中没有感受到的，我感觉时间被放大，视野在不同的类型书的跳跃间变得更大，虽然生活没有那么自由，思想却挣脱牢笼飞的更远。</p>
<p>所以二零一五年开始以后，我希望自己能看更多的书，能体会更宽广的世界，也会记录下自己所看过的书，目标定在截至十二月31日，阅读完120本书，再多的书，我怕会让自己的阅读变得囫囵吞枣。</p>
<p>以上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="写在前边的闲话：">写在前边的闲话：</h4>
<blockquote>
<p>本文纯粹是一篇闲来的随笔，又好像恢复了以前晦涩的感觉，偏意识流一些了。其实大多数时间自己在这种时候，思考的方式更纯粹一些。本周终于看完了《失控》，后小部分理解起来越来越费劲，所以常常读]]>
    </summary>
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何科学午睡]]></title>
    <link href="http://yoursite.com/2015/01/04/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%8D%88%E7%9D%A1/"/>
    <id>http://yoursite.com/2015/01/04/如何科学午睡/</id>
    <published>2015-01-04T15:08:38.000Z</published>
    <updated>2015-01-04T15:10:51.000Z</updated>
    <content type="html"><![CDATA[<p>一直以来，对午睡这件事说不清它的对与错，网上的争论也比较多。一方人认为午睡是必须的且是最重要的养生手段，不午睡的身体伤害很大。另一部分人认为午睡不是必要的，而且可以尽可能的减少自己的午睡习惯。</p>
<p>就我现在的习惯来说，午睡是必不可少的，而且时间还不短，如果中午十二点半睡觉，大约三点前起床，那么中午就睡了两个半小时，一直觉得这个时间有些太长了，每次醒过来，还得大约半个小时时间才能从午睡的状态中清醒过来。而如果不睡午觉的话，在下午四点左右的时候，整个人的状态就会特别的差。所以我一直在试图寻找一种办法，有效地减少午睡时间，而且又能调节好身体状况。<br>所以我今天试着研究一下这个午睡的前前后后，看有没有一个提高工作效率且注重身体的方法。</p>
<p>首先考虑午睡的成因。</p>
<h2 id="餐后犯困">餐后犯困</h2>
<p>参考知乎这条问题。<a href="http://www.zhihu.com/question/27046074" target="_blank" rel="external">如何解决餐后犯困</a><br>知乎上对餐后犯困有几个不同阵营的解释，一个是餐后碱潮，一个是血液重分配，还有一个是胰岛素分泌，一个是食欲素减少，不过主要被承认的是后两个原因。<br><strong>餐后碱潮</strong></p>
<blockquote>
<p>其形成原理也确实是由于胃酸分泌，氢离子大量释放而使得相对应的HCO3-进入血液，使血液碱化。但是这种程度的碱化就能引起嗜睡了么？人体不会放任身体处于一个失衡的碱性状态，代偿机制会使得人体的呼吸变得更慢更浅，以储存更多的CO2来对抗新生成的HCO3-，这种轻度的CO2增加，对皮质下层的刺激加强，可间接的引起皮质兴奋 。也就是说，轻度代谢性碱潴留，是使人兴奋的，而不是我们这里讨论的昏昏欲睡。</p>
</blockquote>
<p><strong>血液分配</strong><br>这个在老一辈人中间传的比较多，意思就是我们在吃完饭后，血液涌进胃部帮助消化，这样供应大脑的血液就少了，所以才比较嗜睡。不过这一理论也不正确。</p>
<blockquote>
<p>人体对于缺血的应答机制最首选保全的就是“司令部”大脑，比如你在剧烈运动，血液大量进入骨骼肌的时候，供大脑使用的血供并没有减少。而仅仅只是为了消化食物就让大脑缺血运转，这是和大原则相悖的。而且最近也有实验证据显示，在用餐前后，颈动脉内的血液量是没有明显改变的。但是为了更好的消化食物，血液确实更多的进入了胃部，这些血供一部分来自骨骼肌施舍的血液，另一部分通过心脏的加班加点来实现。</p>
</blockquote>
<p><strong>副交感神经兴奋</strong>，<strong>胰岛素</strong>，<strong>食欲素</strong>，这三个是目前比较认同的原因，是说进餐之后，副交感神经兴奋，一直交感神经，而副交感神经主司修正恢复，储蓄能量等作用，所以会犯困。胰岛素是会让人进入轻度的低钾状态，感到疲劳，同时促进褪黑素产生，增加睡意。食欲素是因为吃饱后食欲素含量下降，人就会变得昏昏欲睡。</p>
<p>三种原因可见，其实午睡最重要的原因在于午餐，人们发现餐后嗜睡的情况与餐前的饥饿程度，进餐量有关，但和饮食结构的关系并不大。相信这与胰岛素的峰值曲线有很大的关系。如果养成少食多餐的进食习惯，减少过量饮食对餐后嗜睡有很大的益处。</p>
<h2 id="午睡有益？有害？">午睡有益？有害？</h2>
<p>在这个专家打架的社会，基本上没有一个权威的说法，而且不同的人确实也有不同的生活方式。比如有很多国家的人基本上不午睡，比如美国，美国人基本上中午没有午睡时间，而中国现在大城市的民营企业，很多按照西方的企业模式，中午也基本上没有什么午睡的时间。而在中国，基本上都是有午睡的空余的，小时候比较活跃，中午完全没有睡意，很不喜欢午睡，父母总是会强制要求午睡，现在长大了，也习惯午睡，而且餐后确实很容易犯困，所以午睡习惯也就养成了。</p>
<p>我综合了一下网上的信息，大致可以得出一个公共承认的结论：<strong>午睡是有益的，但是睡久了，就无益了</strong>。很明显，如果按照目前我的睡觉方式，基本上是错误的睡觉方式。</p>
<p><a href="http://www.guokr.com/article/1619/" target="_blank" rel="external">午睡有益，睡觉了白睡</a>做了解释：</p>
<blockquote>
<p>美国加州大学伯克利分校（UC Berkeley）的一个睡眠研究小组近日解释了为什么午睡对于整日的工作有着很重要的意义。</p>
<p>在这项研究中，研究小组发现，一个人无论白天黑夜，都在不断遗忘。白天，我们睁着眼的时间越长，我们的意识就越不清楚，就会开始遗忘当天发生的事情——就像电脑清理临时文件，以提高整体运行速度。黑夜，深度的“眼动睡眠”（REM）让脑部一些重要区域关闭，也会造成遗忘（遗忘当天新产生记忆的40%）——就像电脑在重启过程中强制清除内存。</p>
<p>那人们什么时候用来记忆，或者说，什么时候把短时记忆从“临时文件夹”海马中“转存”到“硬盘”前额皮质里呢？答案是：睡眠。但与造成遗忘的“眼动睡眠”不同，记忆发生在它之前的非眼动睡眠（non-REM）。</p>
<p>这样你是不是就明白多了？醒着的时候会遗忘，睡深了也会遗忘，而能用来保存记忆的，就只剩下浅浅的睡眠——午睡了。所以说，午睡的好处很多，一方面可以有效地把你的短时记忆转存为长期记忆，一方面帮助你“轻装上阵”，大大提高下午的工作效率。</p>
<p>所以午睡不宜久，如果睡时间长了，进入深度睡眠，除了上面提到的“转存”问题外，如果一个人被从深度睡眠中吵醒，他就会感觉十分疲惫，昏昏欲睡……早上被闹钟叫醒不就是这个状态吗？</p>
</blockquote>
<p>所以，很明显目前自己的睡觉方式急需要修改。</p>
<h2 id="如何午睡">如何午睡</h2>
<p>午睡可以被分为5个级别，其中20-30分钟属于普通级别，这个时间段的休息，不仅可以解除疲劳、提高敏锐度和记忆力。因此，对大脑来说，睡眠是最好休息时间，短短的20分钟足以。</p>
<p>人的睡眠可以分为浅睡眠和深睡眠，30分钟后的睡眠已经逐渐进入深度睡眠，大脑的各中枢神经的抑制过程加深，体内代谢过程逐渐减少，若在此时醒来，就会感到周身不舒服而更加困倦。这种困倦会持续半到一个小时才能消失。</p>
<p>下面进入重点，如何午睡，目前给自己定了这么几个原则：</p>
<ul>
<li>午睡时间控制在30分钟以为，时间确定在饭后一小时进行，大约是一点至一点三十之间。</li>
<li>起床后可以以喝咖啡的方式缓解困意，并且利用醒后的时间学习工作。</li>
<li>千万不要让睡眠时间超过40分钟，这样转入深度睡眠，即使醒过来之后，很头疼和起床困难。</li>
<li>睡眠时保持良好睡姿，不要将就。</li>
<li>要贯彻这个原则，形成习惯。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来，对午睡这件事说不清它的对与错，网上的争论也比较多。一方人认为午睡是必须的且是最重要的养生手段，不午睡的身体伤害很大。另一部分人认为午睡不是必要的，而且可以尽可能的减少自己的午睡习惯。</p>
<p>就我现在的习惯来说，午睡是必不可少的，而且时间还不短，如果中午十二]]>
    </summary>
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一周阅读笔记（2015年第一周）]]></title>
    <link href="http://yoursite.com/2015/01/04/%E4%B8%80%E5%91%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882015%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2015/01/04/一周阅读笔记（2015年第一周）/</id>
    <published>2015-01-04T14:57:56.000Z</published>
    <updated>2015-01-04T15:03:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《长尾理论》">《长尾理论》</h1>
<p>长尾理论是速读的内容，一天时间读完的，其实内容还是比较丰富的，对如今互联网时代的商业模式做了一次新探讨，同样是畅销书，也要比国内的那些畅销书良心多了。<br>不过总结起来讲，整本书也就是通过不同的方面阐述了长尾理论：<br><strong>在网络时代，由于成本和效率的因素，当商品储存流通展示的场地和渠道足够宽广，商品生产成本急剧下降以至于个人都可以进行生产，并且商品的销售成本急剧降低时，几乎任何以前看似需求极低的产品，只要有卖，都会有人买。这些需求和销量不高的产品所占据的共同市场份额，可以和主流产品的市场份额相比，甚至更大。</strong></p>
<h2 id="长尾理论的六个主题：">长尾理论的六个主题：</h2>
<ol>
<li>在任何市场中，利基产品都远远多于热门产品。而且，随着生产技术变得越来越廉价，越来越普及，利基产品的比重仍在以指数级的速度提高。</li>
<li>获得这些利基产品的成本正在显著下降。</li>
<li>仅仅供应更多的品种并不能改变需求，消费者必须有办法找到适合他们的特殊需求和兴趣的利基产品。</li>
<li>一旦有了空前丰富的品种和用来做出选择的过滤器，需求曲线就会扁平化。热门产品和利基产品仍然存在，但热门产品的流行度会相对下降，利基产品的流行度则会相对上升。</li>
<li>尽管没有一个利基产品能实现大的销量，但由于利基产品数不胜数，它们聚合起来，将共同形成一个可与大热门市场相抗衡的大市场。</li>
<li>当以上几点全部实现，需求曲线的天然形状将会显现出来，不受供给瓶颈、信息匮乏和有限货架空间的扭曲。而且，这种形状受少数大热门的支配程度，远不像我们想象的那样大。相反，它的分布就像人口本身一样分散。 一句话：一条长尾就是没有被经济匮乏滤去真面目的文化。</li>
</ol>
<h2 id="维基百科">维基百科</h2>
<p>长尾的一个典型代表，维基百科：</p>
<blockquote>
<p>2005年，这项非营利事业已经贡献了地球上最大的百科全书。维基百科全书有出自2万多人之手的100余万篇英文文章（远胜于《不列颠百科全书》的8万篇和《微软电子百科全书》的4 500篇），再加上75种其他语言（包括世界语和库尔德语）的内容，维基的文章总数超过了350万篇。</p>
</blockquote>
<p>维基百科代表的就是集体生产的力量。<br>用户自创式的维基模式则有四个主要优势：</p>
<ul>
<li>第一是时时更新的能力；</li>
<li>第二是篇幅的无限性和视觉辅助（比如图片和图表）；</li>
<li>第三是大量连接到其他资源的外部链接；</li>
<li>第四，维基或许还能更好地显示不同的观点和争议之处。</li>
</ul>
<p>像其他的百科一样，维基百科的前一千个条目，在其他百科里也都有，比如恺撒大帝、第二次世界大战、统计学等，这些就是热门“歌曲”。这方面，维基是在同最棒的专家们竞争——他们的权威文章文采飞扬，引经据典，读起来如沐春风，大开眼界。<br>在曲线中部，也就是第1 000~80 000个条目（《不列颠百科全书》到此为止），主题就更专项化了：恺撒的剖腹降生、冲绳岛大战、回归分析等。在这一部分，维基开始超越它的竞争对手。无限的空间意味着维基的条目倾向于更长、更全面。《不列颠百科全书》的每个条目平均篇幅是678个单词，而维基里有不下200 000个条目（相当于两部《不列颠百科全书》）大于这个平均篇幅。同时，外部链接和信息更新成了维基的一大优势，因为这让维基成了进一步研究的出发点。</p>
<p>接下来就是长尾了——第80 000~1 000 000个条目。这些就是维基独有的内容，其他百科全书甚至不屑考虑它们。这些主题更专项化：恺撒密码、士兵们吃的午餐肉罐头、斯皮尔曼等级相关系数等。这部分文章良莠不齐，有些堪称维基中的精品（热情的专家们写的），有些就是维基中的垃圾（自吹自擂、诽谤攻击、恶作剧）。许多批评家只知道盯着这些垃圾，但真正重要的一点是，你在任何地方都找不到其他像维基长尾这样的东西。从核心科学到最新的政治时事，维基的涉猎之广是其他任何百科全书都无法相比的——无论是碍于纸张篇幅上的限制还是DVD性能的限制。《不列颠百科全书》没有关于长尾现象的条目（到目前为止），而维基里不光有，而且写得非常精彩和全面，足有1 500个单词。</p>
<h2 id="Google_&amp;_Amazon">Google &amp; Amazon</h2>
<p> Google是一个最典型的“长尾”公司，其成长历程就是把广告商和出版商的“长尾”商业化的过<br>程。以占据了Google半壁江山的AdSense为例，它面向的客户是数以百万计的中小型网站和个人—对于普通的媒体和广告商而言，这个群体的价值微小得简直不值一提，但是Google通过为其提供个性化定制的广告服务，将这些数量众多的群体汇集起来，形成了非常可观的经济利润。据报道，Google的市值已超过2100亿美元，被认为是“最有价值的媒体公司”，远远超过了那些传统的老牌传媒。</p>
<p>而在图书出版业。图书出版业是“小众产品”行业，市场上流通的图书达300万种。大多数图书很难找到自己的目标读者，只有极少数的图书最终成为畅销书。由于长尾书的印数及销量少，而出版、印刷、销售及库存成本又较高，因此，长期以来出版商和书店的经营模式多以畅销书为中心。网络书店和数字出版社的发展为长尾书销售提供了无限的空间市场。在这个市场里，长尾书的库存和销售成本几乎为零，于是，长尾图书开始有价值了。销售成千上万的小众图书，哪怕一次仅卖一两本，其利润累计起来可以相当甚至超过那些动辄销售几百万册的畅销书。如亚马逊副经理史蒂夫·凯塞尔所说：“如果我有10万种书，哪怕一次仅卖掉一本，10年后加起来它们的销售就会超过最新出版的《哈利·波特》。”</p>
<h2 id="长尾的三种力量：">长尾的三种力量：</h2>
<ul>
<li>生产工具的普及。</li>
<li>通过普及传播工具降低消费成本。</li>
<li>连接供给与需求，将新产品介绍给消费者，推动需求沿曲线向右移动。</li>
</ul>
<h2 id="信号与噪声">信号与噪声</h2>
<p><strong>过滤器是必须存在的，因为如果没有过滤器，长尾有可能只是一个恼人的噪声源而已。</strong></p>
<p>“信息理论”这门学问研究的主要是一个信息采集问题：从随机性的电子噪声中分离出连贯有序的信号。这最初是无线电广播领域的课题，后来延伸到了所有类型的电子传输技术上。“信号-噪声比”这个概念现在已被广泛应用，任何需要清除干扰的传播渠道都要考虑这个比率。在传统的“短头”市场中，这不是个多么大的问题，因为货架上的所有东西都已经过事先过滤，另类的玩意儿和其他非大众化的产品都已经被清除一空。但在一个无奇不有的长尾市场中，噪声有可能成为一个大问题。事实上，如果不加约束，噪声（乱七八糟的内容或质量低劣的产品）有可能毁掉一个市场。如果噪声太多，人们就不会掏钱光顾。 过滤器的职责就是清除这些噪声。就像是小麦脱粒机或是打磨钻石的设备一样，过滤器的任务就是挑选出人们想要的精华部分，滤除人们不想要的多余部分。我可以用一个常见的认知盲点来解释一下这个过程。</p>
<blockquote>
<p>斯特金法则［Sturgeon’s Law，以科幻作家西奥多·斯特金（Theodore Sturgeon）的名字命名］认为“任何事物都有90%是无用的渣滓”。</p>
</blockquote>
<p>另外一本书，<strong>《信号与噪声》</strong>。</p>
<h2 id="被忽视的丰饶经济学">被忽视的丰饶经济学</h2>
<p>十多年前，丰饶理念的倡导者乔治·吉尔德（George Gilder）精辟地阐释了这一点： 在人类历史上，大多数人都相信经济学是一个零和游戏——稀缺性终究会压倒丰饶性。马尔萨斯就是这种观念的一个著名的拥趸：他认为人口会以几何级数增长，而农业产出只能以算术级数增长。根据马尔萨斯的观点，食物匮乏最终会扼杀经济增长。 经济学家们之所以强调稀缺性，是因为资源短缺可以衡量，到零为止。稀缺性可以给经济模型设定一个限度，令它们得出一个明确可数的结果，得出产业系统中的一个可辨识的瓶颈点。而丰饶性既不可数，也没有明显的上限。它们像空气和水一样无处不在，而且它们是不可见的——此所谓“外部性”。然而，丰饶性实际上是所有经济进步和变化的驱动力。</p>
<h2 id="黑天鹅问题">黑天鹅问题</h2>
<p>纳西姆·塔勒布（Nassim Taleb）所说的那种“黑天鹅问题”。 这种提法源自于18世纪的苏格兰哲学家休谟（David Hume）。当时，他以黑天鹅为例解释了从观察结果中得出一般性法则的复杂之处。在提出我们现在所说的“休谟归纳问题”（Hume’s Problem of Induction）时，他问了这样一个问题：一个人在观察到多少只白天鹅之后才能断言所有的天鹅都是白色，黑色天鹅并不存在？100只？1 000只？我们不知道。（黑天鹅问题并不只是一个假设性的比喻：在发现澳洲大陆之前，所有人都认为世界上只有白天鹅。直到有人首次看到了黑天鹅，这种观念才被舍弃。）</p>
<p>他是这样定义黑天鹅问题的： 一个随机性事件满足以下三个条件：<strong>重大影响、无法计算的概率、意外效应。</strong>首先，它一旦发生，就会造成与其本身不成比例的重大影响；其次，它的发生概率很小，而且根据发生前的可用信息也无法计算这个概率；第三，黑天鹅问题的恶性特征就是它的意外效应：在任意一次观察中，不会有任何有说服力的要素可以证明这个事件的发生概率正在提高。</p>
<p><strong>黑天鹅告诉我们，不要忽视那些藏在长尾中的事物，而我们也很容易高估了热门产品的市场，其实他们只是巨量的市场中的一个罕见事例罢了。</strong></p>
<p>另外一本书，<strong>《黑天鹅：如何应对不可预知的未来》</strong></p>
<h4 id="延伸阅读阅读：">延伸阅读阅读：</h4>
<p><a href="http://zh.wikipedia.org/wiki/%E9%95%BF%E5%B0%BE" target="_blank" rel="external">wiki 长尾理论</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="《长尾理论》">《长尾理论》</h1>
<p>长尾理论是速读的内容，一天时间读完的，其实内容还是比较丰富的，对如今互联网时代的商业模式做了一次新探讨，同样是畅销书，也要比国内的那些畅销书良心多了。<br>不过总结起来讲，整本书也就是通过不同的方面阐述了长尾理论：<]]>
    </summary>
    
      <category term="weekly note" scheme="http://yoursite.com/tags/weekly-note/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间碎片化解决方案]]></title>
    <link href="http://yoursite.com/2015/01/01/%E6%97%B6%E9%97%B4%E7%A2%8E%E7%89%87%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2015/01/01/时间碎片化解决方案/</id>
    <published>2015-01-01T15:52:16.000Z</published>
    <updated>2015-01-01T16:05:11.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直各种事情，所以一直是低效的学习状态。不过仔细想想，其实自己也没有在忙什么事情，其实都是这时间太零碎惹的祸，所以决定花时间，考虑考虑解决办法，于是在2015年的第一天写了这篇日志，研究和解决一下时间碎片化的问题。</p>
<h2 id="时间碎片化">时间碎片化</h2>
<p>本来时间碎片化是指的之前自己浮躁的生活状态的，生活在太多的社交媒体之中，往往时间被大量的分割，打开我的手机，看看手机中有多少APP，有多少有关社交和新闻媒体的APP就知道了。知乎，豆瓣，ZAKER，网易新闻，微博，人人，微信，QQ，邮箱等等，而内容又五花八门，无奇不有，想了解的不想了解的统统一股脑塞进你的思考区间，让你的头脑无时无刻不在运转中，却又好似一直在荒废时间。</p>
<p>同样是了解了信息，获取了知识，但为什么说这种碎片化的阅读有十分大的危害呢，常人所说的变得浮躁，虚度时光什么的，我觉得并不是主要因素。碎片化的最大危害就是时间的碎片化，碎片化之后你每天的正收益有效时间锐减，由于各个思考进程的切换，边际时间变得非常大。</p>
<p>这是知乎盐系列《开放的智力》的一段话：</p>
<blockquote>
<p>心理学家早就发现，当你从任务 A 切换到任务 B 后，执行任务 B 的绩效要明显比非任务切换条件下执行 B 的绩效差，这个差异称为「切换代价（switching cost）」。切换代价的形成原因主要有两种，一是任务 A 留下的认知惯性，也就是我之前已经习惯了任务 A 的认知情境、反应方式，这个惯性会对完成任务 B 造成干扰，二是做 B 的时候需要对 B 进行认知重构，重新回忆起 B 的相关背景和信息，这个重构也需要时间，而且可能不完整。</p>
</blockquote>
<p>其中所指的切换代价也就是我所指的边际时间。我以前关注的几个APP我还精挑细选了内容，仍然无法改变碎片化的本质，比如我的微博上关注了一些技术大牛的，技术网站官方微博，设计方向的，几位作家，文化历史方向的，PPT方向的等，ZAKER关注的科技新闻，网易关注的时政新闻，豆瓣几个兴趣小组，知乎一天阅读四次左右。但很明显的可以看出来，每个方向的内容混杂在一起推送，完全无法进行深层次的理解，而只能停留在所谓的浅阅读，基本上大部分的知识点是非常浅层次的理解能力去应对的。</p>
<p>以高逼格的知乎为例，知乎以高密度的知识点为最大卖点，每天阅读之后，感觉自己好像懂了很多，但仔细想想，所谓的懂了很多，其实只是了解了大量的无用之事，而在每一个方向上，知乎上用户的分析就会显得单薄，无法做更深入的探究，于是在多个知识点之间切换的时候，要么是简单的读完则完，止于了解，要么是匆匆翻过，纳入已知范围，要么是对单个问题再自行搜索，进行更深层次的理解和学习。当然，并非批评知乎，作为APP，除了阅读软件，其他的都注重了快节奏和高吸引点。而知乎针对我所说的那些个问题，也有许多办法，比如推专栏，比如出这个盐系列（基本上每一本盐系列我都买了），比如专门做的问题分类汇总。</p>
<p>现在回到现实中来，我所指我的时间碎片化并非指的是上边讲的那些社交媒体引起的碎片化阅读，而是自己所处的环境引起的时间被切割和高打断频率。目前这里的工作环境，因为学习只算是一个完全业余，甚至是不被理解的行为，而白天总是充斥着各种各样的事务影响，即使是有学习的条件，又因为大多是在值班室，而值班室有总是有各种人员出入，总会有各种人来打断你的思考状态，所以整体的上效率不高，这就是我指的时间碎片化。</p>
<p>不过这种碎片化不严重，而且通过调整学习方法和心理状态，就能有效的解决问题，所以今天就是来讨论时间碎片化的解决方案的。</p>
<h2 id="年龄与规划">年龄与规划</h2>
<p>昨天看了一篇文章，有段话刺激到了我，也可以说是今天绝大多数人的状态：</p>
<blockquote>
<p>很多人很大的一个错误在于，在黄金时期，没做什么积累，就顾得享受生活了，而一旦意识到积累的必要性时，却又受困于诸多琐事而欲振乏力，最终人生高度有限，并迅速走低。这就是现代程序员版的“少壮不努力，老大徒伤悲”。</p>
</blockquote>
<p>什么年龄，做什么事，这大概是给人生规划的最重要的原因。而人生大致可以分这么几个阶段。</p>
<ul>
<li>20~30岁这个阶段可以讲是黄金时期，这个阶段里，家庭负担较小，可以自由支配的时间较多算。</li>
<li>30岁之后因为孩子出生等，家庭上的时间开销增加，个人可支配时间变少，当然35岁前和35岁后大约也是个分界线，35岁前工作学习的仍然是重心，而35岁以后就要以家庭为重心了。</li>
<li>40岁之后，家庭琐事会进一步增加，典型的上有老下有小。</li>
<li>50岁之后，时间上会再次解脱，但可惜的是自己也老了，时机不在。</li>
</ul>
<p>不同的人，可能在细小之处有些差别，比如结婚早晚，比如先天性格，比如个人才能，但这条抛物线大约可以算的上是几乎所有人的人生轨迹了，大约在40岁时候，达到人生最重要的巅峰，此后基本都是以40岁的成就为基础了，不排除有大器晚成之人。</p>
<p>所以所谓人生规划，大约就是以这个人生抛物线为基础，进行的规划。大概讲起来，就是要在35岁之前，完成硬技能的学习，应该在这之前，花费大量的时间来学习硬知识，学习曲线陡峭的技能，这个时间段，不可以因为贪图享受，或者是畏惧艰难而止步，更不能三天打鱼两天晒网的细步前行。特别是在30岁以前，要进行的是一种野蛮生长的状态，尽自己的努力，让自己在能力上爬升到一个足够的高度。而这中间，尽量不要在学习上采用添水战术，也就是像我前边所说的碎片化阅读的方式，通过缓慢的学习进度，来获得提高。一次点一根火柴，一万年也烧不开一壶水的，用一万年时间去阅读那些零碎的知识点，一万年你也成不了大神。</p>
<p>而在35岁往后，时间将日趋碎片化，大块的学习时间将越来越少，记忆力和能力减退，此时就需要改成软技能的学习，通过软件能的学习，实在细节和能力上进行的自我完善的过程，也就是锦上添花的过程。这些软件能，将在后边的人生里，起到令人惊喜的作用。</p>
<p>所以，年轻是最大的资本，而时间一到，年轻就像债务一样，必须清还。所以在此之前，必须将年轻的资本最大化的使用掉。下面就写关于规划的一些细节。</p>
<h2 id="硬技能与软技能">硬技能与软技能</h2>
<p>写这篇文字的目的，旨在解决现在环境里所存在的时间碎片化的问题，并且给以后的人生规划以指导。</p>
<p>可解决的办法不多，目前的想法是，因为大约是半年的时间，可以将这半年的学习计划修改成硬知识与软知识结合学习的方法。下面是我所列的一些硬技能，软技能，部分参考了别人文章里的想法。<br>硬技能：</p>
<ul>
<li>精通一门语言</li>
<li>了解平台及基本机制，如Linux的内存管理，线程等等</li>
<li>设计模式</li>
<li>代码量</li>
<li>算法数据结构</li>
<li>掌握软件工程方法 </li>
<li>等等</li>
</ul>
<p>软技能：</p>
<ul>
<li>演讲，沟通能力（结合幻灯片制作）</li>
<li>统筹规划能力</li>
<li>写作能力及逻辑表达能力</li>
<li>等等</li>
</ul>
<p>另外诸如学习英语，学习设计算是软硬适中的能力。</p>
<p>另外还有一些语言的实用框架属于是硬技能里的软知识，因为他们的掌握速度较快，可以快速的应用的实践中，而不需要花大量的时间去分析和理解，比如Bootstrap &amp; Jquery , django , less &amp; sass &amp; stylus , wordpress 等等。</p>
<p>区分完这些技能点，这半年时间里，可以根据现实情况，学习不同的知识点。</p>
<ul>
<li>如果有足够充足的大块时间，且状态比较集中时候，可以学习语言，以及进行实践；</li>
<li>如果有大块时间，但是精神不够集中，外界影响多的情况，可以去学习这些实用框架的实用，并尝试做一些实践。</li>
<li>如果没有大块时间，但是状态相对集中的时候，可以进行英语学习，或者是设计方面的知识学习。</li>
<li>如果没有大块时间，且外部影响较多时候，可以进行软技能的学习，学英语，或者PPT &amp; Keynote制作，或者是对某产品或某APP进行分析（通过部分书籍学习）。</li>
</ul>
<h2 id="最后">最后</h2>
<p>其实最重要的，还是要调整好心理状态，在积极的心态之下，规划好自己的学习方式，就能获得最佳的收益。<br>以前在看《当幸福来敲门》的时候，史密斯带着儿子在教堂里住的时候，我被那段音乐感动到泪下，歌名叫《lord don’t move that mountain》，歌词是这样的：</p>
<blockquote>
<p>Lord don’t move that mountain </p>
<p>Give me the strength to climb it </p>
<p>Please don’t move that stumbling block </p>
<p>But lead me Lord around it </p>
<p>The way may not be easy </p>
<p>seems hard to bear </p>
<p>But i wont give up ,No no </p>
<p>Because you promised me </p>
<p>You’d meet me at the altar of prayer </p>
</blockquote>
<p>新的一年，我希望自己能够以更加饱满的热情，迎接这些人生里的挑战,战胜这些人生的绊脚石，翻越这些险峻的山峰。（某人说我结尾就像小学生国旗下的讲话，仔细一看，好像确实是的 ^.^）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直各种事情，所以一直是低效的学习状态。不过仔细想想，其实自己也没有在忙什么事情，其实都是这时间太零碎惹的祸，所以决定花时间，考虑考虑解决办法，于是在2015年的第一天写了这篇日志，研究和解决一下时间碎片化的问题。</p>
<h2 id="时间碎片化">时间碎片化</h]]>
    </summary>
    
      <category term="个人规划" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92/"/>
    
      <category term="学习方法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014年的我和生活]]></title>
    <link href="http://yoursite.com/2014/12/31/2014%E5%B9%B4%E7%9A%84%E6%88%91%E5%92%8C%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2014/12/31/2014年的我和生活/</id>
    <published>2014-12-31T15:29:40.000Z</published>
    <updated>2014-12-31T15:34:01.000Z</updated>
    <content type="html"><![CDATA[<p>2014年可以说是我人生走向某种价值观人生观分界线的一年，具体的分界时间大约是八月后正式投入工作以后。<br>所以这以前的半年可以算是1.0生活，在这之后算是进化到了2.0阶段了吧。今天写1.0的生活。</p>
<h2 id="1-0生活">1.0生活</h2>
<p>年初，说起来算是在北京呆了半年，可是身份的原因，与北京这座城市完全是疏离的，有时候夜晚看着漆黑的校园，我都在怀疑我所在的地理坐标到底是不是祖国的心脏，是不是帝都，大概也只有天边那猩红的灯火才能给出正确地答案。</p>
<p>BZ的生活算的上平静，因为去年手术的原因，在这里近乎半休养状态，所以那时候的人生状态是希望自己能健健康康，快快乐乐的生活，做喜欢的事情，交喜欢的朋友。所以在性格上，还和之前的二十多年的性格一样，慵懒，喜欢享受。谈不上厌恶或者喜欢预期的未来生活状态，因为对未来没有清晰的体会，而且仍然抱有一些今天看来奇怪的幻想。</p>
<p>当然，当寒假来临之际，BZ忽然通知不给假期，派去实习的时候，着实是生出了强烈的厌恶感，那种四年来强烈地厌恶感又涌上心头。生活随意被委派，随意被命令，那个时候，想过自己的未来到底该作何打算，可是因为惧怕改变，或者惧怕因为改变而需要承担的所有后果，于是这些情绪，就好像是石子投入湖水，泛起涟漪，却引不起浪花。</p>
<p>实习当然无法避免，还好运气尚佳，遇到了个通情达理的指导员，说了几句好话之下，同意了我在过年几天回家。有时候，感觉自己在某些生活或大或小的路口时，总有一种冥冥的神灵助我完成某种期望，让我自然相信这是信仰的力量。站在石家庄火车站大厅下的我，手里拿着回家的火车票，感觉自己就像是站在鸟笼开着的门前鸟儿，因为压抑的生活让这些小小的福利成了巨大的惊喜。</p>
<p>回家七天，和朋友们滑雪，打牌，吃爸妈做的饭，包的饺子，吐槽春晚，K歌，看电影，不长的时间过得还算充实和满足。</p>
<p>七天结束返回石家庄之后，直接又背上背包北上回BZ，开始半个月时间的护校生活，所谓护校就是负责学校南门（貌似是南门）的哨位，因为身体原因，给分配了一个便衣哨，还算轻松愉快。只是没想到的是，让我今天对北京感到怀念的，这短短的半个月最浓重。迎来了 北京的第一场雪，在飘雪的北京和朋友去吃饭，去看电影，玩桌游，看北京的夜景，和战友一起扫雪，吃火锅，打刀塔，包饺子，睡到自然醒。这些愉快的日子，也许是北京十个月最大的收获了。</p>
<p>开学之后，状态调整，再加上身体恢复了加入训练，加上有所谓筹备的毕业考核，以及即将步入岗位的压力之下，心态又开始进入压抑状态，这大概源于自己一直谨小慎微，同时也源于自己贪婪的性格，凡事都想有个不错的收获，直到现在我才搞清楚一些道理，做不了的事为什么不能完全放手。</p>
<p>然而大约五月底的时候，因为感觉身体不适，去医院检查之下，竟然又发现了另外的病症，需要手术。在医生确诊前，自己靠搜索基本上也知道了是什么情况了，了解之后，确实有些打击，短短十个月时间，两个手术，忽然有种格外倒霉的感觉。后来没有太过悲伤，或许是因为已经比较坚强，很快接受了又要做手术的事实。生命力，有些事情，自己无法预见，也注定挡不了，古人说：<strong>好事多磨</strong>。我想，也许曲折蜿蜒的人生，都算是一种特别的经历，它们为以后的人生埋下伏笔，也带去别样的风景。</p>
<p>因为手术的原因，最后的强训阶段又缺席，所谓的一年强化期，却成了自己一年的养病年，或许这就是所谓的命中注定吧。住院大约两周多，手术前因为还可以正常的活动，于是一个人去看电影，去逛书店，去吃饭，在北京的夜里，感觉特别的孤独和哀伤，那个时候，对自己的未来产生了些许的疑惑和迷茫，也为后边的2.0生活买下了伏笔。</p>
<p>毕业时间比预计的晚了几天，但还好仍然是回家休整了几天，然后是来新乡支队报到，开始了我的2.0生活。</p>
<p>在这1.0生活里，我和过去二十多年的我没有太多差别，爱做梦，慵懒，小文艺，谨小慎微，想要十全十美，追求闲适。以为未来的BD生活或许是适合自己的，简单，轻松，可以做一些喜欢的事情，可以慢慢的成长，安家立业，最后收获功名。以为自己可以凭借能力，或者是如这里大多数人信奉的东西（关系），可以有着更轻松和快速地发展之路。以为小城市的闲适和简单，满足了自己的要求，也正是自己想要的平静的生活。</p>
<p>只是，我好想忽略了什么，于是没有悬念的，我开始了我的2.0生活。</p>
<h2 id="2-0的生活">2.0的生活</h2>
<p>2.0的生活开始于北京生活的结束，它不是突然的开始，我现在回想，也找不到那个变化的节点。</p>
<p>从七月初开始，一直到今天，大约六个月的时间，生活简单到单调，没有太多上层施加的压力，但是压抑的感觉仍然没有消退，这是我在来这里之前没有想到的。我以为当身份开始转变的时候，我会慢慢摆脱这种压抑的感觉，会逐渐习惯并接受。可知道这种压抑的感觉没有任何消退迹象的时候，我才终于开始认真分析问题所在。</p>
<p>所以在经历了一开始的难受和想不通，同时又陆续看到同学选择退出的消息，我开始试图去思考和分析，我是否真的适合在这里发展，同时我到底应该选择哪个方向。</p>
<p>当然，一开始，我以为这样的思考或者分析用处并不大，毕竟自以为自己的自我认知已经很清晰，什么事情已经看了很明了。但是经过了大约持续一个月的思考后，我从疑惑，到选择，到纠结，到决心。（这其中的分析过程就略过，涉及秘密信息）</p>
<p>所以，大约是在八月多九月初的时候，我已经坚定了自己的决心，也与父母的想法达成一致。自此2.0生活正式开始了。</p>
<p>利用白天的间隙时间看书，利用所有的时间学习，晚上熄灯之后打开电脑学习，并开始真正开始用一些方法去规划自己的生活，并写各种各样的话去鼓励自己，毕竟选择退出的人，每一个都是要付出莫大的勇气。开始强化自己的世界观，价值观，并开始更深的反省自己。</p>
<p>六个月，看了之前四年想要看的书，技术的，管理的，市场的，社会的，历史的，文学的，科技的，没有做分类和规划，觉得好的书就看，觉得看着不行的就放下。纠正了自己的消费观，为自己买了kindle,mac，都让我觉得付出的金钱完全值得，因为感觉自己的收益更大。</p>
<p>大约两个月前，开始写日记。写日记的习惯，从很早的初中就开始想培养，结果在数次失败之后，都放弃了。而当两个月前我在规划自己的每日生活的时候，考虑要不要每天做一个总结时，选择了写日记的方法。而且，放弃了用实体本子写日记的打算，改用evernote，用手机写。因为手机打字速度已经足够快，所以发现体验非常好，有一种开心的感觉，于是在后边的每天，坚持用手机或者电脑去些日记，总结一天的得失，反省自己的性格缺陷，寻找改正的办法，同时激励自己。</p>
<p>于是，两个月时间一天不落的坚持下来，养成了习惯。而这日记，大约是我最成功的一个决定，每日的日记，让我感受到每天的收获，同时用文字内省了自己，并对未来的生活提出了更多的期许。</p>
<p>这六个月时间过得飞快，我像一只干燥的海绵遇水迅速膨胀开来，他让我看到了自己的野心，看到了自己的性格真相，看到了未来的多少可能，看到了内化的强大力量。孤独的六个月，我做的事情，没有人催促，没有人监督，更没有人给以指导，甚至是身边没有人理解和赞同，我就像个孩子穿行在熙熙攘攘的人流中，孤独又执着。</p>
<p>我知道，这六个月，对于自己想要追求的梦想来说，太短暂。我也知道，自己的力量，仍然无力承载自己的梦想，这个吸了水的海绵仍然显得干燥。我更知道，我选择的这条路，是少有人走的路，更是一条相比眼前这条更辛苦的路。但我就是觉得，生命存在的意义本来就是寻找意义，而非活着，无论走的路多么崎岖，多么艰辛，它都是通往未来的唯一正确地路。</p>
<h2 id="最后">最后</h2>
<p>过去的一年，仍然有许多遗憾，仍然有许多未完成，仍然有太多躁动。<br>过去的一年，我经历了痛苦，经历了愉悦。<br>过去的一年，感谢时光赠予了太多难忘的宝贵的经历，让相信苦难是人终身的财富。<br>过去的一年，我渴望成长，渴望蜕变，渴望更丰富的人生。</p>
<p>这个时候，我忽然想起了高中时候听的广播剧，《让青春继续》，buynow,冰山，大学生活，毕业，我以为这些未来的事物，一瞬间已经变成了过去。此时此刻，我坐在床头，迎接新年。</p>
<p>新的一年，不悲不喜，收拾心情，让青春继续。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2014年可以说是我人生走向某种价值观人生观分界线的一年，具体的分界时间大约是八月后正式投入工作以后。<br>所以这以前的半年可以算是1.0生活，在这之后算是进化到了2.0阶段了吧。今天写1.0的生活。</p>
<h2 id="1-0生活">1.0生活</h2>
<p>年初]]>
    </summary>
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
